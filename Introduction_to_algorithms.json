{"0": {"page_number": 1, "page_information": "ALGORITHMSINTRODUCTION TO\nTHIRD EDITIONTHOMAS H .  \nCHARLES E.       \nRONALD L .  \nCLIFFORD STEINRIVESTLEISERSONCORMEN", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "1": {"page_number": 2, "page_information": "Introduction to Algorithms\nThird Edition", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "2": {"page_number": 3, "page_information": "", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "3": {"page_number": 4, "page_information": "Thomas H. Cormen\nCharles E. LeisersonRonald L. RivestClifford Stein\nIntroduction to Algorithms\nThird Edition\nThe MIT Press\nCambridge, Massachusetts London, England", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "4": {"page_number": 5, "page_information": "c/CR2009 Massachusetts Institute of Technology\nAll rights reserved. No part of this book may be reproduced in any form or by any electronic or mechanical means\n(including photocopying, recording, or information storage and retrieval) without permission in writing from the\npublisher.\nFor information about special quantity discounts, please email special\n sales@mitpress.mit.edu.\nThis book was set in Times Roman and Mathtime Pro 2 by the authors.Printed and bound in the United States of America.Library of Congress Cataloging-in-Publication DataIntroduction to algorithms / Thomas H. Cormen ...[ e ta l . ] . \u2014 3 r de d .\np. cm.\nIncludes bibliographical references and index.\nISBN 978-0-262-03384-8 (hardcover : alk. paper)\u2014ISBN 978-0-262-53305-8 (pbk. : alk. paper)\n1. Computer programming. 2. Computer algorithms. I. Cormen, Thomas H.\nQA76.6.I5858 2009\n005.1\u2014dc22\n2009008593\n1 098765432", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "5": {"page_number": 6, "page_information": "Contents\nPreface xiii\nI Foundations\nIntroduction 3\n1 The Role of Algorithms in Computing 5\n1.1 Algorithms 5\n1.2 Algorithms as a technology 11\n2 Getting Started 16\n2.1 Insertion sort 16\n2.2 Analyzing algorithms 23\n2.3 Designing algorithms 29\n3 Growth of Functions 43\n3.1 Asymptotic notation 43\n3.2 Standard notations and common functions 53\n4 Divide-and-Conquer 65\n4.1 The maximum-subarray problem 68\n4.2 Strassen\u2019s algorithm for matrix multiplication 75\n4.3 The substitution method for solving recurrences 83\n4.4 The recursion-tree method for solving recurrences 88\n4.5 The master method for solving recurrences 93\n? 4.6 Proof of the master theorem 97\n5 Probabilistic Analysis and Randomized Algorithms 114\n5.1 The hiring problem 114\n5.2 Indicator random variables 118\n5.3 Randomized algorithms 122\n? 5.4 Probabilistic analysis and further uses of indicator random variables\n130", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "6": {"page_number": 7, "page_information": "vi Contents\nII Sorting and Order Statistics\nIntroduction 147\n6H e a p s o r t 151\n6.1 Heaps 151\n6.2 Maintaining the heap property 154\n6.3 Building a heap 156\n6.4 The heapsort algorithm 159\n6.5 Priority queues 162\n7 Quicksort 170\n7.1 Description of quicksort 170\n7.2 Performance of quicksort 174\n7.3 A randomized version of quicksort 179\n7.4 Analysis of quicksort 180\n8 Sorting in Linear Time 191\n8.1 Lower bounds for sorting 191\n8.2 Counting sort 194\n8.3 Radix sort 197\n8.4 Bucket sort 200\n9 Medians and Order Statistics 213\n9.1 Minimum and maximum 214\n9.2 Selection in expected linear time 215\n9.3 Selection in worst-case linear time 220\nIII Data Structures\nIntroduction 229\n10 Elementary Data Structures 232\n10.1 Stacks and queues 232\n10.2 Linked lists 236\n10.3 Implementing pointers and objects 241\n10.4 Representing rooted trees 246\n11 Hash Tables 253\n11.1 Direct-address tables 254\n11.2 Hash tables 256\n11.3 Hash functions 262\n11.4 Open addressing 269\n? 11.5 Perfect hashing 277", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "7": {"page_number": 8, "page_information": "Contents vii\n12 Binary Search Trees 286\n12.1 What is a binary search tree? 286\n12.2 Querying a binary search tree 289\n12.3 Insertion and deletion 294\n? 12.4 Randomly built binary search trees 299\n13 Red-Black Trees 308\n13.1 Properties of red-black trees 308\n13.2 Rotations 312\n13.3 Insertion 315\n13.4 Deletion 323\n14 Augmenting Data Structures 339\n14.1 Dynamic order statistics 339\n14.2 How to augment a data structure 345\n14.3 Interval trees 348\nIV Advanced Design and Analysis Techniques\nIntroduction 357\n15 Dynamic Programming 359\n15.1 Rod cutting 360\n15.2 Matrix-chain multiplication 370\n15.3 Elements of dynamic programming 378\n15.4 Longest common subsequence 390\n15.5 Optimal binary search trees 397\n16 Greedy Algorithms 414\n16.1 An activity-selection problem 415\n16.2 Elements of the greedy strategy 423\n16.3 Huffman codes 428\n? 16.4 Matroids and greedy methods 437\n? 16.5 A task-scheduling problem as a matroid 443\n17 Amortized Analysis 451\n17.1 Aggregate analysis 452\n17.2 The accounting method 456\n17.3 The potential method 459\n17.4 Dynamic tables 463", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "8": {"page_number": 9, "page_information": "viii Contents\nV Advanced Data Structures\nIntroduction 481\n18 B-Trees 484\n18.1 De\ufb01nition of B-trees 488\n18.2 Basic operations on B-trees 491\n18.3 Deleting a key from a B-tree 499\n19 Fibonacci Heaps 505\n19.1 Structure of Fibonacci heaps 507\n19.2 Mergeable-heap operations 510\n19.3 Decreasing a key and deleting a node 518\n19.4 Bounding the maximum degree 523\n20 van Emde Boas Trees 531\n20.1 Preliminary approaches 532\n20.2 A recursive structure 536\n20.3 The van Emde Boas tree 545\n21 Data Structures for Disjoint Sets 561\n21.1 Disjoint-set operations 561\n21.2 Linked-list representation of disjoint sets 564\n21.3 Disjoint-set forests 568\n? 21.4 Analysis of union by rank with path compression 573\nVI Graph Algorithms\nIntroduction 587\n22 Elementary Graph Algorithms 589\n22.1 Representations of graphs 589\n22.2 Breadth-\ufb01rst search 594\n22.3 Depth-\ufb01rst search 603\n22.4 Topological sort 612\n22.5 Strongly connected components 615\n23 Minimum Spanning Trees 624\n23.1 Growing a minimum spanning tree 625\n23.2 The algorithms of Kruskal and Prim 631", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "9": {"page_number": 10, "page_information": "Contents ix\n24 Single-Source Shortest Paths 643\n24.1 The Bellman-Ford algorithm 651\n24.2 Single-source shortest paths in directed acyclic graphs 655\n24.3 Dijkstra\u2019s algorithm 658\n24.4 Difference constraints and shortest paths 664\n24.5 Proofs of shortest-paths properties 671\n25 All-Pairs Shortest Paths 684\n25.1 Shortest paths and matrix multiplication 686\n25.2 The Floyd-Warshall algorithm 693\n25.3 Johnson\u2019s algorithm for sparse graphs 700\n26 Maximum Flow 708\n26.1 Flow networks 709\n26.2 The Ford-Fulkerson method 714\n26.3 Maximum bipartite matching 732\n? 26.4 Push-relabel algorithms 736\n? 26.5 The relabel-to-front algorithm 748\nVII Selected Topics\nIntroduction 769\n27 Multithreaded Algorithms 772\n27.1 The basics of dynamic multithreading 774\n27.2 Multithreaded matrix multiplication 792\n27.3 Multithreaded merge sort 797\n28 Matrix Operations 813\n28.1 Solving systems of linear equations 813\n28.2 Inverting matrices 827\n28.3 Symmetric positive-de\ufb01nite matrices and least-squares approximation\n832\n29 Linear Programming 843\n29.1 Standard and slack forms 850\n29.2 Formulating problems as linear programs 859\n29.3 The simplex algorithm 864\n29.4 Duality 879\n29.5 The initial basic feasible solution 886", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "10": {"page_number": 11, "page_information": "x Contents\n30 Polynomials and the FFT 898\n30.1 Representing polynomials 900\n30.2 The DFT and FFT 906\n30.3 Ef\ufb01cient FFT implementations 915\n31 Number-Theoretic Algorithms 926\n31.1 Elementary number-theoretic notions 927\n31.2 Greatest common divisor 933\n31.3 Modular arithmetic 939\n31.4 Solving modular linear equations 946\n31.5 The Chinese remainder theorem 950\n31.6 Powers of an element 954\n31.7 The RSA public-key cryptosystem 958\n? 31.8 Primality testing 965\n? 31.9 Integer factorization 975\n32 String Matching 985\n32.1 The naive string-matching algorithm 988\n32.2 The Rabin-Karp algorithm 990\n32.3 String matching with \ufb01nite automata 995\n? 32.4 The Knuth-Morris-Pratt algorithm 1002\n33 Computational Geometry 1014\n33.1 Line-segment properties 1015\n33.2 Determining whether any pair of segments intersects 1021\n33.3 Finding the convex hull 1029\n33.4 Finding the closest pair of points 1039\n34 NP-Completeness 1048\n34.1 Polynomial time 1053\n34.2 Polynomial-time veri\ufb01cation 1061\n34.3 NP-completeness and reducibility 1067\n34.4 NP-completeness proofs 1078\n34.5 NP-complete problems 1086\n35 Approximation Algorithms 1106\n35.1 The vertex-cover problem 1108\n35.2 The traveling-salesman problem 1111\n35.3 The set-covering problem 1117\n35.4 Randomization and linear programming 1123\n35.5 The subset-sum problem 1128", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "11": {"page_number": 12, "page_information": "Contents xi\nVIII Appendix: Mathematical Background\nIntroduction 1143\nA Summations 1145\nA.1 Summation formulas and properties 1145\nA.2 Bounding summations 1149\nB Sets, Etc. 1158\nB.1 Sets 1158\nB.2 Relations 1163\nB.3 Functions 1166\nB.4 Graphs 1168\nB.5 Trees 1173\nC Counting and Probability 1183\nC.1 Counting 1183\nC.2 Probability 1189\nC.3 Discrete random variables 1196\nC.4 The geometric and binomial distributions 1201\n? C.5 The tails of the binomial distribution 1208\nD Matrices 1217\nD.1 Matrices and matrix operations 1217\nD.2 Basic matrix properties 1222\nBibliography 1231\nIndex 1251", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "12": {"page_number": 13, "page_information": "", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "13": {"page_number": 14, "page_information": "Preface\nBefore there were computers, there were algorithms. But now that there are com-\nputers, there are even more algorithms, and algorithms lie at the heart of computing.\nThis book provides a comprehensive introduction to the modern study of com-\nputer algorithms. It presents many algorithms and covers them in considerabledepth, yet makes their design and analysis accessible to all levels of readers. Wehave tried to keep explanations elementary without sacri\ufb01cing depth of coverageor mathematical rigor.\nEach chapter presents an algorithm, a design technique, an application area, or a\nrelated topic. Algorithms are described in English and in a pseudocode designed to\nbe readable by anyone who has done a little programming. The book contains 244\n\ufb01gures\u2014many with multiple parts\u2014illustrating how the algorithms work. Since\nwe emphasize ef\ufb01ciency as a design criterion, we include careful analyses of the\nrunning times of all our algorithms.\nThe text is intended primarily for use in undergraduate or graduate courses in\nalgorithms or data structures. Because it discusses engineering issues in algorithm\ndesign, as well as mathematical aspects, it is equally well suited for self-study bytechnical professionals.\nIn this, the third edition, we have once again updated the entire book. The\nchanges cover a broad spectrum, including new chapters, revised pseudocode, anda more active writing style.\nTo the teacher\nWe have designed this book to be both versatile and complete. You should \ufb01nd it\nuseful for a variety of courses, from an undergraduate course in data structures upthrough a graduate course in algorithms. Because we have provided considerablymore material than can \ufb01t in a typical one-term course, you can consider this bookto be a \u201cbuffet\u201d or \u201csmorgasbord\u201d from which you can pick and choose the materialthat best supports the course you wish to teach.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "14": {"page_number": 15, "page_information": "xiv Preface\nYou should \ufb01nd it easy to organize your course around just the chapters you\nneed. We have made chapters relatively self-contained, so that you need not worryabout an unexpected and unnecessary dependence of one chapter on another. Eachchapter presents the easier material \ufb01rst and the more dif\ufb01cult material later, withsection boundaries marking natural stopping points. In an undergraduate course,you might use only the earlier sections from a chapter; in a graduate course, youmight cover the entire chapter.\nWe have included 957 exercises and 158 problems. Each section ends with exer-\ncises, and each chapter ends with problems. The exercises are generally short ques-\ntions that test basic mastery of the material. Some are simple self-check thoughtexercises, whereas others are more substantial and are suitable as assigned home-work. The problems are more elaborate case studies that often introduce new ma-terial; they often consist of several questions that lead the student through the stepsrequired to arrive at a solution.\nDeparting from our practice in previous editions of this book, we have made\npublicly available solutions to some, but by no means all, of the problems and ex-\nercises. Our Web site, http://mitpress.mit.edu/algorithms/, links to these solutions.\nYou will want to check this site to make sure that it does not contain the solution to\nan exercise or problem that you plan to assign. We expect the set of solutions thatwe post to grow slowly over time, so you will need to check it each time you teachthe course.\nWe have starred ( ?) the sections and exercises that are more suitable for graduate\nstudents than for undergraduates. A starred section is not necessarily more dif\ufb01-\ncult than an unstarred one, but it may require an understanding of more advancedmathematics. Likewise, starred exercises may require an advanced background ormore than average creativity.\nTo the student\nWe hope that this textbook provides you with an enjoyable introduction to the\n\ufb01eld of algorithms. We have attempted to make every algorithm accessible andinteresting. To help you when you encounter unfamiliar or dif\ufb01cult algorithms, wedescribe each one in a step-by-step manner. We also provide careful explanationsof the mathematics needed to understand the analysis of the algorithms. If youalready have some familiarity with a topic, you will \ufb01nd the chapters organized sothat you can skim introductory sections and proceed quickly to the more advancedmaterial.\nThis is a large book, and your class will probably cover only a portion of its\nmaterial. We have tried, however, to make this a book that will be useful to younow as a course textbook and also later in your career as a mathematical deskreference or an engineering handbook.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "15": {"page_number": 16, "page_information": "Preface xv\nWhat are the prerequisites for reading this book?\n/SIYou should have some programming experience. In particular, you should un-\nderstand recursive procedures and simple data structures such as arrays andlinked lists.\n/SIYou should have some facility with mathematical proofs, and especially proofsby mathematical induction. A few portions of the book rely on some knowledgeof elementary calculus. Beyond that, Parts I and VIII of this book teach you allthe mathematical techniques you will need.\nWe have heard, loud and clear, the call to supply solutions to problems and\nexercises. Our Web site, http://mitpress.mit.edu/algorithms/, links to solutions fora few of the problems and exercises. Feel free to check your solutions against ours.We ask, however, that you do not send your solutions to us.\nTo the professional\nThe wide range of topics in this book makes it an excellent handbook on algo-\nrithms. Because each chapter is relatively self-contained, you can focus in on thetopics that most interest you.\nMost of the algorithms we discuss have great practical utility. We therefore\naddress implementation concerns and other engineering issues. We often provide\npractical alternatives to the few algorithms that are primarily of theoretical interest.\nIf you wish to implement any of the algorithms, you should \ufb01nd the transla-\ntion of our pseudocode into your favorite programming language to be a fairlystraightforward task. We have designed the pseudocode to present each algorithmclearly and succinctly. Consequently, we do not address error-handling and othersoftware-engineering issues that require speci\ufb01c assumptions about your program-ming environment. We attempt to present each algorithm simply and directly with-out allowing the idiosyncrasies of a particular programming language to obscureits essence.\nWe understand that if you are using this book outside of a course, then you\nmight be unable to check your solutions to problems and exercises against solutionsprovided by an instructor. Our Web site, http://mitpress.mit.edu/algorithms/, linksto solutions for some of the problems and exercises so that you can check yourwork. Please do not send your solutions to us.\nTo our colleagues\nWe have supplied an extensive bibliography and pointers to the current literature.\nEach chapter ends with a set of chapter notes that give historical details and ref-erences. The chapter notes do not provide a complete reference to the whole \ufb01eld", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "16": {"page_number": 17, "page_information": "xvi Preface\nof algorithms, however. Though it may be hard to believe for a book of this size,\nspace constraints prevented us from including many interesting algorithms.\nDespite myriad requests from students for solutions to problems and exercises,\nwe have chosen as a matter of policy not to supply references for problems andexercises, to remove the temptation for students to look up a solution rather than to\ufb01nd it themselves.\nChanges for the third edition\nWhat has changed between the second and third editions of this book? The mag-\nnitude of the changes is on a par with the changes between the \ufb01rst and secondeditions. As we said about the second-edition changes, depending on how youlook at it, the book changed either not much or quite a bit.\nA quick look at the table of contents shows that most of the second-edition chap-\nters and sections appear in the third edition. We removed two chapters and onesection, but we have added three new chapters and two new sections apart fromthese new chapters.\nWe kept the hybrid organization from the \ufb01rst two editions. Rather than organiz-\ning chapters by only problem domains or according only to techniques, this book\nhas elements of both. It contains technique-based chapters on divide-and-conquer,\ndynamic programming, greedy algorithms, amortized analysis, NP-Completeness,\nand approximation algorithms. But it also has entire parts on sorting, on data\nstructures for dynamic sets, and on algorithms for graph problems. We \ufb01nd thatalthough you need to know how to apply techniques for designing and analyzing al-gorithms, problems seldom announce to you which techniques are most amenableto solving them.\nHere is a summary of the most signi\ufb01cant changes for the third edition:\n/SIWe added new chapters on van Emde Boas trees and multithreaded algorithms,and we have broken out material on matrix basics into its own appendix chapter.\n/SIWe revised the chapter on recurrences to more broadly cover the divide-and-conquer technique, and its \ufb01rst two sections apply divide-and-conquer to solvetwo problems. The second section of this chapter presents Strassen\u2019s algorithmfor matrix multiplication, which we have moved from the chapter on matrixoperations.\n/SIWe removed two chapters that were rarely taught: binomial heaps and sortingnetworks. One key idea in the sorting networks chapter, the 0-1 principle, ap-pears in this edition within Problem 8-7 as the 0-1 sorting lemma for compare-exchange algorithms. The treatment of Fibonacci heaps no longer relies onbinomial heaps as a precursor.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "17": {"page_number": 18, "page_information": "Preface xvii\n/SIWe revised our treatment of dynamic programming and greedy algorithms. Dy-\nnamic programming now leads off with a more interesting problem, rod cutting,than the assembly-line scheduling problem from the second edition. Further-more, we emphasize memoization a bit more than we did in the second edition,and we introduce the notion of the subproblem graph as a way to understandthe running time of a dynamic-programming algorithm. In our opening exam-ple of greedy algorithms, the activity-selection problem, we get to the greedyalgorithm more directly than we did in the second edition.\n/SIThe way we delete a node from binary search trees (which includes red-blacktrees) now guarantees that the node requested for deletion is the node that isactually deleted. In the \ufb01rst two editions, in certain cases, some other nodewould be deleted, with its contents moving into the node passed to the deletionprocedure. With our new way to delete nodes, if other components of a programmaintain pointers to nodes in the tree, they will not mistakenly end up with stalepointers to nodes that have been deleted.\n/SIThe material on \ufb02ow networks now bases \ufb02ows entirely on edges. This ap-proach is more intuitive than the net \ufb02ow used in the \ufb01rst two editions.\n/SIWith the material on matrix basics and Strassen\u2019s algorithm moved to otherchapters, the chapter on matrix operations is smaller than in the second edition.\n/SIWe have modi\ufb01ed our treatment of the Knuth-Morris-Pratt string-matching al-gorithm.\n/SIWe corrected several errors. Most of these errors were posted on our Web siteof second-edition errata, but a few were not.\n/SIBased on many requests, we changed the syntax (as it were) of our pseudocode.We now use \u201cD\u201d to indicate assignment and \u201c\n==\u201d to test for equality, just as C,\nC++, Java, and Python do. Likewise, we have eliminated the keywords doand\nthen and adopted \u201c //\u201d as our comment-to-end-of-line symbol. We also now use\ndot-notation to indicate object attributes. Our pseudocode remains procedural,rather than object-oriented. In other words, rather than running methods onobjects, we simply call procedures, passing objects as parameters.\n/SIWe added 100 new exercises and 28 new problems. We also updated manybibliography entries and added several new ones.\n/SIFinally, we went through the entire book and rewrote sentences, paragraphs,and sections to make the writing clearer and more active.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "18": {"page_number": 19, "page_information": "xviii Preface\nWeb site\nYou can use our Web site, http://mitpress.mit.edu/algorithms/, to obtain supple-\nmentary information and to communicate with us. The Web site links to a list ofknown errors, solutions to selected exercises and problems, and (of course) a listexplaining the corny professor jokes, as well as other content that we might add.The Web site also tells you how to report errors or make suggestions.\nHow we produced this book\nLike the second edition, the third edition was produced in L\nATEX2\". We used the\nTimes font with mathematics typeset using the MathTime Pro 2 fonts. We thankMichael Spivak from Publish or Perish, Inc., Lance Carnes from Personal TeX,Inc., and Tim Tregubov from Dartmouth College for technical support. As in theprevious two editions, we compiled the index using Windex, a C program that wewrote, and the bibliography was produced with B\nIBTEX. The PDF \ufb01les for this\nbook were created on a MacBook running OS 10.5.\nWe drew the illustrations for the third edition using MacDraw Pro, with some\nof the mathematical expressions in illustrations laid in with the psfrag packagefor L\nATEX2\". Unfortunately, MacDraw Pro is legacy software, having not been\nmarketed for over a decade now. Happily, we still have a couple of Macintoshes\nthat can run the Classic environment under OS 10.4, and hence they can run Mac-Draw Pro\u2014mostly. Even under the Classic environment, we \ufb01nd MacDraw Pro tobe far easier to use than any other drawing software for the types of illustrationsthat accompany computer-science text, and it produces beautiful output.\n1Who\nknows how long our pre-Intel Macs will continue to run, so if anyone from Apple\nis listening: Please create an OS X-compatible version of MacDraw Pro!\nAcknowledgments for the third edition\nWe have been working with the MIT Press for over two decades now, and what a\nterri\ufb01c relationship it has been! We thank Ellen Faran, Bob Prior, Ada Brunstein,and Mary Reilly for their help and support.\nWe were geographically distributed while producing the third edition, working\nin the Dartmouth College Department of Computer Science, the MIT Computer\n1We investigated several drawing programs that run under Mac OS X, but all had signi\ufb01cant short-\ncomings compared with MacDraw Pro. We brie\ufb02y attempted to produce the illustrations for thisbook with a different, well known drawing program. We found that it took at least \ufb01ve times as long\nto produce each illustration as it took with MacDraw Pro, and the resulting illustrations did not look\nas good. Hence the decision to revert to MacDraw Pro running on older Macintoshes.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "19": {"page_number": 20, "page_information": "Preface xix\nScience and Arti\ufb01cial Intelligence Laboratory, and the Columbia University De-\npartment of Industrial Engineering and Operations Research. We thank our re-spective universities and colleagues for providing such supportive and stimulatingenvironments.\nJulie Sussman, P.P.A., once again bailed us out as the technical copyeditor. Time\nand again, we were amazed at the errors that eluded us, but that Julie caught. Shealso helped us improve our presentation in several places. If there is a Hall of Famefor technical copyeditors, Julie is a sure-\ufb01re, \ufb01rst-ballot inductee. She is nothing\nshort of phenomenal. Thank you, thank you, thank you, Julie! Priya Natarajan also\nfound some errors that we were able to correct before this book went to press. Anyerrors that remain (and undoubtedly, some do) are the responsibility of the authors(and probably were inserted after Julie read the material).\nThe treatment for van Emde Boas trees derives from Erik Demaine\u2019s notes,\nwhich were in turn in\ufb02uenced by Michael Bender. We also incorporated ideasfrom Javed Aslam, Bradley Kuszmaul, and Hui Zha into this edition.\nThe chapter on multithreading was based on notes originally written jointly with\nHarald Prokop. The material was in\ufb02uenced by several others working on the Cilk\nproject at MIT, including Bradley Kuszmaul and Matteo Frigo. The design of the\nmultithreaded pseudocode took its inspiration from the MIT Cilk extensions to Cand by Cilk Arts\u2019s Cilk++ extensions to C++.\nWe also thank the many readers of the \ufb01rst and second editions who reported\nerrors or submitted suggestions for how to improve this book. We corrected all the\nbona \ufb01de errors that were reported, and we incorporated as many suggestions as\nwe could. We rejoice that the number of such contributors has grown so great thatwe must regret that it has become impractical to list them all.\nFinally, we thank our wives\u2014Nicole Cormen, Wendy Leiserson, Gail Rivest,\nand Rebecca Ivry\u2014and our children\u2014Ricky, Will, Debby, and Katie Leiserson;Alex and Christopher Rivest; and Molly, Noah, and Benjamin Stein\u2014for their loveand support while we prepared this book. The patience and encouragement of ourfamilies made this project possible. We affectionately dedicate this book to them.\nT\nHOMAS H. C ORMEN Lebanon, New Hampshire\nCHARLES E. L EISERSON Cambridge, Massachusetts\nRONALD L. R IVEST Cambridge, Massachusetts\nCLIFFORD STEIN New York, New York\nFebruary 2009", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "20": {"page_number": 21, "page_information": "", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "21": {"page_number": 22, "page_information": "Introduction to Algorithms\nThird Edition", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "22": {"page_number": 23, "page_information": "I Foundations", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "23": {"page_number": 24, "page_information": "Introduction\nThis part will start you thinking about designing and analyzing algorithms. It is\nintended to be a gentle introduction to how we specify algorithms, some of thedesign strategies we will use throughout this book, and many of the fundamentalideas used in algorithm analysis. Later parts of this book will build upon this base.\nChapter 1 provides an overview of algorithms and their place in modern com-\nputing systems. This chapter de\ufb01nes what an algorithm is and lists some examples.It also makes a case that we should consider algorithms as a technology, along-side technologies such as fast hardware, graphical user interfaces, object-orientedsystems, and networks.\nIn Chapter 2, we see our \ufb01rst algorithms, which solve the problem of sorting\na sequence of nnumbers. They are written in a pseudocode which, although not\ndirectly translatable to any conventional programming language, conveys the struc-\nture of the algorithm clearly enough that you should be able to implement it in the\nlanguage of your choice. The sorting algorithms we examine are insertion sort,\nwhich uses an incremental approach, and merge sort, which uses a recursive tech-\nnique known as \u201cdivide-and-conquer.\u201d Although the time each requires increases\nwith the value of n, the rate of increase differs between the two algorithms. We\ndetermine these running times in Chapter 2, and we develop a useful notation toexpress them.\nChapter 3 precisely de\ufb01nes this notation, which we call asymptotic notation. It\nstarts by de\ufb01ning several asymptotic notations, which we use for bounding algo-rithm running times from above and/or below. The rest of Chapter 3 is primarilya presentation of mathematical notation, more to ensure that your use of notationmatches that in this book than to teach you new mathematical concepts.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "24": {"page_number": 25, "page_information": "4 Part I Foundations\nChapter 4 delves further into the divide-and-conquer method introduced in\nChapter 2. It provides additional examples of divide-and-conquer algorithms, in-cluding Strassen\u2019s surprising method for multiplying two square matrices. Chap-ter 4 contains methods for solving recurrences, which are useful for describingthe running times of recursive algorithms. One powerful technique is the \u201cmas-ter method,\u201d which we often use to solve recurrences that arise from divide-and-conquer algorithms. Although much of Chapter 4 is devoted to proving the cor-rectness of the master method, you may skip this proof yet still employ the master\nmethod.\nChapter 5 introduces probabilistic analysis and randomized algorithms. We typ-\nically use probabilistic analysis to determine the running time of an algorithm incases in which, due to the presence of an inherent probability distribution, therunning time may differ on different inputs of the same size. In some cases, weassume that the inputs conform to a known probability distribution, so that we areaveraging the running time over all possible inputs. In other cases, the probabilitydistribution comes not from the inputs but from random choices made during thecourse of the algorithm. An algorithm whose behavior is determined not only by itsinput but by the values produced by a random-number generator is a randomizedalgorithm. We can use randomized algorithms to enforce a probability distributionon the inputs\u2014thereby ensuring that no particular input always causes poor perfor-mance\u2014or even to bound the error rate of algorithms that are allowed to produceincorrect results on a limited basis.\nAppendices A\u2013D contain other mathematical material that you will \ufb01nd helpful\nas you read this book. You are likely to have seen much of the material in theappendix chapters before having read this book (although the speci\ufb01c de\ufb01nitionsand notational conventions we use may differ in some cases from what you haveseen in the past), and so you should think of the Appendices as reference material.On the other hand, you probably have not already seen most of the material inPart I. All the chapters in Part I and the Appendices are written with a tutorial\ufb02avor.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "25": {"page_number": 26, "page_information": "1 The Role of Algorithms in Computing\nWhat are algorithms? Why is the study of algorithms worthwhile? What is the role\nof algorithms relative to other technologies used in computers? In this chapter, wewill answer these questions.\n1.1 Algorithms\nInformally, an algorithm is any well-de\ufb01ned computational procedure that takes\nsome value, or set of values, as input and produces some value, or set of values, as\noutput . An algorithm is thus a sequence of computational steps that transform the\ninput into the output.\nWe can also view an algorithm as a tool for solving a well-speci\ufb01ed computa-\ntional problem . The statement of the problem speci\ufb01es in general terms the desired\ninput/output relationship. The algorithm describes a speci\ufb01c computational proce-\ndure for achieving that input/output relationship.\nFor example, we might need to sort a sequence of numbers into nondecreasing\norder. This problem arises frequently in practice and provides fertile ground forintroducing many standard design techniques and analysis tools. Here is how weformally de\ufb01ne the sorting problem :\nInput: A sequence of nnumbersha\n1;a2;:::;a ni.\nOutput: A permutation (reordering) ha0\n1;a0\n2;:::;a0\nniof the input sequence such\nthata0\n1/DC4a0\n2/DC4/SOH/SOH/SOH/DC4 a0\nn.\nFor example, given the input sequence h31; 41; 59; 26; 41; 58 i, a sorting algorithm\nreturns as output the sequence h26; 31; 41; 41; 58; 59 i. Such an input sequence is\ncalled an instance of the sorting problem. In general, an instance of a problem\nconsists of the input (satisfying whatever constraints are imposed in the problemstatement) needed to compute a solution to the problem.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "26": {"page_number": 27, "page_information": "6 Chapter 1 The Role of Algorithms in Computing\nBecause many programs use it as an intermediate step, sorting is a fundamental\noperation in computer science. As a result, we have a large number of good sortingalgorithms at our disposal. Which algorithm is best for a given application dependson\u2014among other factors\u2014the number of items to be sorted, the extent to whichthe items are already somewhat sorted, possible restrictions on the item values,the architecture of the computer, and the kind of storage devices to be used: mainmemory, disks, or even tapes.\nAn algorithm is said to be correct if, for every input instance, it halts with the\ncorrect output. We say that a correct algorithm solves the given computational\nproblem. An incorrect algorithm might not halt at all on some input instances, or itmight halt with an incorrect answer. Contrary to what you might expect, incorrectalgorithms can sometimes be useful, if we can control their error rate. We shall seean example of an algorithm with a controllable error rate in Chapter 31 when westudy algorithms for \ufb01nding large prime numbers. Ordinarily, however, we shallbe concerned only with correct algorithms.\nAn algorithm can be speci\ufb01ed in English, as a computer program, or even as\na hardware design. The only requirement is that the speci\ufb01cation must provide a\nprecise description of the computational procedure to be followed.\nWhat kinds of problems are solved by algorithms?\nSorting is by no means the only computational problem for which algorithms have\nbeen developed. (You probably suspected as much when you saw the size of thisbook.) Practical applications of algorithms are ubiquitous and include the follow-ing examples:\n/SIThe Human Genome Project has made great progress toward the goals of iden-tifying all the 100,000 genes in human DNA, determining the sequences of the3 billion chemical base pairs that make up human DNA, storing this informa-\ntion in databases, and developing tools for data analysis. Each of these steps\nrequires sophisticated algorithms. Although the solutions to the various prob-lems involved are beyond the scope of this book, many methods to solve thesebiological problems use ideas from several of the chapters in this book, therebyenabling scientists to accomplish tasks while using resources ef\ufb01ciently. Thesavings are in time, both human and machine, and in money, as more informa-tion can be extracted from laboratory techniques.\n/SIThe Internet enables people all around the world to quickly access and retrievelarge amounts of information. With the aid of clever algorithms, sites on theInternet are able to manage and manipulate this large volume of data. Examplesof problems that make essential use of algorithms include \ufb01nding good routeson which the data will travel (techniques for solving such problems appear in", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "27": {"page_number": 28, "page_information": "1.1 Algorithms 7\nChapter 24), and using a search engine to quickly \ufb01nd pages on which particular\ninformation resides (related techniques are in Chapters 11 and 32).\n/SIElectronic commerce enables goods and services to be negotiated and ex-changed electronically, and it depends on the privacy of personal informa-tion such as credit card numbers, passwords, and bank statements. The coretechnologies used in electronic commerce include public-key cryptography anddigital signatures (covered in Chapter 31), which are based on numerical algo-rithms and number theory.\n/SIManufacturing and other commercial enterprises often need to allocate scarceresources in the most bene\ufb01cial way. An oil company may wish to know whereto place its wells in order to maximize its expected pro\ufb01t. A political candidatemay want to determine where to spend money buying campaign advertising inorder to maximize the chances of winning an election. An airline may wishto assign crews to \ufb02ights in the least expensive way possible, making sure thateach \ufb02ight is covered and that government regulations regarding crew schedul-ing are met. An Internet service provider may wish to determine where to placeadditional resources in order to serve its customers more effectively. All ofthese are examples of problems that can be solved using linear programming,which we shall study in Chapter 29.\nAlthough some of the details of these examples are beyond the scope of this\nbook, we do give underlying techniques that apply to these problems and problemareas. We also show how to solve many speci\ufb01c problems, including the following:\n/SIWe are given a road map on which the distance between each pair of adjacentintersections is marked, and we wish to determine the shortest route from oneintersection to another. The number of possible routes can be huge, even if wedisallow routes that cross over themselves. How do we choose which of allpossible routes is the shortest? Here, we model the road map (which is itselfa model of the actual roads) as a graph (which we will meet in Part VI andAppendix B), and we wish to \ufb01nd the shortest path from one vertex to anotherin the graph. We shall see how to solve this problem ef\ufb01ciently in Chapter 24.\n/SIWe are given two ordered sequences of symbols, XDhx1;x2;:::;x miand\nYDhy1;y2;:::;y ni, and we wish to \ufb01nd a longest common subsequence of\nXandY. A subsequence of Xis just Xwith some (or possibly all or none) of\nits elements removed. For example, one subsequence of hA; B; C; D; E; F; G i\nwould behB; C; E; Gi. The length of a longest common subsequence of X\nandYgives one measure of how similar these two sequences are. For example,\nif the two sequences are base pairs in DNA strands, then we might considerthem similar if they have a long common subsequence. If Xhasmsymbols\nandYhasnsymbols, then XandYhave 2\nmand2npossible subsequences,", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "28": {"page_number": 29, "page_information": "8 Chapter 1 The Role of Algorithms in Computing\nrespectively. Selecting all possible subsequences of XandYand matching\nthem up could take a prohibitively long time unless mandnare very small.\nWe shall see in Chapter 15 how to use a general technique known as dynamicprogramming to solve this problem much more ef\ufb01ciently.\n/SIWe are given a mechanical design in terms of a library of parts, where each partmay include instances of other parts, and we need to list the parts in order sothat each part appears before any part that uses it. If the design comprises n\nparts, then there are n\u0160possible orders, where n\u0160denotes the factorial function.\nBecause the factorial function grows faster than even an exponential function,we cannot feasibly generate each possible order and then verify that, withinthat order, each part appears before the parts using it (unless we have only afew parts). This problem is an instance of topological sorting, and we shall seein Chapter 22 how to solve this problem ef\ufb01ciently.\n/SIWe are given npoints in the plane, and we wish to \ufb01nd the convex hull of\nthese points. The convex hull is the smallest convex polygon containing the\npoints. Intuitively, we can think of each point as being represented by a nail\nsticking out from a board. The convex hull would be represented by a tight\nrubber band that surrounds all the nails. Each nail around which the rubberband makes a turn is a vertex of the convex hull. (See Figure 33.6 on page 1029for an example.) Any of the 2\nnsubsets of the points might be the vertices\nof the convex hull. Knowing which points are vertices of the convex hull isnot quite enough, either, since we also need to know the order in which they\nappear. There are many choices, therefore, for the vertices of the convex hull.\nChapter 33 gives two good methods for \ufb01nding the convex hull.\nThese lists are far from exhaustive (as you again have probably surmised from\nthis book\u2019s heft), but exhibit two characteristics that are common to many interest-ing algorithmic problems:\n1. They have many candidate solutions, the overwhelming majority of which do\nnot solve the problem at hand. Finding one that does, or one that is \u201cbest,\u201d can\npresent quite a challenge.\n2. They have practical applications. Of the problems in the above list, \ufb01nding the\nshortest path provides the easiest examples. A transportation \ufb01rm, such as atrucking or railroad company, has a \ufb01nancial interest in \ufb01nding shortest pathsthrough a road or rail network because taking shorter paths results in lowerlabor and fuel costs. Or a routing node on the Internet may need to \ufb01nd the\nshortest path through the network in order to route a message quickly. Or a\nperson wishing to drive from New York to Boston may want to \ufb01nd drivingdirections from an appropriate Web site, or she may use her GPS while driving.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "29": {"page_number": 30, "page_information": "1.1 Algorithms 9\nNot every problem solved by algorithms has an easily identi\ufb01ed set of candidate\nsolutions. For example, suppose we are given a set of numerical values represent-ing samples of a signal, and we want to compute the discrete Fourier transform ofthese samples. The discrete Fourier transform converts the time domain to the fre-quency domain, producing a set of numerical coef\ufb01cients, so that we can determinethe strength of various frequencies in the sampled signal. In addition to lying atthe heart of signal processing, discrete Fourier transforms have applications in datacompression and multiplying large polynomials and integers. Chapter 30 gives\nan ef\ufb01cient algorithm, the fast Fourier transform (commonl y called the FFT), for\nthis problem, and the chapter also sketches out the design of a hardware circuit tocompute the FFT.\nData structures\nThis book also contains several data structures. A data structure is a way to store\nand organize data in order to facilitate access and modi\ufb01cations. No single datastructure works well for all purposes, and so it is important to know the strengthsand limitations of several of them.\nTechnique\nAlthough you can use this book as a \u201ccookbook\u201d for algorithms, you may someday\nencounter a problem for which you cannot readily \ufb01nd a published algorithm (many\nof the exercises and problems in this book, for example). This book will teach you\ntechniques of algorithm design and analysis so that you can develop algorithms onyour own, show that they give the correct answer, and understand their ef\ufb01ciency.Different chapters address different aspects of algorithmic problem solving. Somechapters address speci\ufb01c problems, such as \ufb01nding medians and order statistics inChapter 9, computing minimum spanning trees in Chapter 23, and determining amaximum \ufb02ow in a network in Chapter 26. Other chapters address techniques,such as divide-and-conquer in Chapter 4, dynamic programming in Chapter 15,and amortized analysis in Chapter 17.\nHard problems\nMost of this book is about ef\ufb01cient algorithms. Our usual measure of ef\ufb01ciency\nis speed, i.e., how long an algorithm takes to produce its result. There are someproblems, however, for which no ef\ufb01cient solution is known. Chapter 34 studies\nan interesting subset of these problems, which are known as NP-complete.\nWhy are NP-complete problems interesting? First, although no ef\ufb01cient algo-\nrithm for an NP-complete problem has ever been found, nobody has ever proven", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "30": {"page_number": 31, "page_information": "10 Chapter 1 The Role of Algorithms in Computing\nthat an ef\ufb01cient algorithm for one cannot exist. In other words, no one knows\nwhether or not ef\ufb01cient algorithms exist for NP-complete problems. Second, theset of NP-complete problems has the remarkable property that if an ef\ufb01cient algo-rithm exists for any one of them, then ef\ufb01cient algorithms exist for all of them. Thisrelationship among the NP-complete problems makes the lack of ef\ufb01cient solutionsall the more tantalizing. Third, several NP-complete problems are similar, but notidentical, to problems for which we do know of ef\ufb01cient algorithms. Computerscientists are intrigued by how a small change to the problem statement can cause\na big change to the ef\ufb01ciency of the best known algorithm.\nYou should know about NP-complete problems because some of them arise sur-\nprisingly often in real applications. If you are called upon to produce an ef\ufb01cientalgorithm for an NP-complete problem, you are likely to spend a lot of time in afruitless search. If you can show that the problem is NP-complete, you can insteadspend your time developing an ef\ufb01cient algorithm that gives a good, but not thebest possible, solution.\nAs a concrete example, consider a delivery company with a central depot. Each\nday, it loads up each delivery truck at the depot and sends it around to deliver goods\nto several addresses. At the end of the day, each truck must end up back at the depot\nso that it is ready to be loaded for the next day. To reduce costs, the company wantsto select an order of delivery stops that yields the lowest overall distance traveledby each truck. This problem is the well-known \u201ctraveling-salesman problem,\u201d andit is NP-complete. It has no known ef\ufb01cient algorithm. Under certain assumptions,\nhowever, we know of ef\ufb01cient algorithms that give an overall distance which is\nnot too far above the smallest possible. Chapter 35 discusses such \u201capproximationalgorithms.\u201d\nParallelism\nFor many years, we could count on processor clock speeds increasing at a steady\nrate. Physical limitations present a fundamental roadblock to ever-increasing clockspeeds, however: because power density increases superlinearly with clock speed,chips run the risk of melting once their clock speeds become high enough. In orderto perform more computations per second, therefore, chips are being designed tocontain not just one but several processing \u201ccores.\u201d We can liken these multicorecomputers to several sequential computers on a single chip; in other words, they area type of \u201cparallel computer.\u201d In order to elicit the best performance from multicorecomputers, we need to design algorithms with parallelism in mind. Chapter 27presents a model for \u201cmultithreaded\u201d algorithms, which take advantage of multiplecores. This model has advantages from a theoretical standpoint, and it forms thebasis of several successful computer programs, including a championship chessprogram.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "31": {"page_number": 32, "page_information": "1.2 Algorithms as a technology 11\nExercises\n1.1-1\nGive a real-world example that requires sorting or a real-world example that re-quires computing a convex hull.\n1.1-2\nOther than speed, what other measures of ef\ufb01ciency might one use in a real-worldsetting?\n1.1-3\nSelect a data structure that you have seen previously, and discuss its strengths andlimitations.\n1.1-4\nHow are the shortest-path and traveling-salesman problems given above similar?How are they different?\n1.1-5\nCome up with a real-world problem in which only the best solution will do. Thencome up with one in which a solution that is \u201capproximately\u201d the best is goodenough.\n1.2 Algorithms as a technology\nSuppose computers were in\ufb01nitely fast and computer memory was free. Wouldyou have any reason to study algorithms? The answer is yes, if for no other reasonthan that you would still like to demonstrate that your solution method terminatesand does so with the correct answer.\nIf computers were in\ufb01nitely fast, any correct method for solving a problem\nwould do. You would probably want your implementation to be within the boundsof good software engineering practice (for example, your implementation should\nbe well designed and documented), but you would most often use whichever\nmethod was the easiest to implement.\nOf course, computers may be fast, but they are not in\ufb01nitely fast. And memory\nmay be inexpensive, but it is not free. Computing time is therefore a boundedresource, and so is space in memory. You should use these resources wisely, andalgorithms that are ef\ufb01cient in terms of time or space will help you do so.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "32": {"page_number": 33, "page_information": "12 Chapter 1 The Role of Algorithms in Computing\nEf\ufb01ciency\nDifferent algorithms devised to solve the same problem often differ dramatically in\ntheir ef\ufb01ciency. These differences can be much more signi\ufb01cant than differencesdue to hardware and software.\nAs an example, in Chapter 2, we will see two algorithms for sorting. The \ufb01rst,\nknown as insertion sort , takes time roughly equal to c\n1n2to sort nitems, where c1\nis a constant that does not depend on n. That is, it takes time roughly proportional\nton2. The second, merge sort , takes time roughly equal to c2nlgn, where lg n\nstands for log2nandc2is another constant that also does not depend on n. Inser-\ntion sort typically has a smaller constant factor than merge sort, so that c1<c 2.\nWe shall see that the constant factors can have far less of an impact on the runningtime than the dependence on the input size n. Let\u2019s write insertion sort\u2019s running\ntime as c\n1n/SOHnand merge sort\u2019s running time as c2n/SOHlgn. Then we see that where\ninsertion sort has a factor of nin its running time, merge sort has a factor of lg n,\nwhich is much smaller. (For example, when nD1000 ,l gnis approximately 10,\nand when nequals one million, lg nis approximately only 20.) Although insertion\nsort usually runs faster than merge sort for small input sizes, once the input size n\nbecomes large enough, merge sort\u2019s advantage of lg nvs.nwill more than com-\npensate for the difference in constant factors. No matter how much smaller c1is\nthanc2, there will always be a crossover point beyond which merge sort is faster.\nFor a concrete example, let us pit a faster computer (computer A) running inser-\ntion sort against a slower computer (computer B) running merge sort. They eachmust sort an array of 10 million numbers. (Although 10 million numbers mightseem like a lot, if the numbers are eight-byte integers, then the input occupiesabout 80 megabytes, which \ufb01ts in the memory of even an inexpensive laptop com-puter many times over.) Suppose that computer A executes 10 billion instructionsper second (faster than any single sequential computer at the time of this writing)and computer B executes only 10 million instructions per second, so that com-\nputer A is 1000 times faster than computer B in raw computing power. To make\nthe difference even more dramatic, suppose that the world\u2019s craftiest programmercodes insertion sort in machine language for computer A, and the resulting coderequires 2n\n2instructions to sort nnumbers. Suppose further that just an average\nprogrammer implements merge sort, using a high-level language with an inef\ufb01cientcompiler, with the resulting code taking 50nlgninstructions. To sort 10 million\nnumbers, computer A takes\n2/SOH.10\n7/2instructions\n1010instructions/secondD20,000 seconds (more than 5.5 hours) ;\nwhile computer B takes", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "33": {"page_number": 34, "page_information": "1.2 Algorithms as a technology 13\n50/SOH107lg107instructions\n107instructions/second/EM1163 seconds (less than 20 minutes) :\nBy using an algorithm whose running time grows more slowly, even with a poor\ncompiler, computer B runs more than 17 times faster than computer A! The advan-tage of merge sort is even more pronounced when we sort 100 million numbers:where insertion sort takes more than 23 days, merge sort takes under four hours.In general, as the problem size increases, so does the relative advantage of mergesort.\nAlgorithms and other technologies\nThe example above shows that we should consider algorithms, like computer hard-\nware, as a technology . Total system performance depends on choosing ef\ufb01cient\nalgorithms as much as on choosing fast hardware. Just as rapid advances are beingmade in other computer technologies, they are being made in algorithms as well.\nYou might wonder whether algorithms are truly that important on contemporary\ncomputers in light of other advanced technologies, such as\n/SIadvanced computer architectures and fabrication technologies,\n/SIeasy-to-use, intuitive, graphical user interfaces (GUIs),\n/SIobject-oriented systems,\n/SIintegrated Web technologies, and\n/SIfast networking, both wired and wireless.\nThe answer is yes. Although some applications do not explicitly require algorith-\nmic content at the application level (such as some simple, Web-based applications),many do. For example, consider a Web-based service that determines how to travelfrom one location to another. Its implementation would rely on fast hardware, agraphical user interface, wide-area networking, and also possibly on object ori-entation. However, it would also require algorithms for certain operations, suchas \ufb01nding routes (probably using a shortest-path algorithm), rendering maps, andinterpolating addresses.\nMoreover, even an application that does not require algorithmic content at the\napplication level relies heavily upon algorithms. Does the application rely on fasthardware? The hardware design used algorithms. Does the application rely ongraphical user interfaces? The design of any GUI relies on algorithms. Does theapplication rely on networking? Routing in networks relies heavily on algorithms.Was the application written in a language other than machine code? Then it wasprocessed by a compiler, interpreter, or assembler, all of which make extensive use", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "34": {"page_number": 35, "page_information": "14 Chapter 1 The Role of Algorithms in Computing\nof algorithms. Algorithms are at the core of most technologies used in contempo-\nrary computers.\nFurthermore, with the ever-increasing capacities of computers, we use them to\nsolve larger problems than ever before. As we saw in the above comparison be-tween insertion sort and merge sort, it is at larger problem sizes that the differencesin ef\ufb01ciency between algorithms become particularly prominent.\nHaving a solid base of algorithmic knowledge and technique is one characteristic\nthat separates the truly skilled programmers from the novices. With modern com-\nputing technology, you can accomplish some tasks without knowing much about\nalgorithms, but with a good background in algorithms, you can do much, muchmore.\nExercises\n1.2-1\nGive an example of an application that requires algorithmic content at the applica-tion level, and discuss the function of the algorithms involved.\n1.2-2\nSuppose we are comparing implementations of insertion sort and merge sort on the\nsame machine. For inputs of size n, insertion sort runs in 8n\n2steps, while merge\nsort runs in 64nlgnsteps. For which values of ndoes insertion sort beat merge\nsort?\n1.2-3\nWhat is the smallest value of nsuch that an algorithm whose running time is 100n2\nruns faster than an algorithm whose running time is 2non the same machine?\nProblems\n1-1 Comparison of running times\nFor each function f .n/ and time tin the following table, determine the largest\nsizenof a problem that can be solved in time t, assuming that the algorithm to\nsolve the problem takes f .n/ microseconds.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "35": {"page_number": 36, "page_information": "Notes for Chapter 1 15\n1\n 1\n 1\n 1\n 1\n 1\n 1\nsecond\n minute\n hour\n day\n month\n year\n century\nlgn\np\nn\nn\nnlgn\nn2\nn3\n2n\nn\u0160\nChapter notes\nThere are many excellent texts on the general topic of algorithms, including those\nby Aho, Hopcroft, and Ullman [5, 6]; Baase and Van Gelder [28]; Brassard andBratley [54]; Dasgupta, Papadimitriou, and Vazirani [82]; Goodrich and Tamassia[148]; Hofri [175]; Horowitz, Sahni, and Rajasekaran [181]; Johnsonbaugh andSchaefer [193]; Kingston [205]; Kleinberg and Tardos [208]; Knuth [209, 210,211]; Kozen [220]; Levitin [235]; Manber [242]; Mehlhorn [249, 250, 251]; Pur-dom and Brown [287]; Reingold, Nievergelt, and Deo [293]; Sedgewick [306];Sedgewick and Flajolet [307]; Skiena [318]; and Wilf [356]. Some of the morepractical aspects of algorithm design are discussed by Bentley [42, 43] and Gonnet[145]. Surveys of the \ufb01eld of algorithms can also be found in the Handbook of The-\noretical Computer Science, Volume A [342] and the CRC Algorithms and Theory of\nComputation Handbook [25]. Overviews of the algorithms used in computational\nbiology can be found in textbooks by Gus\ufb01eld [156], Pevzner [275], Setubal andMeidanis [310], and Waterman [350].", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "36": {"page_number": 37, "page_information": "2 Getting Started\nThis chapter will familiarize you with the framework we shall use throughout the\nbook to think about the design and analysis of algorithms. It is self-contained, butit does include several references to material that we introduce in Chapters 3 and 4.(It also contains several summations, which Appendix A shows how to solve.)\nWe begin by examining the insertion sort algorithm to solve the sorting problem\nintroduced in Chapter 1. We de\ufb01ne a \u201cpseudocode\u201d that should be familiar to you ifyou have done computer programming, and we use it to show how we shall specifyour algorithms. Having speci\ufb01ed the insertion sort algorithm, we then argue that itcorrectly sorts, and we analyze its running time. The analysis introduces a notationthat focuses on how that time increases with the number of items to be sorted.Following our discussion of insertion sort, we introduce the divide-and-conquerapproach to the design of algorithms and use it to develop an algorithm calledmerge sort. We end with an analysis of merge sort\u2019s running time.\n2.1 Insertion sort\nOur \ufb01rst algorithm, insertion sort, solves the sorting problem introduced in Chap-\nter 1:\nInput: A sequence of nnumbersha1;a2;:::;a ni.\nOutput: A permutation (reordering) ha0\n1;a0\n2;:::;a0\nniof the input sequence such\nthata0\n1/DC4a0\n2/DC4/SOH/SOH/SOH/DC4 a0\nn.\nThe numbers that we wish to sort are also known as the keys. Although conceptu-\nally we are sorting a sequence, the input comes to us in the form of an array with n\nelements.\nIn this book, we shall typically describe algorithms as programs written in a\npseudocode that is similar in many respects to C, C++, Java, Python, or Pascal. If\nyou have been introduced to any of these languages, you should have little trouble", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "37": {"page_number": 38, "page_information": "2.1 Insertion sort 17\n2\u2663\u2663\u26632\u26634\u2663\u2663\u2663\u2663\u2663 4\u26635\u2663\u2663\u2663\u2663\u2663 5\u2663\u26637\u2663\n\u2663\u2663\u2663\n\u2663\u2663\u2663\u26637\u266310\u2663\u2663\u2663\u2663\n\u2663\u2663\u2663\u2663\u2663\n\u2663\u266310\u2663\nFigure 2.1 Sorting a hand of cards using insertion sort.\nreading our algorithms. What separates pseudocode from \u201creal\u201d code is that in\npseudocode, we employ whatever expressive method is most clear and concise tospecify a given algorithm. Sometimes, the clearest method is English, so do notbe surprised if you come across an English phrase or sentence embedded withina section of \u201creal\u201d code. Another difference between pseudocode and real codeis that pseudocode is not typically concerned with issues of software engineering.\nIssues of data abstraction, modularity, and error handling are often ignored in order\nto convey the essence of the algorithm more concisely.\nWe start with insertion sort , which is an ef\ufb01cient algorithm for sorting a small\nnumber of elements. Insertion sort works the way many people sort a hand of\nplaying cards. We start with an empty left hand and the cards face down on thetable. We then remove one card at a time from the table and insert it into thecorrect position in the left hand. To \ufb01nd the correct position for a card, we compareit with each of the cards already in the hand, from right to left, as illustrated inFigure 2.1. At all times, the cards held in the left hand are sorted, and these cardswere originally the top cards of the pile on the table.\nWe present our pseudocode for insertion sort as a procedure called I\nNSERTION -\nSORT, which takes as a parameter an array A\u01521 : : n/c141 containing a sequence of\nlength nthat is to be sorted. (In the code, the number nof elements in Ais denoted\nbyA:length .) The algorithm sorts the input numbers in place : it rearranges the\nnumbers within the array A, with at most a constant number of them stored outside\nthe array at any time. The input array Acontains the sorted output sequence when\nthe I NSERTION -SORT procedure is \ufb01nished.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "38": {"page_number": 39, "page_information": "18 Chapter 2 Getting Started\n123456\n524613 (a)123456\n25 4613 (b)123456\n245 613 (c)\n123456\n2456 13 (d)123456\n24561 3 (e)123456\n2 456 1 3 (f)\nFigure 2.2 The operation of I NSERTION -SORT on the array ADh5; 2; 4; 6; 1; 3i. Array indices\nappear above the rectangles, and values stored in the array positions appear within the rectangles.\n(a)\u2013(e) The iterations of the forloop of lines 1\u20138. In each iteration, the black rectangle holds the\nkey taken from A\u0152j /c141 , which is compared with the values in shaded rectangles to its left in the test of\nline 5. Shaded arrows show array values moved one position to the right in line 6, and black arrows\nindicate where the key moves to in line 8. (f)The \ufb01nal sorted array.\nINSERTION -SORT.A/\n1forjD2toA:length\n2 keyDA\u0152j /c141\n3 //Insert A\u0152j /c141 into the sorted sequence A\u01521 : : j/NUL1/c141.\n4 iDj/NUL1\n5 while i>0 andA\u0152i/c141 > key\n6 A\u0152iC1/c141DA\u0152i/c141\n7 iDi/NUL1\n8 A\u0152iC1/c141Dkey\nLoop invariants and the correctness of insertion sort\nFigure 2.2 shows how this algorithm works for ADh5; 2; 4; 6; 1; 3i.T h e i n -\ndexjindicates the \u201ccurrent card\u201d being inserted into the hand. At the beginning\nof each iteration of the forloop, which is indexed by j, the subarray consisting\nof elements A\u01521 : : j/NUL1/c141constitutes the currently sorted hand, and the remaining\nsubarray A\u0152jC1::n /c141 corresponds to the pile of cards still on the table. In fact,\nelements A\u01521 : : j/NUL1/c141are the elements originally in positions 1 through j/NUL1,b u t\nnow in sorted order. We state these properties of A\u01521 : : j/NUL1/c141formally as a loop\ninvariant :\nAt the start of each iteration of the forloop of lines 1\u20138, the subarray\nA\u01521 : : j/NUL1/c141consists of the elements originally in A\u01521 : : j/NUL1/c141, but in sorted\norder.\nWe use loop invariants to help us understand why an algorithm is correct. We\nmust show three things about a loop invariant:", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "39": {"page_number": 40, "page_information": "2.1 Insertion sort 19\nInitialization: It is true prior to the \ufb01rst iteration of the loop.\nMaintenance: If it is true before an iteration of the loop, it remains true before the\nnext iteration.\nTermination: When the loop terminates, the invariant gives us a useful property\nthat helps show that the algorithm is correct.\nWhen the \ufb01rst two properties hold, the loop invariant is true prior to every iteration\nof the loop. (Of course, we are free to use established facts other than the loopinvariant itself to prove that the loop invariant remains true before each iteration.)Note the similarity to mathematical induction, where to prove that a property holds,you prove a base case and an inductive step. Here, showing that the invariant holdsbefore the \ufb01rst iteration corresponds to the base case, and showing that the invariantholds from iteration to iteration corresponds to the inductive step.\nThe third property is perhaps the most important one, since we are using the loop\ninvariant to show correctness. Typically, we use the loop invariant along with the\ncondition that caused the loop to terminate. The termination property differs from\nhow we usually use mathematical induction, in which we apply the inductive stepin\ufb01nitely; here, we stop the \u201cinduction\u201d when the loop terminates.\nLet us see how these properties hold for insertion sort.\nInitialization: We start by showing that the loop invariant holds before the \ufb01rst\nloop iteration, when jD2.\n1The subarray A\u01521 : : j/NUL1/c141, therefore, consists\nof just the single element A\u01521/c141, which is in fact the original element in A\u01521/c141.\nMoreover, this subarray is sorted (trivially, of course), which shows that theloop invariant holds prior to the \ufb01rst iteration of the loop.\nMaintenance: Next, we tackle the second property: showing that each iteration\nmaintains the loop invariant. Informally, the body of the forloop works by\nmoving A\u0152j/NUL1/c141,A\u0152j/NUL2/c141,A\u0152j/NUL3/c141, and so on by one position to the right\nuntil it \ufb01nds the proper position for A\u0152j /c141 (lines 4\u20137), at which point it inserts\nthe value of A\u0152j /c141 (line 8). The subarray A\u01521 : : j /c141 then consists of the elements\noriginally in A\u01521 : : j /c141 , but in sorted order. Incrementing jfor the next iteration\nof the forloop then preserves the loop invariant.\nA more formal treatment of the second property would require us to state and\nshow a loop invariant for the while loop of lines 5\u20137. At this point, however,\n1When the loop is a forloop, the moment at which we check the loop invariant just prior to the \ufb01rst\niteration is immediately after the initial assignment to the loop-counter variable and just before the\n\ufb01rst test in the loop header. In the case of I NSERTION -SORT, this time is after assigning 2to the\nvariable jbut before the \ufb01rst test of whether j/DC4A:length .", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "40": {"page_number": 41, "page_information": "20 Chapter 2 Getting Started\nwe prefer not to get bogged down in such formalism, and so we rely on our\ninformal analysis to show that the second property holds for the outer loop.\nTermination: Finally, we examine what happens when the loop terminates. The\ncondition causing the forloop to terminate is that j> A : lengthDn. Because\neach loop iteration increases jby1,w em u s th a v e jDnC1at that time.\nSubstituting nC1forjin the wording of loop invariant, we have that the\nsubarray A\u01521 : : n/c141 consists of the elements originally in A\u01521 : : n/c141 , but in sorted\norder. Observing that the subarray A\u01521 : : n/c141 is the entire array, we conclude that\nthe entire array is sorted. Hence, the algorithm is correct.\nWe shall use this method of loop invariants to show correctness later in this\nchapter and in other chapters as well.\nPseudocode conventions\nWe use the following conventions in our pseudocode.\n/SIIndentation indicates block structure. For example, the body of the forloop that\nbegins on line 1 consists of lines 2\u20138, and the body of the while loop that begins\non line 5 contains lines 6\u20137 but not line 8. Our indentation style applies to\nif-elsestatements2as well. Using indentation instead of conventional indicators\nof block structure, such as begin andend statements, greatly reduces clutter\nwhile preserving, or even enhancing, clarity.3\n/SIThe looping constructs while ,for,a n drepeat -until and the if-elseconditional\nconstruct have interpretations similar to those in C, C++, Java, Python, andPascal.\n4In this book, the loop counter retains its value after exiting the loop,\nunlike some situations that arise in C++, Java, and Pascal. Thus, immediately\nafter a forloop, the loop counter\u2019s value is the value that \ufb01rst exceeded the for\nloop bound. We used this property in our correctness argument for insertionsort. The forloop header in line 1 is forjD2toA:length , and so when\nthis loop terminates, jDA:lengthC1(or, equivalently, jDnC1,s i n c e\nnDA:length ). We use the keyword towhen a forloop increments its loop\n2In an if-elsestatement, we indent elseat the same level as its matching if. Although we omit the\nkeyword then , we occasionally refer to the portion executed when the test following ifis true as a\nthen clause . For multiway tests, we use elseif for tests after the \ufb01rst one.\n3Each pseudocode procedure in this book appears on one page so that you will not have to discern\nlevels of indentation in code that is split across pages.\n4Most block-structured languages have equivalent constructs, though the exact syntax may differ.\nPython lacks repeat -until loops, and its forloops operate a little differently from the forloops in\nthis book.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "41": {"page_number": 42, "page_information": "2.1 Insertion sort 21\ncounter in each iteration, and we use the keyword downto when a forloop\ndecrements its loop counter. When the loop counter changes by an amountgreater than 1, the amount of change follows the optional keyword by.\n/SIThe symbol \u201c //\u201d indicates that the remainder of the line is a comment.\n/SIA multiple assignment of the form iDjDeassigns to both variables iandj\nthe value of expression e; it should be treated as equivalent to the assignment\njDefollowed by the assignment iDj.\n/SIVariables (such as i,j,a n d key) are local to the given procedure. We shall not\nuse global variables without explicit indication.\n/SIWe access array elements by specifying the array name followed by the in-dex in square brackets. For example, A\u0152i/c141 indicates the ith element of the\narray A. The notation \u201c ::\u201d is used to indicate a range of values within an ar-\nray. Thus, A\u01521 : : j /c141 indicates the subarray of Aconsisting of the jelements\nA \u0152 1 /c141 ;A \u0152 2 /c141 ;:::;A \u0152 j/c141 .\n/SIWe typically organize compound data into objects , which are composed of\nattributes . We access a particular attribute using the syntax found in many\nobject-oriented programming languages: the object name, followed by a dot,\nfollowed by the attribute name. For example, we treat an array as an object\nwith the attribute length indicating how many elements it contains. To specify\nthe number of elements in an array A, we write A:length .\nWe treat a variable representing an array or object as a pointer to the data rep-\nresenting the array or object. For all attributes fof an object x, setting yDx\ncauses y:fto equal x:f. Moreover, if we now set x:fD3, then afterward not\nonly does x:fequal 3,b u ty:fequals 3as well. In other words, xandypoint\nto the same object after the assignment yDx.\nOur attribute notation can \u201ccascade.\u201d For example, suppose that the attribute f\nis itself a pointer to some type of object that has an attribute g. Then the notation\nx:f:gis implicitly parenthesized as .x:f/:g. In other words, if we had assigned\nyDx:f,t h e n x:f:gis the same as y:g.\nSometimes, a pointer will refer to no object at all. In this case, we give it the\nspecial value NIL.\n/SIWe pass parameters to a procedure by value : the called procedure receives its\nown copy of the parameters, and if it assigns a value to a parameter, the changeisnotseen by the calling procedure. When objects are passed, the pointer to\nthe data representing the object is copied, but the object\u2019s attributes are not. Forexample, if xis a parameter of a called procedure, the assignment xDywithin\nthe called procedure is not visible to the calling procedure. The assignmentx:fD3, however, is visible. Similarly, arrays are passed by pointer, so that", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "42": {"page_number": 43, "page_information": "22 Chapter 2 Getting Started\na pointer to the array is passed, rather than the entire array, and changes to\nindividual array elements are visible to the calling procedure.\n/SIAreturn statement immediately transfers control back to the point of call in\nthe calling procedure. Most return statements also take a value to pass back to\nthe caller. Our pseudocode differs from many programming languages in thatwe allow multiple values to be returned in a single return statement.\n/SIThe boolean operators \u201cand\u201d and \u201cor\u201d are short circuiting . That is, when we\nevaluate the expression \u201c xandy\u201dw e\ufb01 r s te v a l u a t e x.I fxevaluates to FALSE ,\nthen the entire expression cannot evaluate to TRUE , and so we do not evaluate y.\nIf, on the other hand, xevaluates to TRUE ,w em u s te v a l u a t e yto determine the\nvalue of the entire expression. Similarly, in the expression \u201c xory\u201dw ee v a l -\nuate the expression yonly if xevaluates to FALSE . Short-circuiting operators\nallow us to write boolean expressions such as \u201c x\u00a4NILandx:fDy\u201d without\nworrying about what happens when we try to evaluate x:fwhen xisNIL.\n/SIThe keyword error indicates that an error occurred because conditions were\nwrong for the procedure to have been called. The calling procedure is respon-sible for handling the error, and so we do not specify what action to take.\nExercises\n2.1-1\nUsing Figure 2.2 as a model, illustrate the operation of I\nNSERTION -SORT on the\narray ADh31; 41; 59; 26; 41; 58 i.\n2.1-2\nRewrite the I NSERTION -SORT procedure to sort into nonincreasing instead of non-\ndecreasing order.\n2.1-3\nConsider the searching problem :\nInput: A sequence of nnumbers ADha1;a2;:::;a niand a value /ETB.\nOutput: An index isuch that /ETBDA\u0152i/c141 or the special value NILif/ETBdoes not\nappear in A.\nWrite pseudocode for linear search , which scans through the sequence, looking\nfor/ETB. Using a loop invariant, prove that your algorithm is correct. Make sure that\nyour loop invariant ful\ufb01lls the three necessary properties.\n2.1-4\nConsider the problem of adding two n-bit binary integers, stored in two n-element\narrays AandB. The sum of the two integers should be stored in binary form in", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "43": {"page_number": 44, "page_information": "2.2 Analyzing algorithms 23\nan.nC1/-element array C. State the problem formally and write pseudocode for\nadding the two integers.\n2.2 Analyzing algorithms\nAnalyzing an algorithm has come to mean predicting the resources that the algo-\nrithm requires. Occasionally, resources such as memory, communication band-width, or computer hardware are of primary concern, but most often it is compu-tational time that we want to measure. Generally, by analyzing several candidatealgorithms for a problem, we can identify a most ef\ufb01cient one. Such analysis mayindicate more than one viable candidate, but we can often discard several inferioralgorithms in the process.\nBefore we can analyze an algorithm, we must have a model of the implemen-\ntation technology that we will use, including a model for the resources of thattechnology and their costs. For most of this book, we shall assume a generic one-processor, random-access machine (RAM) model of computation as our imple-\nmentation technology and understand that our algorithms will be implemented as\ncomputer programs. In the RAM model, instructions are executed one after an-other, with no concurrent operations.\nStrictly speaking, we should precisely de\ufb01ne the instructions of the RAM model\nand their costs. To do so, however, would be tedious and would yield little insight\ninto algorithm design and analysis. Yet we must be careful not to abuse the RAM\nmodel. For example, what if a RAM had an instruction that sorts? Then we couldsort in just one instruction. Such a RAM would be unrealistic, since real computersdo not have such instructions. Our guide, therefore, is how real computers are de-signed. The RAM model contains instructions commonly found in real computers:arithmetic (such as add, subtract, multiply, divide, remainder, \ufb02oor, ceiling), datamovement (load, store, copy), and control (conditional and unconditional branch,subroutine call and return). Each such instruction takes a constant amount of time.\nThe data types in the RAM model are integer and \ufb02oating point (for storing real\nnumbers). Although we typically do not concern ourselves with precision in this\nbook, in some applications precision is crucial. We also assume a limit on the sizeof each word of data. For example, when working with inputs of size n, we typ-\nically assume that integers are represented by clgnbits for some constant c/NAK1.\nWe require c/NAK1so that each word can hold the value of n, enabling us to index the\nindividual input elements, and we restrict cto be a constant so that the word size\ndoes not grow arbitrarily. (If the word size could grow arbitrarily, we could storehuge amounts of data in one word and operate on it all in constant time\u2014clearlyan unrealistic scenario.)", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "44": {"page_number": 45, "page_information": "24 Chapter 2 Getting Started\nReal computers contain instructions not listed above, and such instructions rep-\nresent a gray area in the RAM model. For example, is exponentiation a constant-time instruction? In the general case, no; it takes several instructions to compute x\ny\nwhen xandyare real numbers. In restricted situations, however, exponentiation is\na constant-time operation. Many computers have a \u201cshift left\u201d instruction, whichin constant time shifts the bits of an integer by kpositions to the left. In most\ncomputers, shifting the bits of an integer by one position to the left is equivalentto multiplication by 2, so that shifting the bits by kpositions to the left is equiv-\nalent to multiplication by 2\nk. Therefore, such computers can compute 2kin one\nconstant-time instruction by shifting the integer 1 by kpositions to the left, as long\naskis no more than the number of bits in a computer word. We will endeavor to\navoid such gray areas in the RAM model, but we will treat computation of 2kas a\nconstant-time operation when kis a small enough positive integer.\nIn the RAM model, we do not attempt to model the memory hierarchy that is\ncommon in contemporary computers. That is, we do not model caches or virtual\nmemory. Several computational models attempt to account for memory-hierarchy\neffects, which are sometimes signi\ufb01cant in real programs on real machines. A\nhandful of problems in this book examine memory-hierarchy effects, but for the\nmost part, the analyses in this book will not consider them. Models that includethe memory hierarchy are quite a bit more complex than the RAM model, and sothey can be dif\ufb01cult to work with. Moreover, RAM-model analyses are usuallyexcellent predictors of performance on actual machines.\nAnalyzing even a simple algorithm in the RAM model can be a challenge. The\nmathematical tools required may include combinatorics, probability theory, alge-\nbraic dexterity, and the ability to identify the most signi\ufb01cant terms in a formula.Because the behavior of an algorithm may be different for each possible input, we\nneed a means for summarizing that behavior in simple, easily understood formulas.\nEven though we typically select only one machine model to analyze a given al-\ngorithm, we still face many choices in deciding how to express our analysis. Wewould like a way that is simple to write and manipulate, shows the important char-acteristics of an algorithm\u2019s resource requirements, and suppresses tedious details.\nAnalysis of insertion sort\nThe time taken by the I\nNSERTION -SORT procedure depends on the input: sorting a\nthousand numbers takes longer than sorting three numbers. Moreover, I NSERTION -\nSORT can take different amounts of time to sort two input sequences of the same\nsize depending on how nearly sorted they already are. In general, the time takenby an algorithm grows with the size of the input, so it is traditional to describe therunning time of a program as a function of the size of its input. To do so, we needto de\ufb01ne the terms \u201crunning time\u201d and \u201csize of input\u201d more carefully.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "45": {"page_number": 46, "page_information": "2.2 Analyzing algorithms 25\nThe best notion for input size depends on the problem being studied. For many\nproblems, such as sorting or computing discrete Fourier transforms, the most nat-ural measure is the number of items in the input \u2014for example, the array size n\nfor sorting. For many other problems, such as multiplying two integers, the bestmeasure of input size is the total number of bits needed to represent the input in\nordinary binary notation. Sometimes, it is more appropriate to describe the size ofthe input with two numbers rather than one. For instance, if the input to an algo-rithm is a graph, the input size can be described by the numbers of vertices and\nedges in the graph. We shall indicate which input size measure is being used with\neach problem we study.\nTherunning time of an algorithm on a particular input is the number of primitive\noperations or \u201csteps\u201d executed. It is convenient to de\ufb01ne the notion of step sothat it is as machine-independent as possible. For the moment, let us adopt thefollowing view. A constant amount of time is required to execute each line of ourpseudocode. One line may take a different amount of time than another line, butwe shall assume that each execution of the ith line takes time c\ni,w h e r e ciis a\nconstant. This viewpoint is in keeping with the RAM model, and it also re\ufb02ects\nhow the pseudocode would be implemented on most actual computers.5\nIn the following discussion, our expression for the running time of I NSERTION -\nSORT will evolve from a messy formula that uses all the statement costs cito a\nmuch simpler notation that is more concise and more easily manipulated. This\nsimpler notation will also make it easy to determine whether one algorithm is more\nef\ufb01cient than another.\nWe start by presenting the I NSERTION -SORT procedure with the time \u201ccost\u201d\nof each statement and the number of times each statement is executed. For eachjD2;3 ;:::;n ,w h e r e nDA:length ,w el e t t\njdenote the number of times the\nwhile loop test in line 5 is executed for that value of j.W h e na fororwhile loop\nexits in the usual way (i.e., due to the test in the loop header), the test is executedone time more than the loop body. We assume that comments are not executablestatements, and so they take no time.\n5There are some subtleties here. Computational steps that we specify in English are often variants\nof a procedure that requires more than just a constant amount of time. For example, later in thisbook we might say \u201csort the points by x-coordinate,\u201d which, as we shall see, takes more than a\nconstant amount of time. Also, note that a statement that calls a subroutine takes constant time,\nthough the subroutine, once invoked, may take more. That is, we separate the process of calling the\nsubroutine\u2014passing parameters to it, etc.\u2014from the process of executing the subroutine.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "46": {"page_number": 47, "page_information": "26 Chapter 2 Getting Started\nINSERTION -SORT.A/ cost times\n1forjD2toA:length c1 n\n2 keyDA\u0152j /c141 c 2 n/NUL1\n3 //Insert A\u0152j /c141 into the sorted\nsequence A\u01521 : : j/NUL1/c141.0 n/NUL1\n4 iDj/NUL1c 4 n/NUL1\n5 while i>0 andA\u0152i/c141 > key c5Pn\njD2tj\n6 A\u0152iC1/c141DA\u0152i/c141 c 6Pn\njD2.tj/NUL1/\n7 iDi/NUL1c 7Pn\njD2.tj/NUL1/\n8 A\u0152iC1/c141Dkey c8 n/NUL1\nThe running time of the algorithm is the sum of running times for each state-\nment executed; a statement that takes cisteps to execute and executes ntimes will\ncontribute cinto the total running time.6To compute T .n/ , the running time of\nINSERTION -SORT on an input of nvalues, we sum the products of the cost and\ntimes columns, obtaining\nT .n/Dc1nCc2.n/NUL1/Cc4.n/NUL1/Cc5nX\njD2tjCc6nX\njD2.tj/NUL1/\nCc7nX\njD2.tj/NUL1/Cc8.n/NUL1/ :\nEven for inputs of a given size, an algorithm\u2019s running time may depend on\nwhich input of that size is given. For example, in I NSERTION -SORT, the best\ncase occurs if the array is already sorted. For each jD2;3 ;:::;n , we then \ufb01nd\nthatA\u0152i/c141/DC4keyin line 5 when ihas its initial value of j/NUL1. Thus tjD1for\njD2;3 ;:::;n , and the best-case running time is\nT .n/Dc1nCc2.n/NUL1/Cc4.n/NUL1/Cc5.n/NUL1/Cc8.n/NUL1/\nD.c1Cc2Cc4Cc5Cc8/n/NUL.c2Cc4Cc5Cc8/:\nWe can express this running time as anCbforconstants aandbthat depend on\nthe statement costs ci;i ti st h u sa linear function ofn.\nIf the array is in reverse sorted order\u2014that is, in decreasing order\u2014the worst\ncase results. We must compare each element A\u0152j /c141 with each element in the entire\nsorted subarray A\u01521 : : j/NUL1/c141,a n ds o tjDjforjD2;3 ;:::;n . Noting that\n6This characteristic does not necessarily hold for a resource such as memory. A statement that\nreferences mwords of memory and is executed ntimes does not necessarily reference mndistinct\nwords of memory.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "47": {"page_number": 48, "page_information": "2.2 Analyzing algorithms 27\nnX\njD2jDn.nC1/\n2/NUL1\nand\nnX\njD2.j/NUL1/Dn.n/NUL1/\n2\n(see Appendix A for a review of how to solve these summations), we \ufb01nd that in\nthe worst case, the running time of I NSERTION -SORT is\nT .n/Dc1nCc2.n/NUL1/Cc4.n/NUL1/Cc5/DC2n.nC1/\n2/NUL1/DC3\nCc6/DC2n.n/NUL1/\n2/DC3\nCc7/DC2n.n/NUL1/\n2/DC3\nCc8.n/NUL1/\nD/DLEc5\n2Cc6\n2Cc7\n2/DC1\nn2C/DLE\nc1Cc2Cc4Cc5\n2/NULc6\n2/NULc7\n2Cc8/DC1\nn\n/NUL.c2Cc4Cc5Cc8/:\nWe can express this worst-case running time as an2CbnCcfor constants a,b,\nandcthat again depend on the statement costs ci; it is thus a quadratic function\nofn.\nTypically, as in insertion sort, the running time of an algorithm is \ufb01xed for a\ngiven input, although in later chapters we shall see some interesting \u201crandomized\u201dalgorithms whose behavior can vary even for a \ufb01xed input.\nWorst-case and average-case analysis\nIn our analysis of insertion sort, we looked at both the best case, in which the input\narray was already sorted, and the worst case, in which the input array was reversesorted. For the remainder of this book, though, we shall usually concentrate on\n\ufb01nding only the worst-case running time , that is, the longest running time for any\ninput of size n. We give three reasons for this orientation.\n/SIThe worst-case running time of an algorithm gives us an upper bound on the\nrunning time for any input. Knowing it provides a guarantee that the algorithmwill never take any longer. We need not make some educated guess about therunning time and hope that it never gets much worse.\n/SIFor some algorithms, the worst case occurs fairly often. For example, in search-ing a database for a particular piece of information, the searching algorithm\u2019sworst case will often occur when the information is not present in the database.In some applications, searches for absent information may be frequent.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "48": {"page_number": 49, "page_information": "28 Chapter 2 Getting Started\n/SIThe \u201caverage case\u201d is often roughly as bad as the worst case. Suppose that we\nrandomly choose nnumbers and apply insertion sort. How long does it take to\ndetermine where in subarray A\u01521 : : j/NUL1/c141to insert element A\u0152j /c141 ?O na v e r a g e ,\nhalf the elements in A\u01521 : : j/NUL1/c141are less than A\u0152j /c141 , and half the elements are\ngreater. On average, therefore, we check half of the subarray A\u01521 : : j/NUL1/c141,a n d\nsotjis about j=2. The resulting average-case running time turns out to be a\nquadratic function of the input size, just like the worst-case running time.\nIn some particular cases, we shall be interested in the average-case running time\nof an algorithm; we shall see the technique of probabilistic analysis applied to\nvarious algorithms throughout this book. The scope of average-case analysis islimited, because it may not be apparent what constitutes an \u201caverage\u201d input fora particular problem. Often, we shall assume that all inputs of a given size areequally likely. In practice, this assumption may be violated, but we can sometimesuse arandomized algorithm , which makes random choices, to allow a probabilistic\nanalysis and yield an expected running time. We explore randomized algorithms\nmore in Chapter 5 and in several other subsequent chapters.\nOrder of growth\nWe used some simplifying abstractions to ease our analysis of the I\nNSERTION -\nSORT procedure. First, we ignored the actual cost of each statement, using the\nconstants cito represent these costs. Then, we observed that even these constants\ngive us more detail than we really need: we expressed the worst-case running time\nasan2CbnCcfor some constants a,b,a n d cthat depend on the statement\ncosts ci. We thus ignored not only the actual statement costs, but also the abstract\ncosts ci.\nWe shall now make one more simplifying abstraction: it is the rate of growth ,\nororder of growth , of the running time that really interests us. We therefore con-\nsider only the leading term of a formula (e.g., an2), since the lower-order terms are\nrelatively insigni\ufb01cant for large values of n. We also ignore the leading term\u2019s con-\nstant coef\ufb01cient, since constant factors are less signi\ufb01cant than the rate of growthin determining computational ef\ufb01ciency for large inputs. For insertion sort, whenwe ignore the lower-order terms and the leading term\u2019s constant coef\ufb01cient, we are\nleft with the factor of n\n2from the leading term. We write that insertion sort has a\nworst-case running time of \u201a.n2/(pronounced \u201ctheta of n-squared\u201d). We shall use\n\u201a-notation informally in this chapter, and we will de\ufb01ne it precisely in Chapter 3.\nWe usually consider one algorithm to be more ef\ufb01cient than another if its worst-\ncase running time has a lower order of growth. Due to constant factors and lower-order terms, an algorithm whose running time has a higher order of growth mighttake less time for small inputs than an algorithm whose running time has a lower", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "49": {"page_number": 50, "page_information": "2.3 Designing algorithms 29\norder of growth. But for large enough inputs, a \u201a.n2/algorithm, for example, will\nrun more quickly in the worst case than a \u201a.n3/algorithm.\nExercises\n2.2-1\nExpress the function n3=1000/NUL100n2/NUL100nC3in terms of \u201a-notation.\n2.2-2\nConsider sorting nnumbers stored in array Aby \ufb01rst \ufb01nding the smallest element\nofAand exchanging it with the element in A\u01521/c141. Then \ufb01nd the second smallest\nelement of A, and exchange it with A\u01522/c141. Continue in this manner for the \ufb01rst n/NUL1\nelements of A. Write pseudocode for this algorithm, which is known as selection\nsort. What loop invariant does this algorithm maintain? Why does it need to run\nfor only the \ufb01rst n/NUL1elements, rather than for all nelements? Give the best-case\nand worst-case running times of selection sort in \u201a-notation.\n2.2-3\nConsider linear search again (see Exercise 2.1-3). How many elements of the in-put sequence need to be checked on the average, assuming that the element being\nsearched for is equally likely to be any element in the array? How about in the\nworst case? What are the average-case and worst-case running times of linearsearch in \u201a-notation? Justify your answers.\n2.2-4\nHow can we modify almost any algorithm to have a good best-case running time?\n2.3 Designing algorithms\nWe can choose from a wide range of algorithm design techniques. For insertionsort, we used an incremental approach: having sorted the subarray A\u01521 : : j/NUL1/c141,\nwe inserted the single element A\u0152j /c141 into its proper place, yielding the sorted\nsubarray A\u01521 : : j /c141 .\nIn this section, we examine an alternative design approach, known as \u201cdivide-\nand-conquer,\u201d which we shall explore in more detail in Chapter 4. We\u2019ll use divide-and-conquer to design a sorting algorithm whose worst-case running time is muchless than that of insertion sort. One advantage of divide-and-conquer algorithms isthat their running times are often easily determined using techniques that we willsee in Chapter 4.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "50": {"page_number": 51, "page_information": "30 Chapter 2 Getting Started\n2.3.1 The divide-and-conquer approach\nMany useful algorithms are recursive in structure: to solve a given problem, they\ncall themselves recursively one or more times to deal with closely related sub-problems. These algorithms typically follow a divide-and-conquer approach: they\nbreak the problem into several subproblems that are similar to the original prob-lem but smaller in size, solve the subproblems recursively, and then combine thesesolutions to create a solution to the original problem.\nThe divide-and-conquer paradigm involves three steps at each level of the recur-\nsion:\nDivide the problem into a number of subproblems that are smaller instances of the\nsame problem.\nConquer the subproblems by solving them recursively. If the subproblem sizes are\nsmall enough, however, just solve the subproblems in a straightforward manner.\nCombine the solutions to the subproblems into the solution for the original prob-\nlem.\nThemerge sort algorithm closely follows the divide-and-conquer paradigm. In-\ntuitively, it operates as follows.\nDivide: Divide the n-element sequence to be sorted into two subsequences of n=2\nelements each.\nConquer: Sort the two subsequences recursively using merge sort.\nCombine: Merge the two sorted subsequences to produce the sorted answer.\nThe recursion \u201cbottoms out\u201d when the sequence to be sorted has length 1, in which\ncase there is no work to be done, since every sequence of length 1 is already in\nsorted order.\nThe key operation of the merge sort algorithm is the merging of two sorted\nsequences in the \u201ccombine\u201d step. We merge by calling an auxiliary procedure\nM\nERGE . A ;p;q;r/ ,w h e r e Ais an array and p,q,a n d rare indices into the array\nsuch that p/DC4q<r . The procedure assumes that the subarrays A\u0152p : : q/c141 and\nA\u0152qC1::r/c141 are in sorted order. It merges them to form a single sorted subarray\nthat replaces the current subarray A\u0152p : : r/c141 .\nOur M ERGE procedure takes time \u201a.n/ ,w h e r e nDr/NULpC1is the total\nnumber of elements being merged, and it works as follows. Returning to our card-\nplaying motif, suppose we have two piles of cards face up on a table. Each pile is\nsorted, with the smallest cards on top. We wish to merge the two piles into a single\nsorted output pile, which is to be face down on the table. Our basic step consistsof choosing the smaller of the two cards on top of the face-up piles, removing itfrom its pile (which exposes a new top card), and placing this card face down onto", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "51": {"page_number": 52, "page_information": "2.3 Designing algorithms 31\nthe output pile. We repeat this step until one input pile is empty, at which time\nwe just take the remaining input pile and place it face down onto the output pile.Computationally, each basic step takes constant time, since we are comparing justthe two top cards. Since we perform at most nbasic steps, merging takes \u201a.n/\ntime.\nThe following pseudocode implements the above idea, but with an additional\ntwist that avoids having to check whether either pile is empty in each basic step.We place on the bottom of each pile a sentinel card, which contains a special value\nthat we use to simplify our code. Here, we use 1as the sentinel value, so that\nwhenever a card with 1is exposed, it cannot be the smaller card unless both piles\nhave their sentinel cards exposed. But once that happens, all the nonsentinel cardshave already been placed onto the output pile. Since we know in advance thatexactly r/NULpC1cards will be placed onto the output pile, we can stop once we\nhave performed that many basic steps.\nM\nERGE . A ;p;q;r/\n1n1Dq/NULpC1\n2n2Dr/NULq\n3l e t L \u0152 1::n 1C1/c141andR\u01521: :n 2C1/c141be new arrays\n4foriD1ton1\n5 L\u0152i/c141DA\u0152pCi/NUL1/c141\n6forjD1ton2\n7 R\u0152j/c141DA\u0152qCj/c141\n8L\u0152n 1C1/c141D1\n9R\u0152n 2C1/c141D1\n10iD1\n11jD1\n12forkDptor\n13 ifL\u0152i/c141/DC4R\u0152j/c141\n14 A\u0152k/c141DL\u0152i/c141\n15 iDiC1\n16 elseA\u0152k/c141DR\u0152j/c141\n17 jDjC1\nIn detail, the M ERGE procedure works as follows. Line 1 computes the length n1\nof the subarray A\u0152p : : q/c141 , and line 2 computes the length n2of the subarray\nA\u0152qC1::r/c141 . We create arrays LandR(\u201cleft\u201d and \u201cright\u201d), of lengths n1C1\nandn2C1, respectively, in line 3; the extra position in each array will hold the\nsentinel. The forloop of lines 4\u20135 copies the subarray A\u0152p : : q/c141 intoL \u0152 1::n 1/c141,\nand the forloop of lines 6\u20137 copies the subarray A\u0152qC1::r/c141 intoR \u0152 1::n 2/c141.\nLines 8\u20139 put the sentinels at the ends of the arrays LandR. Lines 10\u201317, illus-", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "52": {"page_number": 53, "page_information": "32 Chapter 2 Getting Started\nA\nLR1234 1234\nijk\n(a)2457 1236A\nLR1234 1234\nijk\n(b)24571\n236124571236 4571236\nA\nLR9 1 01 11 21 31 41 51 6\n1234 1234\nijk\n(c)24571\n23615712362 A\nLR1234 1234\nijk\n(d)24571\n236171236 225\n\u221e5\n\u221e5\n\u221e5\n\u221e\n5\n\u221e5\n\u221e5\n\u221e5\n\u221e9 1 01 11 21 31 41 51 6\n9 1 01 11 21 31 41 51 69 1 01 11 21 31 41 51 6 8\n\u202617\n\u2026\n8\n\u202617\n\u20268\n\u202617\n\u2026\n8\n\u202617\n\u2026\nFigure 2.3 The operation of lines 10\u201317 in the call M ERGE .A; 9; 12; 16/ , when the subarray\nA\u01529 : : 16/c141 contains the sequence h2; 4; 5; 7; 1; 2; 3; 6 i. After copying and inserting sentinels, the\narray Lcontainsh2; 4; 5; 7;1i, and the array Rcontainsh1; 2; 3; 6;1i. Lightly shaded positions\ninAcontain their \ufb01nal values, and lightly shaded positions in LandRcontain values that have yet\nto be copied back into A. Taken together, the lightly shaded positions always comprise the values\noriginally in A\u01529 : : 16/c141 , along with the two sentinels. Heavily shaded positions in Acontain values\nthat will be copied over, and heavily shaded positions in LandRcontain values that have already\nbeen copied back into A.(a)\u2013(h) The arrays A,L,a n d R, and their respective indices k,i,a n d j\nprior to each iteration of the loop of lines 12\u201317.\ntrated in Figure 2.3, perform the r/NULpC1basic steps by maintaining the following\nloop invariant:\nAt the start of each iteration of the forloop of lines 12\u201317, the subarray\nA\u0152p : : k/NUL1/c141contains the k/NULpsmallest elements of L \u0152 1::n 1C1/c141and\nR\u01521: :n 2C1/c141, in sorted order. Moreover, L\u0152i/c141 andR\u0152j/c141 are the smallest\nelements of their arrays that have not been copied back into A.\nWe must show that this loop invariant holds prior to the \ufb01rst iteration of the for\nloop of lines 12\u201317, that each iteration of the loop maintains the invariant, andthat the invariant provides a useful property to show correctness when the loopterminates.\nInitialization: Prior to the \ufb01rst iteration of the loop, we have kDp, so that the\nsubarray A\u0152p : : k/NUL1/c141is empty. This empty subarray contains the k/NULpD0\nsmallest elements of LandR, and since iDjD1, both L\u0152i/c141 andR\u0152j/c141 are the\nsmallest elements of their arrays that have not been copied back into A.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "53": {"page_number": 54, "page_information": "2.3 Designing algorithms 33\nA\nLR1234 1234\nijk\n(e)24571\n23611236 223 A\nLR1234 1234\nijk\n(f)24571\n2361236 2234\nA\nLR1234 1234\nijk\n(g)24571\n236136 22345 A\nLR1234 1234\nijk\n(h)24571\n23616 223455\n\u221e5\n\u221e5\n\u221e5\n\u221e\n5\n\u221e5\n\u221e5\n\u221e5\n\u221e6\nA\nLR1234 1234\nijk\n(i)24571\n23617 22345\n5\n\u221e5\n\u221e69 1 01 11 21 31 41 51 6\n9 1 01 11 21 31 41 51 6\n9 1 01 11 21 31 41 51 69 1 01 11 21 31 41 51 6\n9 1 01 11 21 31 41 51 68\n\u202617\n\u2026\n8\n\u202617\n\u2026\n8\n\u202617\n\u20268\n\u202617\n\u2026\n8\n\u202617\n\u2026\nFigure 2.3, continued (i) The arrays and indices at termination. At this point, the subarray in\nA\u01529 : : 16/c141 is sorted, and the two sentinels in LandRare the only two elements in these arrays that\nhave not been copied into A.\nMaintenance: To see that each iteration maintains the loop invariant, let us \ufb01rst\nsuppose that L\u0152i/c141/DC4R\u0152j/c141 .T h e n L\u0152i/c141 is the smallest element not yet copied\nback into A. Because A\u0152p : : k/NUL1/c141contains the k/NULpsmallest elements, after\nline 14 copies L\u0152i/c141 intoA\u0152k/c141 , the subarray A\u0152p : : k/c141 will contain the k/NULpC1\nsmallest elements. Incrementing k(in the forloop update) and i(in line 15)\nreestablishes the loop invariant for the next iteration. If instead L\u0152i/c141 > R\u0152j /c141 ,\nthen lines 16\u201317 perform the appropriate action to maintain the loop invariant.\nTermination: At termination, kDrC1. By the loop invariant, the subarray\nA\u0152p : : k/NUL1/c141,w h i c hi s A\u0152p : : r/c141 , contains the k/NULpDr/NULpC1smallest\nelements of L \u0152 1::n 1C1/c141andR \u0152 1::n 2C1/c141, in sorted order. The arrays L\nandRtogether contain n1Cn2C2Dr/NULpC3elements. All but the two\nlargest have been copied back into A, and these two largest elements are the\nsentinels.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "54": {"page_number": 55, "page_information": "34 Chapter 2 Getting Started\nTo see that the M ERGE procedure runs in \u201a.n/ time, where nDr/NULpC1,\nobserve that each of lines 1\u20133 and 8\u201311 takes constant time, the forloops of\nlines 4\u20137 take \u201a.n 1Cn2/D\u201a.n/ time,7and there are niterations of the for\nloop of lines 12\u201317, each of which takes constant time.\nWe can now use the M ERGE procedure as a subroutine in the merge sort al-\ngorithm. The procedure M ERGE -SORT. A ;p;r/ sorts the elements in the subar-\nrayA\u0152p : : r/c141 .I fp/NAKr, the subarray has at most one element and is therefore\nalready sorted. Otherwise, the divide step simply computes an index qthat par-\ntitions A\u0152p : : r/c141 into two subarrays: A\u0152p : : q/c141 , containingdn=2eelements, and\nA\u0152qC1::r/c141 , containingbn=2celements.8\nMERGE -SORT. A ;p;r/\n1ifp<r\n2 qDb.pCr/=2c\n3M ERGE -SORT. A ;p;q/\n4M ERGE -SORT.A; qC1; r/\n5M ERGE . A ;p;q;r/\nTo sort the entire sequence ADhA\u01521/c141; A\u01522/c141; : : : ; A\u0152n/c141 i, we make the initial call\nMERGE -SORT. A ;1 ;A: length /, where once again A:lengthDn. Figure 2.4 il-\nlustrates the operation of the procedure bottom-up when ni sap o w e ro f 2.T h e\nalgorithm consists of merging pairs of 1-item sequences to form sorted sequences\nof length 2, merging pairs of sequences of length 2 to form sorted sequences of\nlength 4, and so on, until two sequences of length n=2are merged to form the \ufb01nal\nsorted sequence of length n.\n2.3.2 Analyzing divide-and-conquer algorithms\nWhen an algorithm contains a recursive call to itself, we can often describe its\nrunning time by a recurrence equation orrecurrence , which describes the overall\nrunning time on a problem of size nin terms of the running time on smaller inputs.\nWe can then use mathematical tools to solve the recurrence and provide bounds onthe performance of the algorithm.\n7We shall see in Chapter 3 how to formally interpret equations containing \u201a-notation.\n8The expressiondxedenotes the least integer greater than or equal to x,a n dbxcdenotes the greatest\ninteger less than or equal to x. These notations are de\ufb01ned in Chapter 3. The easiest way to verify\nthat setting qtob.pCr/=2cyields subarrays A\u0152p : : q/c141 andA\u0152qC1::r/c141 of sizesdn=2eandbn=2c,\nrespectively, is to examine the four cases that arise depending on whether each of pandris odd or\neven.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "55": {"page_number": 56, "page_information": "2.3 Designing algorithms 35\n5247132625 47 13 262457 123612234567\nmergemerge\nmergesorted sequence\ninitial sequencemerge merge merge merge\nFigure 2.4 The operation of merge sort on the array ADh5; 2; 4; 7; 1; 3; 2; 6i. The lengths of the\nsorted sequences being merged increase as the algorithm progresses from bottom to top.\nA recurrence for the running time of a divide-and-conquer algorithm falls out\nfrom the three steps of the basic paradigm. As before, we let T .n/ be the running\ntime on a problem of size n. If the problem size is small enough, say n/DC4c\nfor some constant c, the straightforward solution takes constant time, which we\nwrite as \u201a.1/ . Suppose that our division of the problem yields asubproblems,\neach of which is 1=bthe size of the original. (For merge sort, both aandbare2,\nbut we shall see many divide-and-conquer algorithms in which a\u00a4b.) It takes\ntimeT .n=b/ to solve one subproblem of size n=b, and so it takes time aT .n=b/\nto solve aof them. If we take D.n/ time to divide the problem into subproblems\nandC.n/ time to combine the solutions to the subproblems into the solution to the\noriginal problem, we get the recurrence\nT .n/D(\n\u201a.1/ ifn/DC4c;\naT .n=b/CD.n/CC.n/ otherwise :\nIn Chapter 4, we shall see how to solve common recurrences of this form.\nAnalysis of merge sort\nAlthough the pseudocode for M ERGE -SORT works correctly when the number of\nelements is not even, our recurrence-based analysis is simpli\ufb01ed if we assume that", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "56": {"page_number": 57, "page_information": "36 Chapter 2 Getting Started\nthe original problem size is a power of 2. Each divide step then yields two subse-\nquences of size exactly n=2. In Chapter 4, we shall see that this assumption does\nnot affect the order of growth of the solution to the recurrence.\nWe reason as follows to set up the recurrence for T .n/ , the worst-case running\ntime of merge sort on nnumbers. Merge sort on just one element takes constant\ntime. When we have n>1 elements, we break down the running time as follows.\nDivide: The divide step just computes the middle of the subarray, which takes\nconstant time. Thus, D.n/D\u201a.1/ .\nConquer: We recursively solve two subproblems, each of size n=2, which con-\ntributes 2T .n=2/ to the running time.\nCombine: We have already noted that the M ERGE procedure on an n-element\nsubarray takes time \u201a.n/ ,a n ds o C.n/D\u201a.n/ .\nWhen we add the functions D.n/ andC.n/ for the merge sort analysis, we are\nadding a function that is \u201a.n/ and a function that is \u201a.1/ . This sum is a linear\nfunction of n,t h a ti s , \u201a.n/ . Adding it to the 2T .n=2/ term from the \u201cconquer\u201d\nstep gives the recurrence for the worst-case running time T .n/ of merge sort:\nT .n/D(\n\u201a.1/ ifnD1;\n2T .n=2/C\u201a.n/ ifn>1:(2.1)\nIn Chapter 4, we shall see the \u201cmaster theorem,\u201d which we can use to show\nthatT .n/ is\u201a.n lgn/, where lg nstands for log2n. Because the logarithm func-\ntion grows more slowly than any linear function, for large enough inputs, merge\nsort, with its \u201a.n lgn/running time, outperforms insertion sort, whose running\ntime is \u201a.n2/, in the worst case.\nWe do not need the master theorem to intuitively understand why the solution to\nthe recurrence (2.1) is T .n/D\u201a.n lgn/. Let us rewrite recurrence (2.1) as\nT .n/D(\nc ifnD1;\n2T .n=2/Ccn ifn>1;(2.2)\nwhere the constant crepresents the time required to solve problems of size 1as\nwell as the time per array element of the divide and combine steps.9\n9It is unlikely that the same constant exactly represents both the time to solve problems of size 1\nand the time per array element of the divide and combine steps. We can get around this problem by\nletting cbe the larger of these times and understanding that our recurrence gives an upper bound on\nthe running time, or by letting cbe the lesser of these times and understanding that our recurrence\ngives a lower bound on the running time. Both bounds are on the order of nlgnand, taken together,\ngive a \u201a.n lgn/running time.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "57": {"page_number": 58, "page_information": "2.3 Designing algorithms 37\nFigure 2.5 shows how we can solve recurrence (2.2). For convenience, we as-\nsume that nis an exact power of 2. Part (a) of the \ufb01gure shows T .n/ ,w h i c hw e\nexpand in part (b) into an equivalent tree representing the recurrence. The cnterm\nis the root (the cost incurred at the top level of recursion), and the two subtrees ofthe root are the two smaller recurrences T .n=2/ . Part (c) shows this process carried\none step further by expanding T .n=2/ . The cost incurred at each of the two sub-\nnodes at the second level of recursion is cn=2 . We continue expanding each node\nin the tree by breaking it into its constituent parts as determined by the recurrence,\nuntil the problem sizes get down to 1, each with a cost of c. Part (d) shows the\nresulting recursion tree .\nNext, we add the costs across each level of the tree. The top level has total\ncostcn, the next level down has total cost c.n=2/Cc.n=2/Dcn, the level after\nthat has total cost c.n=4/Cc.n=4/Cc.n=4/Cc.n=4/Dcn, and so on. In general,\nthe level ibelow the top has 2\ninodes, each contributing a cost of c.n=2i/,s ot h a t\ntheith level below the top has total cost 2ic.n=2i/Dcn. The bottom level has n\nnodes, each contributing a cost of c, for a total cost of cn.\nThe total number of levels of the recursion tree in Figure 2.5 is lg nC1,w h e r e\nnis the number of leaves, corresponding to the input size. An informal inductive\nargument justi\ufb01es this claim. The base case occurs when nD1, in which case the\ntree has only one level. Since lg 1D0,w eh a v et h a tl g nC1gives the correct\nnumber of levels. Now assume as an inductive hypothesis that the number of levelsof a recursion tree with 2\nileaves is lg 2iC1DiC1(since for any value of i,\nwe have that lg 2iDi). Because we are assuming that the input size is a power\nof2, the next input size to consider is 2iC1. A tree with nD2iC1leaves has\none more level than a tree with 2ileaves, and so the total number of levels is\n.iC1/C1Dlg2iC1C1.\nTo compute the total cost represented by the recurrence (2.2), we simply add up\nthe costs of all the levels. The recursion tree has lg nC1levels, each costing cn,\nfor a total cost of cn.lgnC1/DcnlgnCcn. Ignoring the low-order term and\nthe constant cgives the desired result of \u201a.n lgn/.\nExercises\n2.3-1\nUsing Figure 2.4 as a model, illustrate the operation of merge sort on the arrayADh3; 41; 52; 26; 38; 57; 9; 49 i.\n2.3-2\nRewrite the M\nERGE procedure so that it does not use sentinels, instead stopping\nonce either array LorRhas had all its elements copied back to Aand then copying\nthe remainder of the other array back into A.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "58": {"page_number": 59, "page_information": "38 Chapter 2 Getting Started\ncn\ncn\n\u2026\nTotal: cn lg n + cncnlgncn\nnc c c c c c c\n\u2026\n(d)(c)cn\nT(n/2) T(n/2)\n(b)T(n)\n(a)cn\ncn/2\nT(n/4) T(n/4)cn/2\nT(n/4) T(n/4)\ncn\ncn/2\ncn/4 cn/4cn/2\ncn/4 cn/4\nFigure 2.5 How to construct a recursion tree for the recurrence T .n/D2T .n=2/Ccn.\nPart(a)shows T .n/ , which progressively expands in (b)\u2013(d) to form the recursion tree. The fully\nexpanded tree in part (d) has lg nC1levels (i.e., it has height lg n, as indicated), and each level\ncontributes a total cost of cn. The total cost, therefore, is cnlgnCcn,w h i c hi s \u201a.n lgn/.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "59": {"page_number": 60, "page_information": "Problems for Chapter 2 39\n2.3-3\nUse mathematical induction to show that when nis an exact power of 2,t h es o l u -\ntion of the recurrence\nT .n/D(\n2 ifnD2;\n2T .n=2/CnifnD2k,f o rk>1\nisT .n/Dnlgn.\n2.3-4\nWe can express insertion sort as a recursive procedure as follows. In order to sortA\u01521 : : n/c141 , we recursively sort A\u01521 : : n/NUL1/c141and then insert A\u0152n/c141 into the sorted array\nA\u01521 : : n/NUL1/c141. Write a recurrence for the running time of this recursive version of\ninsertion sort.\n2.3-5\nReferring back to the searching problem (see Exercise 2.1-3), observe that if the\nsequence Ais sorted, we can check the midpoint of the sequence against /ETBand\neliminate half of the sequence from further consideration. The binary search al-\ngorithm repeats this procedure, halving the size of the remaining portion of thesequence each time. Write pseudocode, either iterative or recursive, for binarysearch. Argue that the worst-case running time of binary search is \u201a.lgn/.\n2.3-6\nObserve that the while loop of lines 5\u20137 of the I\nNSERTION -SORT procedure in\nSection 2.1 uses a linear search to scan (backward) through the sorted subarrayA\u01521 : : j/NUL1/c141. Can we use a binary search (see Exercise 2.3-5) instead to improve\nthe overall worst-case running time of insertion sort to \u201a.n lgn/?\n2.3-7 ?\nDescribe a \u201a.n lgn/-time algorithm that, given a set Sofnintegers and another\ninteger x, determines whether or not there exist two elements in Swhose sum is\nexactly x.\nProblems\n2-1 Insertion sort on small arrays in merge sort\nAlthough merge sort runs in \u201a.n lgn/worst-case time and insertion sort runs\nin\u201a.n2/worst-case time, the constant factors in insertion sort can make it faster\nin practice for small problem sizes on many machines. Thus, it makes sense tocoarsen the leaves of the recursion by using insertion sort within merge sort when", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "60": {"page_number": 61, "page_information": "40 Chapter 2 Getting Started\nsubproblems become suf\ufb01ciently small. Consider a modi\ufb01cation to merge sort in\nwhich n=k sublists of length kare sorted using insertion sort and then merged\nusing the standard merging mechanism, where kis a value to be determined.\na.Show that insertion sort can sort the n=k sublists, each of length k,i n\u201a.nk/\nworst-case time.\nb.Show how to merge the sublists in \u201a.n lg.n=k// worst-case time.\nc.Given that the modi\ufb01ed algorithm runs in \u201a.nkCnlg.n=k// worst-case time,\nwhat is the largest value of kas a function of nfor which the modi\ufb01ed algorithm\nhas the same running time as standard merge sort, in terms of \u201a-notation?\nd.How should we choose kin practice?\n2-2 Correctness of bubblesort\nBubblesort is a popular, but inef\ufb01cient, sorting algorithm. It works by repeatedlyswapping adjacent elements that are out of order.\nB\nUBBLESORT .A/\n1foriD1toA:length/NUL1\n2 forjDA:length downto iC1\n3 ifA\u0152j /c141 < A\u0152j/NUL1/c141\n4 exchange A\u0152j /c141 withA\u0152j/NUL1/c141\na.LetA0denote the output of B UBBLESORT .A/. To prove that B UBBLESORT is\ncorrect, we need to prove that it terminates and that\nA0\u01521/c141/DC4A0\u01522/c141/DC4/SOH/SOH/SOH/DC4 A0\u0152n/c141 ; (2.3)\nwhere nDA:length . In order to show that B UBBLESORT actually sorts, what\nelse do we need to prove?\nThe next two parts will prove inequality (2.3).b.State precisely a loop invariant for the forloop in lines 2\u20134, and prove that this\nloop invariant holds. Your proof should use the structure of the loop invariant\nproof presented in this chapter.\nc.Using the termination condition of the loop invariant proved in part (b), state\na loop invariant for the forloop in lines 1\u20134 that will allow you to prove in-\nequality (2.3). Your proof should use the structure of the loop invariant proofpresented in this chapter.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "61": {"page_number": 62, "page_information": "Problems for Chapter 2 41\nd.What is the worst-case running time of bubblesort? How does it compare to the\nrunning time of insertion sort?\n2-3 Correctness of Horner\u2019s rule\nThe following code fragment implements Horner\u2019s rule for evaluating a polynomial\nP.x/DnX\nkD0akxk\nDa0Cx.a 1Cx.a 2C/SOH/SOH/SOHC x.a n/NUL1Cxan//SOH/SOH/SOH// ;\ngiven the coef\ufb01cients a0;a1;:::;a nand a value for x:\n1yD0\n2foriDndownto 0\n3 yDaiCx/SOHy\na.In terms of \u201a-notation, what is the running time of this code fragment for\nHorner\u2019s rule?\nb.Write pseudocode to implement the naive polynomial-evaluation algorithm that\ncomputes each term of the polynomial from scratch. What is the running timeof this algorithm? How does it compare to Horner\u2019s rule?\nc.Consider the following loop invariant:\nAt the start of each iteration of the forloop of lines 2\u20133,\nyDn/NUL.iC1/X\nkD0akCiC1xk:\nInterpret a summation with no terms as equaling 0. Following the structure of\nthe loop invariant proof presented in this chapter, use this loop invariant to showthat, at termination, yDP\nn\nkD0akxk.\nd.Conclude by arguing that the given code fragment correctly evaluates a poly-\nnomial characterized by the coef\ufb01cients a0;a1;:::;a n.\n2-4 Inversions\nLetA\u01521 : : n/c141 be an array of ndistinct numbers. If i<j andA\u0152i/c141 > A\u0152j /c141 , then the\npair.i; j / is called an inversion ofA.\na.List the \ufb01ve inversions of the array h2; 3; 8; 6; 1i.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "62": {"page_number": 63, "page_information": "42 Chapter 2 Getting Started\nb.What array with elements from the set f1 ;2;:::;nghas the most inversions?\nHow many does it have?\nc.What is the relationship between the running time of insertion sort and the\nnumber of inversions in the input array? Justify your answer.\nd.Give an algorithm that determines the number of inversions in any permutation\nonnelements in \u201a.n lgn/worst-case time. ( Hint: Modify merge sort.)\nChapter notes\nIn 1968, Knuth published the \ufb01rst of three volumes with the general title The Art of\nComputer Programming [209, 210, 211]. The \ufb01rst volume ushered in the modern\nstudy of computer algorithms with a focus on the analysis of running time, and thefull series remains an engaging and worthwhile reference for many of the topics\npresented here. According to Knuth, the word \u201calgorithm\u201d is derived from the\nname \u201cal-Khow\u02c6 arizm\u02c6 \u0131,\u201d a ninth-century Persian mathematician.\nAho, Hopcroft, and Ullman [5] advocated the asymptotic analysis of algo-\nrithms\u2014using notations that Chapter 3 introduces, including \u201a-notation\u2014as a\nmeans of comparing relative performance. They also popularized the use of re-currence relations to describe the running times of recursive algorithms.\nKnuth [211] provides an encyclopedic treatment of many sorting algorithms. His\ncomparison of sorting algorithms (page 381) includes exact step-counting analyses,like the one we performed here for insertion sort. Knuth\u2019s discussion of insertionsort encompasses several variations of the algorithm. The most important of theseis Shell\u2019s sort, introduced by D. L. Shell, which uses insertion sort on periodicsubsequences of the input to produce a faster sorting algorithm.\nMerge sort is also described by Knuth. He mentions that a mechanical colla-\ntor capable of merging two decks of punched cards in a single pass was invented\nin 1938. J. von Neumann, one of the pioneers of computer science, apparently\nwrote a program for merge sort on the EDVAC computer in 1945.\nThe early history of proving programs correct is described by Gries [153], who\ncredits P. Naur with the \ufb01rst article in this \ufb01eld. Gries attributes loop invariants toR. W. Floyd. The textbook by Mitchell [256] describes more recent progress inproving programs correct.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "63": {"page_number": 64, "page_information": "3 Growth of Functions\nThe order of growth of the running time of an algorithm, de\ufb01ned in Chapter 2,\ngives a simple characterization of the algorithm\u2019s ef\ufb01ciency and also allows us tocompare the relative performance of alternative algorithms. Once the input size n\nbecomes large enough, merge sort, with its \u201a.n lgn/worst-case running time,\nbeats insertion sort, whose worst-case running time is \u201a.n\n2/. Although we can\nsometimes determine the exact running time of an algorithm, as we did for insertionsort in Chapter 2, the extra precision is not usually worth the effort of computingit. For large enough inputs, the multiplicative constants and lower-order terms ofan exact running time are dominated by the effects of the input size itself.\nWhen we look at input sizes large enough to make only the order of growth of\nthe running time relevant, we are studying the asymptotic ef\ufb01ciency of algorithms.\nThat is, we are concerned with how the running time of an algorithm increases withthe size of the input in the limit , as the size of the input increases without bound.\nUsually, an algorithm that is asymptotically more ef\ufb01cient will be the best choice\nfor all but very small inputs.\nThis chapter gives several standard methods for simplifying the asymptotic anal-\nysis of algorithms. The next section begins by de\ufb01ning several types of \u201casymp-totic notation,\u201d of which we have already seen an example in \u201a-notation. We then\npresent several notational conventions used throughout this book, and \ufb01nally wereview the behavior of functions that commonly arise in the analysis of algorithms.\n3.1 Asymptotic notation\nThe notations we use to describe the asymptotic running time of an algorithm\nare de\ufb01ned in terms of functions whose domains are the set of natural numbers\nNDf0; 1; 2; : : :g. Such notations are convenient for describing the worst-case\nrunning-time function T .n/ , which usually is de\ufb01ned only on integer input sizes.\nWe sometimes \ufb01nd it convenient, however, to abuse asymptotic notation in a va-", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "64": {"page_number": 65, "page_information": "44 Chapter 3 Growth of Functions\nriety of ways. For example, we might extend the notation to the domain of real\nnumbers or, alternatively, restrict it to a subset of the natural numbers. We shouldmake sure, however, to understand the precise meaning of the notation so that whenwe abuse, we do not misuse it. This section de\ufb01nes the basic asymptotic notations\nand also introduces some common abuses.\nAsymptotic notation, functions, and running times\nWe will use asymptotic notation primarily to describe the running times of algo-\nrithms, as when we wrote that insertion sort\u2019s worst-case running time is \u201a.n\n2/.\nAsymptotic notation actually applies to functions, however. Recall that we charac-terized insertion sort\u2019s worst-case running time as an\n2CbnCc, for some constants\na,b,a n d c. By writing that insertion sort\u2019s running time is \u201a.n2/, we abstracted\naway some details of this function. Because asymptotic notation applies to func-\ntions, what we were writing as \u201a.n2/was the function an2CbnCc,w h i c hi n\nthat case happened to characterize the worst-case running time of insertion sort.\nIn this book, the functions to which we apply asymptotic notation will usually\ncharacterize the running times of algorithms. But asymptotic notation can apply tofunctions that characterize some other aspect of algorithms (the amount of spacethey use, for example), or even to functions that have nothing whatsoever to dowith algorithms.\nEven when we use asymptotic notation to apply to the running time of an al-\ngorithm, we need to understand which running time we mean. Sometimes we are\ninterested in the worst-case running time. Often, however, we wish to characterizethe running time no matter what the input. In other words, we often wish to makea blanket statement that covers all inputs, not just the worst case. We shall seeasymptotic notations that are well suited to characterizing running times no matter\nwhat the input.\n\u201a-notation\nIn Chapter 2, we found that the worst-case running time of insertion sort is\nT .n/D\u201a.n\n2/. Let us de\ufb01ne what this notation means. For a given function g.n/ ,\nwe denote by \u201a.g.n// theset of functions\n\u201a.g.n//Dff .n/Wthere exist positive constants c1,c2,a n d n0such that\n0/DC4c1g.n//DC4f .n//DC4c2g.n/ for all n/NAKn0g:1\n1Within set notation, a colon means \u201csuch that.\u201d", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "65": {"page_number": 66, "page_information": "3.1 Asymptotic notation 45\n(b) (c) (a)n n nn0 n0 n0f .n/D\u201a.g.n// f .n/ DO.g.n// f .n/ D/DEL.g.n//f .n/\nf .n/f .n/\ncg.n/cg.n/\nc1g.n/c2g.n/\nFigure 3.1 Graphic examples of the \u201a,O,a n d /DELnotations. In each part, the value of n0shown\nis the minimum possible value; any greater value would also work. (a)\u201a-notation bounds a func-\ntion to within constant factors. We write f. n /D\u201a.g.n// if there exist positive constants n0,c1,\nandc2such that at and to the right of n0,t h ev a l u eo f f. n / always lies between c1g.n/ andc2g.n/\ninclusive. (b)O-notation gives an upper bound for a function to within a constant factor. We write\nf. n /DO.g.n// if there are positive constants n0andcsuch that at and to the right of n0,t h ev a l u e\noff. n / always lies on or below cg.n/ .(c)/DEL-notation gives a lower bound for a function to within\na constant factor. We write f. n /D/DEL.g.n// if there are positive constants n0andcsuch that at and\nto the right of n0,t h ev a l u eo f f. n / always lies on or above cg.n/ .\nA function f .n/ belongs to the set \u201a.g.n// if there exist positive constants c1\nandc2such that it can be \u201csandwiched\u201d between c1g.n/ andc2g.n/ ,f o rs u f \ufb01 -\nciently large n. Because \u201a.g.n// is a set, we could write \u201c f .n/2\u201a.g.n// \u201d\nto indicate that f .n/ is a member of \u201a.g.n// . Instead, we will usually write\n\u201cf .n/D\u201a.g.n// \u201d to express the same notion. You might be confused because\nwe abuse equality in this way, but we shall see later in this section that doing sohas its advantages.\nFigure 3.1(a) gives an intuitive picture of functions f .n/ andg.n/ ,w h e r e\nf .n/D\u201a.g.n// . For all values of nat and to the right of n\n0,t h ev a l u eo f f .n/\nlies at or above c1g.n/ and at or below c2g.n/ . In other words, for all n/NAKn0,t h e\nfunction f .n/ is equal to g.n/ to within a constant factor. We say that g.n/ is an\nasymptotically tight bound forf .n/ .\nThe de\ufb01nition of \u201a.g.n// requires that every member f .n/2\u201a.g.n// be\nasymptotically nonnegative , that is, that f .n/ be nonnegative whenever nis suf-\n\ufb01ciently large. (An asymptotically positive function is one that is positive for all\nsuf\ufb01ciently large n.) Consequently, the function g.n/ itself must be asymptotically\nnonnegative, or else the set \u201a.g.n// is empty. We shall therefore assume that every\nfunction used within \u201a-notation is asymptotically nonnegative. This assumption\nholds for the other asymptotic notations de\ufb01ned in this chapter as well.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "66": {"page_number": 67, "page_information": "46 Chapter 3 Growth of Functions\nIn Chapter 2, we introduced an informal notion of \u201a-notation that amounted\nto throwing away lower-order terms and ignoring the leading coef\ufb01cient of thehighest-order term. Let us brie\ufb02y justify this intuition by using the formal de\ufb01-nition to show that\n1\n2n2/NUL3nD\u201a.n2/. To do so, we must determine positive\nconstants c1,c2,a n d n0such that\nc1n2/DC41\n2n2/NUL3n/DC4c2n2\nfor all n/NAKn0. Dividing by n2yields\nc1/DC41\n2/NUL3\nn/DC4c2:\nWe can make the right-hand inequality hold for any value of n/NAK1by choosing any\nconstant c2/NAK1=2. Likewise, we can make the left-hand inequality hold for any\nvalue of n/NAK7by choosing any constant c1/DC41=14 . Thus, by choosing c1D1=14 ,\nc2D1=2,a n d n0D7, we can verify that1\n2n2/NUL3nD\u201a.n2/. Certainly, other\nchoices for the constants exist, but the important thing is that some choice exists.\nNote that these constants depend on the function1\n2n2/NUL3n; a different function\nbelonging to \u201a.n2/would usually require different constants.\nWe can also use the formal de\ufb01nition to verify that 6n3\u00a4\u201a.n2/. Suppose\nfor the purpose of contradiction that c2andn0exist such that 6n3/DC4c2n2for\nalln/NAKn0. But then dividing by n2yields n/DC4c2=6, which cannot possibly hold\nfor arbitrarily large n,s i n c e c2is constant.\nIntuitively, the lower-order terms of an asymptotically positive function can be\nignored in determining asymptotically tight bounds because they are insigni\ufb01cantfor large n.W h e n nis large, even a tiny fraction of the highest-order term suf-\n\ufb01ces to dominate the lower-order terms. Thus, setting c\n1to a value that is slightly\nsmaller than the coef\ufb01cient of the highest-order term and setting c2to a value that\nis slightly larger permits the inequalities in the de\ufb01nition of \u201a-notation to be sat-\nis\ufb01ed. The coef\ufb01cient of the highest-order term can likewise be ignored, since itonly changes c\n1andc2by a constant factor equal to the coef\ufb01cient.\nAs an example, consider any quadratic function f .n/Dan2CbnCc,w h e r e\na,b,a n d care constants and a>0 . Throwing away the lower-order terms and\nignoring the constant yields f .n/D\u201a.n2/. Formally, to show the same thing, we\ntake the constants c1Da=4,c2D7a=4 ,a n d n0D2/SOHmax.jbj=a;p\njcj=a/.Y o u\nmay verify that 0/DC4c1n2/DC4an2CbnCc/DC4c2n2for all n/NAKn0. In general,\nfor any polynomial p.n/DPd\niD0aini, where the aiare constants and ad>0,w e\nhave p.n/D\u201a.nd/(see Problem 3-1).\nSince any constant is a degree- 0polynomial, we can express any constant func-\ntion as \u201a.n0/,o r\u201a.1/ . This latter notation is a minor abuse, however, because the", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "67": {"page_number": 68, "page_information": "3.1 Asymptotic notation 47\nexpression does not indicate what variable is tending to in\ufb01nity.2We shall often\nuse the notation \u201a.1/ to mean either a constant or a constant function with respect\nto some variable.\nO-notation\nThe\u201a-notation asymptotically bounds a function from above and below. When\nwe have only an asymptotic upper bound ,w eu s e O-notation. For a given func-\ntiong.n/ , we denote by O.g.n// (pronounced \u201cbig-oh of gofn\u201d or sometimes\njust \u201coh of gofn\u201d) the set of functions\nO.g.n//Dff .n/Wthere exist positive constants candn0such that\n0/DC4f .n//DC4cg.n/ for all n/NAKn0g:\nWe use O-notation to give an upper bound on a function, to within a constant\nfactor. Figure 3.1(b) shows the intuition behind O-notation. For all values nat and\nto the right of n0, the value of the function f .n/ is on or below cg.n/ .\nWe write f .n/DO.g.n// to indicate that a function f .n/ i sam e m b e ro ft h e\nsetO.g.n// . Note that f .n/D\u201a.g.n// implies f .n/DO.g.n// ,s i n c e \u201a-\nnotation is a stronger notion than O-notation. Written set-theoretically, we have\n\u201a.g.n///DC2O.g.n// . Thus, our proof that any quadratic function an2CbnCc,\nwhere a>0 ,i si n \u201a.n2/also shows that any such quadratic function is in O.n2/.\nWhat may be more surprising is that when a>0 ,a n y linear function anCbis\ninO.n2/, which is easily veri\ufb01ed by taking cDaCjbjandn0Dmax.1;/NULb=a/ .\nIf you have seen O-notation before, you might \ufb01nd it strange that we should\nwrite, for example, nDO.n2/. In the literature, we sometimes \ufb01nd O-notation\ninformally describing asymptotically tight bounds, that is, what we have de\ufb01ned\nusing \u201a-notation. In this book, however, when we write f .n/DO.g.n// ,w e\nare merely claiming that some constant multiple of g.n/ is an asymptotic upper\nbound on f .n/ , with no claim about how tight an upper bound it is. Distinguish-\ning asymptotic upper bounds from asymptotically tight bounds is standard in thealgorithms literature.\nUsing O-notation, we can often describe the running time of an algorithm\nmerely by inspecting the algorithm\u2019s overall structure. For example, the doublynested loop structure of the insertion sort algorithm from Chapter 2 immediatelyyields an O.n\n2/upper bound on the worst-case running time: the cost of each it-\neration of the inner loop is bounded from above by O.1/ (constant), the indices i\n2The real problem is that our ordinary notation for functions does not distinguish functions from\nvalues. In /NAK-calculus, the parameters to a function are clearly speci\ufb01ed: the function n2could be\nwritten as /NAKn:n2,o re v e n /NAKr:r2. Adopting a more rigorous notation, however, would complicate\nalgebraic manipulations, and so we choose to tolerate the abuse.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "68": {"page_number": 69, "page_information": "48 Chapter 3 Growth of Functions\nandjare both at most n, and the inner loop is executed at most once for each of\nthen2pairs of values for iandj.\nSince O-notation describes an upper bound, when we use it to bound the worst-\ncase running time of an algorithm, we have a bound on the running time of the algo-rithm on every input\u2014the blanket statement we discussed earlier. Thus, the O.n\n2/\nbound on worst-case running time of insertion sort also applies to its running timeon every input. The \u201a.n\n2/bound on the worst-case running time of insertion sort,\nhowever, does not imply a \u201a.n2/bound on the running time of insertion sort on\nevery input. For example, we saw in Chapter 2 that when the input is already\nsorted, insertion sort runs in \u201a.n/ time.\nTechnically, it is an abuse to say that the running time of insertion sort is O.n2/,\nsince for a given n, the actual running time varies, depending on the particular\ninput of size n. When we say \u201cthe running time is O.n2/,\u201d we mean that there is a\nfunction f .n/ that is O.n2/such that for any value of n, no matter what particular\ninput of size nis chosen, the running time on that input is bounded from above by\nthe value f .n/ . Equivalently, we mean that the worst-case running time is O.n2/.\n/DEL-notation\nJust as O-notation provides an asymptotic upper bound on a function, /DEL-notation\nprovides an asymptotic lower bound . For a given function g.n/ , we denote\nby/DEL.g.n// (pronounced \u201cbig-omega of gofn\u201d or sometimes just \u201comega of g\nofn\u201d) the set of functions\n/DEL.g.n//Dff .n/Wthere exist positive constants candn0such that\n0/DC4cg.n//DC4f .n/ for all n/NAKn0g:\nFigure 3.1(c) shows the intuition behind /DEL-notation. For all values nat or to the\nright of n0,t h ev a l u eo f f .n/ is on or above cg.n/ .\nFrom the de\ufb01nitions of the asymptotic notations we have seen thus far, it is easy\nto prove the following important theorem (see Exercise 3.1-5).\nTheorem 3.1\nFor any two functions f .n/ andg.n/ ,w eh a v e f .n/D\u201a.g.n// if and only if\nf .n/DO.g.n// andf .n/D/DEL.g.n// .\nAs an example of the application of this theorem, our proof that an2CbnCcD\n\u201a.n2/for any constants a,b,a n d c,w h e r e a>0 , immediately implies that\nan2CbnCcD/DEL.n2/andan2CbnCcDO.n2/. In practice, rather than using\nTheorem 3.1 to obtain asymptotic upper and lower bounds from asymptoticallytight bounds, as we did for this example, we usually use it to prove asymptoticallytight bounds from asymptotic upper and lower bounds.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "69": {"page_number": 70, "page_information": "3.1 Asymptotic notation 49\nWhen we say that the running time (no modi\ufb01er) of an algorithm is /DEL.g.n// ,\nwe mean that no matter what particular input of size nis chosen for each value\nofn, the running time on that input is at least a constant times g.n/ , for suf\ufb01ciently\nlarge n. Equivalently, we are giving a lower bound on the best-case running time\nof an algorithm. For example, the best-case running time of insertion sort is /DEL.n/ ,\nwhich implies that the running time of insertion sort is /DEL.n/ .\nThe running time of insertion sort therefore belongs to both /DEL.n/ andO.n2/,\nsince it falls anywhere between a linear function of nand a quadratic function of n.\nMoreover, these bounds are asymptotically as tight as possible: for instance, the\nrunning time of insertion sort is not /DEL.n2/, since there exists an input for which\ninsertion sort runs in \u201a.n/ time (e.g., when the input is already sorted). It is not\ncontradictory, however, to say that the worst-case running time of insertion sort\nis/DEL.n2/, since there exists an input that causes the algorithm to take /DEL.n2/time.\nAsymptotic notation in equations and inequalities\nWe have already seen how asymptotic notation can be used within mathematical\nformulas. For example, in introducing O-notation, we wrote \u201c nDO.n2/.\u201d We\nmight also write 2n2C3nC1D2n2C\u201a.n/ . How do we interpret such formulas?\nWhen the asymptotic notation stands alone (that is, not within a larger formula)\non the right-hand side of an equation (or inequality), as in nDO.n2/,w eh a v e\nalready de\ufb01ned the equal sign to mean set membership: n2O.n2/. In general,\nhowever, when asymptotic notation appears in a formula, we interpret it as stand-ing for some anonymous function that we do not care to name. For example, theformula 2n\n2C3nC1D2n2C\u201a.n/ means that 2n2C3nC1D2n2Cf .n/ ,\nwhere f .n/ is some function in the set \u201a.n/ . In this case, we let f .n/D3nC1,\nwhich indeed is in \u201a.n/ .\nUsing asymptotic notation in this manner can help eliminate inessential detail\nand clutter in an equation. For example, in Chapter 2 we expressed the worst-caserunning time of merge sort as the recurrence\nT .n/D2T .n=2/C\u201a.n/ :\nIf we are interested only in the asymptotic behavior of T .n/ , there is no point in\nspecifying all the lower-order terms exactly; they are all understood to be includedin the anonymous function denoted by the term \u201a.n/ .\nThe number of anonymous functions in an expression is understood to be equal\nto the number of times the asymptotic notation appears. For example, in the ex-pression\nnX\niD1O.i/ ;", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "70": {"page_number": 71, "page_information": "50 Chapter 3 Growth of Functions\nthere is only a single anonymous function (a function of i). This expression is thus\nnotthe same as O.1/CO.2/C/SOH/SOH/SOHC O.n/ , which doesn\u2019t really have a clean\ninterpretation.\nIn some cases, asymptotic notation appears on the left-hand side of an equation,\nas in\n2n2C\u201a.n/D\u201a.n2/:\nWe interpret such equations using the following rule: No matter how the anony-\nmous functions are chosen on the left of the equal sign, there is a way to choosethe anonymous functions on the right of the equal sign to make the equation valid .\nThus, our example means that for anyfunction f .n/2\u201a.n/ , there is some func-\ntiong.n/2\u201a.n\n2/such that 2n2Cf .n/Dg.n/ for all n. In other words, the\nright-hand side of an equation provides a coarser level of detail than the left-handside.\nWe can chain together a number of such relationships, as in\n2n\n2C3nC1D2n2C\u201a.n/\nD\u201a.n2/:\nWe can interpret each equation separately by the rules above. The \ufb01rst equa-\ntion says that there is some function f .n/2\u201a.n/ such that 2n2C3nC1D\n2n2Cf .n/ for all n. The second equation says that for anyfunction g.n/2\u201a.n/\n(such as the f .n/ just mentioned), there is some function h.n/2\u201a.n2/such\nthat2n2Cg.n/Dh.n/ for all n. Note that this interpretation implies that\n2n2C3nC1D\u201a.n2/, which is what the chaining of equations intuitively gives\nus.\no-notation\nThe asymptotic upper bound provided by O-notation may or may not be asymp-\ntotically tight. The bound 2n2DO.n2/is asymptotically tight, but the bound\n2nDO.n2/is not. We use o-notation to denote an upper bound that is not asymp-\ntotically tight. We formally de\ufb01ne o.g.n// (\u201clittle-oh of gofn\u201d) as the set\no.g.n//Dff .n/Wfor any positive constant c>0 , there exists a constant\nn0>0such that 0/DC4f .n/ < cg.n/ for all n/NAKn0g:\nFor example, 2nDo.n2/,b u t2n2\u00a4o.n2/.\nThe de\ufb01nitions of O-notation and o-notation are similar. The main difference\nis that in f .n/DO.g.n// , the bound 0/DC4f .n//DC4cg.n/ holds for some con-\nstant c>0 ,b u ti n f .n/Do.g.n// , the bound 0/DC4f .n/ < cg.n/ holds for all\nconstants c>0 . Intuitively, in o-notation, the function f .n/ becomes insigni\ufb01cant\nrelative to g.n/ asnapproaches in\ufb01nity; that is,", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "71": {"page_number": 72, "page_information": "3.1 Asymptotic notation 51\nlim\nn!1f .n/\ng.n/D0: (3.1)\nSome authors use this limit as a de\ufb01nition of the o-notation; the de\ufb01nition in this\nbook also restricts the anonymous functions to be asymptotically nonnegative.\n!-notation\nBy analogy, !-notation is to /DEL-notation as o-notation is to O-notation. We use\n!-notation to denote a lower bound that is not asymptotically tight. One way to\nde\ufb01ne it is by\nf .n/2!.g.n// if and only if g.n/2o.f .n// :\nFormally, however, we de\ufb01ne !.g.n// (\u201clittle-omega of gofn\u201d) as the set\n!.g.n//Dff .n/Wfor any positive constant c>0 , there exists a constant\nn0>0such that 0/DC4cg.n/ < f .n/ for all n/NAKn0g:\nFor example, n2=2D!.n/ ,b u t n2=2\u00a4!.n2/. The relation f .n/D!.g.n//\nimplies that\nlim\nn!1f .n/\ng.n/D1 ;\nif the limit exists. That is, f .n/ becomes arbitrarily large relative to g.n/ asn\napproaches in\ufb01nity.\nComparing functions\nMany of the relational properties of real numbers apply to asymptotic comparisons\nas well. For the following, assume that f .n/ andg.n/ are asymptotically positive.\nTransitivity:\nf .n/D\u201a.g.n// andg.n/D\u201a.h.n// imply f .n/D\u201a.h.n// ;\nf .n/DO.g.n// andg.n/DO.h.n// imply f .n/DO.h.n// ;\nf .n/D/DEL.g.n// andg.n/D/DEL.h.n// imply f .n/D/DEL.h.n// ;\nf .n/Do.g.n// andg.n/Do.h.n// imply f .n/Do.h.n// ;\nf .n/D!.g.n// andg.n/D!.h.n// imply f .n/D!.h.n// :\nRe\ufb02exivity:\nf .n/D\u201a.f .n// ;\nf .n/DO.f .n// ;\nf .n/D/DEL.f .n// :", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "72": {"page_number": 73, "page_information": "52 Chapter 3 Growth of Functions\nSymmetry:\nf .n/D\u201a.g.n// if and only if g.n/D\u201a.f .n// :\nTranspose symmetry:\nf .n/DO.g.n// if and only if g.n/D/DEL.f .n// ;\nf .n/Do.g.n// if and only if g.n/D!.f .n// :\nBecause these properties hold for asymptotic notations, we can draw an analogy\nbetween the asymptotic comparison of two functions fandgand the comparison\nof two real numbers aandb:\nf .n/DO.g.n// is like a/DC4b;\nf .n/D/DEL.g.n// is like a/NAKb;\nf .n/D\u201a.g.n// is like aDb;\nf .n/Do.g.n// is like a<b;\nf .n/D!.g.n// is like a>b:\nWe say that f .n/ isasymptotically smaller thang.n/ iff .n/Do.g.n// ,a n d f .n/\nisasymptotically larger thang.n/ iff .n/D!.g.n// .\nOne property of real numbers, however, does not carry over to asymptotic nota-\ntion:\nTrichotomy: For any two real numbers aandb, exactly one of the following must\nhold: a<b ,aDb,o ra>b .\nAlthough any two real numbers can be compared, not all functions are asymptot-\nically comparable. That is, for two functions f .n/ andg.n/ , it may be the case\nthat neither f .n/DO.g.n// norf .n/D/DEL.g.n// holds. For example, we cannot\ncompare the functions nandn1Csinnusing asymptotic notation, since the value of\nthe exponent in n1Csinnoscillates between 0 and 2, taking on all values in between.\nExercises\n3.1-1\nLetf .n/ andg.n/ be asymptotically nonnegative functions. Using the basic de\ufb01-\nnition of \u201a-notation, prove that max .f .n/; g.n//D\u201a.f .n/Cg.n// .\n3.1-2\nShow that for any real constants aandb,w h e r e b>0 ,\n.nCa/bD\u201a.nb/: (3.2)", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "73": {"page_number": 74, "page_information": "3.2 Standard notations and common functions 53\n3.1-3\nExplain why the statement, \u201cThe running time of algorithm Ais at least O.n2/,\u201d is\nmeaningless.\n3.1-4\nIs2nC1DO.2n/?I s22nDO.2n/?\n3.1-5\nProve Theorem 3.1.\n3.1-6\nProve that the running time of an algorithm is \u201a.g.n// if and only if its worst-case\nrunning time is O.g.n// and its best-case running time is /DEL.g.n// .\n3.1-7\nProve that o.g.n//\\!.g.n// is the empty set.\n3.1-8\nWe can extend our notation to the case of two parameters nandmthat can go to\nin\ufb01nity independently at different rates. For a given function g.n;m/ , we denote\nbyO.g.n;m// the set of functions\nO.g.n;m//Dff. n ;m /Wthere exist positive constants c,n0,a n d m0\nsuch that 0/DC4f. n ;m //DC4cg.n;m/\nfor all n/NAKn0orm/NAKm0g:\nGive corresponding de\ufb01nitions for /DEL.g.n; m// and\u201a.g.n; m// .\n3.2 Standard notations and common functions\nThis section reviews some standard mathematical functions and notations and ex-\nplores the relationships among them. It also illustrates the use of the asymptoticnotations.\nMonotonicity\nA function f .n/ ismonotonically increasing ifm/DC4nimplies f. m //DC4f .n/ .\nSimilarly, it is monotonically decreasing ifm/DC4nimplies f. m //NAKf .n/ .A\nfunction f .n/ isstrictly increasing ifm<n implies f .m/ < f .n/ andstrictly\ndecreasing ifm<n implies f .m/ > f .n/ .", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "74": {"page_number": 75, "page_information": "54 Chapter 3 Growth of Functions\nFloors and ceilings\nFor any real number x, we denote the greatest integer less than or equal to xbybxc\n(read \u201cthe \ufb02oor of x\u201d) and the least integer greater than or equal to xbydxe(read\n\u201cthe ceiling of x\u201d). For all real x,\nx/NUL1<bxc/DC4x/DC4dxe<xC1: (3.3)\nFor any integer n,\ndn=2eCbn=2cDn;\nand for any real number x/NAK0and integers a;b > 0 ,\n/CANdx=ae\nb/EM\nDlx\nabm\n; (3.4)\n/SYNbx=ac\nb/ETB\nDjx\nabk\n; (3.5)\nla\nbm\n/DC4aC.b/NUL1/\nb; (3.6)\nja\nbk\n/NAKa/NUL.b/NUL1/\nb: (3.7)\nThe \ufb02oor function f. x/Dbxcis monotonically increasing, as is the ceiling func-\ntionf. x/Ddxe.\nModular arithmetic\nFor any integer aand any positive integer n,t h ev a l u e amodnis the remainder\n(orresidue ) of the quotient a=n:\namodnDa/NULnba=nc: (3.8)\nIt follows that\n0/DC4amodn<n: (3.9)\nGiven a well-de\ufb01ned notion of the remainder of one integer when divided by an-\nother, it is convenient to provide special notation to indicate equality of remainders.If.amodn/D.bmodn/, we write a/DC1b.mod n/and say that aisequivalent\ntob, modulo n. In other words, a/DC1b.mod n/ifaandbhave the same remain-\nder when divided by n. Equivalently, a/DC1b.mod n/if and only if nis a divisor\nofb/NULa\n. We write a6/DC1b.mod n/ifais not equivalent to b, modulo n.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "75": {"page_number": 76, "page_information": "3.2 Standard notations and common functions 55\nPolynomials\nGiven a nonnegative integer d,apolynomial in nof degree dis a function p.n/\nof the form\np.n/DdX\niD0aini;\nwhere the constants a0;a1;:::;a dare the coef\ufb01cients of the polynomial and\nad\u00a40. A polynomial is asymptotically positive if and only if ad>0.F o r a n\nasymptotically positive polynomial p.n/ of degree d,w eh a v e p.n/D\u201a.nd/.F o r\nany real constant a/NAK0, the function nais monotonically increasing, and for any\nreal constant a/DC40, the function nais monotonically decreasing. We say that a\nfunction f .n/ ispolynomially bounded iff .n/DO.nk/for some constant k.\nExponentials\nFor all real a>0 ,m,a n d n, we have the following identities:\na0D1;\na1Da;\na/NUL1D1=a ;\n.am/nDamn;\n.am/nD.an/m;\namanDamCn:\nFor all nanda/NAK1, the function anis monotonically increasing in n.W h e n\nconvenient, we shall assume 00D1.\nWe can relate the rates of growth of polynomials and exponentials by the fol-\nlowing fact. For all real constants aandbsuch that a>1 ,\nlim\nn!1nb\nanD0; (3.10)\nfrom which we can conclude that\nnbDo.an/:\nThus, any exponential function with a base strictly greater than 1grows faster than\nany polynomial function.\nUsing eto denote 2:71828 : : : , the base of the natural logarithm function, we\nhave for all real x,\nexD1CxCx2\n2\u0160Cx3\n3\u0160C/SOH/SOH/SOHD1X\niD0xi\ni\u0160; (3.11)", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "76": {"page_number": 77, "page_information": "56 Chapter 3 Growth of Functions\nwhere \u201c \u0160\u201d denotes the factorial function de\ufb01ned later in this section. For all real x,\nwe have the inequality\nex/NAK1Cx; (3.12)\nwhere equality holds only when xD0.W h e njxj/DC41, we have the approximation\n1Cx/DC4ex/DC41CxCx2: (3.13)\nWhen x!0, the approximation of exby1Cxis quite good:\nexD1CxC\u201a.x2/:\n(In this equation, the asymptotic notation is used to describe the limiting behavior\nasx!0rather than as x!1 .) We have for all x,\nlim\nn!1/DLE\n1Cx\nn/DC1n\nDex: (3.14)\nLogarithms\nWe shall use the following notations:\nlgnDlog2n (binary logarithm) ,\nlnnDlogen (natural logarithm) ,\nlgknD.lgn/k(exponentiation) ,\nlg lgnDlg.lgn/(composition) .\nAn important notational convention we shall adopt is that logarithm functions will\napply only to the next term in the formula ,s ot h a tl g nCkwill mean .lgn/Ck\nand not lg .nCk/. If we hold b>1 constant, then for n>0 , the function logbn\nis strictly increasing.\nFor all real a>0 ,b>0 ,c>0 ,a n d n,\naDblogba;\nlogc.ab/DlogcaClogcb;\nlogbanDnlogba;\nlogbaDlogca\nlogcb; (3.15)\nlogb.1=a/D/NUL logba;\nlogbaD1\nlogab;\nalogbcDclogba; (3.16)\nwhere, in each equation above, logarithm bases are not 1.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "77": {"page_number": 78, "page_information": "3.2 Standard notations and common functions 57\nBy equation (3.15), changing the base of a logarithm from one constant to an-\nother changes the value of the logarithm by only a constant factor, and so we shalloften use the notation \u201clg n\u201d when we don\u2019t care about constant factors, such as in\nO-notation. Computer scientists \ufb01nd 2to be the most natural base for logarithms\nbecause so many algorithms and data structures involve splitting a problem intotwo parts.\nThere is a simple series expansion for ln .1Cx/whenjxj<1:\nln.1Cx/Dx/NULx\n2\n2Cx3\n3/NULx4\n4Cx5\n5/NUL/SOH/SOH/SOH :\nWe also have the following inequalities for x>/NUL1:\nx\n1Cx/DC4ln.1Cx//DC4x; (3.17)\nwhere equality holds only for xD0.\nWe say that a function f .n/ ispolylogarithmically bounded iff .n/DO.lgkn/\nfor some constant k. We can relate the growth of polynomials and polylogarithms\nby substituting lg nfornand2aforain equation (3.10), yielding\nlim\nn!1lgbn\n.2a/lgnDlim\nn!1lgbn\nnaD0:\nFrom this limit, we can conclude that\nlgbnDo.na/\nfor any constant a>0 . Thus, any positive polynomial function grows faster than\nany polylogarithmic function.\nFactorials\nThe notation n\u0160(read \u201c nfactorial\u201d) is de\ufb01ned for integers n/NAK0as\nn\u0160D(\n1 ifnD0;\nn/SOH.n/NUL1/\u0160 ifn>0:\nThus, n\u0160D1/SOH2/SOH3/SOH/SOH/SOHn.\nA weak upper bound on the factorial function is n\u0160/DC4nn, since each of the n\nterms in the factorial product is at most n.Stirling\u2019s approximation ,\nn\u0160Dp\n2/EMn/DLEn\ne/DC1n/DC2\n1C\u201a/DC21\nn/DC3/DC3\n; (3.18)", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "78": {"page_number": 79, "page_information": "58 Chapter 3 Growth of Functions\nwhere eis the base of the natural logarithm, gives us a tighter upper bound, and a\nlower bound as well. As Exercise 3.2-3 asks you to prove,\nn\u0160Do.nn/;\nn\u0160D!.2n/;\nlg.n\u0160/D\u201a.n lgn/ ; (3.19)\nwhere Stirling\u2019s approximation is helpful in proving equation (3.19). The following\nequation also holds for all n/NAK1:\nn\u0160Dp\n2/EMn/DLEn\ne/DC1n\ne\u02dbn(3.20)\nwhere\n1\n12nC1<\u02db n<1\n12n: (3.21)\nFunctional iteration\nWe use the notation f.i/.n/to denote the function f .n/ iteratively applied itimes\nto an initial value of n. Formally, let f .n/ be a function over the reals. For non-\nnegative integers i, we recursively de\ufb01ne\nf.i/.n/D(\nn ifiD0;\nf. f.i/NUL1/.n// ifi>0:\nFor example, if f .n/D2n,t h e n f.i/.n/D2in.\nThe iterated logarithm function\nWe use the notation lg/ETXn(read \u201clog star of n\u201d) to denote the iterated logarithm, de-\n\ufb01ned as follows. Let lg.i/nbe as de\ufb01ned above, with f .n/Dlgn. Because the log-\narithm of a nonpositive number is unde\ufb01ned, lg.i/nis de\ufb01ned only if lg.i/NUL1/n>0 .\nBe sure to distinguish lg.i/n(the logarithm function applied itimes in succession,\nstarting with argument n) from lgin(the logarithm of nraised to the ith power).\nThen we de\ufb01ne the iterated logarithm function as\nlg/ETXnDmin\u02da\ni/NAK0Wlg.i/n/DC41/TAB\n:\nThe iterated logarithm is a very slowly growing function:\nlg/ETX2D1;\nlg/ETX4D2;\nlg/ETX16D3;\nlg/ETX65536D4;\nlg/ETX.265536/D5:", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "79": {"page_number": 80, "page_information": "3.2 Standard notations and common functions 59\nSince the number of atoms in the observable universe is estimated to be about 1080,\nwhich is much less than 265536, we rarely encounter an input size nsuch that\nlg/ETXn>5 .\nFibonacci numbers\nWe de\ufb01ne the Fibonacci numbers by the following recurrence:\nF0D0;\nF1D1; (3.22)\nFiDFi/NUL1CFi/NUL2 fori/NAK2:\nThus, each Fibonacci number is the sum of the two previous ones, yielding the\nsequence\n0; 1; 1; 2; 3; 5; 8; 13; 21; 34; 55; : : : :\nFibonacci numbers are related to the golden ratio /RSand to its conjugate y/RS,w h i c h\nare the two roots of the equation\nx2DxC1 (3.23)\nand are given by the following formulas (see Exercise 3.2-6):\n/RSD1Cp\n5\n2(3.24)\nD1:61803 : : : ;\ny/RSD1/NULp\n5\n2\nD/NUL :61803 : : : :\nSpeci\ufb01cally, we have\nFiD/RSi/NULy/RSi\np\n5;\nwhich we can prove by induction (Exercise 3.2-7). Since\u02c7\u02c7y/RS\u02c7\u02c7<1,w eh a v e\n\u02c7\u02c7y/RSi\u02c7\u02c7\np\n5<1\np\n5\n<1\n2;\nwhich implies that", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "80": {"page_number": 81, "page_information": "60 Chapter 3 Growth of Functions\nFiD/SYN/RSi\np\n5C1\n2/ETB\n; (3.25)\nwhich is to say that the ith Fibonacci number Fiis equal to /RSi=p\n5rounded to the\nnearest integer. Thus, Fibonacci numbers grow exponentially.\nExercises\n3.2-1\nShow that if f .n/ andg.n/ are monotonically increasing functions, then so are\nthe functions f .n/Cg.n/ andf .g.n// ,a n di f f .n/ andg.n/ are in addition\nnonnegative, then f .n//SOHg.n/ is monotonically increasing.\n3.2-2\nProve equation (3.16).\n3.2-3\nProve equation (3.19). Also prove that n\u0160D!.2n/andn\u0160Do.nn/.\n3.2-4 ?\nIs the functiondlgne\u0160polynomially bounded? Is the function dlg lgne\u0160polynomi-\nally bounded?\n3.2-5 ?\nWhich is asymptotically larger: lg .lg/ETXn/or lg/ETX.lgn/?\n3.2-6\nShow that the golden ratio /RSand its conjugate y/RSboth satisfy the equation\nx2DxC1.\n3.2-7\nProve by induction that the ith Fibonacci number satis\ufb01es the equality\nFiD/RSi/NULy/RSi\np\n5;\nwhere /RSis the golden ratio and y/RSis its conjugate.\n3.2-8\nShow that klnkD\u201a.n/ implies kD\u201a.n= lnn/.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "81": {"page_number": 82, "page_information": "Problems for Chapter 3 61\nProblems\n3-1 Asymptotic behavior of polynomials\nLet\np.n/DdX\niD0aini;\nwhere ad>0,b ead e g r e e - dpolynomial in n,a n dl e t kbe a constant. Use the\nde\ufb01nitions of the asymptotic notations to prove the following properties.\na.Ifk/NAKd,t h e n p.n/DO.nk/.\nb.Ifk/DC4d,t h e n p.n/D/DEL.nk/.\nc.IfkDd,t h e n p.n/D\u201a.nk/.\nd.Ifk>d ,t h e n p.n/Do.nk/.\ne.Ifk<d ,t h e n p.n/D!.nk/.\n3-2 Relative asymptotic growths\nIndicate, for each pair of expressions .A; B/ in the table below, whether AisO,o,\n/DEL,!,o r\u201aofB. Assume that k/NAK1,/SI>0 ,a n d c>1 are constants. Your answer\nshould be in the form of the table with \u201cyes\u201d or \u201cno\u201d written in each box.\nAB\n O\n o\n /DEL\n !\n \u201a\na. lgknn/SI\nb. nkcn\nc.p\nnnsinn\nd. 2n2n=2\ne. nlgcclgn\nf.lg.n\u0160/ lg.nn/\n3-3 Ordering by asymptotic growth rates\na.Rank the following functions by order of growth; that is, \ufb01nd an arrangement\ng1;g2;:::;g 30of the functions satisfying g1D/DEL.g 2/,g2D/DEL.g 3/, ...,\ng29D/DEL.g 30/. Partition your list into equivalence classes such that functions\nf .n/ andg.n/ are in the same class if and only if f .n/D\u201a.g.n// .", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "82": {"page_number": 83, "page_information": "62 Chapter 3 Growth of Functions\nlg.lg/ETXn/ 2lg/ETXn.p\n2/lgnn2n\u0160 . lgn/\u0160\n.3\n2/nn3lg2n lg.n\u0160/ 22nn1=lgn\nln lnn lg/ETXnn/SOH2nnlg lgnlnn1\n2lgn.lgn/lgnen4lgn.nC1/\u0160p\nlgn\nlg/ETX.lgn/ 2p\n2lgnn2nnlgn22nC1\nb.Give an example of a single nonnegative function f .n/ such that for all func-\ntions gi.n/in part (a), f .n/ is neither O.g i.n// nor/DEL.g i.n//.\n3-4 Asymptotic notation properties\nLetf .n/ andg.n/ be asymptotically positive functions. Prove or disprove each of\nthe following conjectures.\na.f .n/DO.g.n// implies g.n/DO.f .n// .\nb.f .n/Cg.n/D\u201a.min.f .n/; g.n/// .\nc.f .n/DO.g.n// implies lg .f .n//DO.lg.g.n/// , where lg .g.n///NAK1and\nf .n//NAK1for all suf\ufb01ciently large n.\nd.f .n/DO.g.n// implies 2f. n /DO/NUL\n2g.n//SOH\n.\ne.f .n/DO ..f .n//2/.\nf.f .n/DO.g.n// implies g.n/D/DEL.f .n// .\ng.f .n/D\u201a.f .n=2// .\nh.f .n/Co.f .n//D\u201a.f .n// .\n3-5 Variations on Oand\u02dd\nSome authors de\ufb01ne /DELin a slightly different way than we do; let\u2019s use1/DEL(read\n\u201comega in\ufb01nity\u201d) for this alternative de\ufb01nition. We say that f .n/D1/DEL.g.n// if\nthere exists a positive constant csuch that f .n//NAKcg.n//NAK0for in\ufb01nitely many\nintegers n.\na.Show that for any two functions f .n/ andg.n/ that are asymptotically nonneg-\native, either f .n/DO.g.n// orf .n/D1/DEL.g.n// or both, whereas this is not\ntrue if we use /DELin place of1/DEL.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "83": {"page_number": 84, "page_information": "Problems for Chapter 3 63\nb.Describe the potential advantages and disadvantages of using1/DELinstead of /DELto\ncharacterize the running times of programs.\nSome authors also de\ufb01ne Oin a slightly different manner; let\u2019s use O0for the\nalternative de\ufb01nition. We say that f .n/DO0.g.n// if and only ifjf .n/jD\nO.g.n// .\nc.What happens to each direction of the \u201cif and only if\u201d in Theorem 3.1 if we\nsubstitute O0forObut still use /DEL?\nSome authors de\ufb01ne eO(read \u201csoft-oh\u201d) to mean Owith logarithmic factors ig-\nnored:\neO.g.n//Dff .n/Wthere exist positive constants c,k,a n d n0such that\n0/DC4f .n//DC4cg.n/ lgk.n/for all n/NAKn0g:\nd.De\ufb01nee/DELande\u201ain a similar manner. Prove the corresponding analog to Theo-\nrem 3.1.\n3-6 Iterated functions\nWe can apply the iteration operator/ETXused in the lg/ETXfunction to any monotonically\nincreasing function f .n/ over the reals. For a given constant c2R,w ed e \ufb01 n et h e\niterated function f/ETX\ncby\nf/ETX\nc.n/Dmin\u02da\ni/NAK0Wf.i/.n//DC4c/TAB\n;\nwhich need not be well de\ufb01ned in all cases. In other words, the quantity f/ETX\nc.n/is\nthe number of iterated applications of the function frequired to reduce its argu-\nment down to cor less.\nFor each of the following functions f .n/ and constants c, give as tight a bound\nas possible on f/ETX\nc.n/.\nf .n/ c\n f/ETX\nc.n/\na. n/NUL10\nb. lgn1\nc. n=2 1\nd. n=2 2\ne.p\nn2\nf.p\nn1\ng. n1=32\nh.n=lgn2\n", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "84": {"page_number": 85, "page_information": "64 Chapter 3 Growth of Functions\nChapter notes\nKnuth [209] traces the origin of the O-notation to a number-theory text by P. Bach-\nmann in 1892. The o-notation was invented by E. Landau in 1909 for his discussion\nof the distribution of prime numbers. The /DELand\u201anotations were advocated by\nKnuth [213] to correct the popular, but technically sloppy, practice in the literature\nof using O-notation for both upper and lower bounds. Many people continue to\nuse the O-notation where the \u201a-notation is more technically precise. Further dis-\ncussion of the history and development of asymptotic notations appears in worksby Knuth [209, 213] and Brassard and Bratley [54].\nNot all authors de\ufb01ne the asymptotic notations in the same way, although the\nvarious de\ufb01nitions agree in most common situations. Some of the alternative def-initions encompass functions that are not asymptotically nonnegative, as long astheir absolute values are appropriately bounded.\nEquation (3.20) is due to Robbins [297]. Other properties of elementary math-\nematical functions can be found in any good mathematical reference, such asAbramowitz and Stegun [1] or Zwillinger [362], or in a calculus book, such asApostol [18] or Thomas et al. [334]. Knuth [209] and Graham, Knuth, and Patash-nik [152] contain a wealth of material on discrete mathematics as used in computerscience.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "85": {"page_number": 86, "page_information": "4 Divide-and-Conquer\nIn Section 2.3.1, we saw how merge sort serves as an example of the divide-and-\nconquer paradigm. Recall that in divide-and-conquer, we solve a problem recur-sively, applying three steps at each level of the recursion:\nDivide the problem into a number of subproblems that are smaller instances of the\nsame problem.\nConquer the subproblems by solving them recursively. If the subproblem sizes are\nsmall enough, however, just solve the subproblems in a straightforward manner.\nCombine the solutions to the subproblems into the solution for the original prob-\nlem.\nWhen the subproblems are large enough to solve recursively, we call that the recur-\nsive case . Once the subproblems become small enough that we no longer recurse,\nwe say that the recursion \u201cbottoms out\u201d and that we have gotten down to the base\ncase. Sometimes, in addition to subproblems that are smaller instances of the same\nproblem, we have to solve subproblems that are not quite the same as the original\nproblem. We consider solving such subproblems as part of the combine step.\nIn this chapter, we shall see more algorithms based on divide-and-conquer. The\n\ufb01rst one solves the maximum-subarray problem: it takes as input an array of num-bers, and it determines the contiguous subarray whose values have the greatest sum.Then we shall see two divide-and-conquer algorithms for multiplying n/STXnmatri-\nces. One runs in \u201a.n\n3/time, which is no better than the straightforward method of\nmultiplying square matrices. But the other, Strassen\u2019s algorithm, runs in O.n2:81/\ntime, which beats the straightforward method asymptotically.\nRecurrences\nRecurrences go hand in hand with the divide-and-conquer paradigm, because they\ngive us a natural way to characterize the running times of divide-and-conquer algo-rithms. A recurrence is an equation or inequality that describes a function in terms", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "86": {"page_number": 87, "page_information": "66 Chapter 4 Divide-and-Conquer\nof its value on smaller inputs. For example, in Section 2.3.2 we described the\nworst-case running time T .n/ of the M ERGE -SORT procedure by the recurrence\nT .n/D(\n\u201a.1/ ifnD1;\n2T .n=2/C\u201a.n/ ifn>1;(4.1)\nwhose solution we claimed to be T .n/D\u201a.n lgn/.\nRecurrences can take many forms. For example, a recursive algorithm might\ndivide subproblems into unequal sizes, such as a 2=3-to-1=3split. If the divide and\ncombine steps take linear time, such an algorithm would give rise to the recurrenceT .n/DT .2n=3/CT .n=3/C\u201a.n/ .\nSubproblems are not necessarily constrained to being a constant fraction of\nthe original problem size. For example, a recursive version of linear search\n(see Exercise 2.1-3) would create just one subproblem containing only one el-\nement fewer than the original problem. Each recursive call would take con-stant time plus the time for the recursive calls it makes, yielding the recurrenceT .n/DT. n/NUL1/C\u201a.1/ .\nThis chapter offers three methods for solving recurrences\u2014that is, for obtaining\nasymptotic \u201c \u201a\u201do r\u201c O\u201d bounds on the solution:\n/SIIn the substitution method , we guess a bound and then use mathematical in-\nduction to prove our guess correct.\n/SITherecursion-tree method converts the recurrence into a tree whose nodes\nrepresent the costs incurred at various levels of the recursion. We use techniques\nfor bounding summations to solve the recurrence.\n/SIThemaster method provides bounds for recurrences of the form\nT .n/DaT .n=b/Cf .n/ ; (4.2)\nwhere a/NAK1,b>1 ,a n d f .n/ is a given function. Such recurrences arise\nfrequently. A recurrence of the form in equation (4.2) characterizes a divide-and-conquer algorithm that creates asubproblems, each of which is 1=b the\nsize of the original problem, and in which the divide and combine steps togethertakef .n/ time.\nTo use the master method, you will need to memorize three cases, but once\nyou do that, you will easily be able to determine asymptotic bounds for manysimple recurrences. We will use the master method to determine the runningtimes of the divide-and-conquer algorithms for the maximum-subarray problemand for matrix multiplication, as well as for other algorithms based on divide-and-conquer elsewhere in this book.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "87": {"page_number": 88, "page_information": "Chapter 4 Divide-and-Conquer 67\nOccasionally, we shall see recurrences that are not equalities but rather inequal-\nities, such as T .n//DC42T .n=2/C\u201a.n/ . Because such a recurrence states only\nan upper bound on T .n/ , we will couch its solution using O-notation rather than\n\u201a-notation. Similarly, if the inequality were reversed to T .n//NAK2T .n=2/C\u201a.n/ ,\nthen because the recurrence gives only a lower bound on T .n/ , we would use\n/DEL-notation in its solution.\nTechnicalities in recurrences\nIn practice, we neglect certain technical details when we state and solve recur-\nrences. For example, if we call M ERGE -SORT onnelements when nis odd, we\nend up with subproblems of size bn=2canddn=2e. Neither size is actually n=2,\nbecause n=2is not an integer when nis odd. Technically, the recurrence describing\nthe worst-case running time of M ERGE -SORT is really\nT .n/D(\n\u201a.1/ ifnD1;\nT.dn=2e/CT.bn=2c/C\u201a.n/ ifn>1:(4.3)\nBoundary conditions represent another class of details that we typically ignore.\nSince the running time of an algorithm on a constant-sized input is a constant,the recurrences that arise from the running times of algorithms generally haveT .n/D\u201a.1/ for suf\ufb01ciently small n. Consequently, for convenience, we shall\ngenerally omit statements of the boundary conditions of recurrences and assumethatT .n/ is constant for small n. For example, we normally state recurrence (4.1)\nas\nT .n/D2T .n=2/C\u201a.n/ ; (4.4)\nwithout explicitly giving values for small n. The reason is that although changing\nthe value of T. 1 / changes the exact solution to the recurrence, the solution typi-\ncally doesn\u2019t change by more than a constant factor, and so the order of growth is\nunchanged.\nWhen we state and solve recurrences, we often omit \ufb02oors, ceilings, and bound-\nary conditions. We forge ahead without these details and later determine whetheror not they matter. They usually do not, but you should know when they do. Ex-perience helps, and so do some theorems stating that these details do not affect theasymptotic bounds of many recurrences characterizing divide-and-conquer algo-rithms (see Theorem 4.1). In this chapter, however, we shall address some of thesedetails and illustrate the \ufb01ne points of recurrence solution methods.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "88": {"page_number": 89, "page_information": "68 Chapter 4 Divide-and-Conquer\n4.1 The maximum-subarray problem\nSuppose that you been offered the opportunity to invest in the Volatile Chemical\nCorporation. Like the chemicals the company produces, the stock price of theVolatile Chemical Corporation is rather volatile. You are allowed to buy one unitof stock only one time and then sell it at a later date, buying and selling after the\nclose of trading for the day. To compensate for this restriction, you are allowed to\nlearn what the price of the stock will be in the future. Your goal is to maximizeyour pro\ufb01t. Figure 4.1 shows the price of the stock over a 17-day period. Youmay buy the stock at any one time, starting after day 0, when the price is $100per share. Of course, you would want to \u201cbuy low, sell high\u201d\u2014buy at the lowestpossible price and later on sell at the highest possible price\u2014to maximize yourpro\ufb01t. Unfortunately, you might not be able to buy at the lowest price and then sellat the highest price within a given period. In Figure 4.1, the lowest price occursafter day 7, which occurs after the highest price, after day 1.\nYou might think that you can always maximize pro\ufb01t by either buying at the\nlowest price or selling at the highest price. For example, in Figure 4.1, we wouldmaximize pro\ufb01t by buying at the lowest price, after day 7. If this strategy alwaysworked, then it would be easy to determine how to maximize pro\ufb01t: \ufb01nd the highestand lowest prices, and then work left from the highest price to \ufb01nd the lowest prior\nprice, work right from the lowest price to \ufb01nd the highest later price, and take\nthe pair with the greater difference. Figure 4.2 shows a simple counterexample,\n0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16120\n110100\n90807060\nDay\n 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16\nPrice\n 100 113 110 85 105 102 86 63 81 101 94 106 101 79 94 90 97\nChange\n 13/NUL3/NUL25 20/NUL3/NUL16/NUL23 18 20/NUL71 2/NUL5/NUL22 15/NUL47\nFigure 4.1 Information about the price of stock in the V olatile Chemical Corporation after the close\nof trading over a period of 17 days. The horizontal axis of the chart indicates the day, and the vertical\naxis shows the price. The bottom row of the table gives the change in price from the previous day.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "89": {"page_number": 90, "page_information": "4.1 The maximum-subarray problem 69\n0123411\n10\n9876 Day\n 01 23 4\nPrice\n 10 11 7 10 6\nChange\n 1/NUL43/NUL4\nFigure 4.2 An example showing that the maximum pro\ufb01t does not always start at the lowest price\nor end at the highest price. Again, the horizontal axis indicates the day, and the vertical axis shows\nthe price. Here, the maximum pro\ufb01t of $3 per share would be earned by buying after day 2 and\nselling after day 3. The price of $7 after day 2 is not the lowest price overall, and the price of $10\nafter day 3 is not the highest price overall.\ndemonstrating that the maximum pro\ufb01t sometimes comes neither by buying at the\nlowest price nor by selling at the highest price.\nA brute-force solution\nWe can easily devise a brute-force solution to this problem: just try every possible\npair of buy and sell dates in which the buy date precedes the sell date. A period of n\ndays has/NULn\n2/SOH\nsuch pairs of dates. Since/NULn\n2/SOH\nis\u201a.n2/, and the best we can hope for\nis to evaluate each pair of dates in constant time, this approach would take /DEL.n2/\ntime. Can we do better?\nA transformation\nIn order to design an algorithm with an o.n2/running time, we will look at the\ninput in a slightly different way. We want to \ufb01nd a sequence of days over which\nthe net change from the \ufb01rst day to the last is maximum. Instead of looking at the\ndaily prices, let us instead consider the daily change in price, where the change on\ndayiis the difference between the prices after day i/NUL1and after day i. The table\nin Figure 4.1 shows these daily changes in the bottom row. If we treat this row as\nan array A, shown in Figure 4.3, we now want to \ufb01nd the nonempty, contiguous\nsubarray of Awhose values have the largest sum. We call this contiguous subarray\nthemaximum subarray . For example, in the array of Figure 4.3, the maximum\nsubarray of A\u01521 : : 16/c141 isA\u01528 : : 11/c141 , with the sum 43. Thus, you would want to buy\nthe stock just before day 8 (that is, after day 7) and sell it after day 11, earning a\npro\ufb01t of $43 per share.\nAt \ufb01rst glance, this transformation does not help. We still need to check/NULn/NUL1\n2/SOH\nD\u201a.n2/subarrays for a period of ndays. Exercise 4.1-2 asks you to show", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "90": {"page_number": 91, "page_information": "70 Chapter 4 Divide-and-Conquer\n131\n\u201332\n\u2013253\n204\n\u201335\n\u2013166\n\u2013237 8 9 10\nmaximum subarray11\n1812\n2013\n\u2013714\n1215\n716\n\u20135 \u201322 15 \u20134 A\nFigure 4.3 The change in stock prices as a maximum-subarray problem. Here, the subar-\nrayA\u01528 : : 11/c141 ,w i t hs u m 43, has the greatest sum of any contiguous subarray of array A.\nthat although computing the cost of one subarray might take time proportional to\nthe length of the subarray, when computing all \u201a.n2/subarray sums, we can orga-\nnize the computation so that each subarray sum takes O.1/ time, given the values\nof previously computed subarray sums, so that the brute-force solution takes \u201a.n2/\ntime.\nSo let us seek a more ef\ufb01cient solution to the maximum-subarray problem.\nWhen doing so, we will usually speak of \u201ca\u201d maximum subarray rather than \u201cthe\u201dmaximum subarray, since there could be more than one subarray that achieves themaximum sum.\nThe maximum-subarray problem is interesting only when the array contains\nsome negative numbers. If all the array entries were nonnegative, then themaximum-subarray problem would present no challenge, since the entire arraywould give the greatest sum.\nA solution using divide-and-conquer\nLet\u2019s think about how we might solve the maximum-subarray problem using\nthe divide-and-conquer technique. Suppose we want to \ufb01nd a maximum subar-\nray of the subarray A\u0152low::high/c141. Divide-and-conquer suggests that we divide\nthe subarray into two subarrays of as equal size as possible. That is, we \ufb01nd\nthe midpoint, say mid, of the subarray, and consider the subarrays A\u0152low::mid/c141\nandA\u0152midC1::high/c141. As Figure 4.4(a) shows, any contiguous subarray A\u0152i : : j /c141\nofA\u0152low::high/c141must lie in exactly one of the following places:\n/SIentirely in the subarray A\u0152low::mid/c141,s ot h a t low/DC4i/DC4j/DC4mid,\n/SIentirely in the subarray A\u0152midC1::high/c141,s ot h a t mid<i/DC4j/DC4high,o r\n/SIcrossing the midpoint, so that low/DC4i/DC4mid<j/DC4high.\nTherefore, a maximum subarray of A\u0152low::high/c141must lie in exactly one of these\nplaces. In fact, a maximum subarray of A\u0152low::high/c141must have the greatest\nsum over all subarrays entirely in A\u0152low::mid/c141, entirely in A\u0152midC1::high/c141,\nor crossing the midpoint. We can \ufb01nd maximum subarrays of A\u0152low::mid/c141and\nA\u0152midC1::high/c141recursively, because these two subproblems are smaller instances\nof the problem of \ufb01nding a maximum subarray. Thus, all that is left to do is \ufb01nd a", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "91": {"page_number": 92, "page_information": "4.1 The maximum-subarray problem 71\n(a) (b)low low mid mid high highcrosses the midpoint\nmidC1 midC1\nentirely in A\u0152low::mid/c141 entirely in A\u0152midC1::high/c141i\nj\nA\u0152i : : mid/c141A\u0152midC1::j/c141\nFigure 4.4 (a) Possible locations of subarrays of A\u0152low::high/c141: entirely in A\u0152low::mid/c141,e n t i r e l y\ninA\u0152midC1::high/c141, or crossing the midpoint mid.(b)Any subarray of A\u0152low::high/c141crossing\nthe midpoint comprises two subarrays A\u0152i : : mid/c141andA\u0152midC1::j/c141 ,w h e r e low/DC4i/DC4midand\nmid<j/DC4high.\nmaximum subarray that crosses the midpoint, and take a subarray with the largest\nsum of the three.\nWe can easily \ufb01nd a maximum subarray crossing the midpoint in time linear\nin the size of the subarray A\u0152low::high/c141. This problem is nota smaller instance\nof our original problem, because it has the added restriction that the subarray it\nchooses must cross the midpoint. As Figure 4.4(b) shows, any subarray crossingthe midpoint is itself made of two subarrays A\u0152i : : mid/c141andA\u0152midC1::j/c141 ,w h e r e\nlow/DC4i/DC4midandmid<j/DC4high. Therefore, we just need to \ufb01nd maximum\nsubarrays of the form A\u0152i : : mid/c141andA\u0152midC1::j/c141 and then combine them. The\nprocedure F\nIND-MAX-CROSSING -SUBARRAY takes as input the array Aand the\nindices low,mid,a n d high, and it returns a tuple containing the indices demarcating\na maximum subarray that crosses the midpoint, along with the sum of the values ina maximum subarray.\nF\nIND-MAX-CROSSING -SUBARRAY .A;low;mid;high/\n1left-sumD/NUL1\n2sumD0\n3foriDmiddownto low\n4 sumDsumCA\u0152i/c141\n5 ifsum>left-sum\n6 left-sumDsum\n7 max-leftDi\n8right -sumD/NUL1\n9sumD0\n10forjDmidC1tohigh\n11 sumDsumCA\u0152j /c141\n12 ifsum>right -sum\n13 right -sumDsum\n14 max-rightDj\n15return .max-left;max-right;left-sumCright -sum/", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "92": {"page_number": 93, "page_information": "72 Chapter 4 Divide-and-Conquer\nThis procedure works as follows. Lines 1\u20137 \ufb01nd a maximum subarray of the\nleft half, A\u0152low::mid/c141. Since this subarray must contain A\u0152mid/c141,t h eforloop of\nlines 3\u20137 starts the index iatmidand works down to low, so that every subarray\nit considers is of the form A\u0152i : : mid/c141. Lines 1\u20132 initialize the variables left-sum,\nwhich holds the greatest sum found so far, and sum, holding the sum of the entries\ninA\u0152i : : mid/c141. Whenever we \ufb01nd, in line 5, a subarray A\u0152i : : mid/c141with a sum of\nvalues greater than left-sum, we update left-sumto this subarray\u2019s sum in line 6, and\nin line 7 we update the variable max-leftto record this index i. Lines 8\u201314 work\nanalogously for the right half, A\u0152midC1::high/c141. Here, the forloop of lines 10\u201314\nstarts the index jatmidC1and works up to high, so that every subarray it considers\nis of the form A\u0152midC1::j/c141 . Finally, line 15 returns the indices max-leftand\nmax-right that demarcate a maximum subarray crossing the midpoint, along with\nthe sum left-sumCright -sumof the values in the subarray A\u0152max-left::max-right/c141.\nIf the subarray A\u0152low::high/c141contains nentries (so that nDhigh/NULlowC1),\nwe claim that the call F IND-MAX-CROSSING -SUBARRAY .A;low;mid;high/\ntakes \u201a.n/ time. Since each iteration of each of the two forloops takes \u201a.1/\ntime, we just need to count up how many iterations there are altogether. The for\nloop of lines 3\u20137 makes mid/NULlowC1iterations, and the forloop of lines 10\u201314\nmakes high/NULmiditerations, and so the total number of iterations is\n.mid/NULlowC1/C.high/NULmid/Dhigh/NULlowC1\nDn:\nWith a linear-time F IND-MAX-CROSSING -SUBARRAY procedure in hand, we\ncan write pseudocode for a divide-and-conquer algorithm to solve the maximum-subarray problem:\nF\nIND-MAXIMUM -SUBARRAY .A;low;high/\n1ifhigh ==low\n2 return .low;high;A \u0152low/c141/ //base case: only one element\n3elsemidDb.lowChigh/=2c\n4 .left-low;left-high;left-sum/D\nFIND-MAXIMUM -SUBARRAY .A;low;mid/\n5 .right -low;right -high;right -sum/D\nFIND-MAXIMUM -SUBARRAY .A;midC1;high/\n6 .cross -low;cross -high;cross -sum/D\nFIND-MAX-CROSSING -SUBARRAY .A;low;mid;high/\n7 ifleft-sum/NAKright -sum andleft-sum/NAKcross -sum\n8 return .left-low;left-high;left-sum/\n9 elseif right -sum/NAKleft-sumandright -sum/NAKcross -sum\n10 return .right -low;right -high;right -sum/\n11 else return .cross -low;cross -high;cross -sum/", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "93": {"page_number": 94, "page_information": "4.1 The maximum-subarray problem 73\nThe initial call F IND-MAXIMUM -SUBARRAY . A ;1 ;A: length /will \ufb01nd a maxi-\nmum subarray of A\u01521 : : n/c141 .\nSimilar to F IND-MAX-CROSSING -SUBARRAY , the recursive procedure F IND-\nMAXIMUM -SUBARRAY returns a tuple containing the indices that demarcate a\nmaximum subarray, along with the sum of the values in a maximum subarray.Line 1 tests for the base case, where the subarray has just one element. A subar-ray with just one element has only one subarray\u2014itself\u2014and so line 2 returns atuple with the starting and ending indices of just the one element, along with its\nvalue. Lines 3\u201311 handle the recursive case. Line 3 does the divide part, comput-\ning the index midof the midpoint. Let\u2019s refer to the subarray A\u0152low::mid/c141as the\nleft subarray and to A\u0152midC1::high/c141as the right subarray . Because we know\nthat the subarray A\u0152low::high/c141contains at least two elements, each of the left and\nright subarrays must have at least one element. Lines 4 and 5 conquer by recur-sively \ufb01nding maximum subarrays within the left and right subarrays, respectively.Lines 6\u201311 form the combine part. Line 6 \ufb01nds a maximum subarray that crossesthe midpoint. (Recall that because line 6 solves a subproblem that is not a smallerinstance of the original problem, we consider it to be in the combine part.) Line 7tests whether the left subarray contains a subarray with the maximum sum, andline 8 returns that maximum subarray. Otherwise, line 9 tests whether the rightsubarray contains a subarray with the maximum sum, and line 10 returns that max-imum subarray. If neither the left nor right subarrays contain a subarray achievingthe maximum sum, then a maximum subarray must cross the midpoint, and line 11\nreturns it.\nAnalyzing the divide-and-conquer algorithm\nNext we set up a recurrence that describes the running time of the recursive F\nIND-\nMAXIMUM -SUBARRAY procedure. As we did when we analyzed merge sort in\nSection 2.3.2, we make the simplifying assumption that the original problem sizei sap o w e ro f 2, so that all subproblem sizes are integers. We denote by T .n/ the\nrunning time of F\nIND-MAXIMUM -SUBARRAY on a subarray of nelements. For\nstarters, line 1 takes constant time. The base case, when nD1, is easy: line 2\ntakes constant time, and so\nT. 1 /D\u201a.1/ : (4.5)\nThe recursive case occurs when n>1 . Lines 1 and 3 take constant time. Each\nof the subproblems solved in lines 4 and 5 is on a subarray of n=2 elements (our\nassumption that the original problem size is a power of 2ensures that n=2 is an\ninteger), and so we spend T .n=2/ time solving each of them. Because we have\nto solve two subproblems\u2014for the left subarray and for the right subarray\u2014the\ncontribution to the running time from lines 4 and 5 comes to 2T .n=2/ .A sw eh a v e", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "94": {"page_number": 95, "page_information": "74 Chapter 4 Divide-and-Conquer\nalready seen, the call to F IND-MAX-CROSSING -SUBARRAY in line 6 takes \u201a.n/\ntime. Lines 7\u201311 take only \u201a.1/ time. For the recursive case, therefore, we have\nT .n/D\u201a.1/C2T .n=2/C\u201a.n/C\u201a.1/\nD2T .n=2/C\u201a.n/ : (4.6)\nCombining equations (4.5) and (4.6) gives us a recurrence for the running\ntimeT .n/ of F IND-MAXIMUM -SUBARRAY :\nT .n/D(\n\u201a.1/ ifnD1;\n2T .n=2/C\u201a.n/ ifn>1:(4.7)\nThis recurrence is the same as recurrence (4.1) for merge sort. As we shall\nsee from the master method in Section 4.5, this recurrence has the solutionT .n/D\u201a.n lgn/. You might also revisit the recursion tree in Figure 2.5 to un-\nderstand why the solution should be T .n/D\u201a.n lgn/.\nThus, we see that the divide-and-conquer method yields an algorithm that is\nasymptotically faster than the brute-force method. With merge sort and now themaximum-subarray problem, we begin to get an idea of how powerful the divide-and-conquer method can be. Sometimes it will yield the asymptotically fastestalgorithm for a problem, and other times we can do even better. As Exercise 4.1-5shows, there is in fact a linear-time algorithm for the maximum-subarray problem,and it does not use divide-and-conquer.\nExercises\n4.1-1\nWhat does F\nIND-MAXIMUM -SUBARRAY return when all elements of Aare nega-\ntive?\n4.1-2\nWrite pseudocode for the brute-force method of solving the maximum-subarrayproblem. Your procedure should run in \u201a.n\n2/time.\n4.1-3\nImplement both the brute-force and recursive algorithms for the maximum-\nsubarray problem on your own computer. What problem size n0gives the crossover\npoint at which the recursive algorithm beats the brute-force algorithm? Then,change the base case of the recursive algorithm to use the brute-force algorithmwhenever the problem size is less than n\n0. Does that change the crossover point?\n4.1-4\nSuppose we change the de\ufb01nition of the maximum-subarray problem to allow theresult to be an empty subarray, where the sum of the values of an empty subar-", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "95": {"page_number": 96, "page_information": "4.2 Strassen\u2019s algorithm for matrix multiplication 75\nray is 0. How would you change any of the algorithms that do not allow empty\nsubarrays to permit an empty subarray to be the result?\n4.1-5\nUse the following ideas to develop a nonrecursive, linear-time algorithm for themaximum-subarray problem. Start at the left end of the array, and progress towardthe right, keeping track of the maximum subarray seen so far. Knowing a maximumsubarray of A\u01521 : : j /c141 , extend the answer to \ufb01nd a maximum subarray ending at in-\ndexjC1by using the following observation: a maximum subarray of A\u01521 : : jC1/c141\nis either a maximum subarray of A\u01521 : : j /c141 or a subarray A\u0152i : : jC1/c141,f o rs o m e\n1/DC4i/DC4jC1. Determine a maximum subarray of the form A\u0152i : : jC1/c141in\nconstant time based on knowing a maximum subarray ending at index j.\n4.2 Strassen\u2019s algorithm for matrix multiplication\nIf you have seen matrices before, then you probably know how to multiply them.\n(Otherwise, you should read Section D.1 in Appendix D.) If AD.aij/and\nBD.bij/are square n/STXnmatrices, then in the product CDA/SOHB,w ed e \ufb01 n et h e\nentry cij,f o ri;jD1 ;2;:::;n ,b y\ncijDnX\nkD1aik/SOHbkj: (4.8)\nWe must compute n2matrix entries, and each is the sum of nvalues. The following\nprocedure takes n/STXnmatrices AandBand multiplies them, returning their n/STXn\nproduct C. We assume that each matrix has an attribute rows , giving the number\nof rows in the matrix.\nSQUARE -MATRIX -MULTIPLY .A; B/\n1nDA:rows\n2l e t Cb ean e w n/STXnmatrix\n3foriD1ton\n4 forjD1ton\n5 cijD0\n6 forkD1ton\n7 cijDcijCaik/SOHbkj\n8return C\nThe S QUARE -MATRIX -MULTIPLY procedure works as follows. The forloop\nof lines 3\u20137 computes the entries of each row i, and within a given row i,t h e", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "96": {"page_number": 97, "page_information": "76 Chapter 4 Divide-and-Conquer\nforloop of lines 4\u20137 computes each of the entries cij, for each column j.L i n e5\ninitializes cijto0as we start computing the sum given in equation (4.8), and each\niteration of the forloop of lines 6\u20137 adds in one more term of equation (4.8).\nBecause each of the triply-nested forloops runs exactly niterations, and each\nexecution of line 7 takes constant time, the S QUARE -MATRIX -MULTIPLY proce-\ndure takes \u201a.n3/time.\nYou might at \ufb01rst think that any matrix multiplication algorithm must take /DEL.n3/\ntime, since the natural de\ufb01nition of matrix multiplication requires that many mul-\ntiplications. You would be incorrect, however: we have a way to multiply matrices\nino.n3/time. In this section, we shall see Strassen\u2019s remarkable recursive algo-\nrithm for multiplying n/STXnmatrices. It runs in \u201a.nlg7/time, which we shall show\nin Section 4.5. Since lg 7lies between 2:80 and2:81, Strassen\u2019s algorithm runs in\nO.n2:81/time, which is asymptotically better than the simple S QUARE -MATRIX -\nMULTIPLY procedure.\nA simple divide-and-conquer algorithm\nTo keep things simple, when we use a divide-and-conquer algorithm to compute\nthe matrix product CDA/SOHB, we assume that nis an exact power of 2in each of\nthen/STXnmatrices. We make this assumption because in each divide step, we will\ndivide n/STXnmatrices into four n=2/STXn=2matrices, and by assuming that nis an\nexact power of 2, we are guaranteed that as long as n/NAK2, the dimension n=2is an\ninteger.\nSuppose that we partition each of A,B,a n d Cinto four n=2/STXn=2matrices\nAD/DC2A11A12\nA21A22/DC3\n;BD/DC2B11B12\nB21B22/DC3\n;CD/DC2C11C12\nC21C22/DC3\n; (4.9)\nso that we rewrite the equation CDA/SOHBas\n/DC2C11C12\nC21C22/DC3\nD/DC2A11A12\nA21A22/DC3\n/SOH/DC2B11B12\nB21B22/DC3\n: (4.10)\nEquation (4.10) corresponds to the four equations\nC11DA11/SOHB11CA12/SOHB21; (4.11)\nC12DA11/SOHB12CA12/SOHB22; (4.12)\nC21DA21/SOHB11CA22/SOHB21; (4.13)\nC22DA21/SOHB12CA22/SOHB22: (4.14)\nEach of these four equations speci\ufb01es two multiplications of n=2/STXn=2 matrices\nand the addition of their n=2/STXn=2products. We can use these equations to create\na straightforward, recursive, divide-and-conquer algorithm:", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "97": {"page_number": 98, "page_information": "4.2 Strassen\u2019s algorithm for matrix multiplication 77\nSQUARE -MATRIX -MULTIPLY -RECURSIVE .A; B/\n1nDA:rows\n2l e t Cbe a new n/STXnmatrix\n3ifn==1\n4 c11Da11/SOHb11\n5elsepartition A,B,a n d Cas in equations (4.9)\n6 C11DSQUARE -MATRIX -MULTIPLY -RECURSIVE .A11;B11/\nCSQUARE -MATRIX -MULTIPLY -RECURSIVE .A12;B21/\n7 C12DSQUARE -MATRIX -MULTIPLY -RECURSIVE .A11;B12/\nCSQUARE -MATRIX -MULTIPLY -RECURSIVE .A12;B22/\n8 C21DSQUARE -MATRIX -MULTIPLY -RECURSIVE .A21;B11/\nCSQUARE -MATRIX -MULTIPLY -RECURSIVE .A22;B21/\n9 C22DSQUARE -MATRIX -MULTIPLY -RECURSIVE .A21;B12/\nCSQUARE -MATRIX -MULTIPLY -RECURSIVE .A22;B22/\n10return C\nThis pseudocode glosses over one subtle but important implementation detail.\nHow do we partition the matrices in line 5? If we were to create 12newn=2/STXn=2\nmatrices, we would spend \u201a.n2/time copying entries. In fact, we can partition\nthe matrices without copying entries. The trick is to use index calculations. Weidentify a submatrix by a range of row indices and a range of column indices ofthe original matrix. We end up representing a submatrix a little differently fromhow we represent the original matrix, which is the subtlety we are glossing over.The advantage is that, since we can specify submatrices by index calculations,executing line 5 takes only \u201a.1/ time (although we shall see that it makes no\ndifference asymptotically to the overall running time whether we copy or partition\nin place).\nNow, we derive a recurrence to characterize the running time of S\nQUARE -\nMATRIX -MULTIPLY -RECURSIVE .L e t T .n/ be the time to multiply two n/STXn\nmatrices using this procedure. In the base case, when nD1, we perform just the\none scalar multiplication in line 4, and so\nT. 1 /D\u201a.1/ : (4.15)\nThe recursive case occurs when n>1 . As discussed, partitioning the matrices in\nline 5 takes \u201a.1/ time, using index calculations. In lines 6\u20139, we recursively call\nSQUARE -MATRIX -MULTIPLY -RECURSIVE a total of eight times. Because each\nrecursive call multiplies two n=2/STXn=2matrices, thereby contributing T .n=2/ to\nthe overall running time, the time taken by all eight recursive calls is 8T .n=2/ .W e\nalso must account for the four matrix additions in lines 6\u20139. Each of these matricescontains n\n2=4entries, and so each of the four matrix additions takes \u201a.n2/time.\nSince the number of matrix additions is a constant, the total time spent adding ma-", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "98": {"page_number": 99, "page_information": "78 Chapter 4 Divide-and-Conquer\ntrices in lines 6\u20139 is \u201a.n2/. (Again, we use index calculations to place the results\nof the matrix additions into the correct positions of matrix C, with an overhead\nof\u201a.1/ time per entry.) The total time for the recursive case, therefore, is the sum\nof the partitioning time, the time for all the recursive calls, and the time to add thematrices resulting from the recursive calls:\nT .n/D\u201a.1/C8T .n=2/C\u201a.n\n2/\nD8T .n=2/C\u201a.n2/: (4.16)\nNotice that if we implemented partitioning by copying matrices, which would cost\n\u201a.n2/time, the recurrence would not change, and hence the overall running time\nwould increase by only a constant factor.\nCombining equations (4.15) and (4.16) gives us the recurrence for the running\ntime of S QUARE -MATRIX -MULTIPLY -RECURSIVE :\nT .n/D(\n\u201a.1/ ifnD1;\n8T .n=2/C\u201a.n2/ifn>1:(4.17)\nAs we shall see from the master method in Section 4.5, recurrence (4.17) has the\nsolution T .n/D\u201a.n3/. Thus, this simple divide-and-conquer approach is no\nfaster than the straightforward S QUARE -MATRIX -MULTIPLY procedure.\nBefore we continue on to examining Strassen\u2019s algorithm, let us review where\nthe components of equation (4.16) came from. Partitioning each n/STXnmatrix by\nindex calculation takes \u201a.1/ time, but we have two matrices to partition. Although\nyou could say that partitioning the two matrices takes \u201a.2/ time, the constant of 2\nis subsumed by the \u201a-notation. Adding two matrices, each with, say, kentries,\ntakes \u201a.k/ time. Since the matrices we add each have n2=4entries, you could\nsay that adding each pair takes \u201a.n2=4/time. Again, however, the \u201a-notation\nsubsumes the constant factor of 1=4, and we say that adding two n2=4/STXn2=4\nmatrices takes \u201a.n2/time. We have four such matrix additions, and once again,\ninstead of saying that they take \u201a.4n2/time, we say that they take \u201a.n2/time.\n(Of course, you might observe that we could say that the four matrix additionstake\u201a.4n\n2=4/time, and that 4n2=4Dn2, but the point here is that \u201a-notation\nsubsumes constant factors, whatever they are.) Thus, we end up with two termsof\u201a.n\n2/, which we can combine into one.\nWhen we account for the eight recursive calls, however, we cannot just sub-\nsume the constant factor of 8. In other words, we must say that together they take\n8T .n=2/ time, rather than just T .n=2/ time. You can get a feel for why by looking\nback at the recursion tree in Figure 2.5, for recurrence (2.1) (which is identical torecurrence (4.7)), with the recursive case T .n/D2T .n=2/C\u201a.n/ . The factor of 2\ndetermined how many children each tree node had, which in turn determined how\nmany terms contributed to the sum at each level of the tree. If we were to ignore", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "99": {"page_number": 100, "page_information": "4.2 Strassen\u2019s algorithm for matrix multiplication 79\nthe factor of 8in equation (4.16) or the factor of 2in recurrence (4.1), the recursion\ntree would just be linear, rather than \u201cbushy,\u201d and each level would contribute onlyone term to the sum.\nBear in mind, therefore, that although asymptotic notation subsumes constant\nmultiplicative factors, recursive notation such as T .n=2/ does not.\nStrassen\u2019s method\nThe key to Strassen\u2019s method is to make the recursion tree slightly less bushy. That\nis, instead of performing eight recursive multiplications of n=2/STXn=2 matrices,\nit performs only seven. The cost of eliminating one matrix multiplication will beseveral new additions of n=2/STXn=2 matrices, but still only a constant number of\nadditions. As before, the constant number of matrix additions will be subsumed\nby\u201a-notation when we set up the recurrence equation to characterize the running\ntime.\nStrassen\u2019s method is not at all obvious. (This might be the biggest understate-\nment in this book.) It has four steps:\n1. Divide the input matrices AandBand output matrix Cinton=2/STXn=2subma-\ntrices, as in equation (4.9). This step takes \u201a.1/ time by index calculation, just\nas in S\nQUARE -MATRIX -MULTIPLY -RECURSIVE .\n2. Create 10matrices S1;S2;:::;S 10, each of which is n=2/STXn=2and is the sum\nor difference of two matrices created in step 1. We can create all 10matrices in\n\u201a.n2/time.\n3. Using the submatrices created in step 1 and the 10matrices created in step 2,\nrecursively compute seven matrix products P1;P2;:::;P 7. Each matrix Piis\nn=2/STXn=2.\n4. Compute the desired submatrices C11;C12;C21;C22of the result matrix Cby\nadding and subtracting various combinations of the Pimatrices. We can com-\npute all four submatrices in \u201a.n2/time.\nWe shall see the details of steps 2\u20134 in a moment, but we already have enough\ninformation to set up a recurrence for the running time of Strassen\u2019s method. Let usassume that once the matrix size ngets down to 1, we perform a simple scalar mul-\ntiplication, just as in line 4 of S\nQUARE -MATRIX -MULTIPLY -RECURSIVE .W h e n\nn>1 , steps 1, 2, and 4 take a total of \u201a.n2/time, and step 3 requires us to per-\nform seven multiplications of n=2/STXn=2matrices. Hence, we obtain the following\nrecurrence for the running time T .n/ of Strassen\u2019s algorithm:\nT .n/D(\n\u201a.1/ ifnD1;\n7T .n=2/C\u201a.n2/ifn>1:(4.18)", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "100": {"page_number": 101, "page_information": "80 Chapter 4 Divide-and-Conquer\nWe have traded off one matrix multiplication for a constant number of matrix ad-\nditions. Once we understand recurrences and their solutions, we shall see that thistradeoff actually leads to a lower asymptotic running time. By the master methodin Section 4.5, recurrence (4.18) has the solution T .n/D\u201a.n\nlg7/.\nWe now proceed to describe the details. In step 2, we create the following 10\nmatrices:\nS1DB12/NULB22;\nS2DA11CA12;\nS3DA21CA22;\nS4DB21/NULB11;\nS5DA11CA22;\nS6DB11CB22;\nS7DA12/NULA22;\nS8DB21CB22;\nS9DA11/NULA21;\nS10DB11CB12:\nSince we must add or subtract n=2/STXn=2matrices 10times, this step does indeed\ntake\u201a.n2/time.\nIn step 3, we recursively multiply n=2/STXn=2matrices seven times to compute the\nfollowing n=2/STXn=2matrices, each of which is the sum or difference of products\nofAandBsubmatrices:\nP1DA11/SOHS1DA11/SOHB12/NULA11/SOHB22;\nP2DS2/SOHB22DA11/SOHB22CA12/SOHB22;\nP3DS3/SOHB11DA21/SOHB11CA22/SOHB11;\nP4DA22/SOHS4DA22/SOHB21/NULA22/SOHB11;\nP5DS5/SOHS6DA11/SOHB11CA11/SOHB22CA22/SOHB11CA22/SOHB22;\nP6DS7/SOHS8DA12/SOHB21CA12/SOHB22/NULA22/SOHB21/NULA22/SOHB22;\nP7DS9/SOHS10DA11/SOHB11CA11/SOHB12/NULA21/SOHB11/NULA21/SOHB12:\nNote that the only multiplications we need to perform are those in the middle col-\numn of the above equations. The right-hand column just shows what these productsequal in terms of the original submatrices created in step 1.\nStep 4 adds and subtracts the P\nimatrices created in step 3 to construct the four\nn=2/STXn=2submatrices of the product C. We start with\nC11DP5CP4/NULP2CP6:", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "101": {"page_number": 102, "page_information": "4.2 Strassen\u2019s algorithm for matrix multiplication 81\nExpanding out the right-hand side, with the expansion of each Pion its own line\nand vertically aligning terms that cancel out, we see that C11equals\nA11/SOHB11CA11/SOHB22CA22/SOHB11CA22/SOHB22\n/NULA22/SOHB11CA22/SOHB21\n/NULA11/SOHB22 /NULA12/SOHB22\n/NULA22/SOHB22/NULA22/SOHB21CA12/SOHB22CA12/SOHB21\nA11/SOHB11 CA12/SOHB21;\nwhich corresponds to equation (4.11).\nSimilarly, we set\nC12DP1CP2;\nand so C12equals\nA11/SOHB12/NULA11/SOHB22\nCA11/SOHB22CA12/SOHB22\nA11/SOHB12CA12/SOHB22;\ncorresponding to equation (4.12).\nSetting\nC21DP3CP4\nmakes C21equal\nA21/SOHB11CA22/SOHB11\n/NULA22/SOHB11CA22/SOHB21\nA21/SOHB11CA22/SOHB21;\ncorresponding to equation (4.13).\nFinally, we set\nC22DP5CP1/NULP3/NULP7;\nso that C22equals\nA11/SOHB11CA11/SOHB22CA22/SOHB11CA22/SOHB22\n/NULA11/SOHB22 CA11/SOHB12\n/NULA22/SOHB11 /NULA21/SOHB11\n/NULA11/SOHB11 /NULA11/SOHB12CA21/SOHB11CA21/SOHB12\nA22/SOHB22 CA21/SOHB12;", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "102": {"page_number": 103, "page_information": "82 Chapter 4 Divide-and-Conquer\nwhich corresponds to equation (4.14). Altogether, we add or subtract n=2/STXn=2\nmatrices eight times in step 4, and so this step indeed takes \u201a.n2/time.\nThus, we see that Strassen\u2019s algorithm, comprising steps 1\u20134, produces the cor-\nrect matrix product and that recurrence (4.18) characterizes its running time. Sincewe shall see in Section 4.5 that this recurrence has the solution T .n/D\u201a.n\nlg7/,\nStrassen\u2019s method is asymptotically faster than the straightforward S QUARE -\nMATRIX -MULTIPLY procedure. The notes at the end of this chapter discuss some\nof the practical aspects of Strassen\u2019s algorithm.\nExercises\nNote: Although Exercises 4.2-3, 4.2-4, and 4.2-5 are about variants on Strassen\u2019s\nalgorithm, you should read Section 4.5 before trying to solve them.\n4.2-1\nUse Strassen\u2019s algorithm to compute the matrix product\n/DC213\n75/DC3/DC268\n42/DC3\n:\nShow your work.\n4.2-2\nWrite pseudocode for Strassen\u2019s algorithm.\n4.2-3\nHow would you modify Strassen\u2019s algorithm to multiply n/STXnmatrices in which n\nis not an exact power of 2? Show that the resulting algorithm runs in time \u201a.nlg7/.\n4.2-4\nWhat is the largest ksuch that if you can multiply 3/STX3matrices using kmulti-\nplications (not assuming commutativity of multiplication), then you can multiplyn/STXnmatrices in time o.n\nlg7/? What would the running time of this algorithm be?\n4.2-5\nV. Pan has discovered a way of multiplying 68/STX68matrices using 132,464 mul-\ntiplications, a way of multiplying 70/STX70matrices using 143,640 multiplications,\nand a way of multiplying 72/STX72matrices using 155,424 multiplications. Which\nmethod yields the best asymptotic running time when used in a divide-and-conquer\nmatrix-multiplication algorithm? How does it compare to Strassen\u2019s algorithm?", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "103": {"page_number": 104, "page_information": "4.3 The substitution method for solving recurrences 83\n4.2-6\nHow quickly can you multiply a kn/STXnmatrix by an n/STXknmatrix, using Strassen\u2019s\nalgorithm as a subroutine? Answer the same question with the order of the inputmatrices reversed.\n4.2-7\nShow how to multiply the complex numbers aCbiandcCdiusing only three\nmultiplications of real numbers. The algorithm should take a,b,c,a n d das input\nand produce the real component ac/NULbdand the imaginary component adCbc\nseparately.\n4.3 The substitution method for solving recurrences\nNow that we have seen how recurrences characterize the running times of divide-\nand-conquer algorithms, we will learn how to solve recurrences. We start in thissection with the \u201csubstitution\u201d method.\nThesubstitution method for solving recurrences comprises two steps:\n1. Guess the form of the solution.\n2. Use mathematical induction to \ufb01nd the constants and show that the solution\nworks.\nWe substitute the guessed solution for the function when applying the inductive\nhypothesis to smaller values; hence the name \u201csubstitution method.\u201d This methodis powerful, but we must be able to guess the form of the answer in order to apply it.\nWe can use the substitution method to establish either upper or lower bounds on\na recurrence. As an example, let us determine an upper bound on the recurrence\nT .n/D2T .bn=2c/Cn; (4.19)\nwhich is similar to recurrences (4.3) and (4.4). We guess that the solution is\nT .n/DO.n lgn/. The substitution method requires us to prove that T .n//DC4\ncnlgnfor an appropriate choice of the constant c>0 . We start by assuming\nthat this bound holds for all positive m<n , in particular for mDbn=2c, yielding\nT.bn=2c//DC4cbn=2clg.bn=2c/. Substituting into the recurrence yields\nT .n//DC42.cbn=2clg.bn=2c//Cn\n/DC4cnlg.n=2/Cn\nDcnlgn/NULcnlg2Cn\nDcnlgn/NULcnCn\n/DC4cnlgn;", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "104": {"page_number": 105, "page_information": "84 Chapter 4 Divide-and-Conquer\nwhere the last step holds as long as c/NAK1.\nMathematical induction now requires us to show that our solution holds for the\nboundary conditions. Typically, we do so by showing that the boundary condi-tions are suitable as base cases for the inductive proof. For the recurrence (4.19),we must show that we can choose the constant clarge enough so that the bound\nT .n//DC4cnlgnworks for the boundary conditions as well. This requirement\ncan sometimes lead to problems. Let us assume, for the sake of argument, thatT. 1 /D1is the sole boundary condition of the recurrence. Then for nD1,t h e\nbound T .n//DC4cnlgnyields T. 1 //DC4c1lg1D0, which is at odds with T. 1 /D1.\nConsequently, the base case of our inductive proof fails to hold.\nWe can overcome this obstacle in proving an inductive hypothesis for a spe-\nci\ufb01c boundary condition with only a little more effort. In the recurrence (4.19),for example, we take advantage of asymptotic notation requiring us only to proveT .n//DC4cnlgnforn/NAKn\n0,w h e r e n0is a constant that we get to choose .W e\nkeep the troublesome boundary condition T. 1 /D1, but remove it from consid-\neration in the inductive proof. We do so by \ufb01rst observing that for n>3 ,t h e\nrecurrence does not depend directly on T. 1 / . Thus, we can replace T. 1 / byT. 2 /\nandT. 3 / as the base cases in the inductive proof, letting n0D2. Note that we\nmake a distinction between the base case of the recurrence ( nD1) and the base\ncases of the inductive proof ( nD2andnD3). With T. 1 /D1, we derive from\nthe recurrence that T. 2 /D4andT. 3 /D5. Now we can complete the inductive\nproof that T .n//DC4cnlgnfor some constant c/NAK1by choosing clarge enough\nso that T. 2 //DC4c2lg2andT. 3 //DC4c3lg3. As it turns out, any choice of c/NAK2\nsuf\ufb01ces for the base cases of nD2andnD3to hold. For most of the recurrences\nwe shall examine, it is straightforward to extend boundary conditions to make theinductive assumption work for small n, and we shall not always explicitly work out\nthe details.\nMaking a good guess\nUnfortunately, there is no general way to guess the correct solutions to recurrences.\nGuessing a solution takes experience and, occasionally, creativity. Fortunately,though, you can use some heuristics to help you become a good guesser. Youcan also use recursion trees, which we shall see in Section 4.4, to generate goodguesses.\nIf a recurrence is similar to one you have seen before, then guessing a similar\nsolution is reasonable. As an example, consider the recurrence\nT .n/D2T .bn=2cC17/Cn;\nwhich looks dif\ufb01cult because of the added \u201c 17\u201d in the argument to Ton the right-\nhand side. Intuitively, however, this additional term cannot substantially affect the", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "105": {"page_number": 106, "page_information": "4.3 The substitution method for solving recurrences 85\nsolution to the recurrence. When nis large, the difference between bn=2cand\nbn=2cC17is not that large: both cut nnearly evenly in half. Consequently, we\nmake the guess that T .n/DO.n lgn/, which you can verify as correct by using\nthe substitution method (see Exercise 4.3-6).\nAnother way to make a good guess is to prove loose upper and lower bounds on\nthe recurrence and then reduce the range of uncertainty. For example, we mightstart with a lower bound of T .n/D/DEL.n/ for the recurrence (4.19), since we\nhave the term nin the recurrence, and we can prove an initial upper bound of\nT .n/DO.n\n2/. Then, we can gradually lower the upper bound and raise the\nlower bound until we converge on the correct, asymptotically tight solution ofT .n/D\u201a.n lgn/.\nSubtleties\nSometimes you might correctly guess an asymptotic bound on the solution of a\nrecurrence, but somehow the math fails to work out in the induction. The problemfrequently turns out to be that the inductive assumption is not strong enough toprove the detailed bound. If you revise the guess by subtracting a lower-order termwhen you hit such a snag, the math often goes through.\nConsider the recurrence\nT .n/DT.bn=2c/CT.dn=2e/C1:\nWe guess that the solution is T .n/DO.n/ , and we try to show that T .n//DC4cnfor\nan appropriate choice of the constant c. Substituting our guess in the recurrence,\nwe obtain\nT .n//DC4cbn=2cCcdn=2eC1\nDcnC1;\nwhich does not imply T .n//DC4cnfor any choice of c. We might be tempted to try\na larger guess, say T .n/DO.n\n2/. Although we can make this larger guess work,\nour original guess of T .n/DO.n/ is correct. In order to show that it is correct,\nhowever, we must make a stronger inductive hypothesis.\nIntuitively, our guess is nearly right: we are off only by the constant 1,a\nlower-order term. Nevertheless, mathematical induction does not work unless weprove the exact form of the inductive hypothesis. We overcome our dif\ufb01cultybysubtracting a lower-order term from our previous guess. Our new guess is\nT .n//DC4cn/NULd,w h e r e d/NAK0is a constant. We now have\nT .n//DC4.cbn=2c/NULd/C.cdn=2e/NULd/C1\nDcn/NUL2dC1\n/DC4cn/NULd;", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "106": {"page_number": 107, "page_information": "86 Chapter 4 Divide-and-Conquer\nas long as d/NAK1. As before, we must choose the constant clarge enough to handle\nthe boundary conditions.\nYou might \ufb01nd the idea of subtracting a lower-order term counterintuitive. Af-\nter all, if the math does not work out, we should increase our guess, right?Not necessarily! When proving an upper bound by induction, it may actually bemore dif\ufb01cult to prove that a weaker upper bound holds, because in order to provethe weaker bound, we must use the same weaker bound inductively in the proof.In our current example, when the recurrence has more than one recursive term, we\nget to subtract out the lower-order term of the proposed bound once per recursive\nterm. In the above example, we subtracted out the constant dtwice, once for the\nT.bn=2c/term and once for the T.dn=2e/term. We ended up with the inequality\nT .n//DC4cn/NUL2dC1, and it was easy to \ufb01nd values of dto make cn/NUL2dC1be\nless than or equal to cn/NULd.\nAvoiding pitfalls\nIt is easy to err in the use of asymptotic notation. For example, in the recur-\nrence (4.19) we can falsely \u201cprove\u201d T .n/DO.n/ by guessing T .n//DC4cnand\nthen arguing\nT .n//DC42.cbn=2c/Cn\n/DC4cnCn\nDO.n/ ;/c143 wrong!!\nsince cis a constant. The error is that we have not proved the exact form of the\ninductive hypothesis, that is, that T .n//DC4cn. We therefore will explicitly prove\nthatT .n//DC4cnwhen we want to show that T .n/DO.n/ .\nChanging variables\nSometimes, a little algebraic manipulation can make an unknown recurrence simi-\nlar to one you have seen before. As an example, consider the recurrence\nT .n/D2T\n/NUL/EOTp\nn\u02d8/SOH\nClgn;\nwhich looks dif\ufb01cult. We can simplify this recurrence, though, with a change of\nvariables. For convenience, we shall not worry about rounding off values, suchasp\nn, to be integers. Renaming mDlgnyields\nT. 2m/D2T .2m=2/Cm:\nWe can now rename S.m/DT. 2m/to produce the new recurrence\nS.m/D2S.m=2/Cm;", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "107": {"page_number": 108, "page_information": "4.3 The substitution method for solving recurrences 87\nwhich is very much like recurrence (4.19). Indeed, this new recurrence has the\nsame solution: S.m/DO.m lgm/. Changing back from S.m/ toT .n/ , we obtain\nT .n/DT. 2m/DS.m/DO.m lgm/DO.lgnlg lgn/ :\nExercises\n4.3-1\nShow that the solution of T .n/DT. n/NUL1/CnisO.n2/.\n4.3-2\nShow that the solution of T .n/DT.dn=2e/C1isO.lgn/.\n4.3-3\nWe saw that the solution of T .n/D2T .bn=2c/CnisO.n lgn/. Show that the so-\nlution of this recurrence is also /DEL.n lgn/. Conclude that the solution is \u201a.n lgn/.\n4.3-4\nShow that by making a different inductive hypothesis, we can overcome the dif\ufb01-culty with the boundary condition T. 1 /D1for recurrence (4.19) without adjusting\nthe boundary conditions for the inductive proof.\n4.3-5\nShow that \u201a.n lgn/is the solution to the \u201cexact\u201d recurrence (4.3) for merge sort.\n4.3-6\nShow that the solution to T .n/D2T .bn=2cC17/CnisO.n lgn/.\n4.3-7\nUsing the master method in Section 4.5, you can show that the solution to therecurrence T .n/D4T .n=3/CnisT .n/D\u201a.n\nlog34/. Show that a substitution\nproof with the assumption T .n//DC4cnlog34fails. Then show how to subtract off a\nlower-order term to make a substitution proof work.\n4.3-8\nUsing the master method in Section 4.5, you can show that the solution to therecurrence T .n/D4T .n=2/Cn\n2isT .n/D\u201a.n2/. Show that a substitution\nproof with the assumption T .n//DC4cn2fails. Then show how to subtract off a\nlower-order term to make a substitution proof work.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "108": {"page_number": 109, "page_information": "88 Chapter 4 Divide-and-Conquer\n4.3-9\nSolve the recurrence T .n/D3T .p\nn/Clognby making a change of variables.\nYour solution should be asymptotically tight. Do not worry about whether valuesare integral.\n4.4 The recursion-tree method for solving recurrences\nAlthough you can use the substitution method to provide a succinct proof thata solution to a recurrence is correct, you might have trouble coming up with agood guess. Drawing out a recursion tree, as we did in our analysis of the mergesort recurrence in Section 2.3.2, serves as a straightforward way to devise a goodguess. In a recursion tree , each node represents the cost of a single subproblem\nsomewhere in the set of recursive function invocations. We sum the costs withineach level of the tree to obtain a set of per-level costs, and then we sum all theper-level costs to determine the total cost of all levels of the recursion.\nA recursion tree is best used to generate a good guess, which you can then verify\nby the substitution method. When using a recursion tree to generate a good guess,\nyou can often tolerate a small amount of \u201csloppiness,\u201d since you will be verifyingyour guess later on. If you are very careful when drawing out a recursion tree andsumming the costs, however, you can use a recursion tree as a direct proof of asolution to a recurrence. In this section, we will use recursion trees to generategood guesses, and in Section 4.6, we will use recursion trees directly to prove thetheorem that forms the basis of the master method.\nFor example, let us see how a recursion tree would provide a good guess for\nthe recurrence T .n/D3T .bn=4c/C\u201a.n\n2/. We start by focusing on \ufb01nding an\nupper bound for the solution. Because we know that \ufb02oors and ceilings usually donot matter when solving recurrences (here\u2019s an example of sloppiness that we cantolerate), we create a recursion tree for the recurrence T .n/D3T .n=4/Ccn\n2,\nhaving written out the implied constant coef\ufb01cient c>0 .\nFigure 4.5 shows how we derive the recursion tree for T .n/D3T .n=4/Ccn2.\nFor convenience, we assume that nis an exact power of 4(another example of\ntolerable sloppiness) so that all subproblem sizes are integers. Part (a) of the \ufb01gureshows T .n/ , which we expand in part (b) into an equivalent tree representing the\nrecurrence. The cn\n2term at the root represents the cost at the top level of recursion,\nand the three subtrees of the root represent the costs incurred by the subproblemsof size n=4. Part (c) shows this process carried one step further by expanding each\nnode with cost T .n=4/ from part (b). The cost for each of the three children of the\nroot is c.n=4/\n2. We continue expanding each node in the tree by breaking it into\nits constituent parts as determined by the recurrence.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "109": {"page_number": 110, "page_information": "4.4 The recursion-tree method for solving recurrences 89\n\u2026\n\u2026\n(d)(c) (b) (a)T .n/ cn2cn2\ncn2T/NULn\n4/SOH\nT/NULn\n4/SOH\nT/NULn\n4/SOH\nT/NULn\n16/SOH\nT/NULn\n16/SOH\nT/NULn\n16/SOH\nT/NULn\n16/SOH\nT/NULn\n16/SOH\nT/NULn\n16/SOH\nT/NULn\n16/SOH\nT/NULn\n16/SOH\nT/NULn\n16/SOH\ncn2c/NULn\n4/SOH2c/NULn\n4/SOH2c/NULn\n4/SOH2\nc/NULn\n4/SOH2c/NULn\n4/SOH2c/NULn\n4/SOH2\nc/NULn\n16/SOH2c/NULn\n16/SOH2c/NULn\n16/SOH2c/NULn\n16/SOH2c/NULn\n16/SOH2c/NULn\n16/SOH2c/NULn\n16/SOH2c/NULn\n16/SOH2c/NULn\n16/SOH23\n16cn2\n/NUL3\n16/SOH2cn2log4n\nnlog43T. 1 / T. 1 / T. 1 / T. 1 / T. 1 / T. 1 / T. 1 / T. 1 / T. 1 / T. 1 / T. 1 / T. 1 / T. 1 / \u201a.nlog43/\nTotal: O.n2/\nFigure 4.5 Constructing a recursion tree for the recurrence T .n/D3T .n=4/Ccn2.P a r t (a)\nshows T .n/ , which progressively expands in (b)\u2013(d) to form the recursion tree. The fully expanded\ntree in part (d) has height log4n(it has log4nC1levels).", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "110": {"page_number": 111, "page_information": "90 Chapter 4 Divide-and-Conquer\nBecause subproblem sizes decrease by a factor of 4each time we go down one\nlevel, we eventually must reach a boundary condition. How far from the root dowe reach one? The subproblem size for a node at depth iisn=4\ni. Thus, the\nsubproblem size hits nD1when n=4iD1or, equivalently, when iDlog4n.\nThus, the tree has log4nC1levels (at depths 0; 1; 2; : : : ; log4n).\nNext we determine the cost at each level of the tree. Each level has three times\nmore nodes than the level above, and so the number of nodes at depth iis3i.\nBecause subproblem sizes reduce by a factor of 4for each level we go down\nfrom the root, each node at depth i,f o r iD0; 1; 2; : : : ; log4n/NUL1,h a sac o s t\nofc.n=4i/2. Multiplying, we see that the total cost over all nodes at depth i,f o r\niD0; 1; 2; : : : ; log4n/NUL1,i s3ic.n=4i/2D.3=16/icn2. The bottom level, at\ndepth log4n,h a s 3log4nDnlog43nodes, each contributing cost T. 1 / , for a total\ncost of nlog43T. 1 / ,w h i c hi s \u201a.nlog43/, since we assume that T. 1 / is a constant.\nNow we add up the costs over all levels to determine the cost for the entire tree:\nT .n/Dcn2C3\n16cn2C/DC23\n16/DC32\ncn2C/SOH/SOH/SOHC/DC23\n16/DC3log4n/NUL1\ncn2C\u201a.nlog43/\nDlog4n/NUL1X\niD0/DC23\n16/DC3i\ncn2C\u201a.nlog43/\nD.3=16/log4n/NUL1\n.3=16//NUL1cn2C\u201a.nlog43/ (by equation (A.5)) :\nThis last formula looks somewhat messy until we realize that we can again take\nadvantage of small amounts of sloppiness and use an in\ufb01nite decreasing geometricseries as an upper bound. Backing up one step and applying equation (A.6), wehave\nT .n/D\nlog4n/NUL1X\niD0/DC23\n16/DC3i\ncn2C\u201a.nlog43/\n<1X\niD0/DC23\n16/DC3i\ncn2C\u201a.nlog43/\nD1\n1/NUL.3=16/cn2C\u201a.nlog43/\nD16\n13cn2C\u201a.nlog43/\nDO.n2/:\nThus, we have derived a guess of T .n/DO.n2/for our original recurrence\nT .n/D3T .bn=4c/C\u201a.n2/. In this example, the coef\ufb01cients of cn2form a\ndecreasing geometric series and, by equation (A.6), the sum of these coef\ufb01cients", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "111": {"page_number": 112, "page_information": "4.4 The recursion-tree method for solving recurrences 91\u2026\u2026cn\ncncncn\nc/NULn\n3/SOH\nc/NUL2n\n3/SOH\nc/NULn\n9/SOH\nc/NUL2n\n9/SOH\nc/NUL2n\n9/SOH\nc/NUL4n\n9/SOHlog3=2n\nTotal: O.n lgn/\nFigure 4.6 A recursion tree for the recurrence T. n /DT .n=3/CT .2n=3/Ccn.\nis bounded from above by the constant 16=13 . Since the root\u2019s contribution to the\ntotal cost is cn2, the root contributes a constant fraction of the total cost. In other\nwords, the cost of the root dominates the total cost of the tree.\nIn fact, if O.n2/is indeed an upper bound for the recurrence (as we shall verify in\na moment), then it must be a tight bound. Why? The \ufb01rst recursive call contributesac o s to f \u201a.n\n2/,a n ds o /DEL.n2/must be a lower bound for the recurrence.\nNow we can use the substitution method to verify that our guess was cor-\nrect, that is, T .n/DO.n2/is an upper bound for the recurrence T .n/D\n3T .bn=4c/C\u201a.n2/. We want to show that T .n//DC4dn2for some constant d>0 .\nUsing the same constant c>0 as before, we have\nT .n//DC43T .bn=4c/Ccn2\n/DC43dbn=4c2Ccn2\n/DC43d.n=4/2Ccn2\nD3\n16dn2Ccn2\n/DC4dn2;\nwhere the last step holds as long as d/NAK.16=13/c .\nIn another, more intricate, example, Figure 4.6 shows the recursion tree for\nT .n/DT .n=3/CT .2n=3/CO.n/ :\n(Again, we omit \ufb02oor and ceiling functions for simplicity.) As before, we let c\nrepresent the constant factor in the O.n/ term. When we add the values across the\nlevels of the recursion tree shown in the \ufb01gure, we get a value of cnfor every level.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "112": {"page_number": 113, "page_information": "92 Chapter 4 Divide-and-Conquer\nThe longest simple path from the root to a leaf is n!.2=3/n!.2=3/2n!\n/SOH/SOH/SOH! 1.S i n c e .2=3/knD1when kDlog3=2n, the height of the tree is log3=2n.\nIntuitively, we expect the solution to the recurrence to be at most the number\nof levels times the cost of each level, or O.cn log3=2n/DO.n lgn/. Figure 4.6\nshows only the top levels of the recursion tree, however, and not every level in thetree contributes a cost of cn. Consider the cost of the leaves. If this recursion tree\nwere a complete binary tree of height log\n3=2n, there would be 2log3=2nDnlog3=22\nleaves. Since the cost of each leaf is a constant, the total cost of all leaves would\nthen be \u201a.nlog3=22/which, since log3=22is a constant strictly greater than 1,\nis!.nlgn/. This recursion tree is not a complete binary tree, however, and so\nit has fewer than nlog3=22leaves. Moreover, as we go down from the root, more\nand more internal nodes are absent. Consequently, levels toward the bottom of therecursion tree contribute less than cnto the total cost. We could work out an accu-\nrate accounting of all costs, but remember that we are just trying to come up with aguess to use in the substitution method. Let us tolerate the sloppiness and attemptto show that a guess of O.n lgn/for the upper bound is correct.\nIndeed, we can use the substitution method to verify that O.n lgn/is an upper\nbound for the solution to the recurrence. We show that T .n//DC4dnlgn,w h e r e dis\na suitable positive constant. We have\nT .n//DC4T .n=3/CT .2n=3/Ccn\n/DC4d.n=3/ lg.n=3/Cd.2n=3/ lg.2n=3/Ccn\nD.d.n=3/ lgn/NULd.n=3/ lg3/\nC.d.2n=3/ lgn/NULd.2n=3/ lg.3=2//Ccn\nDdnlgn/NULd..n=3/ lg3C.2n=3/ lg.3=2//Ccn\nDdnlgn/NULd..n=3/ lg3C.2n=3/ lg3/NUL.2n=3/ lg2/Ccn\nDdnlgn/NULdn.lg3/NUL2=3/\nCcn\n/DC4dnlgn;\nas long as d/NAKc=.lg3/NUL.2=3// . Thus, we did not need to perform a more accurate\naccounting of costs in the recursion tree.\nExercises\n4.4-1\nUse a recursion tree to determine a good asymptotic upper bound on the recurrenceT .n/D3T .bn=2c/Cn. Use the substitution method to verify your answer.\n4.4-2\nUse a recursion tree to determine a good asymptotic upper bound on the recurrenceT\n.n/DT.n=2/Cn2. Use the substitution method to verify your answer.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "113": {"page_number": 114, "page_information": "4.5 The master method for solving recurrences 93\n4.4-3\nUse a recursion tree to determine a good asymptotic upper bound on the recurrenceT .n/D4T .n=2C2/Cn. Use the substitution method to verify your answer.\n4.4-4\nUse a recursion tree to determine a good asymptotic upper bound on the recurrenceT .n/D2T .n/NUL1/C1. Use the substitution method to verify your answer.\n4.4-5\nUse a recursion tree to determine a good asymptotic upper bound on the recurrence\nT .n/DT. n/NUL1/CT .n=2/Cn. Use the substitution method to verify your answer.\n4.4-6\nArgue that the solution to the recurrence T .n/DT .n=3/CT .2n=3/Ccn,w h e r e c\nis a constant, is /DEL.n lgn/by appealing to a recursion tree.\n4.4-7\nDraw the recursion tree for T .n/D4T .bn=2c/Ccn,w h e r e cis a constant, and\nprovide a tight asymptotic bound on its solution. Verify your bound by the substi-tution method.\n4.4-8\nUse a recursion tree to give an asymptotically tight solution to the recurrenceT .n/DT. n/NULa/CT. a/Ccn,w h e r e a/NAK1andc>0 are constants.\n4.4-9\nUse a recursion tree to give an asymptotically tight solution to the recurrenceT .n/DT. \u02dbn /CT ..1/NUL\u02db/n/Ccn,w h e r e \u02dbis a constant in the range 0<\u02db<1\nandc>0 is also a constant.\n4.5 The master method for solving recurrences\nThe master method provides a \u201ccookbook\u201d method for solving recurrences of the\nform\nT .n/DaT .n=b/Cf .n/ ; (4.20)\nwhere a/NAK1andb>1 are constants and f .n/ is an asymptotically positive\nfunction. To use the master method, you will need to memorize three cases, butthen you will be able to solve many recurrences quite easily, often without penciland paper.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "114": {"page_number": 115, "page_information": "94 Chapter 4 Divide-and-Conquer\nThe recurrence (4.20) describes the running time of an algorithm that divides a\nproblem of size nintoasubproblems, each of size n=b,w h e r e aandbare positive\nconstants. The asubproblems are solved recursively, each in time T .n=b/ .T h e\nfunction f .n/ encompasses the cost of dividing the problem and combining the\nresults of the subproblems. For example, the recurrence arising from Strassen\u2019salgorithm has aD7,bD2,a n d f .n/D\u201a.n\n2/.\nAs a matter of technical correctness, the recurrence is not actually well de\ufb01ned,\nbecause n=b might not be an integer. Replacing each of the aterms T .n=b/ with\neither T.bn=bc/orT.dn=be/will not affect the asymptotic behavior of the recur-\nrence, however. (We will prove this assertion in the next section.) We normally\ufb01nd it convenient, therefore, to omit the \ufb02oor and ceiling functions when writingdivide-and-conquer recurrences of this form.\nThe master theorem\nThe master method depends on the following theorem.\nTheorem 4.1 (Master theorem)\nLeta/NAK1andb>1 be constants, let f .n/ be a function, and let T .n/ be de\ufb01ned\non the nonnegative integers by the recurrence\nT .n/DaT .n=b/Cf .n/ ;\nwhere we interpret n=bto mean eitherbn=bcordn=be.T h e n T .n/ has the follow-\ning asymptotic bounds:\n1. If f .n/DO.n\nlogba/NUL/SI/for some constant /SI>0 ,t h e n T .n/D\u201a.nlogba/.\n2. If f .n/D\u201a.nlogba/,t h e n T .n/D\u201a.nlogbalgn/.\n3. If f .n/D/DEL.nlogbaC/SI/for some constant /SI>0 ,a n di f af .n=b//DC4cf .n/ for\nsome constant c<1 and all suf\ufb01ciently large n,t h e n T .n/D\u201a.f .n// .\nBefore applying the master theorem to some examples, let\u2019s spend a moment\ntrying to understand what it says. In each of the three cases, we compare the\nfunction f .n/ with the function nlogba. Intuitively, the larger of the two functions\ndetermines the solution to the recurrence. If, as in case 1, the function nlogbais the\nlarger, then the solution is T .n/D\u201a.nlogba/. If, as in case 3, the function f .n/\nis the larger, then the solution is T .n/D\u201a.f .n// . If, as in case 2, the two func-\ntions are the same size, we multiply by a logarithmic factor, and the solution isT .n/D\u201a.n\nlogbalgn/D\u201a.f .n/ lgn/.\nBeyond this intuition, you need to be aware of some technicalities. In the \ufb01rst\ncase, not only must f .n/ be smaller than nlogba,i tm u s tb e polynomially smaller.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "115": {"page_number": 116, "page_information": "4.5 The master method for solving recurrences 95\nThat is, f .n/ must be asymptotically smaller than nlogbaby a factor of n/SIfor some\nconstant /SI>0 . In the third case, not only must f .n/ be larger than nlogba,i ta l s o\nmust be polynomially larger and in addition satisfy the \u201cregularity\u201d condition thataf .n=b//DC4cf .n/ . This condition is satis\ufb01ed by most of the polynomially bounded\nfunctions that we shall encounter.\nNote that the three cases do not cover all the possibilities for f .n/ . There is\na gap between cases 1 and 2 when f .n/ is smaller than n\nlogbabut not polynomi-\nally smaller. Similarly, there is a gap between cases 2 and 3 when f .n/ is larger\nthannlogbabut not polynomially larger. If the function f .n/ falls into one of these\ngaps, or if the regularity condition in case 3 fails to hold, you cannot use the mastermethod to solve the recurrence.\nUsing the master method\nTo use the master method, we simply determine which case (if any) of the master\ntheorem applies and write down the answer.\nAs a \ufb01rst example, consider\nT .n/D9T .n=3/Cn:\nFor this recurrence, we have aD9,bD3,f .n/Dn, and thus we have that\nn\nlogbaDnlog39D\u201a.n2). Since f .n/DO.nlog39/NUL/SI/,w h e r e /SID1, we can apply\ncase 1 of the master theorem and conclude that the solution is T .n/D\u201a.n2/.\nNow consider\nT .n/DT .2n=3/C1;\nin which aD1,bD3=2,f .n/D1,a n d nlogbaDnlog3=21Dn0D1. Case 2\napplies, since f .n/D\u201a.nlogba/D\u201a.1/ , and thus the solution to the recurrence\nisT .n/D\u201a.lgn/.\nFor the recurrence\nT .n/D3T .n=4/Cnlgn;\nwe have aD3,bD4,f .n/Dnlgn,a n d nlogbaDnlog43DO.n0:793/.\nSince f .n/D/DEL.nlog43C/SI/,w h e r e /SI/EM0:2, case 3 applies if we can show that\nthe regularity condition holds for f .n/ . For suf\ufb01ciently large n,w eh a v et h a t\naf .n=b/D3.n=4/ lg.n=4//DC4.3=4/n lgnDcf .n/ forcD3=4. Consequently,\nby case 3, the solution to the recurrence is T .n/D\u201a.n lgn/.\nThe master method does not apply to the recurrence\nT .n/D2T .n=2/Cnlgn;\neven though it appears to have the proper form: aD2,bD2,f .n/Dnlgn,\nandnlogbaDn. You might mistakenly think that case 3 should apply, since", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "116": {"page_number": 117, "page_information": "96 Chapter 4 Divide-and-Conquer\nf .n/Dnlgnis asymptotically larger than nlogbaDn. The problem is that it\nis not polynomially larger. The ratio f .n/=nlogbaD.nlgn/=nDlgnis asymp-\ntotically less than n/SIfor any positive constant /SI. Consequently, the recurrence falls\ninto the gap between case 2 and case 3. (See Exercise 4.6-2 for a solution.)\nLet\u2019s use the master method to solve the recurrences we saw in Sections 4.1\nand 4.2. Recurrence (4.7),\nT .n/D2T .n=2/C\u201a.n/ ;\ncharacterizes the running times of the divide-and-conquer algorithm for both the\nmaximum-subarray problem and merge sort. (As is our practice, we omit statingthe base case in the recurrence.) Here, we have aD2,bD2,f .n/D\u201a.n/ ,a n d\nthus we have that n\nlogbaDnlog22Dn. Case 2 applies, since f .n/D\u201a.n/ ,a n ds o\nwe have the solution T .n/D\u201a.n lgn/.\nRecurrence (4.17),\nT .n/D8T .n=2/C\u201a.n2/;\ndescribes the running time of the \ufb01rst divide-and-conquer algorithm that we saw\nfor matrix multiplication. Now we have aD8,bD2,a n d f .n/D\u201a.n2/,\nand so nlogbaDnlog28Dn3.S i n c e n3is polynomially larger than f .n/ (that is,\nf .n/DO.n3/NUL/SI/for/SID1), case 1 applies, and T .n/D\u201a.n3/.\nFinally, consider recurrence (4.18),\nT .n/D7T .n=2/C\u201a.n2/;\nwhich describes the running time of Strassen\u2019s algorithm. Here, we have aD7,\nbD2,f .n/D\u201a.n2/, and thus nlogbaDnlog27. Rewriting log27as lg 7and\nrecalling that 2:80 < lg7<2 : 8 1 , we see that f .n/DO.nlg7/NUL/SI/for/SID0:8.\nAgain, case 1 applies, and we have the solution T .n/D\u201a.nlg7/.\nExercises\n4.5-1\nUse the master method to give tight asymptotic bounds for the following recur-rences.\na.T .n/D2T .n=4/C1.\nb.T .n/D2T .n=4/Cp\nn.\nc.T .n/D2T .n=4/Cn.\nd.T .n/D2T .n=4/Cn2.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "117": {"page_number": 118, "page_information": "4.6 Proof of the master theorem 97\n4.5-2\nProfessor Caesar wishes to develop a matrix-multiplication algorithm that isasymptotically faster than Strassen\u2019s algorithm. His algorithm will use the divide-and-conquer method, dividing each matrix into pieces of size n=4/STXn=4,a n dt h e\ndivide and combine steps together will take \u201a.n\n2/time. He needs to determine\nhow many subproblems his algorithm has to create in order to beat Strassen\u2019s algo-rithm. If his algorithm creates asubproblems, then the recurrence for the running\ntimeT .n/ becomes T .n/DaT .n=4/C\u201a.n\n2/. What is the largest integer value\nofafor which Professor Caesar\u2019s algorithm would be asymptotically faster than\nStrassen\u2019s algorithm?\n4.5-3\nUse the master method to show that the solution to the binary-search recurrenceT .n/DT .n=2/C\u201a.1/ isT .n/D\u201a.lgn/. (See Exercise 2.3-5 for a description\nof binary search.)\n4.5-4\nCan the master method be applied to the recurrence T .n/D4T .n=2/Cn\n2lgn?\nWhy or why not? Give an asymptotic upper bound for this recurrence.\n4.5-5 ?\nConsider the regularity condition af .n=b//DC4cf .n/ for some constant c<1 ,\nwhich is part of case 3 of the master theorem. Give an example of constants a/NAK1\nandb>1 and a function f .n/ that satis\ufb01es all the conditions in case 3 of the\nmaster theorem except the regularity condition.\n?4.6 Proof of the master theorem\nThis section contains a proof of the master theorem (Theorem 4.1). You do notneed to understand the proof in order to apply the master theorem.\nThe proof appears in two parts. The \ufb01rst part analyzes the master recur-\nrence (4.20), under the simplifying assumption that T .n/ is de\ufb01ned only on ex-\nact powers of b>1 ,t h a ti s ,f o r nD1; b; b\n2;:::. This part gives all the intuition\nneeded to understand why the master theorem is true. The second part shows howto extend the analysis to all positive integers n; it applies mathematical technique\nto the problem of handling \ufb02oors and ceilings.\nIn this section, we shall sometimes abuse our asymptotic notation slightly by\nusing it to describe the behavior of functions that are de\ufb01ned only over exact\npowers of b. Recall that the de\ufb01nitions of asymptotic notations require that", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "118": {"page_number": 119, "page_information": "98 Chapter 4 Divide-and-Conquer\nbounds be proved for all suf\ufb01ciently large numbers, not just those that are pow-\ners of b. Since we could make new asymptotic notations that apply only to the set\nfbiWiD0; 1; 2; : : :g, instead of to the nonnegative numbers, this abuse is minor.\nNevertheless, we must always be on guard when we use asymptotic notation over\na limited domain lest we draw improper conclusions. For example, proving thatT .n/DO.n/ when nis an exact power of 2does not guarantee that T .n/DO.n/ .\nThe function T .n/ could be de\ufb01ned as\nT .n/D(\nn ifnD1;2;4;8;::: ;\nn\n2otherwise ;\nin which case the best upper bound that applies to all values of nisT .n/DO.n2/.\nBecause of this sort of drastic consequence, we shall never use asymptotic notationover a limited domain without making it absolutely clear from the context that weare doing so.\n4.6.1 The proof for exact powers\nThe \ufb01rst part of the proof of the master theorem analyzes the recurrence (4.20)\nT .n/DaT .n=b/Cf .n/ ;\nfor the master method, under the assumption that nis an exact power of b>1 ,\nwhere bneed not be an integer. We break the analysis into three lemmas. The \ufb01rst\nreduces the problem of solving the master recurrence to the problem of evaluatingan expression that contains a summation. The second determines bounds on thissummation. The third lemma puts the \ufb01rst two together to prove a version of themaster theorem for the case in which nis an exact power of b.\nLemma 4.2\nLeta/NAK1andb>1 be constants, and let f .n/ be a nonnegative function de\ufb01ned\non exact powers of b.D e \ufb01 n e T .n/ on exact powers of bby the recurrence\nT .n/D(\n\u201a.1/ ifnD1;\naT .n=b/Cf .n/ ifnDb\ni;\nwhere iis a positive integer. Then\nT .n/D\u201a.nlogba/Clogbn/NUL1X\njD0ajf .n=bj/: (4.21)\nProof We use the recursion tree in Figure 4.7. The root of the tree has cost f .n/ ,\nand it has achildren, each with cost f .n=b/ . (It is convenient to think of aas being", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "119": {"page_number": 120, "page_information": "4.6 Proof of the master theorem 99\n\u2026\u2026\n\u2026\n\u2026 \u2026 \u2026\u2026\n\u2026 \u2026 \u2026\u2026\n\u2026 \u2026 \u2026\n\u2026f .n/ f .n/\na a aa\na a aa\na a aaa\nf .n=b/ f .n=b/ f .n=b/\nf .n=b2/ f .n=b2/ f .n=b2/ f .n=b2/ f .n=b2/ f .n=b2/ f .n=b2/ f .n=b2/ f .n=b2/af .n=b/\na2f .n=b2/logbn\nnlogba\u201a.1/ \u201a.1/ \u201a.1/ \u201a.1/ \u201a.1/ \u201a.1/ \u201a.1/ \u201a.1/ \u201a.1/ \u201a.1/ \u201a.1/ \u201a.1/ \u201a.1/ \u201a.nlogba/\nTotal: \u201a.nlogba/Clogbn/NUL1X\njD0ajf .n=bj/\nFigure 4.7 The recursion tree generated by T .n/DaT .n=b/Cf .n/ . The tree is a complete a-ary\ntree with nlogbaleaves and height logbn. The cost of the nodes at each depth is shown at the right,\nand their sum is given in equation (4.21).\nan integer, especially when visualizing the recursion tree, but the mathematics does\nnot require it.) Each of these children has achildren, making a2nodes at depth 2,\nand each of the achildren has cost f .n=b2/. In general, there are ajnodes at\ndepth j, and each has cost f .n=bj/. The cost of each leaf is T. 1 /D\u201a.1/ ,a n d\neach leaf is at depth logbn,s i n c e n=blogbnD1.T h e r e a r e alogbnDnlogbaleaves\nin the tree.\nWe can obtain equation (4.21) by summing the costs of the nodes at each depth\nin the tree, as shown in the \ufb01gure. The cost for all internal nodes at depth jis\najf .n=bj/, and so the total cost of all internal nodes is\nlogbn/NUL1X\njD0ajf .n=bj/:\nIn the underlying divide-and-conquer algorithm, this sum represents the costs of\ndividing problems into subproblems and then recombining the subproblems. The", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "120": {"page_number": 121, "page_information": "100 Chapter 4 Divide-and-Conquer\ncost of all the leaves, which is the cost of doing all nlogbasubproblems of size 1,\nis\u201a.nlogba/.\nIn terms of the recursion tree, the three cases of the master theorem correspond\nto cases in which the total cost of the tree is (1) dominated by the costs in theleaves, (2) evenly distributed among the levels of the tree, or (3) dominated by thecost of the root.\nThe summation in equation (4.21) describes the cost of the dividing and com-\nbining steps in the underlying divide-and-conquer algorithm. The next lemma pro-vides asymptotic bounds on the summation\u2019s growth.\nLemma 4.3\nLeta/NAK1andb>1 be constants, and let f .n/ be a nonnegative function de\ufb01ned\non exact powers of b. A function g.n/ de\ufb01ned over exact powers of bby\ng.n/D\nlogbn/NUL1X\njD0ajf .n=bj/ (4.22)\nhas the following asymptotic bounds for exact powers of b:\n1. If f .n/DO.nlogba/NUL/SI/for some constant /SI>0 ,t h e n g.n/DO.nlogba/.\n2. If f .n/D\u201a.nlogba/,t h e n g.n/D\u201a.nlogbalgn/.\n3. If af .n=b//DC4cf .n/ for some constant c<1 and for all suf\ufb01ciently large n,\ntheng.n/D\u201a.f .n// .\nProof For case 1, we have f .n/DO.nlogba/NUL/SI/, which implies that f .n=bj/D\nO..n=bj/logba/NUL/SI/. Substituting into equation (4.22) yields\ng.n/DO logbn/NUL1X\njD0aj/DLEn\nbj/DC1logba/NUL/SI!\n: (4.23)\nWe bound the summation within the O-notation by factoring out terms and simpli-\nfying, which leaves an increasing geometric series:\nlogbn/NUL1X\njD0aj/DLEn\nbj/DC1logba/NUL/SI\nDnlogba/NUL/SIlogbn/NUL1X\njD0/DC2ab/SI\nblogba/DC3j\nDnlogba/NUL/SIlogbn/NUL1X\njD0.b/SI/j\nDnlogba/NUL/SI/DC2b/SIlogbn/NUL1\nb/SI/NUL1/DC3", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "121": {"page_number": 122, "page_information": "4.6 Proof of the master theorem 101\nDnlogba/NUL/SI/DC2n/SI/NUL1\nb/SI/NUL1/DC3\n:\nSince band/SIare constants, we can rewrite the last expression as nlogba/NUL/SIO.n/SI/D\nO.nlogba/. Substituting this expression for the summation in equation (4.23) yields\ng.n/DO.nlogba/;\nthereby proving case 1.\nBecause case 2 assumes that f .n/D\u201a.nlogba/,w eh a v et h a t f .n=bj/D\n\u201a..n=bj/logba/. Substituting into equation (4.22) yields\ng.n/D\u201a logbn/NUL1X\njD0aj/DLEn\nbj/DC1logba!\n: (4.24)\nWe bound the summation within the \u201a-notation as in case 1, but this time we do not\nobtain a geometric series. Instead, we discover that every term of the summation\nis the same:\nlogbn/NUL1X\njD0aj/DLEn\nbj/DC1logba\nDnlogbalogbn/NUL1X\njD0/DLEa\nblogba/DC1j\nDnlogbalogbn/NUL1X\njD01\nDnlogbalogbn:\nSubstituting this expression for the summation in equation (4.24) yieldsg.n/D\u201a.n\nlogbalogbn/\nD\u201a.nlogbalgn/ ;\nproving case 2.\nWe prove case 3 similarly. Since f .n/ appears in the de\ufb01nition (4.22) of g.n/\nand all terms of g.n/ are nonnegative, we can conclude that g.n/D/DEL.f .n// for\nexact powers of b. We assume in the statement of the lemma that af .n=b//DC4cf .n/\nfor some constant c<1 and all suf\ufb01ciently large n. We rewrite this assumption\nasf .n=b//DC4.c=a/f .n/ and iterate jtimes, yielding f .n=bj//DC4.c=a/jf .n/ or,\nequivalently, ajf .n=bj//DC4cjf .n/ , where we assume that the values we iterate\non are suf\ufb01ciently large. Since the last, and smallest, such value is n=bj/NUL1,i ti s\nenough to assume that n=bj/NUL1is suf\ufb01ciently large.\nSubstituting into equation (4.22) and simplifying yields a geometric series, but\nunlike the series in case 1, this one has decreasing terms. We use an O.1/ term to", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "122": {"page_number": 123, "page_information": "102 Chapter 4 Divide-and-Conquer\ncapture the terms that are not covered by our assumption that nis suf\ufb01ciently large:\ng.n/Dlogbn/NUL1X\njD0ajf .n=bj/\n/DC4logbn/NUL1X\njD0cjf .n/CO.1/\n/DC4f .n/1X\njD0cjCO.1/\nDf .n//DC21\n1/NULc/DC3\nCO.1/\nDO.f .n// ;\nsince cis a constant. Thus, we can conclude that g.n/D\u201a.f .n// for exact powers\nofb. With case 3 proved, the proof of the lemma is complete.\nWe can now prove a version of the master theorem for the case in which nis an\nexact power of b.\nLemma 4.4\nLeta/NAK1andb>1 be constants, and let f .n/ be a nonnegative function de\ufb01ned\non exact powers of b.D e \ufb01 n e T .n/ on exact powers of bby the recurrence\nT .n/D(\n\u201a.1/ ifnD1;\naT .n=b/Cf .n/ ifnDbi;\nwhere iis a positive integer. Then T .n/ has the following asymptotic bounds for\nexact powers of b:\n1. If f .n/DO.nlogba/NUL/SI/for some constant /SI>0 ,t h e n T .n/D\u201a.nlogba/.\n2. If f .n/D\u201a.nlogba/,t h e n T .n/D\u201a.nlogbalgn/.\n3. If f .n/D/DEL.nlogbaC/SI/for some constant /SI>0 ,a n di f af .n=b//DC4cf .n/ for\nsome constant c<1 and all suf\ufb01ciently large n,t h e n T .n/D\u201a.f .n// .\nProof We use the bounds in Lemma 4.3 to evaluate the summation (4.21) from\nLemma 4.2. For case 1, we have\nT .n/D\u201a.nlogba/CO.nlogba/\nD\u201a.nlogba/;", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "123": {"page_number": 124, "page_information": "4.6 Proof of the master theorem 103\nand for case 2,\nT .n/D\u201a.nlogba/C\u201a.nlogbalgn/\nD\u201a.nlogbalgn/ :\nFor case 3,T .n/D\u201a.n\nlogba/C\u201a.f .n//\nD\u201a.f .n// ;\nbecause f .n/D/DEL.nlogbaC/SI/.\n4.6.2 Floors and ceilings\nTo complete the proof of the master theorem, we must now extend our analysis to\nthe situation in which \ufb02oors and ceilings appear in the master recurrence, so thatthe recurrence is de\ufb01ned for all integers, not for just exact powers of b. Obtaining\na lower bound on\nT .n/DaT.dn=be/Cf .n/ (4.25)\nand an upper bound onT .n/DaT.bn=bc/Cf .n/ (4.26)\nis routine, since we can push through the bound dn=be/NAKn=b in the \ufb01rst case to\nyield the desired result, and we can push through the bound bn=bc/DC4n=b in the\nsecond case. We use much the same technique to lower-bound the recurrence (4.26)as to upper-bound the recurrence (4.25), and so we shall present only this latterbound.\nWe modify the recursion tree of Figure 4.7 to produce the recursion tree in Fig-\nure 4.8. As we go down in the recursion tree, we obtain a sequence of recursiveinvocations on the arguments\nn;\ndn=be;\nddn=be=be;\ndddn=be=be=be;\n:::\nLet us denote the jth element in the sequence by n\nj,w h e r e\nnjD(\nn ifjD0;\ndnj/NUL1=beifj> 0 :(4.27)", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "124": {"page_number": 125, "page_information": "104 Chapter 4 Divide-and-Conquer\n\u2026\u2026\n\u2026\n\u2026 \u2026 \u2026\u2026\n\u2026 \u2026 \u2026\u2026\n\u2026 \u2026 \u2026\n\u2026f .n/ f .n/\na a aa\na a aa\na a aaa\nf. n 1/ f. n 1/ f. n 1/\nf. n 2/ f. n 2/ f. n 2/ f. n 2/ f. n 2/ f. n 2/ f. n 2/ f. n 2/ f. n 2/af .n 1/\na2f. n 2/blogbnc\n\u201a.nlogba/\u201a.1/ \u201a.1/ \u201a.1/ \u201a.1/ \u201a.1/ \u201a.1/ \u201a.1/ \u201a.1/ \u201a.1/ \u201a.1/ \u201a.1/ \u201a.1/ \u201a.1/ \u201a.nlogba/\nTotal: \u201a.nlogba/Cblogbnc/NUL1X\njD0ajf. n j/\nFigure 4.8 The recursion tree generated by T .n/DaT .dn=be/Cf .n/ . The recursive argument nj\nis given by equation (4.27).\nOur \ufb01rst goal is to determine the depth ksuch that nkis a constant. Using the\ninequalitydxe/DC4xC1, we obtain\nn0/DC4n;\nn1/DC4n\nbC1;\nn2/DC4n\nb2C1\nbC1;\nn3/DC4n\nb3C1\nb2C1\nbC1;\n:::\nIn general, we have", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "125": {"page_number": 126, "page_information": "4.6 Proof of the master theorem 105\nnj/DC4n\nbjCj/NUL1X\niD01\nbi\n<n\nbjC1X\niD01\nbi\nDn\nbjCb\nb/NUL1:\nLetting jDblogbnc, we obtain\nnblogbnc<n\nbblogbncCb\nb/NUL1\n<n\nblogbn/NUL1Cb\nb/NUL1\nDn\nn=bCb\nb/NUL1\nDbCb\nb/NUL1\nDO.1/ ;\nand thus we see that at depth blogbnc, the problem size is at most a constant.\nFrom Figure 4.8, we see that\nT .n/D\u201a.nlogba/Cblogbnc/NUL1X\njD0ajf. n j/; (4.28)\nwhich is much the same as equation (4.21), except that nis an arbitrary integer and\nnot restricted to be an exact power of b.\nWe can now evaluate the summation\ng.n/Dblogbnc/NUL1X\njD0ajf. n j/ (4.29)\nfrom equation (4.28) in a manner analogous to the proof of Lemma 4.3. Beginning\nwith case 3, if af .dn=be//DC4cf .n/ forn>bCb=.b/NUL1/,w h e r e c<1 is a constant,\nthen it follows that ajf. n j//DC4cjf .n/ . Therefore, we can evaluate the sum in\nequation (4.29) just as in Lemma 4.3. For case 2, we have f .n/D\u201a.nlogba/.I fw e\ncan show that f. n j/DO.nlogba=aj/DO..n=bj/logba/, then the proof for case 2\nof Lemma 4.3 will go through. Observe that j/DC4blogbncimplies bj=n/DC41.T h e\nbound f .n/DO.nlogba/implies that there exists a constant c>0 such that for all\nsuf\ufb01ciently large nj,", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "126": {"page_number": 127, "page_information": "106 Chapter 4 Divide-and-Conquer\nf. n j//DC4c/DC2n\nbjCb\nb/NUL1/DC3logba\nDc/DC2n\nbj/DC2\n1Cbj\nn/SOHb\nb/NUL1/DC3/DC3 logba\nDc/DC2nlogba\naj/DC3/DC2\n1C/DC2bj\nn/SOHb\nb/NUL1/DC3/DC3 logba\n/DC4c/DC2nlogba\naj/DC3/DC2\n1Cb\nb/NUL1/DC3logba\nDO/DC2nlogba\naj/DC3\n;\nsince c.1Cb=.b/NUL1//logbais a constant. Thus, we have proved case 2. The proof\nof case 1 is almost identical. The key is to prove the bound f. n j/DO.nlogba/NUL/SI/,\nwhich is similar to the corresponding proof of case 2, though the algebra is moreintricate.\nWe have now proved the upper bounds in the master theorem for all integers n.\nThe proof of the lower bounds is similar.\nExercises\n4.6-1 ?\nGive a simple and exact expression for n\njin equation (4.27) for the case in which b\nis a positive integer instead of an arbitrary real number.\n4.6-2 ?\nShow that if f .n/D\u201a.nlogbalgkn/,w h e r e k/NAK0, then the master recurrence has\nsolution T .n/D\u201a.nlogbalgkC1n/. For simplicity, con\ufb01ne your analysis to exact\npowers of b.\n4.6-3 ?\nShow that case 3 of the master theorem is overstated, in the sense that the regularitycondition af .n=b//DC4cf .n/ for some constant c<1 implies that there exists a\nconstant /SI>0 such that f .n/D/DEL.n\nlogbaC/SI/.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "127": {"page_number": 128, "page_information": "Problems for Chapter 4 107\nProblems\n4-1 Recurrence examples\nGive asymptotic upper and lower bounds for T .n/ in each of the following recur-\nrences. Assume that T .n/ is constant for n/DC42. Make your bounds as tight as\npossible, and justify your answers.\na.T .n/D2T .n=2/Cn4.\nb.T .n/DT .7n=10/Cn.\nc.T .n/D16T .n=4/Cn2.\nd.T .n/D7T .n=3/Cn2.\ne.T .n/D7T .n=2/Cn2.\nf.T .n/D2T .n=4/Cp\nn.\ng.T .n/DT. n/NUL2/Cn2.\n4-2 Parameter-passing costs\nThroughout this book, we assume that parameter passing during procedure callstakes constant time, even if an N-element array is being passed. This assumption\nis valid in most systems because a pointer to the array is passed, not the array itself.\nThis problem examines the implications of three parameter-passing strategies:\n1. An array is passed by pointer. Time D\u201a.1/ .\n2. An array is passed by copying. Time D\u201a.N / ,w h e r e Nis the size of the array.\n3. An array is passed by copying only the subrange that might be accessed by the\ncalled procedure. Time D\u201a.q/NULpC1/if the subarray A\u0152p : : q/c141 is passed.\na.Consider the recursive binary search algorithm for \ufb01nding a number in a sorted\narray (see Exercise 2.3-5). Give recurrences for the worst-case running times\nof binary search when arrays are passed using each of the three methods above,and give good upper bounds on the solutions of the recurrences. Let Nbe the\nsize of the original problem and nbe the size of a subproblem.\nb.Redo part (a) for the M\nERGE -SORT algorithm from Section 2.3.1.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "128": {"page_number": 129, "page_information": "108 Chapter 4 Divide-and-Conquer\n4-3 More recurrence examples\nGive asymptotic upper and lower bounds for T .n/ in each of the following recur-\nrences. Assume that T .n/ is constant for suf\ufb01ciently small n. Make your bounds\nas tight as possible, and justify your answers.\na.T .n/D4T .n=3/Cnlgn.\nb.T .n/D3T .n=3/Cn=lgn.\nc.T .n/D4T .n=2/Cn2p\nn.\nd.T .n/D3T .n=3/NUL2/Cn=2.\ne.T .n/D2T .n=2/Cn=lgn.\nf.T .n/DT .n=2/CT .n=4/CT .n=8/Cn.\ng.T .n/DT. n/NUL1/C1=n.\nh.T .n/DT. n/NUL1/Clgn.\ni.T .n/DT. n/NUL2/C1=lgn.\nj.T .n/Dp\nnT .p\nn/Cn.\n4-4 Fibonacci numbers\nThis problem develops properties of the Fibonacci numbers, which are de\ufb01nedby recurrence (3.22). We shall use the technique of generating functions to solvethe Fibonacci recurrence. De\ufb01ne the generating function (orformal power se-\nries)Fas\nF.\u00b4/D\n1X\niD0Fi\u00b4i\nD0C\u00b4C\u00b42C2\u00b43C3\u00b44C5\u00b45C8\u00b46C13\u00b47C21\u00b48C/SOH/SOH/SOH ;\nwhere Fiis the ith Fibonacci number.\na.Show that F.\u00b4/D\u00b4C\u00b4F.\u00b4/C\u00b42F.\u00b4/.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "129": {"page_number": 130, "page_information": "Problems for Chapter 4 109\nb.Show that\nF.\u00b4/D\u00b4\n1/NUL\u00b4/NUL\u00b42\nD\u00b4\n.1/NUL/RS\u00b4/.1/NULy/RS\u00b4/\nD1\np\n5/DC21\n1/NUL/RS\u00b4/NUL1\n1/NULy/RS\u00b4/DC3\n;\nwhere\n/RSD1Cp\n5\n2D1:61803 : : :\nand\ny/RSD1/NULp\n5\n2D/NUL0:61803 : : : :\nc.Show that\nF.\u00b4/D1X\niD01\np\n5./RSi/NULy/RSi/\u00b4i:\nd.Use part (c) to prove that FiD/RSi=p\n5fori>0 , rounded to the nearest integer.\n(Hint: Observe that\u02c7\u02c7y/RS\u02c7\u02c7<1.)\n4-5 Chip testing\nProfessor Diogenes has nsupposedly identical integrated-circuit chips that in prin-\nciple are capable of testing each other. The professor\u2019s test jig accommodates twochips at a time. When the jig is loaded, each chip tests the other and reports whetherit is good or bad. A good chip always reports accurately whether the other chip isgood or bad, but the professor cannot trust the answer of a bad chip. Thus, the fourpossible outcomes of a test are as follows:\nChip Asays Chip Bsays Conclusion\nBis good Ais good both are good, or both are bad\nBis good Ais bad at least one is bad\nBis bad Ais good at least one is bad\nBis bad Ais bad at least one is bad\na.Show that if more than n=2chips are bad, the professor cannot necessarily de-\ntermine which chips are good using any strategy based on this kind of pairwisetest. Assume that the bad chips can conspire to fool the professor.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "130": {"page_number": 131, "page_information": "110 Chapter 4 Divide-and-Conquer\nb.Consider the problem of \ufb01nding a single good chip from among nchips, as-\nsuming that more than n=2 of the chips are good. Show that bn=2cpairwise\ntests are suf\ufb01cient to reduce the problem to one of nearly half the size.\nc.Show that the good chips can be identi\ufb01ed with \u201a.n/ pairwise tests, assuming\nthat more than n=2 of the chips are good. Give and solve the recurrence that\ndescribes the number of tests.\n4-6 Monge arrays\nAnm/STXnarray Aof real numbers is a Monge array if for all i,j,k,a n d lsuch\nthat1/DC4i<k/DC4mand1/DC4j< l/DC4n,w eh a v e\nA\u0152i; j /c141CA\u0152k; l/c141/DC4A\u0152i; l/c141CA\u0152k; j /c141 :\nIn other words, whenever we pick two rows and two columns of a Monge array and\nconsider the four elements at the intersections of the rows and the columns, the sumof the upper-left and lower-right elements is less than or equal to the sum of thelower-left and upper-right elements. For example, the following array is Monge:\n10 17 13 28 23\n17 22 16 29 2324 28 22 34 2411 13 6 17 745 44 32 37 2336 33 19 21 675 66 51 53 34\na.Prove that an array is Monge if and only if for all iD1; 2; :::; m/NUL1and\njD1; 2; :::; n/NUL1,w eh a v e\nA\u0152i; j /c141CA\u0152iC1; jC1/c141/DC4A\u0152i; jC1/c141CA\u0152iC1; j /c141 :\n(Hint: For the \u201cif\u201d part, use induction separately on rows and columns.)\nb.The following array is not Monge. Change one element in order to make it\nMonge. ( Hint: Use part (a).)\n37 23 22 32\n21 6 7 10\n53 34 30 3132 13 9 643 21 15 8", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "131": {"page_number": 132, "page_information": "Notes for Chapter 4 111\nc.Letf. i/ be the index of the column containing the leftmost minimum element\nof row i. Prove that f. 1 //DC4f. 2 //DC4/SOH/SOH/SOH/DC4 f. m / for any m/STXnMonge array.\nd.Here is a description of a divide-and-conquer algorithm that computes the left-\nmost minimum element in each row of an m/STXnMonge array A:\nConstruct a submatrix A0ofAconsisting of the even-numbered rows of A.\nRecursively determine the leftmost minimum for each row of A0.T h e n\ncompute the leftmost minimum in the odd-numbered rows of A.\nExplain how to compute the leftmost minimum in the odd-numbered rows of A\n(given that the leftmost minimum of the even-numbered rows is known) in\nO.mCn/time.\ne.Write the recurrence describing the running time of the algorithm described in\npart (d). Show that its solution is O.mCnlogm/.\nChapter notes\nDivide-and-conquer as a technique for designing algorithms dates back to at least\n1962 in an article by Karatsuba and Ofman [194]. It might have been used well be-fore then, however; according to Heideman, Johnson, and Burrus [163], C. F. Gaussdevised the \ufb01rst fast Fourier transform algorithm in 1805, and Gauss\u2019s formulationbreaks the problem into smaller subproblems whose solutions are combined.\nThe maximum-subarray problem in Section 4.1 is a minor variation on a problem\nstudied by Bentley [43, Chapter 7].\nStrassen\u2019s algorithm [325] caused much excitement when it was published\nin 1969. Before then, few imagined the possibility of an algorithm asymptoticallyfaster than the basic S\nQUARE -MATRIX -MULTIPLY procedure. The asymptotic\nupper bound for matrix multiplication has been improved since then. The most\nasymptotically ef\ufb01cient algorithm for multiplying n/STXnmatrices to date, due to\nCoppersmith and Winograd [78], has a running time of O.n2:376/. The best lower\nbound known is just the obvious /DEL.n2/bound (obvious because we must \ufb01ll in n2\nelements of the product matrix).\nFrom a practical point of view, Strassen\u2019s algorithm is often not the method of\nchoice for matrix multiplication, for four reasons:\n1. The constant factor hidden in the \u201a.nlg7/running time of Strassen\u2019s algo-\nrithm is larger than the constant factor in the \u201a.n3/-time S QUARE -MATRIX -\nMULTIPLY procedure.\n2. When the matrices are sparse, methods tailored for sparse matrices are faster.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "132": {"page_number": 133, "page_information": "112 Chapter 4 Divide-and-Conquer\n3. Strassen\u2019s algorithm is not quite as numerically stable as S QUARE -MATRIX -\nMULTIPLY . In other words, because of the limited precision of computer arith-\nmetic on noninteger values, larger errors accumulate in Strassen\u2019s algorithmthan in S\nQUARE -MATRIX -MULTIPLY .\n4. The submatrices formed at the levels of recursion consume space.\nThe latter two reasons were mitigated around 1990. Higham [167] demonstrated\nthat the difference in numerical stability had been overemphasized; althoughStrassen\u2019s algorithm is too numerically unstable for some applications, it is withinacceptable limits for others. Bailey, Lee, and Simon [32] discuss techniques forreducing the memory requirements for Strassen\u2019s algorithm.\nIn practice, fast matrix-multiplication implementations for dense matrices use\nStrassen\u2019s algorithm for matrix sizes above a \u201ccrossover point,\u201d and they switchto a simpler method once the subproblem size reduces to below the crossoverpoint. The exact value of the crossover point is highly system dependent. Analysesthat count operations but ignore effects from caches and pipelining have produced\ncrossover points as low as nD8(by Higham [167]) or nD12(by Huss-Lederman\net al. [186]). D\u2019Alberto and Nicolau [81] developed an adaptive scheme, whichdetermines the crossover point by benchmarking when their software package isinstalled. They found crossover points on various systems ranging from nD400\ntonD2150 , and they could not \ufb01nd a crossover point on a couple of systems.\nRecurrences were studied as early as 1202 by L. Fibonacci, for whom the Fi-\nbonacci numbers are named. A. De Moivre introduced the method of generating\nfunctions (see Problem 4-4) for solving recurrences. The master method is adaptedfrom Bentley, Haken, and Saxe [44], which provides the extended method justi\ufb01edby Exercise 4.6-2. Knuth [209] and Liu [237] show how to solve linear recurrencesusing the method of generating functions. Purdom and Brown [287] and Graham,Knuth, and Patashnik [152] contain extended discussions of recurrence solving.\nSeveral researchers, including Akra and Bazzi [13], Roura [299], Verma [346],\nand Yap [360], have given methods for solving more general divide-and-conquer\nrecurrences than are solved by the master method. We describe the result of Akra\nand Bazzi here, as modi\ufb01ed by Leighton [228]. The Akra-Bazzi method works forrecurrences of the form\nT. x/D(\n\u201a.1/ if1/DC4x/DC4x\n0;Pk\niD1aiT. b ix/Cf. x/ ifx>x 0;(4.30)\nwhere\n/SIx/NAK1is a real number,\n/SIx0is a constant such that x0/NAK1=b iandx0/NAK1=.1/NULbi/foriD1 ;2;:::;k ,\n/SIaiis a positive constant for iD1 ;2;:::;k ,", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "133": {"page_number": 134, "page_information": "Notes for Chapter 4 113\n/SIbiis a constant in the range 0<b i<1foriD1 ;2;:::;k ,\n/SIk/NAK1is an integer constant, and\n/SIf. x/ is a nonnegative function that satis\ufb01es the polynomial-growth condi-\ntion: there exist positive constants c1andc2such that for all x/NAK1,f o r\niD1 ;2;:::;k , and for all usuch that bix/DC4u/DC4x,w eh a v e c1f. x//DC4\nf. u //DC4c2f. x/ . (Ifjf0.x/jis upper-bounded by some polynomial in x,t h e n\nf. x/ satis\ufb01es the polynomial-growth condition. For example, f. x/Dx\u02dblg\u02c7x\nsatis\ufb01es this condition for any real constants \u02dband\u02c7.)\nAlthough the master method does not apply to a recurrence such as T .n/D\nT.bn=3c/CT.b2n=3c/CO.n/ , the Akra-Bazzi method does. To solve the re-\ncurrence (4.30), we \ufb01rst \ufb01nd the unique real number psuch thatPk\niD1aibp\niD1.\n(Such a palways exists.) The solution to the recurrence is then\nT .n/D\u201a/DC2\nxp/DC2\n1CZx\n1f. u /\nupC1du/DC3/DC3\n:\nThe Akra-Bazzi method can be somewhat dif\ufb01cult to use, but it serves in solving\nrecurrences that model division of the problem into substantially unequally sizedsubproblems. The master method is simpler to use, but it applies only when sub-problem sizes are equal.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "134": {"page_number": 135, "page_information": "5 Probabilistic Analysis and Randomized\nAlgorithms\nThis chapter introduces probabilistic analysis and randomized algorithms. If you\nare unfamiliar with the basics of probability theory, you should read Appendix C,which reviews this material. We shall revisit probabilistic analysis and randomizedalgorithms several times throughout this book.\n5.1 The hiring problem\nSuppose that you need to hire a new of\ufb01ce assistant. Your previous attempts athiring have been unsuccessful, and you decide to use an employment agency. Theemployment agency sends you one candidate each day. You interview that person\nand then decide either to hire that person or not. You must pay the employment\nagency a small fee to interview an applicant. To actually hire an applicant is morecostly, however, since you must \ufb01re your current of\ufb01ce assistant and pay a substan-tial hiring fee to the employment agency. You are committed to having, at all times,the best possible person for the job. Therefore, you decide that, after interviewingeach applicant, if that applicant is better quali\ufb01ed than the current of\ufb01ce assistant,you will \ufb01re the current of\ufb01ce assistant and hire the new applicant. You are willingto pay the resulting price of this strategy, but you wish to estimate what that pricewill be.\nThe procedure H\nIRE-ASSISTANT , given below, expresses this strategy for hiring\nin pseudocode. It assumes that the candidates for the of\ufb01ce assistant job are num-\nbered 1through n. The procedure assumes that you are able to, after interviewing\ncandidate i, determine whether candidate iis the best candidate you have seen so\nfar. To initialize, the procedure creates a dummy candidate, numbered 0, who is\nless quali\ufb01ed than each of the other candidates.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "135": {"page_number": 136, "page_information": "5.1 The hiring problem 115\nHIRE-ASSISTANT .n/\n1bestD0 //candidate 0 is a least-quali\ufb01ed dummy candidate\n2foriD1ton\n3 interview candidate i\n4 ifcandidate iis better than candidate best\n5 bestDi\n6 hire candidate i\nThe cost model for this problem differs from the model described in Chapter 2.\nWe focus not on the running time of H IRE-ASSISTANT , but instead on the costs\nincurred by interviewing and hiring. On the surface, analyzing the cost of this algo-rithm may seem very different from analyzing the running time of, say, merge sort.The analytical techniques used, however, are identical whether we are analyzing\ncost or running time. In either case, we are counting the number of times certain\nbasic operations are executed.\nInterviewing has a low cost, say c\ni, whereas hiring is expensive, costing ch.L e t -\ntingmbe the number of people hired, the total cost associated with this algorithm\nisO.c inCchm/. No matter how many people we hire, we always interview n\ncandidates and thus always incur the cost cinassociated with interviewing. We\ntherefore concentrate on analyzing chm, the hiring cost. This quantity varies with\neach run of the algorithm.\nThis scenario serves as a model for a common computational paradigm. We of-\nten need to \ufb01nd the maximum or minimum value in a sequence by examining eachelement of the sequence and maintaining a current \u201cwinner.\u201d The hiring problemmodels how often we update our notion of which element is currently winning.\nWorst-case analysis\nIn the worst case, we actually hire every candidate that we interview. This situation\noccurs if the candidates come in strictly increasing order of quality, in which casewe hire ntimes, for a total hiring cost of O.c\nhn/.\nOf course, the candidates do not always come in increasing order of quality. In\nfact, we have no idea about the order in which they arrive, nor do we have any\ncontrol over this order. Therefore, it is natural to ask what we expect to happen ina typical or average case.\nProbabilistic analysis\nProbabilistic analysis is the use of probability in the analysis of problems. Most\ncommonly, we use probabilistic analysis to analyze the running time of an algo-rithm. Sometimes we use it to analyze other quantities, such as the hiring cost", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "136": {"page_number": 137, "page_information": "116 Chapter 5 Probabilistic Analysis and Randomized Algorithms\nin procedure H IRE-ASSISTANT . In order to perform a probabilistic analysis, we\nmust use knowledge of, or make assumptions about, the distribution of the inputs.Then we analyze our algorithm, computing an average-case running time, wherewe take the average over the distribution of the possible inputs. Thus we are, ineffect, averaging the running time over all possible inputs. When reporting such arunning time, we will refer to it as the average-case running time .\nWe must be very careful in deciding on the distribution of inputs. For some\nproblems, we may reasonably assume something about the set of all possible in-\nputs, and then we can use probabilistic analysis as a technique for designing an\nef\ufb01cient algorithm and as a means for gaining insight into a problem. For otherproblems, we cannot describe a reasonable input distribution, and in these caseswe cannot use probabilistic analysis.\nFor the hiring problem, we can assume that the applicants come in a random\norder. What does that mean for this problem? We assume that we can compareany two candidates and decide which one is better quali\ufb01ed; that is, there is atotal order on the candidates. (See Appendix B for the de\ufb01nition of a total or-der.) Thus, we can rank each candidate with a unique number from 1through n,\nusing rank.i/to denote the rank of applicant i, and adopt the convention that a\nhigher rank corresponds to a better quali\ufb01ed applicant. The ordered list hrank.1/;\nrank. 2 / ;:::; rank.n/iis a permutation of the list h1 ;2;:::;ni. Saying that the\napplicants come in a random order is equivalent to saying that this list of ranks isequally likely to be any one of the n\u0160permutations of the numbers 1through n.\nAlternatively, we say that the ranks form a uniform random permutation ;t h a ti s ,\neach of the possible n\u0160permutations appears with equal probability.\nSection 5.2 contains a probabilistic analysis of the hiring problem.\nRandomized algorithms\nIn order to use probabilistic analysis, we need to know something about the distri-\nbution of the inputs. In many cases, we know very little about the input distribution.\nEven if we do know something about the distribution, we may not be able to modelthis knowledge computationally. Yet we often can use probability and randomness\nas a tool for algorithm design and analysis, by making the behavior of part of thealgorithm random.\nIn the hiring problem, it may seem as if the candidates are being presented to us\nin a random order, but we have no way of knowing whether or not they really are.Thus, in order to develop a randomized algorithm for the hiring problem, we musthave greater control over the order in which we interview the candidates. We will,therefore, change the model slightly. We say that the employment agency has n\ncandidates, and they send us a list of the candidates in advance. On each day, wechoose, randomly, which candidate to interview. Although we know nothing about", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "137": {"page_number": 138, "page_information": "5.1 The hiring problem 117\nthe candidates (besides their names), we have made a signi\ufb01cant change. Instead\nof relying on a guess that the candidates come to us in a random order, we haveinstead gained control of the process and enforced a random order.\nMore generally, we call an algorithm randomized if its behavior is determined\nnot only by its input but also by values produced by a random-number gener-\nator. We shall assume that we have at our disposal a random-number generator\nR\nANDOM . A call to R ANDOM .a; b/ returns an integer between aandb,i n c l u -\nsive, with each such integer being equally likely. For example, R ANDOM .0; 1/\nproduces 0with probability 1=2, and it produces 1with probability 1=2. A call to\nRANDOM .3; 7/ returns either 3,4,5,6,o r7, each with probability 1=5. Each inte-\nger returned by R ANDOM is independent of the integers returned on previous calls.\nYou may imagine R ANDOM as rolling a .b/NULaC1/-sided die to obtain its out-\nput. (In practice, most programming environments offer a pseudorandom-number\ngenerator : a deterministic algorithm returning numbers that \u201clook\u201d statistically\nrandom.)\nWhen analyzing the running time of a randomized algorithm, we take the expec-\ntation of the running time over the distribution of values returned by the random\nnumber generator. We distinguish these algorithms from those in which the input\nis random by referring to the running time of a randomized algorithm as an ex-\npected running time . In general, we discuss the average-case running time when\nthe probability distribution is over the inputs to the algorithm, and we discuss theexpected running time when the algorithm itself makes random choices.\nExercises\n5.1-1\nShow that the assumption that we are always able to determine which candidate isbest, in line 4 of procedure H\nIRE-ASSISTANT , implies that we know a total order\non the ranks of the candidates.\n5.1-2 ?\nDescribe an implementation of the procedure R ANDOM .a; b/ that only makes calls\nto R ANDOM .0; 1/ . What is the expected running time of your procedure, as a\nfunction of aandb?\n5.1-3 ?\nSuppose that you want to output 0with probability 1=2and1with probability 1=2.\nAt your disposal is a procedure B IASED -RANDOM , that outputs either 0or1.I t\noutputs 1with some probability pand0with probability 1/NULp,w h e r e 0<p<1 ,\nbut you do not know what pis. Give an algorithm that uses B IASED -RANDOM\nas a subroutine, and returns an unbiased answer, returning 0with probability 1=2", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "138": {"page_number": 139, "page_information": "118 Chapter 5 Probabilistic Analysis and Randomized Algorithms\nand1with probability 1=2. What is the expected running time of your algorithm\nas a function of p?\n5.2 Indicator random variables\nIn order to analyze many algorithms, including the hiring problem, we use indicator\nrandom variables. Indicator random variables provide a convenient method forconverting between probabilities and expectations. Suppose we are given a samplespace Sand an event A. Then the indicator random variable IfAgassociated with\nevent Ais de\ufb01ned as\nIfAgD(\n1ifAoccurs ;\n0ifAdoes not occur :(5.1)\nAs a simple example, let us determine the expected number of heads that we\nobtain when \ufb02ipping a fair coin. Our sample space is SDfH;Tg, with PrfHgD\nPrfTgD1=2. We can then de\ufb01ne an indicator random variable X\nH, associated\nwith the coin coming up heads, which is the event H. This variable counts the\nnumber of heads obtained in this \ufb02ip, and it is 1if the coin comes up heads and 0\notherwise. We write\nXHDIfHg\nD(\n1ifHoccurs ;\n0ifToccurs :\nThe expected number of heads obtained in one \ufb02ip of the coin is simply the ex-\npected value of our indicator variable XH:\nE\u0152XH/c141DE\u0152IfHg/c141\nD1/SOHPrfHgC0/SOHPrfTg\nD1/SOH.1=2/C0/SOH.1=2/\nD1=2 :\nThus the expected number of heads obtained by one \ufb02ip of a fair coin is 1=2.A s\nthe following lemma shows, the expected value of an indicator random variable\nassociated with an event Ais equal to the probability that Aoccurs.\nLemma 5.1\nGiven a sample space Sa n da ne v e n t Ain the sample space S,l e tXADIfAg.\nThen E \u0152XA/c141DPrfAg.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "139": {"page_number": 140, "page_information": "5.2 Indicator random variables 119\nProof By the de\ufb01nition of an indicator random variable from equation (5.1) and\nthe de\ufb01nition of expected value, we have\nE\u0152XA/c141DE\u0152IfAg/c141\nD1/SOHPrfAgC0/SOHPr\u02da\nA/TAB\nDPrfAg;\nwhere\n Adenotes S/NULA, the complement of A.\nAlthough indicator random variables may seem cumbersome for an application\nsuch as counting the expected number of heads on a \ufb02ip of a single coin, they are\nuseful for analyzing situations in which we perform repeated random trials. Forexample, indicator random variables give us a simple way to arrive at the resultof equation (C.37). In this equation, we compute the number of heads in ncoin\n\ufb02ips by considering separately the probability of obtaining 0heads, 1head, 2heads,\netc. The simpler method proposed in equation (C.38) instead uses indicator randomvariables implicitly. Making this argument more explicit, we let X\nibe the indicator\nrandom variable associated with the event in which the ith \ufb02ip comes up heads:\nXiDIftheith \ufb02ip results in the event Hg.L e tXbe the random variable denoting\nthe total number of heads in the ncoin \ufb02ips, so that\nXDnX\niD1Xi:\nWe wish to compute the expected number of heads, and so we take the expectation\nof both sides of the above equation to obtain\nE\u0152X/c141DE\"nX\niD1Xi#\n:\nThe above equation gives the expectation of the sum of nindicator random vari-\nables. By Lemma 5.1, we can easily compute the expectation of each of the random\nvariables. By equation (C.21)\u2014linearity of expectation\u2014it is easy to compute the\nexpectation of the sum: it equals the sum of the expectations of the nrandom\nvariables. Linearity of expectation makes the use of indicator random variables a\npowerful analytical technique; it applies even when there is dependence among the\nrandom variables. We now can easily compute the expected number of heads:", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "140": {"page_number": 141, "page_information": "120 Chapter 5 Probabilistic Analysis and Randomized Algorithms\nE\u0152X/c141DE\"nX\niD1Xi#\nDnX\niD1E\u0152Xi/c141\nDnX\niD11=2\nDn=2 :\nThus, compared to the method used in equation (C.37), indicator random variables\ngreatly simplify the calculation. We shall use indicator random variables through-\nout this book.\nAnalysis of the hiring problem using indicator random variables\nReturning to the hiring problem, we now wish to compute the expected number of\ntimes that we hire a new of\ufb01ce assistant. In order to use a probabilistic analysis, weassume that the candidates arrive in a random order, as discussed in the previoussection. (We shall see in Section 5.3 how to remove this assumption.) Let Xbe the\nrandom variable whose value equals the number of times we hire a new of\ufb01ce as-\nsistant. We could then apply the de\ufb01nition of expected value from equation (C.20)\nto obtain\nE\u0152X/c141D\nnX\nxD1xPrfXDxg;\nbut this calculation would be cumbersome. We shall instead use indicator random\nvariables to greatly simplify the calculation.\nTo use indicator random variables, instead of computing E \u0152X/c141by de\ufb01ning one\nvariable associated with the number of times we hire a new of\ufb01ce assistant, wede\ufb01ne nvariables related to whether or not each particular candidate is hired. In\nparticular, we let X\nibe the indicator random variable associated with the event in\nwhich the ith candidate is hired. Thus,\nXiDIfcandidate iis hiredg\nD(\n1if candidate iis hired ;\n0if candidate iis not hired ;\nand\nXDX1CX2C/SOH/SOH/SOHC Xn: (5.2)", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "141": {"page_number": 142, "page_information": "5.2 Indicator random variables 121\nBy Lemma 5.1, we have that\nE\u0152Xi/c141DPrfcandidate iis hiredg;\nand we must therefore compute the probability that lines 5\u20136 of H IRE-ASSISTANT\nare executed.\nCandidate iis hired, in line 6, exactly when candidate iis better than each of\ncandidates 1through i/NUL1. Because we have assumed that the candidates arrive in\na random order, the \ufb01rst icandidates have appeared in a random order. Any one of\nthese \ufb01rst icandidates is equally likely to be the best-quali\ufb01ed so far. Candidate i\nhas a probability of 1=iof being better quali\ufb01ed than candidates 1through i/NUL1\nand thus a probability of 1=iof being hired. By Lemma 5.1, we conclude that\nE\u0152Xi/c141D1=i : (5.3)\nNow we can compute E \u0152X/c141:\nE\u0152X/c141DE\"nX\niD1Xi#\n(by equation (5.2)) (5.4)\nDnX\niD1E\u0152Xi/c141 (by linearity of expectation)\nDnX\niD11=i (by equation (5.3))\nDlnnCO.1/ (by equation (A.7)) . (5.5)\nEven though we interview npeople, we actually hire only approximately ln nof\nthem, on average. We summarize this result in the following lemma.\nLemma 5.2\nAssuming that the candidates are presented in a random order, algorithm H IRE-\nASSISTANT has an average-case total hiring cost of O.c hlnn/.\nProof The bound follows immediately from our de\ufb01nition of the hiring cost\nand equation (5.5), which shows that the expected number of hires is approxi-mately ln n.\nThe average-case hiring cost is a signi\ufb01cant improvement over the worst-case\nhiring cost of O.c hn/.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "142": {"page_number": 143, "page_information": "122 Chapter 5 Probabilistic Analysis and Randomized Algorithms\nExercises\n5.2-1\nIn H IRE-ASSISTANT , assuming that the candidates are presented in a random or-\nder, what is the probability that you hire exactly one time? What is the probability\nthat you hire exactly ntimes?\n5.2-2\nIn H IRE-ASSISTANT , assuming that the candidates are presented in a random or-\nder, what is the probability that you hire exactly twice?\n5.2-3\nUse indicator random variables to compute the expected value of the sum of ndice.\n5.2-4\nUse indicator random variables to solve the following problem, which is known asthehat-check problem . Each of ncustomers gives a hat to a hat-check person at a\nrestaurant. The hat-check person gives the hats back to the customers in a randomorder. What is the expected number of customers who get back their own hat?\n5.2-5\nLetA\u01521 : : n/c141 be an array of ndistinct numbers. If i<j andA\u0152i/c141 > A\u0152j /c141 ,t h e n\nthe pair .i; j / is called an inversion ofA. (See Problem 2-4 for more on inver-\nsions.) Suppose that the elements of Aform a uniform random permutation of\nh1 ;2;:::;ni. Use indicator random variables to compute the expected number of\ninversions.\n5.3 Randomized algorithms\nIn the previous section, we showed how knowing a distribution on the inputs canhelp us to analyze the average-case behavior of an algorithm. Many times, we donot have such knowledge, thus precluding an average-case analysis. As mentioned\nin Section 5.1, we may be able to use a randomized algorithm.\nFor a problem such as the hiring problem, in which it is helpful to assume that\nall permutations of the input are equally likely, a probabilistic analysis can guidethe development of a randomized algorithm. Instead of assuming a distributionof inputs, we impose a distribution. In particular, before running the algorithm,we randomly permute the candidates in order to enforce the property that everypermutation is equally likely. Although we have modi\ufb01ed the algorithm, we stillexpect to hire a new of\ufb01ce assistant approximately ln ntimes. But now we expect", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "143": {"page_number": 144, "page_information": "5.3 Randomized algorithms 123\nthis to be the case for anyinput, rather than for inputs drawn from a particular\ndistribution.\nLet us further explore the distinction between probabilistic analysis and random-\nized algorithms. In Section 5.2, we claimed that, assuming that the candidates ar-rive in a random order, the expected number of times we hire a new of\ufb01ce assistantis about ln n. Note that the algorithm here is deterministic; for any particular input,\nthe number of times a new of\ufb01ce assistant is hired is always the same. Furthermore,the number of times we hire a new of\ufb01ce assistant differs for different inputs, and it\ndepends on the ranks of the various candidates. Since this number depends only on\nthe ranks of the candidates, we can represent a particular input by listing, in order,the ranks of the candidates, i.e., hrank.1/;rank. 2 / ;:::; rank.n/i. Given the rank\nlistA\n1Dh1;2;3;4;5;6; 7; 8; 9; 10 i, a new of\ufb01ce assistant is always hired 10times,\nsince each successive candidate is better than the previous one, and lines 5\u20136 areexecuted in each iteration. Given the list of ranks A\n2Dh10; 9; 8; 7; 6; 5; 4; 3; 2; 1 i,\na new of\ufb01ce assistant is hired only once, in the \ufb01rst iteration. Given a list of ranks\nA3Dh5; 2; 1; 8; 4; 7; 10; 9; 3; 6 i, a new of\ufb01ce assistant is hired three times,\nupon interviewing the candidates with ranks 5,8,a n d 10. Recalling that the cost\nof our algorithm depends on how many times we hire a new of\ufb01ce assistant, we\nsee that there are expensive inputs such as A1, inexpensive inputs such as A2,a n d\nmoderately expensive inputs such as A3.\nConsider, on the other hand, the randomized algorithm that \ufb01rst permutes the\ncandidates and then determines the best candidate. In this case, we randomize in\nthe algorithm, not in the input distribution. Given a particular input, say A3above,\nwe cannot say how many times the maximum is updated, because this quantitydiffers with each run of the algorithm. The \ufb01rst time we run the algorithm on A\n3,\nit may produce the permutation A1and perform 10updates; but the second time\nwe run the algorithm, we may produce the permutation A2and perform only one\nupdate. The third time we run it, we may perform some other number of updates.Each time we run the algorithm, the execution depends on the random choicesmade and is likely to differ from the previous execution of the algorithm. For thisalgorithm and many other randomized algorithms, no particular input elicits its\nworst-case behavior . Even your worst enemy cannot produce a bad input array,\nsince the random permutation makes the input order irrelevant. The randomizedalgorithm performs badly only if the random-number generator produces an \u201cun-lucky\u201d permutation.\nFor the hiring problem, the only change needed in the code is to randomly per-\nmute the array.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "144": {"page_number": 145, "page_information": "124 Chapter 5 Probabilistic Analysis and Randomized Algorithms\nRANDOMIZED -HIRE-ASSISTANT .n/\n1 randomly permute the list of candidates\n2bestD0 //candidate 0 is a least-quali\ufb01ed dummy candidate\n3foriD1ton\n4 interview candidate i\n5 ifcandidate iis better than candidate best\n6 bestDi\n7 hire candidate i\nWith this simple change, we have created a randomized algorithm whose perfor-\nmance matches that obtained by assuming that the candidates were presented in arandom order.\nLemma 5.3\nThe expected hiring cost of the procedure R\nANDOMIZED -HIRE-ASSISTANT is\nO.c hlnn/.\nProof After permuting the input array, we have achieved a situation identical to\nthat of the probabilistic analysis of H IRE-ASSISTANT .\nComparing Lemmas 5.2 and 5.3 highlights the difference between probabilistic\nanalysis and randomized algorithms. In Lemma 5.2, we make an assumption aboutthe input. In Lemma 5.3, we make no such assumption, although randomizing theinput takes some additional time. To remain consistent with our terminology, we\ncouched Lemma 5.2 in terms of the average-case hiring cost and Lemma 5.3 in\nterms of the expected hiring cost. In the remainder of this section, we discuss someissues involved in randomly permuting inputs.\nRandomly permuting arrays\nMany randomized algorithms randomize the input by permuting the given input\narray. (There are other ways to use randomization.) Here, we shall discuss twomethods for doing so. We assume that we are given an array Awhich, without loss\nof generality, contains the elements 1through n. Our goal is to produce a random\npermutation of the array.\nOne common method is to assign each element A\u0152i/c141 of the array a random pri-\nority P\u0152 i/c141, and then sort the elements of Aaccording to these priorities. For ex-\nample, if our initial array is ADh1; 2; 3; 4iand we choose random priorities\nPDh36; 3; 62; 19i, we would produce an array BDh2;4;1;3i, since the second\npriority is the smallest, followed by the fourth, then the \ufb01rst, and \ufb01nally the third.\nWe call this procedure P\nERMUTE -BY-SORTING :", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "145": {"page_number": 146, "page_information": "5.3 Randomized algorithms 125\nPERMUTE -BY-SORTING .A/\n1nDA:length\n2l e t P\u0152 1::n /c141 be a new array\n3foriD1ton\n4 P\u0152 i/c141DRANDOM .1; n3/\n5s o r t A,u s i n g Pas sort keys\nLine 4 chooses a random number between 1andn3. We use a range of 1ton3\nto make it likely that all the priorities in Pare unique. (Exercise 5.3-5 asks you\nto prove that the probability that all entries are unique is at least 1/NUL1=n,a n d\nExercise 5.3-6 asks how to implement the algorithm even if two or more prioritiesare identical.) Let us assume that all the priorities are unique.\nThe time-consuming step in this procedure is the sorting in line 5. As we shall\nsee in Chapter 8, if we use a comparison sort, sorting takes /DEL.n lgn/time. We\ncan achieve this lower bound, since we have seen that merge sort takes \u201a.n lgn/\ntime. (We shall see other comparison sorts that take \u201a.n lgn/time in Part II.\nExercise 8.3-4 asks you to solve the very similar problem of sorting numbers in the\nrange 0ton\n3/NUL1inO.n/ time.) After sorting, if P\u0152 i/c141 is the jth smallest priority,\nthenA\u0152i/c141 lies in position jof the output. In this manner we obtain a permutation. It\nremains to prove that the procedure produces a uniform random permutation ,t h a t\nis, that the procedure is equally likely to produce every permutation of the numbers\n1through n.\nLemma 5.4\nProcedure P ERMUTE -BY-SORTING produces a uniform random permutation of the\ninput, assuming that all priorities are distinct.\nProof We start by considering the particular permutation in which each ele-\nment A\u0152i/c141 receives the ith smallest priority. We shall show that this permutation\noccurs with probability exactly 1=n\u0160 .F o r iD1 ;2;:::;n ,l e tEibe the event\nthat element A\u0152i/c141 receives the ith smallest priority. Then we wish to compute the\nprobability that for all i,e v e n t Eioccurs, which is\nPrfE1\\E2\\E3\\/SOH/SOH/SOH\\ En/NUL1\\Eng:\nUsing Exercise C.2-5, this probability is equal to\nPrfE1g/SOHPrfE2jE1g/SOHPrfE3jE2\\E1g/SOHPrfE4jE3\\E2\\E1g\n/SOH/SOH/SOHPrfEijEi/NUL1\\Ei/NUL2\\/SOH/SOH/SOH\\ E1g/SOH/SOH/SOHPrfEnjEn/NUL1\\/SOH/SOH/SOH\\ E1g:\nWe have that PrfE1gD1=n because it is the probability that one priority\nchosen randomly out of a set of nis the smallest priority. Next, we observe", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "146": {"page_number": 147, "page_information": "126 Chapter 5 Probabilistic Analysis and Randomized Algorithms\nthat PrfE2jE1gD1=.n/NUL1/because given that element A\u01521/c141 has the small-\nest priority, each of the remaining n/NUL1elements has an equal chance of hav-\ning the second smallest priority. In general, for iD2;3 ;:::;n ,w eh a v et h a t\nPrfEijEi/NUL1\\Ei/NUL2\\/SOH/SOH/SOH\\ E1gD1=.n/NULiC1/, since, given that elements A\u01521/c141\nthrough A\u0152i/NUL1/c141have the i/NUL1smallest priorities (in order), each of the remaining\nn/NUL.i/NUL1/elements has an equal chance of having the ith smallest priority. Thus,\nwe have\nPrfE1\\E2\\E3\\/SOH/SOH/SOH\\ En/NUL1\\EngD/DC21\nn/DC3/DC21\nn/NUL1/DC3\n/SOH/SOH/SOH/DC21\n2/DC3/DC21\n1/DC3\nD1\nn\u0160;\nand we have shown that the probability of obtaining the identity permutation\nis1=n\u0160 .\nWe can extend this proof to work for any permutation of priorities. Consider\nany \ufb01xed permutation /ESCDh/ESC.1/; /ESC.2/; : : : ; /ESC.n/ iof the setf1 ;2;:::;ng.L e tu s\ndenote by rithe rank of the priority assigned to element A\u0152i/c141, where the element\nwith the jth smallest priority has rank j.I f w e d e \ufb01 n e Eias the event in which\nelement A\u0152i/c141 receives the /ESC.i/th smallest priority, or riD/ESC.i/, the same proof\nstill applies. Therefore, if we calculate the probability of obtaining any particularpermutation, the calculation is identical to the one above, so that the probability ofobtaining this permutation is also 1=n\u0160 .\nYou might think that to prove that a permutation is a uniform random permuta-\ntion, it suf\ufb01ces to show that, for each element A\u0152i/c141, the probability that the element\nwinds up in position jis1=n. Exercise 5.3-4 shows that this weaker condition is,\nin fact, insuf\ufb01cient.\nA better method for generating a random permutation is to permute the given\narray in place. The procedure R ANDOMIZE -IN-PLACE does so in O.n/ time. In\nitsith iteration, it chooses the element A\u0152i/c141 randomly from among elements A\u0152i/c141\nthrough A\u0152n/c141. Subsequent to the ith iteration, A\u0152i/c141 is never altered.\nRANDOMIZE -IN-PLACE .A/\n1nDA:length\n2foriD1ton\n3s w a p A\u0152i/c141 withA\u0152RANDOM .i; n//c141\nWe shall use a loop invariant to show that procedure R ANDOMIZE -IN-PLACE\nproduces a uniform random permutation. A k-permutation on a set of nele-\nments is a sequence containing kof the nelements, with no repetitions. (See\nAppendix C.) There are n\u0160=.n/NULk/\u0160such possible k-permutations.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "147": {"page_number": 148, "page_information": "5.3 Randomized algorithms 127\nLemma 5.5\nProcedure R ANDOMIZE -IN-PLACE computes a uniform random permutation.\nProof We use the following loop invariant:\nJust prior to the ith iteration of the forloop of lines 2\u20133, for each possible\n.i/NUL1/-permutation of the nelements, the subarray A\u01521 : : i/NUL1/c141contains\nthis.i/NUL1/-permutation with probability .n/NULiC1/\u0160=n\u0160 .\nWe need to show that this invariant is true prior to the \ufb01rst loop iteration, that each\niteration of the loop maintains the invariant, and that the invariant provides a usefulproperty to show correctness when the loop terminates.\nInitialization: Consider the situation just before the \ufb01rst loop iteration, so that\niD1. The loop invariant says that for each possible 0-permutation, the sub-\narray A\u01521 : : 0/c141 contains this 0-permutation with probability .n/NULiC1/\u0160=n\u0160D\nn\u0160=n\u0160D1. The subarray A\u01521 : : 0/c141 is an empty subarray, and a 0-permutation\nhas no elements. Thus, A\u01521 : : 0/c141 contains any 0-permutation with probability 1,\nand the loop invariant holds prior to the \ufb01rst iteration.\nMaintenance: We assume that just before the ith iteration, each possible\n.i/NUL1/-permutation appears in the subarray A\u01521 : : i/NUL1/c141with probability\n.n/NULiC1/\u0160=n\u0160 , and we shall show that after the ith iteration, each possible\ni-permutation appears in the subarray A\u01521 : : i/c141 with probability .n/NULi/\u0160=n\u0160 .\nIncrementing ifor the next iteration then maintains the loop invariant.\nLet us examine the ith iteration. Consider a particular i\n-permutation, and de-\nnote the elements in it by hx1;x2;:::;x ii. This permutation consists of an\n.i/NUL1/-permutationhx1;:::;x i/NUL1ifollowed by the value xithat the algorithm\nplaces in A\u0152i/c141.L e t E1denote the event in which the \ufb01rst i/NUL1iterations have\ncreated the particular .i/NUL1/-permutationhx1;:::;x i/NUL1iinA\u01521 : : i/NUL1/c141.B yt h e\nloop invariant, PrfE1gD.n/NULiC1/\u0160=n\u0160 .L e t E2be the event that ith iteration\nputsxiin position A\u0152i/c141.T h e i-permutationhx1;:::;x iiappears in A\u01521 : : i/c141 pre-\ncisely when both E1andE2occur, and so we wish to compute Pr fE2\\E1g.\nUsing equation (C.14), we have\nPrfE2\\E1gDPrfE2jE1gPrfE1g:\nThe probability PrfE2jE1gequals 1=.n/NULiC1/because in line 3 the algorithm\nchooses xirandomly from the n/NULiC1values in positions A\u0152i : : n/c141 . Thus, we\nhave", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "148": {"page_number": 149, "page_information": "128 Chapter 5 Probabilistic Analysis and Randomized Algorithms\nPrfE2\\E1gDPrfE2jE1gPrfE1g\nD1\nn/NULiC1/SOH.n/NULiC1/\u0160\nn\u0160\nD.n/NULi/\u0160\nn\u0160:\nTermination: At termination, iDnC1, and we have that the subarray A\u01521 : : n/c141\nis a given n-permutation with probability .n/NUL.nC1/C1/=n\u0160D0\u0160=n\u0160D1=n\u0160 .\nThus, R ANDOMIZE -IN-PLACE produces a uniform random permutation.\nA randomized algorithm is often the simplest and most ef\ufb01cient way to solve a\nproblem. We shall use randomized algorithms occasionally throughout this book.\nExercises\n5.3-1\nProfessor Marceau objects to the loop invariant used in the proof of Lemma 5.5. Hequestions whether it is true prior to the \ufb01rst iteration. He reasons that we could justas easily declare that an empty subarray contains no 0-permutations. Therefore,\nthe probability that an empty subarray contains a 0-permutation should be 0, thus\ninvalidating the loop invariant prior to the \ufb01rst iteration. Rewrite the procedure\nR\nANDOMIZE -IN-PLACE so that its associated loop invariant applies to a nonempty\nsubarray prior to the \ufb01rst iteration, and modify the proof of Lemma 5.5 for yourprocedure.\n5.3-2\nProfessor Kelp decides to write a procedure that produces at random any permuta-tion besides the identity permutation. He proposes the following procedure:\nP\nERMUTE -WITHOUT -IDENTITY .A/\n1nDA:length\n2foriD1ton/NUL1\n3s w a p A\u0152i/c141 withA\u0152RANDOM .iC1; n//c141\nDoes this code do what Professor Kelp intends?\n5.3-3\nSuppose that instead of swapping element A\u0152i/c141 with a random element from the\nsubarray A\u0152i : : n/c141 , we swapped it with a random element from anywhere in the\narray:", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "149": {"page_number": 150, "page_information": "5.3 Randomized algorithms 129\nPERMUTE -WITH-ALL.A/\n1nDA:length\n2foriD1ton\n3s w a p A\u0152i/c141 withA\u0152RANDOM .1; n//c141\nDoes this code produce a uniform random permutation? Why or why not?\n5.3-4\nProfessor Armstrong suggests the following procedure for generating a uniformrandom permutation:\nP\nERMUTE -BY-CYCLIC .A/\n1nDA:length\n2l e t B\u0152 1::n /c141 be a new array\n3offsetDRANDOM .1; n/\n4foriD1ton\n5 destDiCoffset\n6 ifdest>n\n7 destDdest/NULn\n8 B\u0152dest/c141DA\u0152i/c141\n9return B\nShow that each element A\u0152i/c141 has a 1=nprobability of winding up in any particular\nposition in B. Then show that Professor Armstrong is mistaken by showing that\nthe resulting permutation is not uniformly random.\n5.3-5 ?\nProve that in the array Pin procedure P ERMUTE -BY-SORTING , the probability\nthat all elements are unique is at least 1/NUL1=n.\n5.3-6\nExplain how to implement the algorithm P ERMUTE -BY-SORTING to handle the\ncase in which two or more priorities are identical. That is, your algorithm should\nproduce a uniform random permutation, even if two or more priorities are identical.\n5.3-7\nSuppose we want to create a random sample of the setf1; 2; 3; : : : ; ng,t h a ti s ,\nanm-element subset S,w h e r e 0/DC4m/DC4n, such that each m-subset is equally\nlikely to be created. One way would be to set A\u0152i/c141DiforiD1; 2; 3; : : : ; n ,\ncall R ANDOMIZE -IN-PLACE .A/, and then take just the \ufb01rst marray elements.\nThis method would make ncalls to the R ANDOM procedure. If nis much larger\nthanm, we can create a random sample with fewer calls to R ANDOM . Show that", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "150": {"page_number": 151, "page_information": "130 Chapter 5 Probabilistic Analysis and Randomized Algorithms\nthe following recursive procedure returns a random m-subset Soff1; 2; 3; : : : ; ng,\nin which each m-subset is equally likely, while making only mcalls to R ANDOM :\nRANDOM -SAMPLE .m; n/\n1ifm==0\n2 return;\n3elseSDRANDOM -SAMPLE .m/NUL1; n/NUL1/\n4 iDRANDOM .1; n/\n5 ifi2S\n6 SDS[fng\n7 elseSDS[fig\n8 return S\n?5.4 Probabilistic analysis and further uses of indicator random variables\nThis advanced section further illustrates probabilistic analysis by way of four ex-\namples. The \ufb01rst determines the probability that in a room of kpeople, two of\nthem share the same birthday. The second example examines what happens whenwe randomly toss balls into bins. The third investigates \u201cstreaks\u201d of consecutive\nheads when we \ufb02ip coins. The \ufb01nal example analyzes a variant of the hiring prob-\nlem in which you have to make decisions without actually interviewing all thecandidates.\n5.4.1 The birthday paradox\nOur \ufb01rst example is the birthday paradox . How many people must there be in a\nroom before there is a 50% chance that two of them were born on the same day ofthe year? The answer is surprisingly few. The paradox is that it is in fact far fewerthan the number of days in a year, or even half the number of days in a year, as weshall see.\nTo answer this question, we index the people in the room with the integers\n1 ;2;:::;k ,w h e r e kis the number of people in the room. We ignore the issue\nof leap years and assume that all years have nD365days. For iD1 ;2;:::;k ,\nletb\nibe the day of the year on which person i\u2019s birthday falls, where 1/DC4bi/DC4n.\nWe also assume that birthdays are uniformly distributed across the ndays of the\nyear, so that PrfbiDrgD1=nforiD1 ;2;:::;k andrD1 ;2;:::;n .\nThe probability that two given people, say iandj, have matching birthdays\ndepends on whether the random selection of birthdays is independent. We assumefrom now on that birthdays are independent, so that the probability that i\u2019s birthday", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "151": {"page_number": 152, "page_information": "5.4 Probabilistic analysis and further uses of indicator random variables 131\nandj\u2019s birthday both fall on day ris\nPrfbiDrandbjDrgDPrfbiDrgPrfbjDrg\nD1=n2:\nThus, the probability that they both fall on the same day is\nPrfbiDbjgDnX\nrD1PrfbiDrandbjDrg\nDnX\nrD1.1=n2/\nD1=n : (5.6)\nMore intuitively, once biis chosen, the probability that bjis chosen to be the same\nday is 1=n. Thus, the probability that iandjhave the same birthday is the same\nas the probability that the birthday of one of them falls on a given day. Notice,however, that this coincidence depends on the assumption that the birthdays areindependent.\nWe can analyze the probability of at least 2out of kpeople having matching\nbirthdays by looking at the complementary event. The probability that at least twoof the birthdays match is 1minus the probability that all the birthdays are different.\nThe event that kpeople have distinct birthdays is\nB\nkDk\\\niD1Ai;\nwhere Aiis the event that person i\u2019s birthday is different from person j\u2019s for\nallj< i . Since we can write BkDAk\\Bk/NUL1, we obtain from equation (C.16)\nthe recurrence\nPrfBkgDPrfBk/NUL1gPrfAkjBk/NUL1g; (5.7)\nwhere we take PrfB1gDPrfA1gD1as an initial condition. In other words,\nthe probability that b1;b2;:::;b kare distinct birthdays is the probability that\nb1;b2;:::;b k/NUL1are distinct birthdays times the probability that bk\u00a4bifor\niD1 ;2;:::;k/NUL1, given that b1;b2;:::;b k/NUL1are distinct.\nIfb1;b2;:::;b k/NUL1are distinct, the conditional probability that bk\u00a4bifor\niD1 ;2;:::;k/NUL1is PrfAkjBk/NUL1gD.n/NULkC1/=n , since out of the ndays,\nn/NUL.k/NUL1/days are not taken. We iteratively apply the recurrence (5.7) to obtain", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "152": {"page_number": 153, "page_information": "132 Chapter 5 Probabilistic Analysis and Randomized Algorithms\nPrfBkgDPrfBk/NUL1gPrfAkjBk/NUL1g\nDPrfBk/NUL2gPrfAk/NUL1jBk/NUL2gPrfAkjBk/NUL1g\n:::\nDPrfB1gPrfA2jB1gPrfA3jB2g/SOH/SOH/SOHPrfAkjBk/NUL1g\nD1/SOH/DC2n/NUL1\nn/DC3/DC2n/NUL2\nn/DC3\n/SOH/SOH/SOH/DC2n/NULkC1\nn/DC3\nD1/SOH/DC2\n1/NUL1\nn/DC3/DC2\n1/NUL2\nn/DC3\n/SOH/SOH/SOH/DC2\n1/NULk/NUL1\nn/DC3\n:\nInequality (3.12), 1Cx/DC4ex,g i v e su s\nPrfBkg/DC4e/NUL1=ne/NUL2=n/SOH/SOH/SOHe/NUL.k/NUL1/=n\nDe/NULPk/NUL1\niD1i=n\nDe/NULk.k/NUL1/=2n\n/DC41=2\nwhen/NULk.k/NUL1/=2n/DC4ln.1=2/ . The probability that all kbirthdays are distinct\nis at most 1=2when k.k/NUL1//NAK2nln2or, solving the quadratic equation, when\nk/NAK.1Cp\n1C.8ln2/n/=2 .F o r nD365,w em u s th a v e k/NAK23. Thus, if at\nleast 23 people are in a room, the probability is at least 1=2that at least two people\nhave the same birthday. On Mars, a year is 669 Martian days long; it thereforetakes 31Martians to get the same effect.\nAn analysis using indicator random variables\nWe can use indicator random variables to provide a simpler but approximate anal-\nysis of the birthday paradox. For each pair .i; j / of the kpeople in the room, we\nde\ufb01ne the indicator random variable X\nij,f o r1/DC4i<j/DC4k,b y\nXijDIfperson iand person jhave the same birthday g\nD(\n1if person iand person jhave the same birthday ;\n0otherwise :\nBy equation (5.6), the probability that two people have matching birthdays is 1=n,\nand thus by Lemma 5.1, we have\nE\u0152Xij/c141DPrfperson iand person jhave the same birthday g\nD1=n :\nLetting Xbe the random variable that counts the number of pairs of individuals\nhaving the same birthday, we have", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "153": {"page_number": 154, "page_information": "5.4 Probabilistic analysis and further uses of indicator random variables 133\nXDkX\niD1kX\njDiC1Xij:\nTaking expectations of both sides and applying linearity of expectation, we obtain\nE\u0152X/c141DE\"kX\niD1kX\njDiC1Xij#\nDkX\niD1kX\njDiC1E\u0152Xij/c141\nD \nk\n2!\n1\nn\nDk.k/NUL1/\n2n:\nWhen k.k/NUL1//NAK2n, therefore, the expected number of pairs of people with the\nsame birthday is at least 1. Thus, if we have at leastp\n2nC1individuals in a room,\nwe can expect at least two to have the same birthday. For nD365,i fkD28,t h e\nexpected number of pairs with the same birthday is .28/SOH27/=.2/SOH365//EM1:0356 .\nThus, with at least 28 people, we expect to \ufb01nd at least one matching pair of birth-days. On Mars, where a year is 669Martian days long, we need at least 38Mar-\ntians.\nThe \ufb01rst analysis, which used only probabilities, determined the number of peo-\nple required for the probability to exceed 1=2 that a matching pair of birthdays\nexists, and the second analysis, which used indicator random variables, determined\nthe number such that the expected number of matching birthdays is 1. Although\nthe exact numbers of people differ for the two situations, they are the same asymp-\ntotically: \u201a.p\nn/.\n5.4.2 Balls and bins\nConsider a process in which we randomly toss identical balls into bbins, numbered\n1 ;2;:::;b . The tosses are independent, and on each toss the ball is equally likely\nto end up in any bin. The probability that a tossed ball lands in any given bin is 1=b.\nThus, the ball-tossing process is a sequence of Bernoulli trials (see Appendix C.4)with a probability 1=b of success, where success means that the ball falls in the\ngiven bin. This model is particularly useful for analyzing hashing (see Chapter 11),and we can answer a variety of interesting questions about the ball-tossing process.(Problem C-1 asks additional questions about balls and bins.)", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "154": {"page_number": 155, "page_information": "134 Chapter 5 Probabilistic Analysis and Randomized Algorithms\nHow many balls fall in a given bin? The number of balls that fall in a given bin\nfollows the binomial distribution b.kIn; 1=b/ .I f w e t o s s nballs, equation (C.37)\ntells us that the expected number of balls that fall in the given bin is n=b.\nHow many balls must we toss, on the average, until a given bin contains a ball?\nThe number of tosses until the given bin receives a ball follows the geometricdistribution with probability 1=band, by equation (C.32), the expected number of\ntosses until success is 1=.1=b/Db.\nHow many balls must we toss until every bin contains at least one ball? Let us\ncall a toss in which a ball falls into an empty bin a \u201chit.\u201d We want to know the\nexpected number nof tosses required to get bhits.\nUsing the hits, we can partition the ntosses into stages. The ith stage consists of\nthe tosses after the .i/NUL1/st hit until the ith hit. The \ufb01rst stage consists of the \ufb01rst\ntoss, since we are guaranteed to have a hit when all bins are empty. For each tossduring the ith stage, i/NUL1bins contain balls and b/NULiC1bins are empty. Thus,\nfor each toss in the ith stage, the probability of obtaining a hit is .b/NULiC1/=b .\nLetn\nidenote the number of tosses in the ith stage. Thus, the number of tosses\nrequired to get bhits is nDPb\niD1ni. Each random variable nihas a geometric\ndistribution with probability of success .b/NULiC1/=b and thus, by equation (C.32),\nwe have\nE\u0152ni/c141Db\nb/NULiC1:\nBy linearity of expectation, we have\nE\u0152n/c141DE\"bX\niD1ni#\nDbX\niD1E\u0152ni/c141\nDbX\niD1b\nb/NULiC1\nDbbX\niD11\ni\nDb.lnbCO.1// (by equation (A.7)) .\nIt therefore takes approximately blnbtosses before we can expect that every bin\nhas a ball. This problem is also known as the coupon collector\u2019s problem ,w h i c h\nsays that a person trying to collect each of bdifferent coupons expects to acquire\napproximately blnbrandomly obtained coupons in order to succeed.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "155": {"page_number": 156, "page_information": "5.4 Probabilistic analysis and further uses of indicator random variables 135\n5.4.3 Streaks\nSuppose you \ufb02ip a fair coin ntimes. What is the longest streak of consecutive\nheads that you expect to see? The answer is \u201a.lgn/, as the following analysis\nshows.\nWe \ufb01rst prove that the expected length of the longest streak of heads is O.lgn/.\nThe probability that each coin \ufb02ip is a head is 1=2.L e t Aikbe the event that a\nstreak of heads of length at least kbegins with the ith coin \ufb02ip or, more precisely,\nthe event that the kconsecutive coin \ufb02ips i;iC1 ;:::;iCk/NUL1yield only heads,\nwhere 1/DC4k/DC4nand1/DC4i/DC4n/NULkC1. Since coin \ufb02ips are mutually independent,\nfor any given event Aik, the probability that all k\ufb02ips are heads is\nPrfAikgD1=2k: (5.8)\nForkD2dlgne,\nPrfAi;2dlgnegD1=22dlgne\n/DC41=22lgn\nD1=n2;\nand thus the probability that a streak of heads of length at least 2dlgnebegins in\nposition iis quite small. There are at most n/NUL2dlgneC1positions where such\na streak can begin. The probability that a streak of heads of length at least 2dlgne\nbegins anywhere is therefore\nPr(n/NUL2dlgneC1[\niD1Ai;2dlgne)\n/DC4n/NUL2dlgneC1X\niD11=n2\n<nX\niD11=n2\nD1=n ; (5.9)\nsince by Boole\u2019s inequality (C.19), the probability of a union of events is at most\nthe sum of the probabilities of the individual events. (Note that Boole\u2019s inequality\nholds even for events such as these that are not independent.)\nWe now use inequality (5.9) to bound the length of the longest streak. For\njD0; 1; 2; : : : ; n ,l e tLjbe the event that the longest streak of heads has length ex-\nactly j,a n dl e t Lbe the length of the longest streak. By the de\ufb01nition of expected\nvalue, we have\nE\u0152L/c141DnX\njD0jPrfLjg: (5.10)", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "156": {"page_number": 157, "page_information": "136 Chapter 5 Probabilistic Analysis and Randomized Algorithms\nWe could try to evaluate this sum using upper bounds on each Pr fLjgsimilar to\nthose computed in inequality (5.9). Unfortunately, this method would yield weakbounds. We can use some intuition gained by the above analysis to obtain a goodbound, however. Informally, we observe that for no individual term in the sum-mation in equation (5.10) are both the factors jand PrfL\njglarge. Why? When\nj/NAK2dlgne,t h e nP rfLjgis very small, and when j< 2dlgne,t h e n jis fairly\nsmall. More formally, we note that the events LjforjD0; 1; : : : ; n are disjoint,\nand so the probability that a streak of heads of length at least 2dlgnebegins any-\nwhere isPn\njD2dlgnePrfLjg. By inequality (5.9), we havePn\njD2dlgnePrfLjg<1 = n .\nAlso, noting thatPn\njD0PrfLjgD1,w eh a v et h a tP2dlgne/NUL1\njD0 PrfLjg/DC41. Thus,\nwe obtain\nE\u0152L/c141DnX\njD0jPrfLjg\nD2dlgne/NUL1X\njD0jPrfLjgCnX\njD2dlgnejPrfLjg\n<2dlgne/NUL1X\njD0.2dlgne/PrfLjgCnX\njD2dlgnenPrfLjg\nD2dlgne2dlgne/NUL1X\njD0PrfLjgCnnX\njD2dlgnePrfLjg\n<2dlgne/SOH1Cn/SOH.1=n/\nDO.lgn/ :\nThe probability that a streak of heads exceeds rdlgne\ufb02ips diminishes quickly\nwithr.F o r r/NAK1, the probability that a streak of at least rdlgneheads starts in\nposition iis\nPrfAi;rdlgnegD1=2rdlgne\n/DC41=nr:\nThus, the probability is at most n=nrD1=nr/NUL1that the longest streak is at\nleastrdlgne, or equivalently, the probability is at least 1/NUL1=nr/NUL1that the longest\nstreak has length less than rdlgne.\nAs an example, for nD1000 coin \ufb02ips, the probability of having a streak of at\nleast2dlgneD20heads is at most 1=nD1=1000 . The chance of having a streak\nlonger than 3dlgneD30heads is at most 1=n2D1=1,000,000.\nWe now prove a complementary lower bound: the expected length of the longest\nstreak of heads in ncoin \ufb02ips is /DEL.lgn/. To prove this bound, we look for streaks", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "157": {"page_number": 158, "page_information": "5.4 Probabilistic analysis and further uses of indicator random variables 137\nof length sby partitioning the n\ufb02ips into approximately n=s groups of s\ufb02ips\neach. If we choose sDb.lgn/=2c, we can show that it is likely that at least one\nof these groups comes up all heads, and hence it is likely that the longest streakhas length at least sD/DEL.lgn/. We then show that the longest streak has expected\nlength /DEL.lgn/.\nWe partition the ncoin \ufb02ips into at least bn=b.lgn/=2ccgroups ofb.lgn/=2c\nconsecutive \ufb02ips, and we bound the probability that no group comes up all heads.\nBy equation (5.8), the probability that the group starting in position icomes up all\nheads is\nPrfA\ni;b.lgn/=2 cgD1=2b.lgn/=2 c\n/NAK1=p\nn:\nThe probability that a streak of heads of length at least b.lgn/=2cdoes not begin\nin position iis therefore at most 1/NUL1=p\nn. Since thebn=b.lgn/=2ccgroups are\nformed from mutually exclusive, independent coin \ufb02ips, the probability that everyone of these groups fails to be a streak of length b.lgn/=2cis at most\n/NUL\n1/NUL1=p\nn/SOHbn=b.lgn/=2 cc/DC4/NUL\n1/NUL1=p\nn/SOHn=b.lgn/=2 c/NUL1\n/DC4/NUL\n1/NUL1=p\nn/SOH2n= lgn/NUL1\n/DC4e/NUL.2n= lgn/NUL1/=p\nn\nDO.e/NULlgn/\nDO.1=n/ :\nFor this argument, we used inequality (3.12), 1Cx/DC4ex, and the fact, which you\nmight want to verify, that .2n= lgn/NUL1/=p\nn/NAKlgnfor suf\ufb01ciently large n.\nThus, the probability that the longest streak exceeds b.lgn/=2cis\nnX\njDb.lgn/=2 cC1PrfLjg/NAK1/NULO.1=n/ : (5.11)\nWe can now calculate a lower bound on the expected length of the longest streak,\nbeginning with equation (5.10) and proceeding in a manner similar to our analysisof the upper bound:", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "158": {"page_number": 159, "page_information": "138 Chapter 5 Probabilistic Analysis and Randomized Algorithms\nE\u0152L/c141DnX\njD0jPrfLjg\nDb.lgn/=2 cX\njD0jPrfLjgCnX\njDb.lgn/=2 cC1jPrfLjg\n/NAKb.lgn/=2 cX\njD00/SOHPrfLjgCnX\njDb.lgn/=2 cC1b.lgn/=2cPrfLjg\nD0/SOHb.lgn/=2 cX\njD0PrfLjgCb.lgn/=2cnX\njDb.lgn/=2 cC1PrfLjg\n/NAK0Cb.lgn/=2c.1/NULO.1=n// (by inequality (5.11))\nD/DEL.lgn/ :\nAs with the birthday paradox, we can obtain a simpler but approximate analysis\nusing indicator random variables. We let XikDIfAikgbe the indicator random\nvariable associated with a streak of heads of length at least kbeginning with the\nith coin \ufb02ip. To count the total number of such streaks, we de\ufb01ne\nXDn/NULkC1X\niD1Xik:\nTaking expectations and using linearity of expectation, we have\nE\u0152X/c141DE\"n/NULkC1X\niD1Xik#\nDn/NULkC1X\niD1E\u0152Xik/c141\nDn/NULkC1X\niD1PrfAikg\nDn/NULkC1X\niD11=2k\nDn/NULkC1\n2k:\nBy plugging in various values for k, we can calculate the expected number of\nstreaks of length k. If this number is large (much greater than 1), then we expect\nmany streaks of length kto occur and the probability that one occurs is high. If", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "159": {"page_number": 160, "page_information": "5.4 Probabilistic analysis and further uses of indicator random variables 139\nthis number is small (much less than 1), then we expect few streaks of length kto\noccur and the probability that one occurs is low. If kDclgn, for some positive\nconstant c, we obtain\nE\u0152X/c141Dn/NULclgnC1\n2clgn\nDn/NULclgnC1\nnc\nD1\nnc/NUL1/NUL.clgn/NUL1/=n\nnc/NUL1\nD\u201a.1=nc/NUL1/:\nIfcis large, the expected number of streaks of length clgnis small, and we con-\nclude that they are unlikely to occur. On the other hand, if cD1=2, then we obtain\nE\u0152X/c141D\u201a.1=n1=2/NUL1/D\u201a.n1=2/, and we expect that there are a large number\nof streaks of length .1=2/ lgn. Therefore, one streak of such a length is likely to\noccur. From these rough estimates alone, we can conclude that the expected lengthof the longest streak is \u201a.lgn/.\n5.4.4 The on-line hiring problem\nAs a \ufb01nal example, we consider a variant of the hiring problem. Suppose now that\nwe do not wish to interview all the candidates in order to \ufb01nd the best one. Wealso do not wish to hire and \ufb01re as we \ufb01nd better and better applicants. Instead, weare willing to settle for a candidate who is close to the best, in exchange for hiringexactly once. We must obey one company requirement: after each interview wemust either immediately offer the position to the applicant or immediately reject the\napplicant. What is the trade-off between minimizing the amount of interviewing\nand maximizing the quality of the candidate hired?\nWe can model this problem in the following way. After meeting an applicant,\nwe are able to give each one a score; let score .i/denote the score we give to the ith\napplicant, and assume that no two applicants receive the same score. After we haveseenjapplicants, we know which of the jhas the highest score, but we do not\nknow whether any of the remaining n/NULjapplicants will receive a higher score. We\ndecide to adopt the strategy of selecting a positive integer k<n , interviewing and\nthen rejecting the \ufb01rst kapplicants, and hiring the \ufb01rst applicant thereafter who has\na higher score than all preceding applicants. If it turns out that the best-quali\ufb01edapplicant was among the \ufb01rst kinterviewed, then we hire the nth applicant. We\nformalize this strategy in the procedure O\nN-LINE-MAXIMUM .k; n/ , which returns\nthe index of the candidate we wish to hire.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "160": {"page_number": 161, "page_information": "140 Chapter 5 Probabilistic Analysis and Randomized Algorithms\nON-LINE-MAXIMUM .k; n/\n1bestscoreD/NUL1\n2foriD1tok\n3 ifscore .i/ > bestscore\n4 bestscoreDscore .i/\n5foriDkC1ton\n6 ifscore .i/ > bestscore\n7 return i\n8return n\nWe wish to determine, for each possible value of k, the probability that we\nhire the most quali\ufb01ed applicant. We then choose the best possible k,a n d\nimplement the strategy with that value. For the moment, assume that kis\n\ufb01xed. Let M.j/Dmax 1/DC4i/DC4jfscore .i/gdenote the maximum score among ap-\nplicants 1through j.L e t Sbe the event that we succeed in choosing the best-\nquali\ufb01ed applicant, and let Sibe the event that we succeed when the best-quali\ufb01ed\napplicant is the ith one interviewed. Since the various Siare disjoint, we have\nthat PrfSgDPn\niD1PrfSig. Noting that we never succeed when the best-quali\ufb01ed\napplicant is one of the \ufb01rst k,w eh a v et h a tP rfSigD0foriD1 ;2;:::;k . Thus,\nwe obtain\nPrfSgDnX\niDkC1PrfSig: (5.12)\nWe now compute Pr fSig. In order to succeed when the best-quali\ufb01ed applicant\nis the ith one, two things must happen. First, the best-quali\ufb01ed applicant must be\nin position i, an event which we denote by Bi. Second, the algorithm must not\nselect any of the applicants in positions kC1through i/NUL1, which happens only if,\nfor each jsuch that kC1/DC4j/DC4i/NUL1,w e\ufb01 n dt h a t score .j / < bestscore in line 6.\n(Because scores are unique, we can ignore the possibility of score .j /Dbestscore .)\nIn other words, all of the values score .kC1/through score .i/NUL1/must be less\nthanM.k/ ; if any are greater than M.k/ , we instead return the index of the \ufb01rst\none that is greater. We use Oito denote the event that none of the applicants in\nposition kC1through i/NUL1are chosen. Fortunately, the two events BiandOi\nare independent. The event Oidepends only on the relative ordering of the values\nin positions 1through i/NUL1, whereas Bidepends only on whether the value in\nposition iis greater than the values in all other positions. The ordering of the\nvalues in positions 1through i/NUL1does not affect whether the value in position i\nis greater than all of them, and the value in position idoes not affect the ordering\nof the values in positions 1through i/NUL1. Thus we can apply equation (C.15) to\nobtain", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "161": {"page_number": 162, "page_information": "5.4 Probabilistic analysis and further uses of indicator random variables 141\nPrfSigDPrfBi\\OigDPrfBigPrfOig:\nThe probability PrfBigis clearly 1=n, since the maximum is equally likely to\nbe in any one of the npositions. For event Oito occur, the maximum value in\npositions 1through i/NUL1, which is equally likely to be in any of these i/NUL1positions,\nmust be in one of the \ufb01rst kpositions. Consequently, Pr fOigDk=.i/NUL1/and\nPrfSigDk=.n.i/NUL1//. Using equation (5.12), we have\nPrfSgDnX\niDkC1PrfSig\nDnX\niDkC1k\nn.i/NUL1/\nDk\nnnX\niDkC11\ni/NUL1\nDk\nnn/NUL1X\niDk1\ni:\nWe approximate by integrals to bound this summation from above and below. By\nthe inequalities (A.12), we have\nZn\nk1\nxdx/DC4n/NUL1X\niDk1\ni/DC4Zn/NUL1\nk/NUL11\nxdx :\nEvaluating these de\ufb01nite integrals gives us the bounds\nk\nn.lnn/NULlnk//DC4PrfSg/DC4k\nn.ln.n/NUL1//NULln.k/NUL1// ;\nwhich provide a rather tight bound for Pr fSg. Because we wish to maximize our\nprobability of success, let us focus on choosing the value of kthat maximizes the\nlower bound on PrfSg. (Besides, the lower-bound expression is easier to maximize\nthan the upper-bound expression.) Differentiating the expression .k=n/. lnn/NULlnk/\nwith respect to k, we obtain\n1\nn.lnn/NULlnk/NUL1/ :\nSetting this derivative equal to 0, we see that we maximize the lower bound on the\nprobability when ln kDlnn/NUL1Dln.n=e/ or, equivalently, when kDn=e. Thus,\nif we implement our strategy with kDn=e, we succeed in hiring our best-quali\ufb01ed\napplicant with probability at least 1=e.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "162": {"page_number": 163, "page_information": "142 Chapter 5 Probabilistic Analysis and Randomized Algorithms\nExercises\n5.4-1\nHow many people must there be in a room before the probability that someonehas the same birthday as you do is at least 1=2? How many people must there be\nbefore the probability that at least two people have a birthday on July 4 is greater\nthan1=2?\n5.4-2\nSuppose that we toss balls into bbins until some bin contains two balls. Each toss\nis independent, and each ball is equally likely to end up in any bin. What is the\nexpected number of ball tosses?\n5.4-3 ?\nFor the analysis of the birthday paradox, is it important that the birthdays be mutu-ally independent, or is pairwise independence suf\ufb01cient? Justify your answer.\n5.4-4 ?\nHow many people should be invited to a party in order to make it likely that there\narethree people with the same birthday?\n5.4-5 ?\nWhat is the probability that a k-string over a set of size nforms a k-permutation?\nHow does this question relate to the birthday paradox?\n5.4-6 ?\nSuppose that nballs are tossed into nbins, where each toss is independent and the\nball is equally likely to end up in any bin. What is the expected number of emptybins? What is the expected number of bins with exactly one ball?\n5.4-7 ?\nSharpen the lower bound on streak length by showing that in n\ufb02ips of a fair coin,\nthe probability is less than 1=nthat no streak longer than lg n/NUL2lg lgnconsecutive\nheads occurs.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "163": {"page_number": 164, "page_information": "Problems for Chapter 5 143\nProblems\n5-1 Probabilistic counting\nWith a b-bit counter, we can ordinarily only count up to 2b/NUL1. With R. Morris\u2019s\nprobabilistic counting , we can count up to a much larger value at the expense of\nsome loss of precision.\nWe let a counter value of irepresent a count of niforiD0; 1; : : : ; 2b/NUL1,w h e r e\ntheniform an increasing sequence of nonnegative values. We assume that the ini-\ntial value of the counter is 0, representing a count of n0D0.T h e I NCREMENT\noperation works on a counter containing the value iin a probabilistic manner. If\niD2b/NUL1, then the operation reports an over\ufb02ow error. Otherwise, the I NCRE -\nMENT operation increases the counter by 1with probability 1=.n iC1/NULni/,a n di t\nleaves the counter unchanged with probability 1/NUL1=.n iC1/NULni/.\nIf we select niDifor all i/NAK0, then the counter is an ordinary one. More\ninteresting situations arise if we select, say, niD2i/NUL1fori>0 orniDFi(the\nith Fibonacci number\u2014see Section 3.2).\nFor this problem, assume that n2b/NUL1is large enough that the probability of an\nover\ufb02ow error is negligible.\na.Show that the expected value represented by the counter after nINCREMENT\noperations have been performed is exactly n.\nb.The analysis of the variance of the count represented by the counter depends\non the sequence of the ni. Let us consider a simple case: niD100i for\nalli/NAK0. Estimate the variance in the value represented by the register after n\nINCREMENT operations have been performed.\n5-2 Searching an unsorted array\nThis problem examines three algorithms for searching for a value xin an unsorted\narray Aconsisting of nelements.\nConsider the following randomized strategy: pick a random index iintoA.I f\nA\u0152i/c141Dx, then we terminate; otherwise, we continue the search by picking a new\nrandom index into A. We continue picking random indices into Auntil we \ufb01nd an\nindex jsuch that A\u0152j /c141Dxor until we have checked every element of A.N o t e\nthat we pick from the whole set of indices each time, so that we may examine agiven element more than once.\na.Write pseudocode for a procedure R\nANDOM -SEARCH to implement the strat-\negy above. Be sure that your algorithm terminates when all indices into Ahave\nbeen picked.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "164": {"page_number": 165, "page_information": "144 Chapter 5 Probabilistic Analysis and Randomized Algorithms\nb.Suppose that there is exactly one index isuch that A\u0152i/c141Dx. What is the\nexpected number of indices into Athat we must pick before we \ufb01nd xand\nRANDOM -SEARCH terminates?\nc.Generalizing your solution to part (b), suppose that there are k/NAK1indices i\nsuch that A\u0152i/c141Dx. What is the expected number of indices into Athat we\nmust pick before we \ufb01nd xand R ANDOM -SEARCH terminates? Your answer\nshould be a function of nandk.\nd.Suppose that there are no indices isuch that A\u0152i/c141Dx. What is the expected\nnumber of indices into Athat we must pick before we have checked all elements\nofAand R ANDOM -SEARCH terminates?\nNow consider a deterministic linear search algorithm, which we refer to as\nDETERMINISTIC -SEARCH . Speci\ufb01cally, the algorithm searches Aforxin order,\nconsidering A \u0152 1 /c141 ;A \u0152 2 /c141 ;A \u0152 3 /c141 ;:::;A \u0152 n /c141 until either it \ufb01nds A\u0152i/c141Dxor it reaches\nthe end of the array. Assume that all possible permutations of the input array are\nequally likely.\ne.Suppose that there is exactly one index isuch that A\u0152i/c141Dx. What is the\naverage-case running time of D ETERMINISTIC -SEARCH ? What is the worst-\ncase running time of D ETERMINISTIC -SEARCH ?\nf.Generalizing your solution to part (e), suppose that there are k/NAK1indices i\nsuch that A\u0152i/c141Dx. What is the average-case running time of D ETERMINISTIC -\nSEARCH ? What is the worst-case running time of D ETERMINISTIC -SEARCH ?\nYour answer should be a function of nandk.\ng.Suppose that there are no indices isuch that A\u0152i/c141Dx. What is the average-case\nrunning time of D ETERMINISTIC -SEARCH ? What is the worst-case running\ntime of D ETERMINISTIC -SEARCH ?\nFinally, consider a randomized algorithm S CRAMBLE -SEARCH that works by\n\ufb01rst randomly permuting the input array and then running the deterministic lin-\near search given above on the resulting permuted array.\nh.Letting kbe the number of indices isuch that A\u0152i/c141Dx, give the worst-case and\nexpected running times of S CRAMBLE -SEARCH for the cases in which kD0\nandkD1. Generalize your solution to handle the case in which k/NAK1.\ni.Which of the three searching algorithms would you use? Explain your answer.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "165": {"page_number": 166, "page_information": "Notes for Chapter 5 145\nChapter notes\nBollob\u00b4 as [53], Hofri [174], and Spencer [321] contain a wealth of advanced prob-\nabilistic techniques. The advantages of randomized algorithms are discussed andsurveyed by Karp [200] and Rabin [288]. The textbook by Motwani and Raghavan[262] gives an extensive treatment of randomized algorithms.\nSeveral variants of the hiring problem have been widely studied. These problems\nare more commonly referred to as \u201csecretary problems.\u201d An example of work inthis area is the paper by Ajtai, Meggido, and Waarts [11].", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "166": {"page_number": 167, "page_information": "II Sorting and Order Statistics", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "167": {"page_number": 168, "page_information": "Introduction\nThis part presents several algorithms that solve the following sorting problem :\nInput: A sequence of nnumbersha1;a2;:::;a ni.\nOutput: A permutation (reordering) ha0\n1;a0\n2;:::;a0\nniof the input sequence such\nthata0\n1/DC4a0\n2/DC4/SOH/SOH/SOH/DC4 a0\nn.\nThe input sequence is usually an n-element array, although it may be represented\nin some other fashion, such as a linked list.\nThe structure of the data\nIn practice, the numbers to be sorted are rarely isolated values. Each is usually part\nof a collection of data called a record . Each record contains a key, which is the\nvalue to be sorted. The remainder of the record consists of satellite data , which are\nusually carried around with the key. In practice, when a sorting algorithm permutesthe keys, it must permute the satellite data as well. If each record includes a large\namount of satellite data, we often permute an array of pointers to the records rather\nthan the records themselves in order to minimize data movement.\nIn a sense, it is these implementation details that distinguish an algorithm from\na full-blown program. A sorting algorithm describes the method by which we\ndetermine the sorted order, regardless of whether we are sorting individual numbersor large records containing many bytes of satellite data. Thus, when focusing on theproblem of sorting, we typically assume that the input consists only of numbers.Translating an algorithm for sorting numbers into a program for sorting records", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "168": {"page_number": 169, "page_information": "148 Part II Sorting and Order Statistics\nis conceptually straightforward, although in a given engineering situation other\nsubtleties may make the actual programming task a challenge.\nWhy sorting?\nMany computer scientists consider sorting to be the most fundamental problem in\nthe study of algorithms. There are several reasons:\n/SISometimes an application inherently needs to sort information. For example,in order to prepare customer statements, banks need to sort checks by checknumber.\n/SIAlgorithms often use sorting as a key subroutine. For example, a program thatrenders graphical objects which are layered on top of each other might have\nto sort the objects according to an \u201cabove\u201d relation so that it can draw these\nobjects from bottom to top. We shall see numerous algorithms in this text thatuse sorting as a subroutine.\n/SIWe can draw from among a wide variety of sorting algorithms, and they em-ploy a rich set of techniques. In fact, many important techniques used through-out algorithm design appear in the body of sorting algorithms that have beendeveloped over the years. In this way, sorting is also a problem of historicalinterest.\n/SIWe can prove a nontrivial lower bound for sorting (as we shall do in Chapter 8).Our best upper bounds match the lower bound asymptotically, and so we knowthat our sorting algorithms are asymptotically optimal. Moreover, we can usethe lower bound for sorting to prove lower bounds for certain other problems.\n/SIMany engineering issues come to the fore when implementing sorting algo-rithms. The fastest sorting program for a particular situation may depend onmany factors, such as prior knowledge about the keys and satellite data, thememory hierarchy (caches and virtual memory) of the host computer, and thesoftware environment. Many of these issues are best dealt with at the algorith-mic level, rather than by \u201ctweaking\u201d the code.\nSorting algorithms\nWe introduced two algorithms that sort nreal numbers in Chapter 2. Insertion sort\ntakes \u201a.n\n2/time in the worst case. Because its inner loops are tight, however,\nit is a fast in-place sorting algorithm for small input sizes. (Recall that a sortingalgorithm sorts in place if only a constant number of elements of the input ar-\nray are ever stored outside the array.) Merge sort has a better asymptotic runningtime, \u201a.n lgn/,b u tt h eM\nERGE procedure it uses does not operate in place.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "169": {"page_number": 170, "page_information": "Part II Sorting and Order Statistics 149\nIn this part, we shall introduce two more algorithms that sort arbitrary real num-\nbers. Heapsort, presented in Chapter 6, sorts nnumbers in place in O.n lgn/time.\nIt uses an important data structure, called a heap, with which we can also imple-ment a priority queue.\nQuicksort, in Chapter 7, also sorts nnumbers in place, but its worst-case running\ntime is \u201a.n\n2/. Its expected running time is \u201a.n lgn/, however, and it generally\noutperforms heapsort in practice. Like insertion sort, quicksort has tight code, andso the hidden constant factor in its running time is small. It is a popular algorithm\nfor sorting large input arrays.\nInsertion sort, merge sort, heapsort, and quicksort are all comparison sorts: they\ndetermine the sorted order of an input array by comparing elements. Chapter 8 be-gins by introducing the decision-tree model in order to study the performance limi-tations of comparison sorts. Using this model, we prove a lower bound of /DEL.n lgn/\non the worst-case running time of any comparison sort on ninputs, thus showing\nthat heapsort and merge sort are asymptotically optimal comparison sorts.\nChapter 8 then goes on to show that we can beat this lower bound of /DEL.n lgn/\nif we can gather information about the sorted order of the input by means other\nthan comparing elements. The counting sort algorithm, for example, assumes that\nthe input numbers are in the set f0; 1; : : : ; kg. By using array indexing as a tool\nfor determining relative order, counting sort can sort nnumbers in \u201a.kCn/time.\nThus, when kDO.n/ , counting sort runs in time that is linear in the size of the\ninput array. A related algorithm, radix sort, can be used to extend the range of\ncounting sort. If there are nintegers to sort, each integer has ddigits, and each\ndigit can take on up to kpossible values, then radix sort can sort the numbers\nin\u201a.d.nCk//time. When dis a constant and kisO.n/ , radix sort runs in\nlinear time. A third algorithm, bucket sort, requires knowledge of the probabilisticdistribution of numbers in the input array. It can sort nreal numbers uniformly\ndistributed in the half-open interval \u01520; 1/ in average-case O.n/ time.\nThe following table summarizes the running times of the sorting algorithms from\nChapters 2 and 6\u20138. As usual, ndenotes the number of items to sort. For counting\nsort, the items to sort are integers in the set f0; 1; : : : ; kg. For radix sort, each item\nis ad-digit number, where each digit takes on kpossible values. For bucket sort,\nwe assume that the keys are real numbers uniformly distributed in the half-openinterval \u01520; 1/ . The rightmost column gives the average-case or expected running\ntime, indicating which it gives when it differs from the worst-case running time.We omit the average-case running time of heapsort because we do not analyze it inthis book.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "170": {"page_number": 171, "page_information": "150 Part II Sorting and Order Statistics\nWorst-case Average-case/expected\nAlgorithm\n running time running time\nInsertion sort\n \u201a.n2/ \u201a.n2/\nMerge sort\n \u201a.n lgn/ \u201a.n lgn/\nHeapsort\n O.n lgn/ \u2014\nQuicksort\n \u201a.n2/ \u201a.n lgn/ (expected)\nCounting sort\n \u201a.kCn/ \u201a.kCn/\nRadix sort\n \u201a.d.nCk// \u201a.d.nCk//\nBucket sort\n \u201a.n2/ \u201a.n/ (average-case)\nOrder statistics\nTheith order statistic of a set of nnumbers is the ith smallest number in the set.\nWe can, of course, select the ith order statistic by sorting the input and indexing\ntheith element of the output. With no assumptions about the input distribution,\nthis method runs in /DEL.n lgn/time, as the lower bound proved in Chapter 8 shows.\nIn Chapter 9, we show that we can \ufb01nd the ith smallest element in O.n/ time,\neven when the elements are arbitrary real numbers. We present a randomized algo-rithm with tight pseudocode that runs in \u201a.n\n2/time in the worst case, but whose\nexpected running time is O.n/ . We also give a more complicated algorithm that\nruns in O.n/ worst-case time.\nBackground\nAlthough most of this part does not rely on dif\ufb01cult mathematics, some sections\ndo require mathematical sophistication. In particular, analyses of quicksort, bucketsort, and the order-statistic algorithm use probability, which is reviewed in Ap-pendix C, and the material on probabilistic analysis and randomized algorithms inChapter 5. The analysis of the worst-case linear-time algorithm for order statis-tics involves somewhat more sophisticated mathematics than the other worst-caseanalyses in this part.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "171": {"page_number": 172, "page_information": "6H e a p s o r t\nIn this chapter, we introduce another sorting algorithm: heapsort. Like merge sort,\nbut unlike insertion sort, heapsort\u2019s running time is O.n lgn/. Like insertion sort,\nbut unlike merge sort, heapsort sorts in place: only a constant number of arrayelements are stored outside the input array at any time. Thus, heapsort combinesthe better attributes of the two sorting algorithms we have already discussed.\nHeapsort also introduces another algorithm design technique: using a data struc-\nture, in this case one we call a \u201cheap,\u201d to manage information. Not only is the heapdata structure useful for heapsort, but it also makes an ef\ufb01cient priority queue. Theheap data structure will reappear in algorithms in later chapters.\nThe term \u201cheap\u201d was originally coined in the context of heapsort, but it has since\ncome to refer to \u201cgarbage-collected storage,\u201d such as the programming languages\nJava and Lisp provide. Our heap data structure is notgarbage-collected storage,\nand whenever we refer to heaps in this book, we shall mean a data structure ratherthan an aspect of garbage collection.\n6.1 Heaps\nThe(binary) heap data structure is an array object that we can view as a\nnearly complete binary tree (see Section B.5.3), as shown in Figure 6.1. Eachnode of the tree corresponds to an element of the array. The tree is com-pletely \ufb01lled on all levels except possibly the lowest, which is \ufb01lled from theleft up to a point. An array Athat represents a heap is an object with two at-\ntributes: A:length , which (as usual) gives the number of elements in the array, and\nA:heap -size, which represents how many elements in the heap are stored within\narray A. That is, although A\u01521 : : A: length /c141may contain numbers, only the ele-\nments in A\u01521 : : A: heap -size/c141,w h e r e 0/DC4A:heap -size/DC4A:length , are valid ele-\nments of the heap. The root of the tree is A\u01521/c141, and given the index iof a node, we\ncan easily compute the indices of its parent, left child, and right child:", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "172": {"page_number": 173, "page_information": "152 Chapter 6 Heapsort\n(a)1 6 1 4 1 0 8793241123456789 1 0\n(b)1\n23\n45 67\n89 1 016\n14 10\n87 93\n241\nFigure 6.1 A max-heap viewed as (a)ab i n a r yt r e ea n d (b)an array. The number within the circle\nat each node in the tree is the value stored at that node. The number above a node is the corresponding\nindex in the array. Above and below the array are lines showing parent-child relationships; parents\nare always to the left of their children. The tree has height three; the node at index 4 (with value 8)has height one.\nPARENT .i/\n1returnbi=2c\nLEFT.i/\n1return 2i\nRIGHT.i/\n1return 2iC1\nOn most computers, the L EFT procedure can compute 2iin one instruction by\nsimply shifting the binary representation of ileft by one bit position. Similarly, the\nRIGHT procedure can quickly compute 2iC1by shifting the binary representation\nofileft by one bit position and then adding in a 1as the low-order bit. The\nPARENT procedure can compute bi=2cby shifting iright one bit position. Good\nimplementations of heapsort often implement these procedures as \u201cmacros\u201d or \u201cin-line\u201d procedures.\nThere are two kinds of binary heaps: max-heaps and min-heaps. In both kinds,\nthe values in the nodes satisfy a heap property , the speci\ufb01cs of which depend on\nthe kind of heap. In a max-heap ,t h emax-heap property is that for every node i\nother than the root,\nA\u0152P\nARENT .i//c141/NAKA\u0152i/c141 ;\nthat is, the value of a node is at most the value of its parent. Thus, the largest\nelement in a max-heap is stored at the root, and the subtree rooted at a node contains", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "173": {"page_number": 174, "page_information": "6.1 Heaps 153\nvalues no larger than that contained at the node itself. A min-heap is organized in\nthe opposite way; the min-heap property is that for every node iother than the\nroot,\nA\u0152PARENT .i//c141/DC4A\u0152i/c141 :\nThe smallest element in a min-heap is at the root.\nFor the heapsort algorithm, we use max-heaps. Min-heaps commonly imple-\nment priority queues, which we discuss in Section 6.5. We shall be precise in\nspecifying whether we need a max-heap or a min-heap for any particular applica-tion, and when properties apply to either max-heaps or min-heaps, we just use theterm \u201cheap.\u201d\nViewing a heap as a tree, we de\ufb01ne the height of a node in a heap to be the\nnumber of edges on the longest simple downward path from the node to a leaf, andwe de\ufb01ne the height of the heap to be the height of its root. Since a heap of nele-\nments is based on a complete binary tree, its height is \u201a.lgn/(see Exercise 6.1-2).\nWe shall see that the basic operations on heaps run in time at most proportionalto the height of the tree and thus take O.lgn/time. The remainder of this chapter\npresents some basic procedures and shows how they are used in a sorting algorithmand a priority-queue data structure.\n/SIThe M AX-HEAPIFY procedure, which runs in O.lgn/time, is the key to main-\ntaining the max-heap property.\n/SIThe B UILD -MAX-HEAP procedure, which runs in linear time, produces a max-\nheap from an unordered input array.\n/SIThe H EAPSORT procedure, which runs in O.n lgn/time, sorts an array in\nplace.\n/SIThe M AX-HEAP-INSERT ,H EAP-EXTRACT -MAX,H EAP-INCREASE -KEY,\nand H EAP-MAXIMUM procedures, which run in O.lgn/time, allow the heap\ndata structure to implement a priority queue.\nExercises\n6.1-1\nWhat are the minimum and maximum numbers of elements in a heap of height h?\n6.1-2\nShow that an n-element heap has height blgnc.\n6.1-3\nShow that in any subtree of a max-heap, the root of the subtree contains the largestvalue occurrin\nganywhere in that subtree.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "174": {"page_number": 175, "page_information": "154 Chapter 6 Heapsort\n6.1-4\nWhere in a max-heap might the smallest element reside, assuming that all elementsare distinct?\n6.1-5\nIs an array that is in sorted order a min-heap?\n6.1-6\nIs the array with values h23; 17; 14; 6; 13; 10; 1; 5; 7; 12 ia max-heap?\n6.1-7\nShow that, with the array representation for storing an n-element heap, the leaves\nare the nodes indexed by bn=2cC1;bn=2cC2;:::;n .\n6.2 Maintaining the heap property\nIn order to maintain the max-heap property, we call the procedure M AX-HEAPIFY .\nIts inputs are an array Aa n da ni n d e x iinto the array. When it is called, M AX-\nHEAPIFY assumes that the binary trees rooted at L EFT.i/and R IGHT.i/are max-\nheaps, but that A\u0152i/c141 might be smaller than its children, thus violating the max-heap\nproperty. M AX-HEAPIFY lets the value at A\u0152i/c141 \u201c\ufb02oat down\u201d in the max-heap so\nthat the subtree rooted at index iobeys the max-heap property.\nMAX-HEAPIFY .A; i/\n1lDLEFT.i/\n2rDRIGHT.i/\n3ifl/DC4A:heap -sizeandA\u0152l/c141 > A\u0152i/c141\n4 largestDl\n5elselargestDi\n6ifr/DC4A:heap -sizeandA\u0152r/c141 > A\u0152 largest /c141\n7 largestDr\n8iflargest\u00a4i\n9 exchange A\u0152i/c141 withA\u0152largest /c141\n10 M AX-HEAPIFY .A;largest /\nFigure 6.2 illustrates the action of M AX-HEAPIFY . At each step, the largest of\nthe elements A\u0152i/c141,A\u0152LEFT.i//c141,a n d A\u0152RIGHT.i//c141is determined, and its index is\nstored in largest .I fA\u0152i/c141 is largest, then the subtree rooted at node iis already a\nmax-heap and the procedure terminates. Otherwise, one of the two children has thelargest element, and A\u0152i/c141 is swapped with A\u0152largest /c141, which causes node iand its", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "175": {"page_number": 176, "page_information": "6.2 Maintaining the heap property 155\n16\n41 0\n14 7 9\n281\n(a)16\n14 10\n47 93\n281\n(b)\n16\n14 10\n87 93\n241\n(c)31\n3\n45 67\n91 02\n81\n3\n45 67\n91 02\n8\n1\n3\n45 67\n91 02\n8i\ni\ni\nFigure 6.2 The action of M AX-HEAPIFY .A; 2/ ,w h e r e A:heap -sizeD10.(a)The initial con-\n\ufb01guration, with A\u01522/c141 at node iD2violating the max-heap property since it is not larger than\nboth children. The max-heap property is restored for node 2in(b)by exchanging A\u01522/c141 withA\u01524/c141,\nwhich destroys the max-heap property for node 4. The recursive call M AX-HEAPIFY .A; 4/ now\nhasiD4. After swapping A\u01524/c141 withA\u01529/c141,a ss h o w ni n (c), node 4is \ufb01xed up, and the recursive call\nMAX-HEAPIFY .A; 9/ yields no further change to the data structure.\nchildren to satisfy the max-heap property. The node indexed by largest ,h o w e v e r ,\nnow has the original value A\u0152i/c141, and thus the subtree rooted at largest might violate\nthe max-heap property. Consequently, we call M AX-HEAPIFY recursively on that\nsubtree.\nThe running time of M AX-HEAPIFY on a subtree of size nrooted at a given\nnode iis the \u201a.1/ time to \ufb01x up the relationships among the elements A\u0152i/c141,\nA\u0152LEFT.i//c141,a n d A\u0152RIGHT.i//c141, plus the time to run M AX-HEAPIFY on a subtree\nrooted at one of the children of node i(assuming that the recursive call occurs).\nThe children\u2019s subtrees each have size at most 2n=3 \u2014the worst case occurs when\nthe bottom level of the tree is exactly half full\u2014and therefore we can describe the\nrunning time of M AX-HEAPIFY by the recurrence\nT .n//DC4T .2n=3/C\u201a.1/ :", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "176": {"page_number": 177, "page_information": "156 Chapter 6 Heapsort\nThe solution to this recurrence, by case 2 of the master theorem (Theorem 4.1),\nisT .n/DO.lgn/. Alternatively, we can characterize the running time of M AX-\nHEAPIFY on a node of height hasO.h/ .\nExercises\n6.2-1\nUsing Figure 6.2 as a model, illustrate the operation of M AX-HEAPIFY .A; 3/ on\nthe array ADh27; 17; 3; 16; 13; 10; 1; 5; 7; 12; 4; 8; 9; 0 i.\n6.2-2\nStarting with the procedure M AX-HEAPIFY , write pseudocode for the procedure\nMIN-HEAPIFY .A; i/ , which performs the corresponding manipulation on a min-\nheap. How does the running time of M IN-HEAPIFY compare to that of M AX-\nHEAPIFY ?\n6.2-3\nWhat is the effect of calling M AX-HEAPIFY .A; i/ when the element A\u0152i/c141 is larger\nthan its children?\n6.2-4\nWhat is the effect of calling M AX-HEAPIFY .A; i/ fori>A : heap -size=2?\n6.2-5\nThe code for M AX-HEAPIFY is quite ef\ufb01cient in terms of constant factors, except\npossibly for the recursive call in line 10, which might cause some compilers to\nproduce inef\ufb01cient code. Write an ef\ufb01cient M AX-HEAPIFY that uses an iterative\ncontrol construct (a loop) instead of recursion.\n6.2-6\nShow that the worst-case running time of M AX-HEAPIFY on a heap of size n\nis/DEL.lgn/.(Hint: For a heap with nnodes, give node values that cause M AX-\nHEAPIFY to be called recursively at every node on a simple path from the root\ndown to a leaf.)\n6.3 Building a heap\nWe can use the procedure M AX-HEAPIFY in a bottom-up manner to convert an\narray A\u01521 : : n/c141 ,w h e r e nDA:length , into a max-heap. By Exercise 6.1-7, the\nelements in the subarray A\u0152.bn=2cC1 /::n /c141 are all leaves of the tree, and so each is", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "177": {"page_number": 178, "page_information": "6.3 Building a heap 157\na1-element heap to begin with. The procedure B UILD -MAX-HEAP goes through\nthe remaining nodes of the tree and runs M AX-HEAPIFY on each one.\nBUILD -MAX-HEAP.A/\n1A:heap -sizeDA:length\n2foriDbA:length =2cdownto 1\n3M AX-HEAPIFY .A; i/\nFigure 6.3 shows an example of the action of B UILD -MAX-HEAP.\nTo show why B UILD -MAX-HEAP works correctly, we use the following loop\ninvariant:\nAt the start of each iteration of the forloop of lines 2\u20133, each node iC1;\niC2 ;:::;n is the root of a max-heap.\nWe need to show that this invariant is true prior to the \ufb01rst loop iteration, that each\niteration of the loop maintains the invariant, and that the invariant provides a usefulproperty to show correctness when the loop terminates.\nInitialization: Prior to the \ufb01rst iteration of the loop, iDbn=2c. Each node\nbn=2cC1;bn=2cC2;:::;n is a leaf and is thus the root of a trivial max-heap.\nMaintenance: To see that each iteration maintains the loop invariant, observe that\nthe children of node iare numbered higher than i. By the loop invariant, there-\nfore, they are both roots of max-heaps. This is precisely the condition requiredfor the call M\nAX-HEAPIFY .A; i/ to make node ia max-heap root. Moreover,\nthe M AX-HEAPIFY call preserves the property that nodes iC1; iC2;:::;n\nare all roots of max-heaps. Decrementing iin the forloop update reestablishes\nthe loop invariant for the next iteration.\nTermination: At termination, iD0. By the loop invariant, each node 1 ;2;:::;n\nis the root of a max-heap. In particular, node 1is.\nWe can compute a simple upper bound on the running time of B UILD -MAX-\nHEAP as follows. Each call to M AX-HEAPIFY costs O.lgn/time, and B UILD -\nMAX-HEAP makes O.n/ such calls. Thus, the running time is O.n lgn/.T h i s\nupper bound, though correct, is not asymptotically tight.\nWe can derive a tighter bound by observing that the time for M AX-HEAPIFY to\nrun at a node varies with the height of the node in the tree, and the heights of mostnodes are small. Our tighter analysis relies on the properties that an n-element heap\nhas heightblgnc(see Exercise 6.1-2) and at most\u02d9\nn=2\nhC1/BEL\nnodes of any height h\n(see Exercise 6.3-3).\nThe time required by M AX-HEAPIFY when called on a node of height hisO.h/ ,\nand so we can express the total cost of B UILD -MAX-HEAP as being bounded from\nabove by", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "178": {"page_number": 179, "page_information": "158 Chapter 6 Heapsort\n1\n23\n45 67\n89 1 01\n23\n45 67\n89 1 01\n23\n45 67\n89 1 01\n23\n45 67\n89 1 01\n23\n45 67\n89 1 01\n23\n45 67\n89 1 04\n13\n29 1 0\n14 8 7\n(a)1641 2 3 16 9 10 14 8 7\n4\n13\n29 1 0\n14 8 7\n(b)16\n4\n13\n14 9 10\n287\n(c)164\n11 0\n14 9 3\n287\n(d)16\n4\n16 10\n14 9 3\n281\n(e)716\n14 10\n89 3\n241\n(f)7A\nii\ni i\ni\nFigure 6.3 The operation of B UILD -MAX-HEAP, showing the data structure before the call to\nMAX-HEAPIFY in line 3 of B UILD -MAX-HEAP.(a)A 10-element input array Aand the bi-\nnary tree it represents. The \ufb01gure shows that the loop index irefers to node 5before the call\nMAX-HEAPIFY .A; i/ .(b)The data structure that results. The loop index ifor the next iteration\nrefers to node 4.(c)\u2013(e) Subsequent iterations of the forloop in B UILD -MAX-HEAP. Observe that\nwhenever M AX-HEAPIFY is called on a node, the two subtrees of that node are both max-heaps.\n(f)The max-heap after B UILD -MAX-HEAP\ufb01nishes.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "179": {"page_number": 180, "page_information": "6.4 The heapsort algorithm 159\nblgncX\nhD0ln\n2hC1m\nO.h/DO \nnblgncX\nhD0h\n2h!\n:\nWe evalaute the last summation by substituting xD1=2 in the formula (A.8),\nyielding\n1X\nhD0h\n2hD1=2\n.1/NUL1=2/2\nD2:\nThus, we can bound the running time of B UILD -MAX-HEAP as\nO \nnblgncX\nhD0h\n2h!\nDO \nn1X\nhD0h\n2h!\nDO.n/ :\nHence, we can build a max-heap from an unordered array in linear time.\nWe can build a min-heap by the procedure B UILD -MIN-HEAP, which is the\nsame as B UILD -MAX-HEAP but with the call to M AX-HEAPIFY in line 3 replaced\nby a call to M IN-HEAPIFY (see Exercise 6.2-2). B UILD -MIN-HEAP produces a\nmin-heap from an unordered linear array in linear time.\nExercises\n6.3-1\nUsing Figure 6.3 as a model, illustrate the operation of B UILD -MAX-HEAP on the\narray ADh5; 3; 17; 10; 84; 19; 6; 22; 9 i.\n6.3-2\nWhy do we want the loop index iin line 2 of B UILD -MAX-HEAP to decrease from\nbA:length =2cto1rather than increase from 1tobA:length =2c?\n6.3-3\nShow that there are at most\u02d9\nn=2hC1/BEL\nnodes of height hin any n-element heap.\n6.4 The heapsort algorithm\nThe heapsort algorithm starts by using B UILD -MAX-HEAP to build a max-heap\non the input array A\u01521 : : n/c141 ,w h e r e nDA:length . Since the maximum element\nof the array is stored at the root A\u01521/c141, we can put it into its correct \ufb01nal position", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "180": {"page_number": 181, "page_information": "160 Chapter 6 Heapsort\nby exchanging it with A\u0152n/c141. If we now discard node nfrom the heap\u2014and we\ncan do so by simply decrementing A:heap -size\u2014we observe that the children of\nthe root remain max-heaps, but the new root element might violate the max-heapproperty. All we need to do to restore the max-heap property, however, is call\nM\nAX-HEAPIFY .A; 1/ , which leaves a max-heap in A\u01521 : : n/NUL1/c141. The heapsort\nalgorithm then repeats this process for the max-heap of size n/NUL1down to a heap\nof size 2. (See Exercise 6.4-2 for a precise loop invariant.)\nHEAPSORT .A/\n1B UILD -MAX-HEAP.A/\n2foriDA:length downto 2\n3 exchange A\u01521/c141 withA\u0152i/c141\n4 A:heap -sizeDA:heap -size/NUL1\n5M AX-HEAPIFY .A; 1/\nFigure 6.4 shows an example of the operation of H EAPSORT after line 1 has built\nthe initial max-heap. The \ufb01gure shows the max-heap before the \ufb01rst iteration oftheforloop of lines 2\u20135 and after each iteration.\nThe H\nEAPSORT procedure takes time O.n lgn/, since the call to B UILD -MAX-\nHEAP takes time O.n/ and each of the n/NUL1calls to M AX-HEAPIFY takes\ntimeO.lgn/.\nExercises\n6.4-1\nUsing Figure 6.4 as a model, illustrate the operation of H EAPSORT on the array\nADh5; 13; 2; 25; 7; 17; 20; 8; 4 i.\n6.4-2\nArgue the correctness of H EAPSORT using the following loop invariant:\nAt the start of each iteration of the forloop of lines 2\u20135, the subarray\nA\u01521 : : i/c141 is a max-heap containing the ismallest elements of A\u01521 : : n/c141 ,a n d\nthe subarray A\u0152iC1::n /c141 contains the n/NULilargest elements of A\u01521 : : n/c141 ,\nsorted.\n6.4-3\nWhat is the running time of H EAPSORT on an array Aof length nthat is already\nsorted in increasing order? What about decreasing order?\n6.4-4\nShow that the worst-case running time of H EAPSORT is/DEL.n lgn/.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "181": {"page_number": 182, "page_information": "6.4 The heapsort algorithm 161\n(a) (b) (c)\n(d) (e) (f)\n(g) (h) (i)\n(j) (k)1234789 1 0 1 4 1 6102\n13\n47 89\n16 14\n1\n23\n47 89\n16 14 103\n21\n9 8 7 4\n10 14 164\n23\n9 8 7 1\n10 14 168\n3 7\n42 19\n16 14 107\n43\n9 8 2 1\n10 14 169\n83\n2 1 7 4\n16 14 1010\n89\n3 1 7 4\n16 14214\n81 0\n3 9 7 4\n161 216\n14 10\n3 9 7 8\n1 4 2\nAii\niii\niii\ni\nFigure 6.4 The operation of H EAPSORT .(a)The max-heap data structure just after B UILD -MAX-\nHEAP has built it in line 1. (b)\u2013(j) The max-heap just after each call of M AX-HEAPIFY in line 5,\nshowing the value of iat that time. Only lightly shaded nodes remain in the heap. (k)The resulting\nsorted array A.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "182": {"page_number": 183, "page_information": "162 Chapter 6 Heapsort\n6.4-5 ?\nShow that when all elements are distinct, the best-case running time of H EAPSORT\nis/DEL.n lgn/.\n6.5 Priority queues\nHeapsort is an excellent algorithm, but a good implementation of quicksort, pre-\nsented in Chapter 7, usually beats it in practice. Nevertheless, the heap data struc-ture itself has many uses. In this section, we present one of the most popular ap-plications of a heap: as an ef\ufb01cient priority queue. As with heaps, priority queuescome in two forms: max-priority queues and min-priority queues. We will focushere on how to implement max-priority queues, which are in turn based on max-heaps; Exercise 6.5-3 asks you to write the procedures for min-priority queues.\nApriority queue is a data structure for maintaining a set Sof elements, each\nwith an associated value called a key.Amax-priority queue supports the following\noperations:\nI\nNSERT .S; x/ inserts the element xinto the set S, which is equivalent to the oper-\nation SDS[fxg.\nMAXIMUM .S/returns the element of Swith the largest key.\nEXTRACT -MAX.S/removes and returns the element of Swith the largest key.\nINCREASE -KEY. S;x;k/ increases the value of element x\u2019s key to the new value k,\nwhich is assumed to be at least as large as x\u2019s current key value.\nAmong their other applications, we can use max-priority queues to schedule\njobs on a shared computer. The max-priority queue keeps track of the jobs tobe performed and their relative priorities. When a job is \ufb01nished or interrupted,the scheduler selects the highest-priority job from among those pending by calling\nE\nXTRACT -MAX. The scheduler can add a new job to the queue at any time by\ncalling I NSERT .\nAlternatively, a min-priority queue supports the operations I NSERT ,MINIMUM ,\nEXTRACT -MIN,a n dD ECREASE -KEY. A min-priority queue can be used in an\nevent-driven simulator. The items in the queue are events to be simulated, eachwith an associated time of occurrence that serves as its key. The events must besimulated in order of their time of occurrence, because the simulation of an eventcan cause other events to be simulated in the future. The simulation program calls\nE\nXTRACT -MINat each step to choose the next event to simulate. As new events are\nproduced, the simulator inserts them into the min-priority queue by calling I NSERT .", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "183": {"page_number": 184, "page_information": "6.5 Priority queues 163\nWe shall see other uses for min-priority queues, highlighting the D ECREASE -KEY\noperation, in Chapters 23 and 24.\nNot surprisingly, we can use a heap to implement a priority queue. In a given ap-\nplication, such as job scheduling or event-driven simulation, elements of a priorityqueue correspond to objects in the application. We often need to determine whichapplication object corresponds to a given priority-queue element, and vice versa.When we use a heap to implement a priority queue, therefore, we often need tostore a handle to the corresponding application object in each heap element. The\nexact makeup of the handle (such as a pointer or an integer) depends on the ap-\nplication. Similarly, we need to store a handle to the corresponding heap elementin each application object. Here, the handle would typically be an array index.Because heap elements change locations within the array during heap operations,an actual implementation, upon relocating a heap element, would also have to up-date the array index in the corresponding application object. Because the detailsof accessing application objects depend heavily on the application and its imple-mentation, we shall not pursue them here, other than noting that in practice, thesehandles do need to be correctly maintained.\nNow we discuss how to implement the operations of a max-priority queue. The\nprocedure H\nEAP-MAXIMUM implements the M AXIMUM operation in \u201a.1/ time.\nHEAP-MAXIMUM .A/\n1return A\u01521/c141\nThe procedure H EAP-EXTRACT -MAXimplements the E XTRACT -MAXopera-\ntion. It is similar to the forloop body (lines 3\u20135) of the H EAPSORT procedure.\nHEAP-EXTRACT -MAX.A/\n1ifA:heap -size<1\n2 error \u201cheap under\ufb02ow\u201d\n3maxDA\u01521/c141\n4A\u01521/c141DA\u0152A: heap -size/c141\n5A:heap -sizeDA:heap -size/NUL1\n6M AX-HEAPIFY .A; 1/\n7return max\nThe running time of H EAP-EXTRACT -MAXisO.lgn/, since it performs only a\nconstant amount of work on top of the O.lgn/time for M AX-HEAPIFY .\nThe procedure H EAP-INCREASE -KEYimplements the I NCREASE -KEYopera-\ntion. An index iinto the array identi\ufb01es the priority-queue element whose key we\nwish to increase. The procedure \ufb01rst updates the key of element A\u0152i/c141 to its new\nvalue. Because increasing the key of A\u0152i/c141 might violate the max-heap property,", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "184": {"page_number": 185, "page_information": "164 Chapter 6 Heapsort\nthe procedure then, in a manner reminiscent of the insertion loop (lines 5\u20137) of\nINSERTION -SORT from Section 2.1, traverses a simple path from this node toward\nthe root to \ufb01nd a proper place for the newly increased key. As H EAP-INCREASE -\nKEYtraverses this path, it repeatedly compares an element to its parent, exchang-\ning their keys and continuing if the element\u2019s key is larger, and terminating if the el-ement\u2019s key is smaller, since the max-heap property now holds. (See Exercise 6.5-5for a precise loop invariant.)\nH\nEAP-INCREASE -KEY.A; i; key/\n1ifkey< A\u0152i/c141\n2 error \u201cnew key is smaller than current key\u201d\n3A\u0152i/c141Dkey\n4while i>1 andA\u0152PARENT .i//c141 < A\u0152i/c141\n5 exchange A\u0152i/c141 withA\u0152PARENT .i//c141\n6 iDPARENT .i/\nFigure 6.5 shows an example of a H EAP-INCREASE -KEYoperation. The running\ntime of H EAP-INCREASE -KEYon an n-element heap is O.lgn/, since the path\ntraced from the node updated in line 3 to the root has length O.lgn/.\nThe procedure M AX-HEAP-INSERT implements the I NSERT operation. It takes\nas an input the key of the new element to be inserted into max-heap A. The proce-\ndure \ufb01rst expands the max-heap by adding to the tree a new leaf whose key is /NUL1.\nThen it calls H EAP-INCREASE -KEYto set the key of this new node to its correct\nvalue and maintain the max-heap property.\nMAX-HEAP-INSERT .A;key/\n1A:heap -sizeDA:heap -sizeC1\n2A\u0152A: heap -size/c141D/NUL1\n3H EAP-INCREASE -KEY.A; A: heap -size;key/\nThe running time of M AX-HEAP-INSERT on an n-element heap is O.lgn/.\nIn summary, a heap can support any priority-queue operation on a set of size n\ninO.lgn/time.\nExercises\n6.5-1\nIllustrate the operation of H EAP-EXTRACT -MAXon the heap ADh15; 13; 9; 5;\n1 2;8 ;7 ;4;0 ;6 ;2;1i.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "185": {"page_number": 186, "page_information": "6.5 Priority queues 165\n16\n14 10\n87 93\n241\n(a)i16\n14 10\n87 93\n2 15 1\n(b)\n16\n14 10\n879 3\n215\n1\n(c)i\ni16\n1410\n879 3\n215\n1\n(d)i\nFigure 6.5 The operation of H EAP-INCREASE -KEY.(a)The max-heap of Figure 6.4(a) with a\nnode whose index is iheavily shaded. (b)This node has its key increased to 15.(c)After one\niteration of the while loop of lines 4\u20136, the node and its parent have exchanged keys, and the index i\nmoves up to the parent. (d)The max-heap after one more iteration of the while loop. At this point,\nA\u0152PARENT .i//c141/NAKA\u0152i/c141. The max-heap property now holds and the procedure terminates.\n6.5-2\nIllustrate the operation of M AX-HEAP-INSERT .A; 10/ on the heap ADh15; 13; 9;\n5 ;1 2;8 ;7 ;4;0 ;6 ;2;1 i.\n6.5-3\nWrite pseudocode for the procedures H EAP-MINIMUM ,H EAP-EXTRACT -MIN,\nHEAP-DECREASE -KEY,a n dM IN-HEAP-INSERT that implement a min-priority\nqueue with a min-heap.\n6.5-4\nWhy do we bother setting the key of the inserted node to /NUL1 in line 2 of M AX-\nHEAP-INSERT when the next thing we do is increase its key to the desired value?", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "186": {"page_number": 187, "page_information": "166 Chapter 6 Heapsort\n6.5-5\nArgue the correctness of H EAP-INCREASE -KEYusing the following loop invari-\nant:\nAt the start of each iteration of the while loop of lines 4\u20136, the subarray\nA\u01521 : : A: heap -size/c141satis\ufb01es the max-heap property, except that there may\nbe one violation: A\u0152i/c141 may be larger than A\u0152PARENT .i//c141.\nYou may assume that the subarray A\u01521 : : A: heap -size/c141satis\ufb01es the max-heap prop-\nerty at the time H EAP-INCREASE -KEYis called.\n6.5-6\nEach exchange operation on line 5 of H EAP-INCREASE -KEYtypically requires\nthree assignments. Show how to use the idea of the inner loop of I NSERTION -\nSORT to reduce the three assignments down to just one assignment.\n6.5-7\nShow how to implement a \ufb01rst-in, \ufb01rst-out queue with a priority queue. Showhow to implement a stack with a priority queue. (Queues and stacks are de\ufb01ned inSection 10.1.)\n6.5-8\nThe operation H\nEAP-DELETE .A; i/ deletes the item in node ifrom heap A.G i v e\nan implementation of H EAP-DELETE that runs in O.lgn/time for an n-element\nmax-heap.\n6.5-9\nGive an O.n lgk/-time algorithm to merge ksorted lists into one sorted list,\nwhere nis the total number of elements in all the input lists. ( Hint: Use a min-\nheap for k-way merging.)\nProblems\n6-1 Building a heap using insertion\nWe can build a heap by repeatedly calling M AX-HEAP-INSERT to insert the ele-\nments into the heap. Consider the following variation on the B UILD -MAX-HEAP\nprocedure:", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "187": {"page_number": 188, "page_information": "Problems for Chapter 6 167\nBUILD -MAX-HEAP0.A/\n1A:heap -sizeD1\n2foriD2toA:length\n3M AX-HEAP-INSERT .A; A\u0152i/c141/\na.Do the procedures B UILD -MAX-HEAP and B UILD -MAX-HEAP0always create\nthe same heap when run on the same input array? Prove that they do, or providea counterexample.\nb.Show that in the worst case, B\nUILD -MAX-HEAP0requires \u201a.n lgn/time to\nbuild an n-element heap.\n6-2 Analysis of d-ary heaps\nAd-ary heap is like a binary heap, but (with one possible exception) non-leaf\nnodes have dchildren instead of 2children.\na.How would you represent a d-ary heap in an array?\nb.What is the height of a d-ary heap of nelements in terms of nandd?\nc.Give an ef\ufb01cient implementation of E XTRACT -MAXin ad-ary max-heap. An-\nalyze its running time in terms of dandn.\nd.Give an ef\ufb01cient implementation of I NSERT in ad-ary max-heap. Analyze its\nrunning time in terms of dandn.\ne.Give an ef\ufb01cient implementation of I NCREASE -KEY. A ;i;k/ , which \ufb02ags an\nerror if k < A\u0152i/c141 , but otherwise sets A\u0152i/c141Dkand then updates the d-ary max-\nheap structure appropriately. Analyze its running time in terms of dandn.\n6-3 Young tableaus\nAnm/STXnYoung tableau is an m/STXnmatrix such that the entries of each row are\nin sorted order from left to right and the entries of each column are in sorted order\nfrom top to bottom. Some of the entries of a Young tableau may be 1,w h i c hw e\ntreat as nonexistent elements. Thus, a Young tableau can be used to hold r/DC4mn\n\ufb01nite numbers.\na.Draw a 4/STX4Young tableau containing the elements f9; 16; 3; 2; 4; 8; 5; 14; 12 g.\nb.Argue that an m/STXnYoung tableau Yis empty if Y \u01521; 1/c141D1 . Argue that Y\nis full (contains mnelements) if Y\u0152 m ;n /c141<1.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "188": {"page_number": 189, "page_information": "168 Chapter 6 Heapsort\nc.Give an algorithm to implement E XTRACT -MINon a nonempty m/STXnYoung\ntableau that runs in O.mCn/time. Your algorithm should use a recur-\nsive subroutine that solves an m/STXnproblem by recursively solving either\nan.m/NUL1//STXnor an m/STX.n/NUL1/subproblem. ( Hint: Think about M AX-\nHEAPIFY .) De\ufb01ne T. p/ ,w h e r e pDmCn, to be the maximum running time\nof E XTRACT -MINon any m/STXnYoung tableau. Give and solve a recurrence\nforT. p/ that yields the O.mCn/time bound.\nd.Show how to insert a new element into a nonfull m/STXnYoung tableau in\nO.mCn/time.\ne.Using no other sorting method as a subroutine, show how to use an n/STXnYoung\ntableau to sort n2numbers in O.n3/time.\nf.Give an O.mCn/-time algorithm to determine whether a given number is\nstored in a given m/STXnYoung tableau.\nChapter notes\nThe heapsort algorithm was invented by Williams [357], who also described how\nto implement a priority queue with a heap. The B UILD -MAX-HEAP procedure\nwas suggested by Floyd [106].\nWe use min-heaps to implement min-priority queues in Chapters 16, 23, and 24.\nWe also give an implementation with improved time bounds for certain operationsin Chapter 19 and, assuming that the keys are drawn from a bounded set of non-negative integers, Chapter 20.\nIf the data are b-bit integers, and the computer memory consists of addressable\nb-bit words, Fredman and Willard [115] showed how to implement M\nINIMUM in\nO.1/ time and I NSERT and E XTRACT -MINinO.p\nlgn/time. Thorup [337] has\nimproved the O.p\nlgn/bound to O.lg lgn/time. This bound uses an amount of\nspace unbounded in n, but it can be implemented in linear space by using random-\nized hashing.\nAn important special case of priority queues occurs when the sequence of\nEXTRACT -MINoperations is monotone , that is, the values returned by succes-\nsive E XTRACT -MINoperations are monotonically increasing over time. This case\narises in several important applications, such as Dijkstra\u2019s single-source shortest-paths algorithm, which we discuss in Chapter 24, and in discrete-event simula-tion. For Dijkstra\u2019s algorithm it is particularly important that the D\nECREASE -KEY\noperation be implemented ef\ufb01ciently. For the monotone case, if the data are in-tegers in the range 1 ;2;:::;C , Ahuja, Mehlhorn, Orlin, and Tarjan [8] describe", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "189": {"page_number": 190, "page_information": "Notes for Chapter 6 169\nhow to implement E XTRACT -MINand I NSERT inO.lgC/amortized time (see\nChapter 17 for more on amortized analysis) and D ECREASE -KEYinO.1/ time,\nusing a data structure called a radix heap. The O.lgC/bound can be improved\ntoO.p\nlgC/using Fibonacci heaps (see Chapter 19) in conjunction with radix\nheaps. Cherkassky, Goldberg, and Silverstein [65] further improved the bound toO.lg\n1=3C/SIC/expected time by combining the multilevel bucketing structure of\nDenardo and Fox [85] with the heap of Thorup mentioned earlier. Raman [291]further improved these results to obtain a bound of O.min.lg\n1=4C/SIC;lg1=3C/SIn//,\nfor any \ufb01xed /SI>0 .", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "190": {"page_number": 191, "page_information": "7 Quicksort\nThe quicksort algorithm has a worst-case running time of \u201a.n2/on an input array\nofnnumbers. Despite this slow worst-case running time, quicksort is often the best\npractical choice for sorting because it is remarkably ef\ufb01cient on the average: itsexpected running time is \u201a.n lgn/, and the constant factors hidden in the \u201a.n lgn/\nnotation are quite small. It also has the advantage of sorting in place (see page 17),and it works well even in virtual-memory environments.\nSection 7.1 describes the algorithm and an important subroutine used by quick-\nsort for partitioning. Because the behavior of quicksort is complex, we start with\nan intuitive discussion of its performance in Section 7.2 and postpone its precise\nanalysis to the end of the chapter. Section 7.3 presents a version of quicksort that\nuses random sampling. This algorithm has a good expected running time, and no\nparticular input elicits its worst-case behavior. Section 7.4 analyzes the random-ized algorithm, showing that it runs in \u201a.n\n2/time in the worst case and, assuming\ndistinct elements, in expected O.n lgn/time.\n7.1 Description of quicksort\nQuicksort, like merge sort, applies the divide-and-conquer paradigm introduced\nin Section 2.3.1. Here is the three-step divide-and-conquer process for sorting atypical subarray A\u0152p : : r/c141 :\nDivide: Partition (rearrange) the array A\u0152p : : r/c141 into two (possibly empty) subar-\nraysA\u0152p : : q/NUL1/c141andA\u0152qC1::r/c141 such that each element of A\u0152p : : q/NUL1/c141is\nless than or equal to A\u0152q/c141, which is, in turn, less than or equal to each element\nofA\u0152qC1::r/c141 . Compute the index qas part of this partitioning procedure.\nConquer: Sort the two subarrays A\u0152p : : q/NUL1/c141andA\u0152qC1::r/c141 by recursive calls\nto quicksort.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "191": {"page_number": 192, "page_information": "7.1 Description of quicksort 171\nCombine: Because the subarrays are already sorted, no work is needed to combine\nthem: the entire array A\u0152p : : r/c141 is now sorted.\nThe following procedure implements quicksort:\nQUICKSORT . A ;p;r/\n1ifp<r\n2 qDPARTITION . A ;p;r/\n3Q UICKSORT . A ;p;q/NUL1/\n4Q UICKSORT .A; qC1; r/\nTo sort an entire array A, the initial call is Q UICKSORT . A ;1 ;A: length /.\nPartitioning the array\nThe key to the algorithm is the P ARTITION procedure, which rearranges the subar-\nrayA\u0152p : : r/c141 in place.\nPARTITION . A ;p;r/\n1xDA\u0152r/c141\n2iDp/NUL1\n3forjDptor/NUL1\n4 ifA\u0152j /c141/DC4x\n5 iDiC1\n6 exchange A\u0152i/c141 withA\u0152j /c141\n7 exchange A\u0152iC1/c141withA\u0152r/c141\n8return iC1\nF i g u r e7 . 1s h o w sh o wP ARTITION works on an 8-element array. P ARTITION\nalways selects an element xDA\u0152r/c141 as apivot element around which to partition the\nsubarray A\u0152p : : r/c141 . As the procedure runs, it partitions the array into four (possibly\nempty) regions. At the start of each iteration of the forloop in lines 3\u20136, the regions\nsatisfy certain properties, shown in Figure 7.2. We state these properties as a loopinvariant:\nAt the beginning of each iteration of the loop of lines 3\u20136, for any array\nindex k,\n1. Ifp/DC4k/DC4i,t h e n A\u0152k/c141/DC4x.\n2. IfiC1/DC4k/DC4j/NUL1,t h e n A\u0152k/c141 > x .\n3. IfkDr,t h e n A\u0152k/c141Dx.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "192": {"page_number": 193, "page_information": "172 Chapter 7 Quicksort\n28713564p,j ri\n(a)\n28713564p,i r j\n(b)\n28713564p,i r j\n(c)\n28713564p,i r j\n(d)\n28 71 3564pr j\n(e)i\n28 713 564pr j\n(f)i\n28 713 564pr j\n(g)i\n28 713 564pr\n(h)i\n28 7 13 56 4pr\n(i)i\nFigure 7.1 The operation of P ARTITION on a sample array. Array entry A\u0152r/c141 becomes the pivot\nelement x. Lightly shaded array elements are all in the \ufb01rst partition with values no greater than x.\nHeavily shaded elements are in the second partition with values greater than x. The unshaded el-\nements have not yet been put in one of the \ufb01rst two partitions, and the \ufb01nal white element is the\npivot x.(a)The initial array and variable settings. None of the elements have been placed in either\nof the \ufb01rst two partitions. (b)The value 2is \u201cswapped with itself\u201d and put in the partition of smaller\nvalues. (c)\u2013(d) The values 8and7are added to the partition of larger values. (e)The values 1and8\nare swapped, and the smaller partition grows. (f)The values 3and7are swapped, and the smaller\npartition grows. (g)\u2013(h) The larger partition grows to include 5and6, and the loop terminates. (i)In\nlines 7\u20138, the pivot element is swapped so that it lies between the two partitions.\nThe indices between jandr/NUL1are not covered by any of the three cases, and the\nvalues in these entries have no particular relationship to the pivot x.\nWe need to show that this loop invariant is true prior to the \ufb01rst iteration, that\neach iteration of the loop maintains the invariant, and that the invariant provides auseful property to show correctness when the loop terminates.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "193": {"page_number": 194, "page_information": "7.1 Description of quicksort 173\n\u2264x >x unrestrictedxpi j r\nFigure 7.2 The four regions maintained by the procedure P ARTITION on a subarray A\u0152p : : r/c141 .T h e\nvalues in A\u0152p : : i/c141 are all less than or equal to x,t h ev a l u e si n A\u0152iC1::j/NUL1/c141are all greater than x,\nandA\u0152r/c141Dx. The subarray A \u0152 j ::r/NUL1/c141can take on any values.\nInitialization: Prior to the \ufb01rst iteration of the loop, iDp/NUL1andjDp.B e -\ncause no values lie between pandiand no values lie between iC1andj/NUL1,\nthe \ufb01rst two conditions of the loop invariant are trivially satis\ufb01ed. The assign-ment in line 1 satis\ufb01es the third condition.\nMaintenance: As Figure 7.3 shows, we consider two cases, depending on the\noutcome of the test in line 4. Figure 7.3(a) shows what happens when A\u0152j /c141 > x ;\nthe only action in the loop is to increment j. After jis incremented, condition 2\nholds for A\u0152j/NUL1/c141and all other entries remain unchanged. Figure 7.3(b) shows\nwhat happens when A\u0152j /c141/DC4x; the loop increments i,s w a p s A\u0152i/c141 andA\u0152j /c141 ,\nand then increments j. Because of the swap, we now have that A\u0152i/c141/DC4x,a n d\ncondition 1is satis\ufb01ed. Similarly, we also have that A\u0152j/NUL1/c141 > x , since the\nitem that was swapped into A\u0152j/NUL1/c141is, by the loop invariant, greater than x.\nTermination: At termination, jDr. Therefore, every entry in the array is in one\nof the three sets described by the invariant, and we have partitioned the values\nin the array into three sets: those less than or equal to x, those greater than x,\nand a singleton set containing x.\nThe \ufb01nal two lines of P\nARTITION \ufb01nish up by swapping the pivot element with\nthe leftmost element greater than x, thereby moving the pivot into its correct place\nin the partitioned array, and then returning the pivot\u2019s new index. The output of\nPARTITION now satis\ufb01es the speci\ufb01cations given for the divide step. In fact, it\nsatis\ufb01es a slightly stronger condition: after line 2 of Q UICKSORT ,A\u0152q/c141 is strictly\nless than every element of A\u0152qC1::r/c141 .\nThe running time of P ARTITION on the subarray A\u0152p : : r/c141 is\u201a.n/ ,w h e r e\nnDr/NULpC1(see Exercise 7.1-3).\nExercises\n7.1-1\nUsing Figure 7.1 as a model, illustrate the operation of P ARTITION on the array\nADh13; 19; 9; 5; 12; 8; 7; 4; 21; 2; 6; 11 i.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "194": {"page_number": 195, "page_information": "174 Chapter 7 Quicksort\n\u2264x >xxpi j r\n>x (a)\n\u2264x >xxpi j r\n\u2264x >xxpi j r\n\u2264x (b)\n\u2264x >xxpi jr\nFigure 7.3 The two cases for one iteration of procedure P ARTITION .(a)IfA\u0152j /c141 > x , the only\naction is to increment j, which maintains the loop invariant. (b)IfA\u0152j /c141/DC4x, index iis incremented,\nA\u0152i/c141 andA\u0152j /c141 are swapped, and then jis incremented. Again, the loop invariant is maintained.\n7.1-2\nWhat value of qdoes P ARTITION return when all elements in the array A\u0152p : : r/c141\nhave the same value? Modify P ARTITION so that qDb.pCr/=2cwhen all\nelements in the array A\u0152p : : r/c141 have the same value.\n7.1-3\nGive a brief argument that the running time of P ARTITION on a subarray of size n\nis\u201a.n/ .\n7.1-4\nHow would you modify Q UICKSORT to sort into nonincreasing order?\n7.2 Performance of quicksort\nThe running time of quicksort depends on whether the partitioning is balanced orunbalanced, which in turn depends on which elements are used for partitioning.\nIf the partitioning is balanced, the algorithm runs asymptotically as fast as merge", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "195": {"page_number": 196, "page_information": "7.2 Performance of quicksort 175\nsort. If the partitioning is unbalanced, however, it can run asymptotically as slowly\nas insertion sort. In this section, we shall informally investigate how quicksortperforms under the assumptions of balanced versus unbalanced partitioning.\nWorst-case partitioning\nThe worst-case behavior for quicksort occurs when the partitioning routine pro-\nduces one subproblem with n/NUL1elements and one with 0elements. (We prove\nthis claim in Section 7.4.1.) Let us assume that this unbalanced partitioning arisesin each recursive call. The partitioning costs \u201a.n/ time. Since the recursive call\non an array of size 0just returns, T. 0 /D\u201a.1/ , and the recurrence for the running\ntime is\nT .n/DT. n/NUL1/CT. 0 /C\u201a.n/\nDT. n/NUL1/C\u201a.n/ :\nIntuitively, if we sum the costs incurred at each level of the recursion, we get\nan arithmetic series (equation (A.2)), which evaluates to \u201a.n\n2/. Indeed, it is\nstraightforward to use the substitution method to prove that the recurrence T .n/D\nT. n/NUL1/C\u201a.n/ has the solution T .n/D\u201a.n2/. (See Exercise 7.2-1.)\nThus, if the partitioning is maximally unbalanced at every recursive level of the\nalgorithm, the running time is \u201a.n2/. Therefore the worst-case running time of\nquicksort is no better than that of insertion sort. Moreover, the \u201a.n2/running time\noccurs when the input array is already completely sorted\u2014a common situation inwhich insertion sort runs in O.n/ time.\nBest-case partitioning\nIn the most even possible split, P\nARTITION produces two subproblems, each of\nsize no more than n=2, since one is of size bn=2cand one of sizedn=2e/NUL1.I nt h i s\ncase, quicksort runs much faster. The recurrence for the running time is then\nT .n/D2T .n=2/C\u201a.n/ ;\nwhere we tolerate the sloppiness from ignoring the \ufb02oor and ceiling and from sub-\ntracting 1. By case 2 of the master theorem (Theorem 4.1), this recurrence has the\nsolution T .n/D\u201a.n lgn/. By equally balancing the two sides of the partition at\nevery level of the recursion, we get an asymptotically faster algorithm.\nBalanced partitioning\nThe average-case running time of quicksort is much closer to the best case than to\nthe worst case, as the analyses in Section 7.4 will show. The key to understand-", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "196": {"page_number": 197, "page_information": "176 Chapter 7 Quicksort\nn\ncncncncn\n/DC4cn/DC4cn\n11\nO.n lgn/log10n\nlog10=9n1\n10n9\n10n\n1\n100n9\n100n9\n100n81\n100n\n81\n1000n729\n1000n\nFigure 7.4 A recursion tree for Q UICKSORT in which P ARTITION always produces a 9-to-1split,\nyielding a running time of O.n lgn/. Nodes show subproblem sizes, with per-level costs on the right.\nThe per-level costs include the constant cimplicit in the \u201a.n/ term.\ning why is to understand how the balance of the partitioning is re\ufb02ected in the\nrecurrence that describes the running time.\nSuppose, for example, that the partitioning algorithm always produces a 9-to-1\nproportional split, which at \ufb01rst blush seems quite unbalanced. We then obtain therecurrence\nT .n/DT .9n=10/CT .n=10/Ccn ;\non the running time of quicksort, where we have explicitly included the constant c\nhidden in the \u201a.n/ term. Figure 7.4 shows the recursion tree for this recurrence.\nNotice that every level of the tree has cost cn, until the recursion reaches a bound-\nary condition at depth log\n10nD\u201a.lgn/, and then the levels have cost at most cn.\nThe recursion terminates at depth log10=9nD\u201a.lgn/. The total cost of quick-\nsort is therefore O.n lgn/. Thus, with a 9-to-1proportional split at every level of\nrecursion, which intuitively seems quite unbalanced, quicksort runs in O.n lgn/\ntime\u2014asymptotically the same as if the split were right down the middle. Indeed,\neven a 99-to-1split yields an O.n lgn/running time. In fact, any split of constant\nproportionality yields a recursion tree of depth \u201a.lgn/, where the cost at each level\nisO.n/ . The running time is therefore O.n lgn/whenever the split has constant\nproportionality.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "197": {"page_number": 198, "page_information": "7.2 Performance of quicksort 177\nn\n0 n\u20131\n(n\u20131)/2 \u2013 1 ( n\u20131)/2n\n(n\u20131)/2\n(a) (b)(n\u20131)/2\u0398(n) \u0398(n)\nFigure 7.5 (a) Two levels of a recursion tree for qui cksort. The partitioni ng at the root costs n\nand produces a \u201cbad\u201d split: two subarrays of sizes 0andn/NUL1. The partitioning of the subarray of\nsizen/NUL1costs n/NUL1and produces a \u201cgood\u201d split: subarrays of size .n/NUL1/=2/NUL1and.n/NUL1/=2.\n(b)A single level of a recursion tree that is very well balanced. In both parts, the partitioning cost for\nthe subproblems shown with elliptical shading is \u201a.n/ . Yet the subproblems remaining to be solved\nin (a), shown with square shading, are no larger than the corresponding subproblems remaining to be\nsolved in (b).\nIntuition for the average case\nTo develop a clear notion of the randomized behavior of quicksort, we must make\nan assumption about how frequently we expect to encounter the various inputs.\nThe behavior of quicksort depends on the relative ordering of the values in the\narray elements given as the input, and not by the particular values in the array. Asin our probabilistic analysis of the hiring problem in Section 5.2, we will assumefor now that all permutations of the input numbers are equally likely.\nWhen we run quicksort on a random input array, the partitioning is highly un-\nlikely to happen in the same way at every level, as our informal analysis has as-sumed. We expect that some of the splits will be reasonably well balanced andthat some will be fairly unbalanced. For example, Exercise 7.2-6 asks you to showthat about 80 percent of the time P\nARTITION produces a split that is more balanced\nthan9to1, and about 20 percent of the time it produces a split that is less balanced\nthan9to1.\nIn the average case, P ARTITION produces a mix of \u201cgood\u201d and \u201cbad\u201d splits. In a\nrecursion tree for an average-case execution of P ARTITION , the good and bad splits\nare distributed randomly throughout the tree. Suppose, for the sake of intuition,\nthat the good and bad splits alternate levels in the tree, and that the good splits\nare best-case splits and the bad splits are worst-case splits. Figure 7.5(a) shows\nthe splits at two consecutive levels in the recursion tree. At the root of the tree,the cost is nfor partitioning, and the subarrays produced have sizes n/NUL1and0:\nthe worst case. At the next level, the subarray of size n/NUL1undergoes best-case\npartitioning into subarrays of size .n/NUL1/=2/NUL1and.n/NUL1/=2 . Let\u2019s assume that\nthe boundary-condition cost is 1for the subarray of size 0.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "198": {"page_number": 199, "page_information": "178 Chapter 7 Quicksort\nThe combination of the bad split followed by the good split produces three sub-\narrays of sizes 0,.n/NUL1/=2/NUL1,a n d .n/NUL1/=2 at a combined partitioning cost\nof\u201a.n/C\u201a.n/NUL1/D\u201a.n/ . Certainly, this situation is no worse than that in\nFigure 7.5(b), namely a single level of partitioning that produces two subarrays ofsize.n/NUL1/=2 , at a cost of \u201a.n/ . Yet this latter situation is balanced! Intuitively,\nthe\u201a.n/NUL1/cost of the bad split can be absorbed into the \u201a.n/ cost of the good\nsplit, and the resulting split is good. Thus, the running time of quicksort, when lev-els alternate between good and bad splits, is like the running time for good splits\nalone: still O.n lgn/, but with a slightly larger constant hidden by the O-notation.\nWe shall give a rigorous analysis of the expected running time of a randomizedversion of quicksort in Section 7.4.2.\nExercises\n7.2-1\nUse the substitution method to prove that the recurrence T .n/DT. n/NUL1/C\u201a.n/\nhas the solution T .n/D\u201a.n\n2/, as claimed at the beginning of Section 7.2.\n7.2-2\nWhat is the running time of Q UICKSORT when all elements of array Ahave the\nsame value?\n7.2-3\nShow that the running time of Q UICKSORT is\u201a.n2/when the array Acontains\ndistinct elements and is sorted in decreasing order.\n7.2-4\nBanks often record transactions on an account in order of the times of the transac-\ntions, but many people like to receive their bank statements with checks listed in\norder by check number. People usually write checks in order by check number, andmerchants usually cash them with reasonable dispatch. The problem of convertingtime-of-transaction ordering to check-number ordering is therefore the problem ofsorting almost-sorted input. Argue that the procedure I\nNSERTION -SORT would\ntend to beat the procedure Q UICKSORT on this problem.\n7.2-5\nSuppose that the splits at every level of quicksort are in the proportion 1/NUL\u02dbto\u02db,\nwhere 0<\u02db/DC41=2is a constant. Show that the minimum depth of a leaf in the re-\ncursion tree is approximately /NULlgn=lg\u02dband the maximum depth is approximately\n/NULlgn=lg.1/NUL\u02db/. (Don\u2019t worry about integer round-off.)", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "199": {"page_number": 200, "page_information": "7.3 A randomized version of quicksort 179\n7.2-6 ?\nArgue that for any constant 0<\u02db/DC41=2, the probability is approximately 1/NUL2\u02db\nthat on a random input array, P ARTITION produces a split more balanced than 1/NUL\u02db\nto\u02db.\n7.3 A randomized version of quicksort\nIn exploring the average-case behavior of quicksort, we have made an assumption\nthat all permutations of the input numbers are equally likely. In an engineeringsituation, however, we cannot always expect this assumption to hold. (See Exer-cise 7.2-4.) As we saw in Section 5.3, we can sometimes add randomization to analgorithm in order to obtain good expected performance over all inputs. Many peo-ple regard the resulting randomized version of quicksort as the sorting algorithmof choice for large enough inputs.\nIn Section 5.3, we randomized our algorithm by explicitly permuting the in-\nput. We could do so for quicksort also, but a different randomization technique,\ncalled random sampling , yields a simpler analysis. Instead of always using A\u0152r/c141\nas the pivot, we will select a randomly chosen element from the subarray A\u0152p : : r/c141 .\nWe do so by \ufb01rst exchanging element A\u0152r/c141 with an element chosen at random\nfrom A\u0152p : : r/c141 . By randomly sampling the range p ;:::;r , we ensure that the pivot\nelement xDA\u0152r/c141 is equally likely to be any of the r/NULpC1elements in the\nsubarray. Because we randomly choose the pivot element, we expect the split of\nthe input array to be reasonably well balanced on average.\nThe changes to P\nARTITION and Q UICKSORT are small. In the new partition\nprocedure, we simply implement the swap before actually partitioning:\nRANDOMIZED -PARTITION . A ;p;r/\n1iDRANDOM .p; r/\n2 exchange A\u0152r/c141 withA\u0152i/c141\n3return PARTITION . A ;p;r/\nThe new quicksort calls R ANDOMIZED -PARTITION in place of P ARTITION :\nRANDOMIZED -QUICKSORT . A ;p;r/\n1ifp<r\n2 qDRANDOMIZED -PARTITION . A ;p;r/\n3R ANDOMIZED -QUICKSORT . A ;p;q/NUL1/\n4R ANDOMIZED -QUICKSORT .A; qC1; r/\nWe analyze this algorithm in the next section.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "200": {"page_number": 201, "page_information": "180 Chapter 7 Quicksort\nExercises\n7.3-1\nWhy do we analyze the expected running time of a randomized algorithm and notits worst-case running time?\n7.3-2\nWhen R\nANDOMIZED -QUICKSORT runs, how many calls are made to the random-\nnumber generator R ANDOM in the worst case? How about in the best case? Give\nyour answer in terms of \u201a-notation.\n7.4 Analysis of quicksort\nSection 7.2 gave some intuition for the worst-case behavior of quicksort and for\nwhy we expect it to run quickly. In this section, we analyze the behavior of quick-\nsort more rigorously. We begin with a worst-case analysis, which applies to either\nQUICKSORT or R ANDOMIZED -QUICKSORT , and conclude with an analysis of the\nexpected running time of R ANDOMIZED -QUICKSORT .\n7.4.1 Worst-case analysis\nWe saw in Section 7.2 that a worst-case split at every level of recursion in quicksort\nproduces a \u201a.n2/running time, which, intuitively, is the worst-case running time\nof the algorithm. We now prove this assertion.\nUsing the substitution method (see Section 4.3), we can show that the running\ntime of quicksort is O.n2/.L e t T .n/ be the worst-case time for the procedure\nQUICKSORT on an input of size n. We have the recurrence\nT .n/Dmax\n0/DC4q/DC4n/NUL1.T .q/CT. n/NULq/NUL1//C\u201a.n/ ; (7.1)\nwhere the parameter qranges from 0ton/NUL1because the procedure P ARTITION\nproduces two subproblems with total size n/NUL1. We guess that T .n//DC4cn2for\nsome constant c. Substituting this guess into recurrence (7.1), we obtain\nT .n//DC4 max\n0/DC4q/DC4n/NUL1.cq2Cc.n/NULq/NUL1/2/C\u201a.n/\nDc/SOHmax\n0/DC4q/DC4n/NUL1.q2C.n/NULq/NUL1/2/C\u201a.n/ :\nThe expression q2C.n/NULq/NUL1/2achieves a maximum over the parameter\u2019s\nrange 0/DC4q/DC4n/NUL1at either endpoint. To verify this claim, note that the second\nderivative of the expression with respect to qis positive (see Exercise 7.4-3). This", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "201": {"page_number": 202, "page_information": "7.4 Analysis of quicksort 181\nobservation gives us the bound max 0/DC4q/DC4n/NUL1.q2C.n/NULq/NUL1/2//DC4.n/NUL1/2D\nn2/NUL2nC1. Continuing with our bounding of T .n/ , we obtain\nT .n//DC4cn2/NULc.2n/NUL1/C\u201a.n/\n/DC4cn2;\nsince we can pick the constant clarge enough so that the c.2n/NUL1/term dom-\ninates the \u201a.n/ term. Thus, T .n/DO.n2/. We saw in Section 7.2 a speci\ufb01c\ncase in which quicksort takes /DEL.n2/time: when partitioning is unbalanced. Al-\nternatively, Exercise 7.4-1 asks you to show that recurrence (7.1) has a solution ofT .n/D/DEL.n\n2/. Thus, the (worst-case) running time of quicksort is \u201a.n2/.\n7.4.2 Expected running time\nWe have already seen the intuition behind why the expected running time of\nRANDOMIZED -QUICKSORT isO.n lgn/: if, in each level of recursion, the split\ninduced by R ANDOMIZED -PARTITION puts any constant fraction of the elements\non one side of the partition, then the recursion tree has depth \u201a.lgn/,a n d O.n/\nwork is performed at each level. Even if we add a few new levels with the most un-balanced split possible between these levels, the total time remains O.n lgn/.W e\ncan analyze the expected running time of R\nANDOMIZED -QUICKSORT precisely\nby \ufb01rst understanding how the partitioning procedure operates and then using this\nunderstanding to derive an O.n lgn/bound on the expected running time. This\nupper bound on the expected running time, combined with the \u201a.n lgn/best-case\nbound we saw in Section 7.2, yields a \u201a.n lgn/expected running time. We assume\nthroughout that the values of the elements being sorted are distinct.\nRunning time and comparisons\nThe Q UICKSORT and R ANDOMIZED -QUICKSORT procedures differ only in how\nthey select pivot elements; they are the same in all other respects. We can therefore\ncouch our analysis of R ANDOMIZED -QUICKSORT by discussing the Q UICKSORT\nand P ARTITION procedures, but with the assumption that pivot elements are se-\nlected randomly from the subarray passed to R ANDOMIZED -PARTITION .\nThe running time of Q UICKSORT is dominated by the time spent in the P ARTI -\nTION procedure. Each time the P ARTITION procedure is called, it selects a pivot\nelement, and this element is never included in any future recursive calls to Q UICK -\nSORT and P ARTITION . Thus, there can be at most ncalls to P ARTITION over the\nentire execution of the quicksort algorithm. One call to P ARTITION takes O.1/\ntime plus an amount of time that is proportional to the number of iterations of theforloop in lines 3\u20136. Each iteration of this forloop performs a comparison in\nline 4, comparing the pivot element to another element of the array A. Therefore,", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "202": {"page_number": 203, "page_information": "182 Chapter 7 Quicksort\nif we can count the total number of times that line 4 is executed, we can bound the\ntotal time spent in the forloop during the entire execution of Q UICKSORT .\nLemma 7.1\nLetXbe the number of comparisons performed in line 4 of P ARTITION over the\nentire execution of Q UICKSORT on an n-element array. Then the running time of\nQUICKSORT isO.nCX/.\nProof By the discussion above, the algorithm makes at most ncalls to P ARTI -\nTION , each of which does a constant amount of work and then executes the for\nloop some number of times. Each iteration of the forloop executes line 4.\nOur goal, therefore, is to compute X, the total number of comparisons performed\nin all calls to P ARTITION . We will not attempt to analyze how many comparisons\nare made in each call to P ARTITION . Rather, we will derive an overall bound on the\ntotal number of comparisons. To do so, we must understand when the algorithmcompares two elements of the array and when it does not. For ease of analysis, werename the elements of the array Aas\u00b4\n1;\u00b42;:::;\u00b4 n, with \u00b4ibeing the ith smallest\nelement. We also de\ufb01ne the set ZijDf\u00b4i;\u00b4iC1;:::;\u00b4 jgto be the set of elements\nbetween \u00b4iand\u00b4j,i n c l u s i v e .\nWhen does the algorithm compare \u00b4iand\u00b4j? To answer this question, we \ufb01rst\nobserve that each pair of elements is compared at most once. Why? Elementsare compared only to the pivot element and, after a particular call of P\nARTITION\n\ufb01nishes, the pivot element used in that call is never again compared to any otherelements.\nOur analysis uses indicator random variables (see Section 5.2). We de\ufb01ne\nX\nijDIf\u00b4iis compared to \u00b4jg;\nwhere we are considering whether the comparison takes place at any time during\nthe execution of the algorithm, not just during one iteration or one call of P ARTI -\nTION . Since each pair is compared at most once, we can easily characterize the\ntotal number of comparisons performed by the algorithm:\nXDn/NUL1X\niD1nX\njDiC1Xij:\nTaking expectations of both sides, and then using linearity of expectation and\nLemma 5.1, we obtain\nE\u0152X/c141DE\"n/NUL1X\niD1nX\njDiC1Xij#", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "203": {"page_number": 204, "page_information": "7.4 Analysis of quicksort 183\nDn/NUL1X\niD1nX\njDiC1E\u0152Xij/c141\nDn/NUL1X\niD1nX\njDiC1Prf\u00b4iis compared to \u00b4jg: (7.2)\nIt remains to compute Pr f\u00b4iis compared to \u00b4jg. Our analysis assumes that the\nRANDOMIZED -PARTITION procedure chooses each pivot randomly and indepen-\ndently.\nLet us think about when two items are notcompared. Consider an input to\nquicksort of the numbers 1through 10(in any order), and suppose that the \ufb01rst\npivot element is 7. Then the \ufb01rst call to P ARTITION separates the numbers into two\nsets:f1; 2; 3; 4; 5; 6gandf8; 9; 10g. In doing so, the pivot element 7is compared\nto all other elements, but no number from the \ufb01rst set (e.g., 2) is or ever will becompared to any number from the second set (e.g., 9).\nIn general, because we assume that element values are distinct, once a pivot x\nis chosen with \u00b4\ni<x<\u00b4 j, we know that \u00b4iand\u00b4jcannot be compared at any\nsubsequent time. If, on the other hand, \u00b4iis chosen as a pivot before any other item\ninZij,t h e n \u00b4iwill be compared to each item in Zij, except for itself. Similarly,\nif\u00b4jis chosen as a pivot before any other item in Zij,t h e n \u00b4jwill be compared to\neach item in Zij, except for itself. In our example, the values 7and9are compared\nbecause 7is the \ufb01rst item from Z7;9to be chosen as a pivot. In contrast, 2and9will\nnever be compared because the \ufb01rst pivot element chosen from Z2;9is7. Thus, \u00b4i\nand\u00b4jare compared if and only if the \ufb01rst element to be chosen as a pivot from Zij\nis either \u00b4ior\u00b4j.\nWe now compute the probability that this event occurs. Prior to the point at\nwhich an element from Zijhas been chosen as a pivot, the whole set Zijis together\nin the same partition. Therefore, any element of Zijis equally likely to be the \ufb01rst\none chosen as a pivot. Because the set Zijhasj/NULiC1elements, and because pivots\nare chosen randomly and independently, the probability that any given element isthe \ufb01rst one chosen as a pivot is 1=.j/NULiC1/. Thus, we have\nPrf\u00b4\niis compared to \u00b4jgDPrf\u00b4ior\u00b4jis \ufb01rst pivot chosen from Zijg\nDPrf\u00b4iis \ufb01rst pivot chosen from Zijg\nCPrf\u00b4jis \ufb01rst pivot chosen from Zijg\nD1\nj/NULiC1C1\nj/NULiC1\nD2\nj/NULiC1: (7.3)", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "204": {"page_number": 205, "page_information": "184 Chapter 7 Quicksort\nThe second line follows because the two events are mutually exclusive. Combining\nequations (7.2) and (7.3), we get that\nE\u0152X/c141Dn/NUL1X\niD1nX\njDiC12\nj/NULiC1:\nWe can evaluate this sum using a change of variables ( kDj/NULi) and the bound\non the harmonic series in equation (A.7):\nE\u0152X/c141Dn/NUL1X\niD1nX\njDiC12\nj/NULiC1\nDn/NUL1X\niD1n/NULiX\nkD12\nkC1\n<n/NUL1X\niD1nX\nkD12\nk\nDn/NUL1X\niD1O.lgn/\nDO.n lgn/ : (7.4)\nThus we conclude that, using R ANDOMIZED -PARTITION , the expected running\ntime of quicksort is O.n lgn/when element values are distinct.\nExercises\n7.4-1\nShow that in the recurrence\nT .n/Dmax\n0/DC4q/DC4n/NUL1.T .q/CT. n/NULq/NUL1//C\u201a.n/ ;\nT .n/D/DEL.n2/.\n7.4-2\nShow that quicksort\u2019s best-case running time is /DEL.n lgn/.\n7.4-3\nShow that the expression q2C.n/NULq/NUL1/2achieves a maximum over qD\n0; 1; : : : ; n/NUL1when qD0orqDn/NUL1.\n7.4-4\nShow that R ANDOMIZED -QUICKSORT \u2019s expected running time is /DEL.n lgn/.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "205": {"page_number": 206, "page_information": "Problems for Chapter 7 185\n7.4-5\nWe can improve the running time of quicksort in practice by taking advantage of thefast running time of insertion sort when its input is \u201cnearly\u201d sorted. Upon callingquicksort on a subarray with fewer than kelements, let it simply return without\nsorting the subarray. After the top-level call to quicksort returns, run insertion sorton the entire array to \ufb01nish the sorting process. Argue that this sorting algorithmruns in O.nkCnlg.n=k// expected time. How should we pick k, both in theory\nand in practice?\n7.4-6 ?\nConsider modifying the P\nARTITION procedure by randomly picking three elements\nfrom array Aand partitioning about their median (the middle value of the three\nelements). Approximate the probability of getting at worst an \u02db-to-.1/NUL\u02db/split, as\na function of \u02dbin the range 0<\u02db<1 .\nProblems\n7-1 Hoare partition correctness\nThe version of P ARTITION given in this chapter is not the original partitioning\nalgorithm. Here is the original partition algorithm, which is due to C. A. R. Hoare:\nHOARE -PARTITION . A ;p;r/\n1xDA\u0152p/c141\n2iDp/NUL1\n3jDrC1\n4while TRUE\n5 repeat\n6 jDj/NUL1\n7 until A\u0152j /c141/DC4x\n8 repeat\n9 iDiC1\n10 until A\u0152i/c141/NAKx\n11 ifi<j\n12 exchange A\u0152i/c141 withA\u0152j /c141\n13 else return j\na.Demonstrate the operation of H OARE -PARTITION on the array ADh13; 19; 9;\n5; 12; 8; 7; 4; 11; 2; 6; 21 i, showing the values of the array and auxiliary values\nafter each iteration of the while loop in lines 4\u201313.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "206": {"page_number": 207, "page_information": "186 Chapter 7 Quicksort\nThe next three questions ask you to give a careful argument that the procedure\nHOARE -PARTITION is correct. Assuming that the subarray A\u0152p : : r/c141 contains at\nleast two elements, prove the following:\nb.The indices iandjare such that we never access an element of Aoutside the\nsubarray A\u0152p : : r/c141 .\nc.When H OARE -PARTITION terminates, it returns a value jsuch that p/DC4j< r .\nd.Every element of A\u0152p : : j /c141 is less than or equal to every element of A\u0152jC1::r/c141\nwhen H OARE -PARTITION terminates.\nThe P ARTITION procedure in Section 7.1 separates the pivot value (originally\ninA\u0152r/c141) from the two partitions it forms. The H OARE -PARTITION procedure, on\nthe other hand, always places the pivot value (originally in A\u0152p/c141 ) into one of the\ntwo partitions A\u0152p : : j /c141 andA\u0152jC1::r/c141 .S i n c e p/DC4j< r , this split is always\nnontrivial.\ne.Rewrite the Q UICKSORT procedure to use H OARE -PARTITION .\n7-2 Quicksort with equal element values\nThe analysis of the expected running time of randomized quicksort in Section 7.4.2assumes that all element values are distinct. In this problem, we examine whathappens when they are not.\na.Suppose that all element values are equal. What would be randomized quick-\nsort\u2019s running time in this case?\nb.The P\nARTITION procedure returns an index qsuch that each element of\nA\u0152p : : q/NUL1/c141is less than or equal to A\u0152q/c141 and each element of A\u0152qC1::r/c141\nis greater than A\u0152q/c141. Modify the P ARTITION procedure to produce a procedure\nPARTITION0. A ;p;r/ , which permutes the elements of A\u0152p : : r/c141 and returns two\nindices qandt,w h e r e p/DC4q/DC4t/DC4r, such that\n/SIall elements of A\u0152q : : t/c141 are equal,\n/SIeach element of A\u0152p : : q/NUL1/c141is less than A\u0152q/c141,a n d\n/SIeach element of A\u0152tC1::r/c141 is greater than A\u0152q/c141.\nLike P ARTITION , your P ARTITION0procedure should take \u201a.r/NULp/time.\nc.Modify the R ANDOMIZED -QUICKSORT procedure to call P ARTITION0,a n d\nname the new procedure R ANDOMIZED -QUICKSORT0. Then modify the\nQUICKSORT procedure to produce a procedure Q UICKSORT0.p; r/ that calls", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "207": {"page_number": 208, "page_information": "Problems for Chapter 7 187\nRANDOMIZED -PARTITION0and recurses only on partitions of elements not\nknown to be equal to each other.\nd.Using Q UICKSORT0, how would you adjust the analysis in Section 7.4.2 to\navoid the assumption that all elements are distinct?\n7-3 Alternative quicksort analysis\nAn alternative analysis of the running time of randomized quicksort focuses onthe expected running time of each individual recursive call to R\nANDOMIZED -\nQUICKSORT , rather than on the number of comparisons performed.\na.Argue that, given an array of size n, the probability that any particular element\nis chosen as the pivot is 1=n. Use this to de\ufb01ne indicator random variables\nXiDIfith smallest element is chosen as the pivot g.W h a ti sE \u0152Xi/c141?\nb.LetT .n/ be a random variable denoting the running time of quicksort on an\narray of size n. Argue that\nE\u0152T .n//c141DE\"nX\nqD1Xq.T .q/NUL1/CT. n/NULq/C\u201a.n//#\n: (7.5)\nc.Show that we can rewrite equation (7.5) as\nE\u0152T .n//c141D2\nnn/NUL1X\nqD2E\u0152T .q//c141C\u201a.n/ : (7.6)\nd.Show that\nn/NUL1X\nkD2klgk/DC41\n2n2lgn/NUL1\n8n2: (7.7)\n(Hint: Split the summation into two parts, one for kD2;3 ;:::;dn=2e/NUL1and\none for kDdn=2e;:::;n/NUL1.)\ne.Using the bound from equation (7.7), show that the recurrence in equation (7.6)\nhas the solution E \u0152T .n//c141D\u201a.n lgn/.(Hint: Show, by substitution, that\nE\u0152T .n//c141/DC4anlgnfor suf\ufb01ciently large nand for some positive constant a.)", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "208": {"page_number": 209, "page_information": "188 Chapter 7 Quicksort\n7-4 Stack depth for quicksort\nThe Q UICKSORT algorithm of Section 7.1 contains two recursive calls to itself.\nAfter Q UICKSORT calls P ARTITION , it recursively sorts the left subarray and then\nit recursively sorts the right subarray. The second recursive call in Q UICKSORT\nis not really necessary; we can avoid it by using an iterative control structure.This technique, called tail recursion , is provided automatically by good compilers.\nConsider the following version of quicksort, which simulates tail recursion:\nT\nAIL-RECURSIVE -QUICKSORT . A ;p;r/\n1while p<r\n2 //Partition and sort left subarray.\n3 qDPARTITION . A ;p;r/\n4T AIL-RECURSIVE -QUICKSORT . A ;p;q/NUL1/\n5 pDqC1\na.Argue that T AIL-RECURSIVE -QUICKSORT . A ;1 ;A: length /correctly sorts the\narray A.\nCompilers usually execute recursive procedures by using a stack that contains per-\ntinent information, including the parameter values, for each recursive call. Theinformation for the most recent call is at the top of the stack, and the informationfor the initial call is at the bottom. Upon calling a procedure, its information ispushed onto the stack; when it terminates, its information is popped .S i n c e w e\nassume that array parameters are represented by pointers, the information for each\nprocedure call on the stack requires O.1/ stack space. The stack depth is the max-\nimum amount of stack space used at any time during a computation.\nb.Describe a scenario in which T\nAIL-RECURSIVE -QUICKSORT \u2019s stack depth is\n\u201a.n/ on an n-element input array.\nc.Modify the code for T AIL-RECURSIVE -QUICKSORT so that the worst-case\nstack depth is \u201a.lgn/. Maintain the O.n lgn/expected running time of the\nalgorithm.\n7-5 Median-of-3 partition\nOne way to improve the R ANDOMIZED -QUICKSORT procedure is to partition\naround a pivot that is chosen more carefully than by picking a random elementfrom the subarray. One common approach is the median-of-3 method: choose\nthe pivot as the median (middle element) of a set of 3 elements randomly selected\nfrom the subarray. (See Exercise 7.4-6.) For this problem, let us assume that theelements in the input array A\u01521 : : n/c141 are distinct and that n/NAK3. We denote the", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "209": {"page_number": 210, "page_information": "Problems for Chapter 7 189\nsorted output array by A0\u0152 1::n /c141 . Using the median-of-3 method to choose the\npivot element x,d e \ufb01 n e piDPrfxDA0\u0152i/c141g.\na.Give an exact formula for pia saf u n c t i o no f nandiforiD2;3 ;:::;n/NUL1.\n(Note that p1DpnD0.)\nb.By what amount have we increased the likelihood of choosing the pivot as\nxDA0\u0152b.nC1/=2c/c141, the median of A\u01521 : : n/c141 , compared with the ordinary\nimplementation? Assume that n!1 , and give the limiting ratio of these\nprobabilities.\nc.If we de\ufb01ne a \u201cgood\u201d split to mean choosing the pivot as xDA0\u0152i/c141,w h e r e\nn=3/DC4i/DC42n=3 , by what amount have we increased the likelihood of getting\na good split compared with the ordinary implementation? ( Hint: Approximate\nthe sum by an integral.)\nd.Argue that in the /DEL.n lgn/running time of quicksort, the median-of-3 method\naffects only the constant factor.\n7-6 Fuzzy sorting of intervals\nConsider a sorting problem in which we do not know the numbers exactly. In-\nstead, for each number, we know an interval on the real line to which it belongs.\nThat is, we are given nclosed intervals of the form \u0152ai;bi/c141,w h e r e ai/DC4bi.W e\nwish to fuzzy-sort these intervals, i.e., to produce a permutation hi1;i2;:::;i niof\nthe intervals such that for jD1 ;2;:::;n , there exist cj2\u0152aij;bij/c141satisfying\nc1/DC4c2/DC4/SOH/SOH/SOH/DC4 cn.\na.Design a randomized algorithm for fuzzy-sorting nintervals. Your algorithm\nshould have the general structure of an algorithm that quicksorts the left end-points (the a\nivalues), but it should take advantage of overlapping intervals to\nimprove the running time. (As the intervals overlap more and more, the prob-lem of fuzzy-sorting the intervals becomes progressively easier. Your algorithmshould take advantage of such overlapping, to the extent that it exists.)\nb.Argue that your algorithm runs in expected time \u201a.n lgn/in general, but runs\nin expected time \u201a.n/ when all of the intervals overlap (i.e., when there exists a\nvalue xsuch that x2\u0152a\ni;bi/c141for all i). Your algorithm should not be checking\nfor this case explicitly; rather, its performance should naturally improve as theamount of overlap increases.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "210": {"page_number": 211, "page_information": "190 Chapter 7 Quicksort\nChapter notes\nThe quicksort procedure was invented by Hoare [170]; Hoare\u2019s version appears in\nProblem 7-1. The P ARTITION procedure given in Section 7.1 is due to N. Lomuto.\nThe analysis in Section 7.4 is due to Avrim Blum. Sedgewick [305] and Bent-ley [43] provide a good reference on the details of implementation and how they\nmatter.\nMcIlroy [248] showed how to engineer a \u201ckiller adversary\u201d that produces an\narray on which virtually any implementation of quicksort takes \u201a.n\n2/time. If the\nimplementation is randomized, the adversary produces the array after seeing therandom choices of the quicksort algorithm.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "211": {"page_number": 212, "page_information": "8 Sorting in Linear Time\nWe have now introduced several algorithms that can sort nnumbers in O.n lgn/\ntime. Merge sort and heapsort achieve this upper bound in the worst case; quicksortachieves it on average. Moreover, for each of these algorithms, we can produce asequence of ninput numbers that causes the algorithm to run in /DEL.n lgn/time.\nThese algorithms share an interesting property: the sorted order they determine\nis based only on comparisons between the input elements . We call such sorting\nalgorithms comparison sorts . All the sorting algorithms introduced thus far are\ncomparison sorts.\nIn Section 8.1, we shall prove that any comparison sort must make /DEL.n lgn/\ncomparisons in the worst case to sort nelements. Thus, merge sort and heapsort\nare asymptotically optimal, and no comparison sort exists that is faster by more\nthan a constant factor.\nSections 8.2, 8.3, and 8.4 examine three sorting algorithms\u2014counting sort, radix\nsort, and bucket sort\u2014that run in linear time. Of course, these algorithms use\noperations other than comparisons to determine the sorted order. Consequently,\nthe/DEL.n lgn/lower bound does not apply to them.\n8.1 Lower bounds for sorting\nIn a comparison sort, we use only comparisons between elements to gain order\ninformation about an input sequence ha1;a2;:::;a ni. That is, given two elements\naiandaj, we perform one of the tests ai<a j,ai/DC4aj,aiDaj,ai/NAKaj,o r\nai>a jto determine their relative order. We may not inspect the values of the\nelements or gain order information about them in any other way.\nIn this section, we assume without loss of generality that all the input elements\nare distinct. Given this assumption, comparisons of the form aiDajare useless,\nso we can assume that no comparisons of this form are made. We also note thatthe comparisons a\ni/DC4aj,ai/NAKaj,ai>a j,a n d ai<a jare all equivalent in that", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "212": {"page_number": 213, "page_information": "192 Chapter 8 Sorting in Linear Time\n\u2264 >\n\u2264 >1:2\n2:3 1:3\n\u23291,2,3 \u232a 1:3 \u23292,1,3 \u232a 2:3\n\u23291,3,2 \u232a \u23293,1,2 \u232a \u23293,2,1 \u232a\u2264 >\n\u2264 >\n\u2264 >\n\u23292,3,1 \u232a\nFigure 8.1 The decision tree for insertion sort operating on three elements. An internal node an-\nnotated by i:jindicates a comparison between aiandaj. A leaf annotated by the permutation\nh/EM.1/; /EM.2/; : : : ; /EM.n/ iindicates the ordering a/EM.1//DC4a/EM.2//DC4/SOH/SOH/SOH/DC4 a/EM.n/. The shaded path\nindicates the decisions made when sorting the input sequence ha1D6; a2D8; a3D5i;t h e\npermutationh3; 1; 2iat the leaf indicates that the sorted ordering is a3D5/DC4a1D6/DC4a2D8.\nThere are 3\u0160D6possible permutations of the input elements, and so the decision tree must have at\nleast6leaves.\nthey yield identical information about the relative order of aiandaj. We therefore\nassume that all comparisons have the form ai/DC4aj.\nThe decision-tree model\nWe can view comparison sorts abstractly in terms of decision trees. A decision\ntree is a full binary tree that represents the comparisons between elements that\nare performed by a particular sorting algorithm operating on an input of a givensize. Control, data movement, and all other aspects of the algorithm are ignored.Figure 8.1 shows the decision tree corresponding to the insertion sort algorithmfrom Section 2.1 operating on an input sequence of three elements.\nIn a decision tree, we annotate each internal node by i:jfor some iandjin the\nrange 1/DC4i;j/DC4n,w h e r e nis the number of elements in the input sequence. We\nalso annotate each leaf by a permutation h/EM.1/; /EM.2/; : : : ; /EM.n/ i. (See Section C.1\nfor background on permutations.) The execution of the sorting algorithm corre-sponds to tracing a simple path from the root of the decision tree down to a leaf.Each internal node indicates a comparison a\ni/DC4aj. The left subtree then dictates\nsubsequent comparisons once we know that ai/DC4aj, and the right subtree dictates\nsubsequent comparisons knowing that ai>a j. When we come to a leaf, the sort-\ning algorithm has established the ordering a/EM.1//DC4a/EM.2//DC4/SOH/SOH/SOH/DC4 a/EM.n/. Because\nany correct sorting algorithm must be able to produce each permutation of its input,each of the n\u0160permutations on nelements must appear as one of the leaves of the\ndecision tree for a comparison sort to be correct. Furthermore, each of these leaves\nmust be reachable from the root by a downward path corresponding to an actual", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "213": {"page_number": 214, "page_information": "8.1 Lower bounds for sorting 193\nexecution of the comparison sort. (We shall refer to such leaves as \u201creachable.\u201d)\nThus, we shall consider only decision trees in which each permutation appears asa reachable leaf.\nA lower bound for the worst case\nThe length of the longest simple path from the root of a decision tree to any of\nits reachable leaves represents the worst-case number of comparisons that the cor-responding sorting algorithm performs. Consequently, the worst-case number ofcomparisons for a given comparison sort algorithm equals the height of its decisiontree. A lower bound on the heights of all decision trees in which each permutationappears as a reachable leaf is therefore a lower bound on the running time of anycomparison sort algorithm. The following theorem establishes such a lower bound.\nTheorem 8.1\nAny comparison sort algorithm requires /DEL.n lgn/comparisons in the worst case.\nProof From the preceding discussion, it suf\ufb01ces to determine the height of a\ndecision tree in which each permutation appears as a reachable leaf. Consider a\ndecision tree of height hwith lreachable leaves corresponding to a comparison\nsort on nelements. Because each of the n\u0160permutations of the input appears as\nsome leaf, we have n\u0160/DC4l. Since a binary tree of height hhas no more than 2\nh\nleaves, we have\nn\u0160/DC4l/DC42h;\nwhich, by taking logarithms, impliesh/NAKlg.n\u0160/ (since the lg function is monotonically increasing)\nD/DEL.n lgn/(by equation (3.19)) .\nCorollary 8.2\nHeapsort and merge sort are asymptotically optimal comparison sorts.\nProof TheO.n lgn/upper bounds on the running times for heapsort and merge\nsort match the /DEL.n lgn/worst-case lower bound from Theorem 8.1.\nExercises\n8.1-1\nWhat is the smallest possible depth of a leaf in a decision tree for a comparisonsort?", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "214": {"page_number": 215, "page_information": "194 Chapter 8 Sorting in Linear Time\n8.1-2\nObtain asymptotically tight bounds on lg .n\u0160/ without using Stirling\u2019s approxi-\nmation. Instead, evaluate the summationPn\nkD1lgkusing techniques from Sec-\ntion A.2.\n8.1-3\nShow that there is no comparison sort whose running time is linear for at least halfof the n\u0160inputs of length n. What about a fraction of 1=nof the inputs of length n?\nWhat about a fraction 1=2\nn?\n8.1-4\nSuppose that you are given a sequence of nelements to sort. The input sequence\nconsists of n=k subsequences, each containing kelements. The elements in a given\nsubsequence are all smaller than the elements in the succeeding subsequence andlarger than the elements in the preceding subsequence. Thus, all that is needed tosort the whole sequence of length nis to sort the kelements in each of the n=k\nsubsequences. Show an /DEL.n lgk/lower bound on the number of comparisons\nneeded to solve this variant of the sorting problem. ( Hint: It is not rigorous to\nsimply combine the lower bounds for the individual subsequences.)\n8.2 Counting sort\nCounting sort assumes that each of the ninput elements is an integer in the range\n0tok, for some integer k.W h e n kDO.n/ , the sort runs in \u201a.n/ time.\nCounting sort determines, for each input element x, the number of elements less\nthanx. It uses this information to place element xdirectly into its position in the\noutput array. For example, if 17elements are less than x,t h e n xbelongs in output\nposition 18. We must modify this scheme slightly to handle the situation in which\nseveral elements have the same value, since we do not want to put them all in thesame position.\nIn the code for counting sort, we assume that the input is an array A\u01521 : : n/c141 ,a n d\nthusA:lengthDn. We require two other arrays: the array B\u0152 1::n /c141 holds the\nsorted output, and the array C\u0152 0::k/c141 provides temporary working storage.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "215": {"page_number": 216, "page_information": "8.2 Counting sort 195\n2530230312345678\n20230112345A\nC\n(a)224778C\n(b)312345678\n224678B\nC\n(c)\n312345678\n124678B\nC\n(d)0 312345678\n124578B\nC\n(e)03\n312345678\nB\n(f)030 223 50123450\n123450 12345 0123450\nFigure 8.2 The operation of C OUNTING -SORT on an input array A \u0152 1::8 /c141 , where each element\nofAis a nonnegative integer no larger than kD5.(a)The array Aand the auxiliary array Cafter\nline 5. (b)The array Cafter line 8. (c)\u2013(e) The output array Band the auxiliary array Cafter one,\ntwo, and three iterations of the loop in lines 10\u201312, respectively. Only the lightly shaded elements ofarray Bhave been \ufb01lled in. (f)The \ufb01nal sorted output array B.\nCOUNTING -SORT. A ;B;k/\n1l e t C\u0152 0::k/c141 b ean e wa r r a y\n2foriD0tok\n3 C\u0152 i/c141D0\n4forjD1toA:length\n5 C \u0152A\u0152j /c141/c141DC \u0152A\u0152j /c141/c141C1\n6//C\u0152 i/c141 now contains the number of elements equal to i.\n7foriD1tok\n8 C\u0152 i/c141DC\u0152 i/c141CC\u0152 i/NUL1/c141\n9//C\u0152 i/c141 now contains the number of elements less than or equal to i.\n10forjDA:length downto 1\n11 B\u0152C \u0152A\u0152j /c141/c141/c141DA\u0152j /c141\n12 C \u0152A\u0152j /c141/c141DC \u0152A\u0152j /c141/c141/NUL1\nFigure 8.2 illustrates counting sort. After the forloop of lines 2\u20133 initializes the\narray Cto all zeros, the forloop of lines 4\u20135 inspects each input element. If the\nvalue of an input element is i, we increment C\u0152 i/c141. Thus, after line 5, C\u0152 i/c141 holds\nthe number of input elements equal to ifor each integer iD0; 1; : : : ; k . Lines 7\u20138\ndetermine for each iD0; 1; : : : ; k how many input elements are less than or equal\ntoiby keeping a running sum of the array C.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "216": {"page_number": 217, "page_information": "196 Chapter 8 Sorting in Linear Time\nFinally, the forloop of lines 10\u201312 places each element A\u0152j /c141 into its correct\nsorted position in the output array B.I fa l l nelements are distinct, then when we\n\ufb01rst enter line 10, for each A\u0152j /c141 ,t h ev a l u e C \u0152A\u0152j /c141/c141 is the correct \ufb01nal position\nofA\u0152j /c141 in the output array, since there are C \u0152A\u0152j /c141/c141 elements less than or equal\ntoA\u0152j /c141 . Because the elements might not be distinct, we decrement C \u0152A\u0152j /c141/c141 each\ntime we place a value A\u0152j /c141 into the Barray. Decrementing C \u0152A\u0152j /c141/c141 causes the\nnext input element with a value equal to A\u0152j /c141 , if one exists, to go to the position\nimmediately before A\u0152j /c141 in the output array.\nHow much time does counting sort require? The forloop of lines 2\u20133 takes\ntime\u201a.k/ ,t h eforloop of lines 4\u20135 takes time \u201a.n/ ,t h eforloop of lines 7\u20138 takes\ntime\u201a.k/ ,a n dt h e forloop of lines 10\u201312 takes time \u201a.n/ . Thus, the overall time\nis\u201a.kCn/. In practice, we usually use counting sort when we have kDO.n/ ,i n\nwhich case the running time is \u201a.n/ .\nCounting sort beats the lower bound of /DEL.n lgn/proved in Section 8.1 because\nit is not a comparison sort. In fact, no comparisons between input elements occur\nanywhere in the code. Instead, counting sort uses the actual values of the elements\nto index into an array. The /DEL.n lgn/lower bound for sorting does not apply when\nwe depart from the comparison sort model.\nAn important property of counting sort is that it is stable : numbers with the same\nvalue appear in the output array in the same order as they do in the input array. Thatis, it breaks ties between two numbers by the rule that whichever number appears\n\ufb01rst in the input array appears \ufb01rst in the output array. Normally, the property of\nstability is important only when satellite data are carried around with the element\nbeing sorted. Counting sort\u2019s stability is important for another reason: countingsort is often used as a subroutine in radix sort. As we shall see in the next section,in order for radix sort to work correctly, counting sort must be stable.\nExercises\n8.2-1\nUsing Figure 8.2 as a model, illustrate the operation of C\nOUNTING -SORT on the\narray ADh6; 0; 2; 0; 1; 3; 4; 6; 1; 3; 2 i.\n8.2-2\nProve that C OUNTING -SORT is stable.\n8.2-3\nSuppose that we were to rewrite the forloop header in line 10 of the C OUNTING -\nSORT as\n10forjD1toA:length\nShow that the algorithm still works properly. Is the modi\ufb01ed algorithm stable?", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "217": {"page_number": 218, "page_information": "8.3 Radix sort 197\n8.2-4\nDescribe an algorithm that, given nintegers in the range 0tok, preprocesses its\ninput and then answers any query about how many of the nintegers fall into a\nrange \u0152 a::b/c141 inO.1/ time. Your algorithm should use \u201a.nCk/preprocessing\ntime.\n8.3 Radix sort\nRadix sort is the algorithm used by the card-sorting machines you now \ufb01nd only in\ncomputer museums. The cards have 80 columns, and in each column a machine canpunch a hole in one of 12 places. The sorter can be mechanically \u201cprogrammed\u201dto examine a given column of each card in a deck and distribute the card into oneof 12 bins depending on which place has been punched. An operator can thengather the cards bin by bin, so that cards with the \ufb01rst place punched are on top ofcards with the second place punched, and so on.\nFor decimal digits, each column uses only 10 places. (The other two places\nare reserved for encoding nonnumeric characters.) A d-digit number would then\noccupy a \ufb01eld of dcolumns. Since the card sorter can look at only one column\nat a time, the problem of sorting ncards on a d-digit number requires a sorting\nalgorithm.\nIntuitively, you might sort numbers on their most signi\ufb01cant digit, sort each of\nthe resulting bins recursively, and then combine the decks in order. Unfortunately,since the cards in 9of the 10bins must be put aside to sort each of the bins, this\nprocedure generates many intermediate piles of cards that you would have to keep\ntrack of. (See Exercise 8.3-5.)\nRadix sort solves the problem of card sorting\u2014counterintuitively\u2014by sorting on\ntheleast signi\ufb01cant digit \ufb01rst. The algorithm then combines the cards into a single\ndeck, with the cards in the 0bin preceding the cards in the 1bin preceding the\ncards in the 2bin, and so on. Then it sorts the entire deck again on the second-least\nsigni\ufb01cant digit and recombines the deck in a like manner. The process continues\nuntil the cards have been sorted on all ddigits. Remarkably, at that point the cards\nare fully sorted on the d-digit number. Thus, only dpasses through the deck are\nrequired to sort. Figure 8.3 shows how radix sort operates on a \u201cdeck\u201d of seven3-digit numbers.\nIn order for radix sort to work correctly, the digit sorts must be stable. The sort\nperformed by a card sorter is stable, but the operator has to be wary about notchanging the order of the cards as they come out of a bin, even though all the cardsin a bin have the same digit in the chosen column.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "218": {"page_number": 219, "page_information": "198 Chapter 8 Sorting in Linear Time\n329\n457657839\n436\n720355\n329457\n657\n839436720\n355 329\n457\n657839436720\n355329\n457\n657\n839436\n720355\nFigure 8.3 The operation of radix sort on a list of seven 3-digit numbers. The leftmost column is\nthe input. The remaining columns show the list after successive sorts on increasingly signi\ufb01cant digit\npositions. Shading indicates the digit position sorted on to produce each list from the previous one.\nIn a typical computer, which is a sequential random-access machine, we some-\ntimes use radix sort to sort records of information that are keyed by multiple \ufb01elds.\nFor example, we might wish to sort dates by three keys: year, month, and day. Wecould run a sorting algorithm with a comparison function that, given two dates,compares years, and if there is a tie, compares months, and if another tie occurs,compares days. Alternatively, we could sort the information three times with astable sort: \ufb01rst on day, next on month, and \ufb01nally on year.\nThe code for radix sort is straightforward. The following procedure assumes that\neach element in the n-element array Ahasddigits, where digit 1is the lowest-order\ndigit and digit dis the highest-order digit.\nR\nADIX -SORT.A; d/\n1foriD1tod\n2 use a stable sort to sort array Aon digit i\nLemma 8.3\nGiven nd-digit numbers in which each digit can take on up to kpossible values,\nRADIX -SORT correctly sorts these numbers in \u201a.d.nCk//time if the stable sort\nit uses takes \u201a.nCk/time.\nProof The correctness of radix sort follows by induction on the column being\nsorted (see Exercise 8.3-3). The analysis of the running time depends on the stable\nsort used as the intermediate sorting algorithm. When each digit is in the range 0\ntok/NUL1(so that it can take on kpossible values), and kis not too large, counting sort\nis the obvious choice. Each pass over nd-digit numbers then takes time \u201a.nCk/.\nThere are dpasses, and so the total time for radix sort is \u201a.d.nCk//.\nWhen dis constant and kDO.n/ , we can make radix sort run in linear time.\nMore generally, we have some \ufb02exibility in how to break each key into digits.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "219": {"page_number": 220, "page_information": "8.3 Radix sort 199\nLemma 8.4\nGiven nb-bit numbers and any positive integer r/DC4b,RADIX -SORT correctly sorts\nthese numbers in \u201a..b=r/.nC2r//time if the stable sort it uses takes \u201a.nCk/\ntime for inputs in the range 0tok.\nProof For a value r/DC4b, we view each key as having dDdb=redigits of rbits\neach. Each digit is an integer in the range 0 to 2r/NUL1, so that we can use counting\nsort with kD2r/NUL1. (For example, we can view a 32-bit word as having four 8-bit\ndigits, so that bD32,rD8,kD2r/NUL1D255,a n d dDb=rD4.) Each pass of\ncounting sort takes time \u201a.nCk/D\u201a.nC2r/and there are dpasses, for a total\nrunning time of \u201a.d.nC2r//D\u201a..b=r/.nC2r//.\nFor given values of nandb, we wish to choose the value of r, with r/DC4b,\nthat minimizes the expression .b=r/.nC2r/.I fb<blgnc, then for any value\nofr/DC4b,w eh a v et h a t .nC2r/D\u201a.n/ . Thus, choosing rDbyields a running\ntime of .b=b/.nC2b/D\u201a.n/ , which is asymptotically optimal. If b/NAKblgnc,\nthen choosing rDblgncgives the best time to within a constant factor, which\nwe can see as follows. Choosing rDblgncyields a running time of \u201a.bn= lgn/.\nAs we increase raboveblgnc,t h e2rterm in the numerator increases faster than\ntherterm in the denominator, and so increasing raboveblgncyields a running\ntime of /DEL.bn= lgn/. If instead we were to decrease rbelowblgnc, then the b=r\nterm increases and the nC2rterm remains at \u201a.n/ .\nIs radix sort preferable to a comparison-based sorting algorithm, such as quick-\nsort? If bDO.lgn/, as is often the case, and we choose r/EMlgn, then radix sort\u2019s\nrunning time is \u201a.n/ , which appears to be better than quicksort\u2019s expected running\ntime of \u201a.n lgn/. The constant factors hidden in the \u201a-notation differ, however.\nAlthough radix sort may make fewer passes than quicksort over the nkeys, each\npass of radix sort may take signi\ufb01cantly longer. Which sorting algorithm we preferdepends on the characteristics of the implementations, of the underlying machine(e.g., quicksort often uses hardware caches more effectively than radix sort), andof the input data. Moreover, the version of radix sort that uses counting sort as theintermediate stable sort does not sort in place, which many of the \u201a.n lgn/-time\ncomparison sorts do. Thus, when primary memory storage is at a premium, wemight prefer an in-place algorithm such as quicksort.\nExercises\n8.3-1\nUsing Figure 8.3 as a model, illustrate the operation of R\nADIX -SORT on the fol-\nlowing list of English words: COW, DOG, SEA, RUG, ROW, MOB, BOX, TAB,BAR, EAR, TAR, DIG, BIG, TEA, NOW, FOX.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "220": {"page_number": 221, "page_information": "200 Chapter 8 Sorting in Linear Time\n8.3-2\nWhich of the following sorting algorithms are stable: insertion sort, merge sort,heapsort, and quicksort? Give a simple scheme that makes any sorting algorithmstable. How much additional time and space does your scheme entail?\n8.3-3\nUse induction to prove that radix sort works. Where does your proof need theassumption that the intermediate sort is stable?\n8.3-4\nShow how to sort nintegers in the range 0ton\n3/NUL1inO.n/ time.\n8.3-5 ?\nIn the \ufb01rst card-sorting algorithm in this section, exactly how many sorting passesare needed to sort d-digit decimal numbers in the worst case? How many piles of\ncards would an operator need to keep track of in the worst case?\n8.4 Bucket sort\nBucket sort assumes that the input is drawn from a uniform distribution and has an\naverage-case running time of O.n/ . Like counting sort, bucket sort is fast because\nit assumes something about the input. Whereas counting sort assumes that the inputconsists of integers in a small range, bucket sort assumes that the input is generatedby a random process that distributes elements uniformly and independently overthe interval \u01520; 1/ . (See Section C.2 for a de\ufb01nition of uniform distribution.)\nBucket sort divides the interval \u01520; 1/ intonequal-sized subintervals, or buckets ,\nand then distributes the ninput numbers into the buckets. Since the inputs are uni-\nformly and independently distributed over \u01520; 1/ , we do not expect many numbers\nto fall into each bucket. To produce the output, we simply sort the numbers in each\nbucket and then go through the buckets in order, listing the elements in each.\nOur code for bucket sort assumes that the input is an n-element array Aand\nthat each element A\u0152i/c141 in the array satis\ufb01es 0/DC4A\u0152i/c141 < 1 . The code requires an\nauxiliary array B\u0152 0::n/NUL1/c141of linked lists (buckets) and assumes that there is a\nmechanism for maintaining such lists. (Section 10.2 describes how to implement\nbasic operations on linked lists.)", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "221": {"page_number": 222, "page_information": "8.4 Bucket sort 201\n1\n23\n4\n567\n8\n9\n10.78\n.17.39\n.72\n.94.21.12.23.68A\n(a)1\n23\n4\n567\n8\n9B\n(b)0\n.12 .17\n.21 .23\n.26.26\n.39\n.68\n.72 .78\n.94\nFigure 8.4 The operation of B UCKET -SORT fornD10.(a)The input array A\u01521 : : 10/c141 .(b)The\narray B\u01520::9/c141 of sorted lists (buckets) after line 8 of the algorithm. Bucket iholds values in the\nhalf-open interval \u0152i=10; .iC1/=10/ . The sorted output consists of a concatenation in order of the\nlistsB\u01520/c141; B\u01521/c141; : : : ; B\u01529/c141 .\nBUCKET -SORT.A/\n1l e t B\u0152 0::n/NUL1/c141b ean e wa r r a y\n2nDA:length\n3foriD0ton/NUL1\n4m a k e B\u0152i/c141 an empty list\n5foriD1ton\n6 insert A\u0152i/c141 into list B\u0152bnA\u0152i/c141c/c141\n7foriD0ton/NUL1\n8 sort list B\u0152i/c141 with insertion sort\n9 concatenate the lists B\u01520/c141; B\u01521/c141; : : : ; B\u0152n /NUL1/c141together in order\nFigure 8.4 shows the operation of bucket sort on an input array of 10numbers.\nTo see that this algorithm works, consider two elements A\u0152i/c141 andA\u0152j /c141 . Assume\nwithout loss of generality that A\u0152i/c141/DC4A\u0152j /c141 .S i n c ebnA\u0152i/c141c/DC4bnA\u0152j /c141c, either\nelement A\u0152i/c141 goes into the same bucket as A\u0152j /c141 or it goes into a bucket with a lower\nindex. If A\u0152i/c141 andA\u0152j /c141 go into the same bucket, then the forloop of lines 7\u20138 puts\nthem into the proper order. If A\u0152i/c141 andA\u0152j /c141 go into different buckets, then line 9\nputs them into the proper order. Therefore, bucket sort works correctly.\nTo analyze the running time, observe that all lines except line 8 take O.n/ time\nin the worst case. We need to analyze the total time taken by the ncalls to insertion\nsort in line 8.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "222": {"page_number": 223, "page_information": "202 Chapter 8 Sorting in Linear Time\nTo analyze the cost of the calls to insertion sort, let nibe the random variable\ndenoting the number of elements placed in bucket B\u0152i/c141. Since insertion sort runs\nin quadratic time (see Section 2.2), the running time of bucket sort is\nT .n/D\u201a.n/Cn/NUL1X\niD0O.n2\ni/:\nWe now analyze the average-case running time of bucket sort, by computing the\nexpected value of the running time, where we take the expectation over the inputdistribution. Taking expectations of both sides and using linearity of expectation,we have\nE\u0152T .n//c141DE\"\n\u201a.n/C\nn/NUL1X\niD0O.n2\ni/#\nD\u201a.n/Cn/NUL1X\niD0E/STX\nO.n2\ni//ETX\n(by linearity of expectation)\nD\u201a.n/Cn/NUL1X\niD0O/NUL\nE/STX\nn2\ni/ETX/SOH\n(by equation (C.22)) . (8.1)\nWe claim that\nE/STX\nn2\ni/ETX\nD2/NUL1=n (8.2)\nforiD0; 1; : : : ; n/NUL1. It is no surprise that each bucket ihas the same value of\nE\u0152n2\ni/c141, since each value in the input array Ais equally likely to fall in any bucket.\nTo prove equation (8.2), we de\ufb01ne indicator random variables\nXijDIfA\u0152j /c141 falls in bucket ig\nforiD0; 1; : : : ; n/NUL1andjD1 ;2;:::;n . Thus,\nniDnX\njD1Xij:\nTo compute E \u0152n2\ni/c141, we expand the square and regroup terms:", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "223": {"page_number": 224, "page_information": "8.4 Bucket sort 203\nE/STX\nn2\ni/ETX\nDE\" nX\njD1Xij!2#\nDE\"nX\njD1nX\nkD1XijXik#\nDE2\n4nX\njD1X2\nijCX\n1/DC4j/DC4nX\n1/DC4k/DC4n\nk\u00a4jXijXik3\n5\nDnX\njD1E/STX\nX2\nij/ETX\nCX\n1/DC4j/DC4nX\n1/DC4k/DC4n\nk\u00a4jE\u0152XijXik/c141; (8.3)\nwhere the last line follows by linearity of expectation. We evaluate the two sum-\nmations separately. Indicator random variable Xijis1with probability 1=n and0\notherwise, and therefore\nE/STX\nX2\nij/ETX\nD12/SOH1\nnC02/SOH/DC2\n1/NUL1\nn/DC3\nD1\nn:\nWhen k\u00a4j, the variables XijandXikare independent, and hence\nE\u0152XijXik/c141DE\u0152Xij/c141E\u0152Xik/c141\nD1\nn/SOH1\nn\nD1\nn2:\nSubstituting these two expected values in equation (8.3), we obtain\nE/STX\nn2\ni/ETX\nDnX\njD11\nnCX\n1/DC4j/DC4nX\n1/DC4k/DC4n\nk\u00a4j1\nn2\nDn/SOH1\nnCn.n/NUL1//SOH1\nn2\nD1Cn/NUL1\nn\nD2/NUL1\nn;\nwhich proves equation (8.2).", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "224": {"page_number": 225, "page_information": "204 Chapter 8 Sorting in Linear Time\nUsing this expected value in equation (8.1), we conclude that the average-case\nrunning time for bucket sort is \u201a.n/Cn/SOHO.2/NUL1=n/D\u201a.n/ .\nEven if the input is not drawn from a uniform distribution, bucket sort may still\nrun in linear time. As long as the input has the property that the sum of the squaresof the bucket sizes is linear in the total number of elements, equation (8.1) tells usthat bucket sort will run in linear time.\nExercises\n8.4-1\nUsing Figure 8.4 as a model, illustrate the operation of B\nUCKET -SORT on the array\nADh:79; :13; :16; :64; :39; :20; :89; :53; :71; :42 i.\n8.4-2\nExplain why the worst-case running time for bucket sort is \u201a.n2/. What simple\nchange to the algorithm preserves its linear average-case running time and makesits worst-case running time O.n lgn/?\n8.4-3\nLetXbe a random variable that is equal to the number of heads in two \ufb02ips of a\nfair coin. What is E \u0152X\n2/c141?W h a ti sE2\u0152X/c141?\n8.4-4 ?\nWe are given npoints in the unit circle, piD.xi;yi/, such that 0<x2\niCy2\ni/DC41\nforiD1 ;2;:::;n . Suppose that the points are uniformly distributed; that is, the\nprobability of \ufb01nding a point in any region of the circle is proportional to the area\nof that region. Design an algorithm with an average-case running time of \u201a.n/ to\nsort the npoints by their distances diDp\nx2\niCy2\nifrom the origin. ( Hint: Design\nthe bucket sizes in B UCKET -SORT to re\ufb02ect the uniform distribution of the points\nin the unit circle.)\n8.4-5 ?\nAprobability distribution function P.x/ for a random variable Xis de\ufb01ned\nbyP.x/DPrfX/DC4xg. Suppose that we draw a list of nrandom variables\nX1;X2;:::;X nfrom a continuous probability distribution function Pthat is com-\nputable in O.1/ time. Give an algorithm that sorts these numbers in linear average-\ncase time.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "225": {"page_number": 226, "page_information": "Problems for Chapter 8 205\nProblems\n8-1 Probabilistic lower bounds on comparison sorting\nIn this problem, we prove a probabilistic /DEL.n lgn/lower bound on the running time\nof any deterministic or randomized comparison sort on ndistinct input elements.\nWe begin by examining a deterministic comparison sort Awith decision tree TA.\nWe assume that every permutation of A\u2019s inputs is equally likely.\na.Suppose that each leaf of TAis labeled with the probability that it is reached\ngiven a random input. Prove that exactly n\u0160leaves are labeled 1=n\u0160 and that the\nrest are labeled 0.\nb.LetD.T / denote the external path length of a decision tree T;t h a ti s , D.T /\nis the sum of the depths of all the leaves of T.L e t Tbe a decision tree with\nk>1 leaves, and let LTandRTbe the left and right subtrees of T. Show that\nD.T /DD.LT/CD.RT/Ck.\nc.Letd.k/ be the minimum value of D.T / over all decision trees Twithk>1\nleaves. Show that d.k/Dmin 1/DC4i/DC4k/NUL1fd.i/Cd.k/NULi/Ckg.(Hint: Consider\na decision tree Twithkleaves that achieves the minimum. Let i0be the number\nof leaves in LTandk/NULi0the number of leaves in RT.)\nd.Prove that for a given value of k>1 andiin the range 1/DC4i/DC4k/NUL1,t h e\nfunction ilgiC.k/NULi/lg.k/NULi/is minimized at iDk=2. Conclude that\nd.k/D/DEL.k lgk/.\ne.Prove that D.T A/D/DEL.n\u0160 lg.n\u0160// , and conclude that the average-case time to\nsortnelements is /DEL.n lgn/.\nNow, consider a randomized comparison sort B. We can extend the decision-\ntree model to handle randomization by incorporating two kinds of nodes: ordinary\ncomparison nodes and \u201crandomization\u201d nodes. A randomization node models arandom choice of the form R\nANDOM .1; r/ made by algorithm B; the node has r\nchildren, each of which is equally likely to be chosen during an execution of thealgorithm.\nf.Show that for any randomized comparison sort B, there exists a deterministic\ncomparison sort Awhose expected number of comparisons is no more than\nthose made by B.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "226": {"page_number": 227, "page_information": "206 Chapter 8 Sorting in Linear Time\n8-2 Sorting in place in linear time\nSuppose that we have an array of ndata records to sort and that the key of each\nrecord has the value 0or1. An algorithm for sorting such a set of records might\npossess some subset of the following three desirable characteristics:\n1. The algorithm runs in O.n/ time.\n2. The algorithm is stable.3. The algorithm sorts in place, using no more than a constant amount of storage\nspace in addition to the original array.\na.Give an algorithm that satis\ufb01es criteria 1 and 2 above.\nb.Give an algorithm that satis\ufb01es criteria 1 and 3 above.\nc.Give an algorithm that satis\ufb01es criteria 2 and 3 above.\nd.Can you use any of your sorting algorithms from parts (a)\u2013(c) as the sorting\nmethod used in line 2 of R\nADIX -SORT,s ot h a tR ADIX -SORT sorts nrecords\nwithb-bit keys in O.bn/ time? Explain how or why not.\ne.Suppose that the nrecords have keys in the range from 1tok.S h o w h o w t o\nmodify counting sort so that it sorts the records in place in O.nCk/time. You\nmay use O.k/ storage outside the input array. Is your algorithm stable? ( Hint:\nHow would you do it for kD3?)\n8-3 Sorting variable-length items\na.You are given an array of integers, where different integers may have different\nnumbers of digits, but the total number of digits over allthe integers in the array\nisn. Show how to sort the array in O.n/ time.\nb.You are given an array of strings, where different strings may have different\nnumbers of characters, but the total number of characters over all the stringsisn. Show how to sort the strings in O.n/ time.\n(Note that the desired order here is the standard alphabetical order; for example,\na<ab<b.)\n8-4 Water jugs\nSuppose that you are given nred and nblue water jugs, all of different shapes and\nsizes. All red jugs hold different amounts of water, as do the blue ones. Moreover,for every red jug, there is a blue jug that holds the same amount of water, and viceversa.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "227": {"page_number": 228, "page_information": "Problems for Chapter 8 207\nYour task is to \ufb01nd a grouping of the jugs into pairs of red and blue jugs that hold\nthe same amount of water. To do so, you may perform the following operation: picka pair of jugs in which one is red and one is blue, \ufb01ll the red jug with water, andthen pour the water into the blue jug. This operation will tell you whether the redor the blue jug can hold more water, or that they have the same volume. Assumethat such a comparison takes one time unit. Your goal is to \ufb01nd an algorithm thatmakes a minimum number of comparisons to determine the grouping. Rememberthat you may not directly compare two red jugs or two blue jugs.\na.Describe a deterministic algorithm that uses \u201a.n\n2/comparisons to group the\njugs into pairs.\nb.Prove a lower bound of /DEL.n lgn/for the number of comparisons that an algo-\nrithm solving this problem must make.\nc.Give a randomized algorithm whose expected number of comparisons is\nO.n lgn/, and prove that this bound is correct. What is the worst-case num-\nber of comparisons for your algorithm?\n8-5 Average sorting\nSuppose that, instead of sorting an array, we just require that the elements increaseon average. More precisely, we call an n-element array Ak-sorted if, for all\niD1 ;2;:::;n/NULk, the following holds:\nP\niCk/NUL1\njDiA\u0152j /c141\nk/DC4PiCk\njDiC1A\u0152j /c141\nk:\na.What does it mean for an array to be 1-sorted?\nb.Give a permutation of the numbers 1 ;2;:::;1 0 that is 2-sorted, but not sorted.\nc.Prove that an n-element array is k-sorted if and only if A\u0152i/c141/DC4A\u0152iCk/c141for all\niD1 ;2;:::;n/NULk.\nd.Give an algorithm that k-sorts an n-element array in O.n lg.n=k// time.\nWe can also show a lower bound on the time to produce a k-sorted array, when k\nis a constant.\ne.Show that we can sort a k-sorted array of length ninO.n lgk/time. ( Hint:\nUse the solution to Exercise 6.5-9. )\nf.Show that when kis a constant, k-sorting an n-element array requires /DEL.n lgn/\ntime. ( Hint: Use the solution to the previous part along with the lower bound\non comparison sorts.)", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "228": {"page_number": 229, "page_information": "208 Chapter 8 Sorting in Linear Time\n8-6 Lower bound on merging sorted lists\nThe problem of merging two sorted lists arises frequently. We have seen a pro-cedure for it as the subroutine M\nERGE in Section 2.3.1. In this problem, we will\nprove a lower bound of 2n/NUL1on the worst-case number of comparisons required\nto merge two sorted lists, each containing nitems.\nFirst we will show a lower bound of 2n/NULo.n/ comparisons by using a decision\ntree.\na.Given 2nnumbers, compute the number of possible ways to divide them into\ntwo sorted lists, each with nnumbers.\nb.Using a decision tree and your answer to part (a), show that any algorithm that\ncorrectly merges two sorted lists must perform at least 2n/NULo.n/ comparisons.\nNow we will show a slightly tighter 2n/NUL1bound.\nc.Show that if two elements are consecutive in the sorted order and from different\nlists, then they must be compared.\nd.Use your answer to the previous part to show a lower bound of 2n/NUL1compar-\nisons for merging two sorted lists.\n8-7 The 0-1 sorting lemma and columnsort\nAcompare-exchange operation on two array elements A\u0152i/c141 andA\u0152j /c141 ,w h e r e i<j ,\nhas the form\nCOMPARE -EXCHANGE . A ;i;j/\n1ifA\u0152i/c141 > A\u0152j /c141\n2 exchange A\u0152i/c141 withA\u0152j /c141\nAfter the compare-exchange operation, we know that A\u0152i/c141/DC4A\u0152j /c141 .\nAnoblivious compare-exchange algorithm operates solely by a sequence of\nprespeci\ufb01ed compare-exchange operations. The indices of the positions comparedin the sequence must be determined in advance, and although they can dependon the number of elements being sorted, they cannot depend on the values beingsorted, nor can they depend on the result of any prior compare-exchange operation.\nFor example, here is insertion sort expressed as an oblivious compare-exchange\nalgorithm:\nI\nNSERTION -SORT.A/\n1forjD2toA:length\n2 foriDj/NUL1downto 1\n3C OMPARE -EXCHANGE . A ;i;iC1/", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "229": {"page_number": 230, "page_information": "Problems for Chapter 8 209\nThe0-1 sorting lemma provides a powerful way to prove that an oblivious\ncompare-exchange algorithm produces a sorted result. It states that if an oblivi-ous compare-exchange algorithm correctly sorts all input sequences consisting ofonly 0s and 1s, then it correctly sorts all inputs containing arbitrary values.\nYou will prove the 0-1 sorting lemma by proving its contrapositive: if an oblivi-\nous compare-exchange algorithm fails to sort an input containing arbitrary values,then it fails to sort some 0-1 input. Assume that an oblivious compare-exchange al-gorithm X fails to correctly sort the array A\u01521 : : n/c141 .L e t A\u0152p/c141 be the smallest value\ninAthat algorithm X puts into the wrong location, and let A\u0152q/c141 be the value that\nalgorithm X moves to the location into which A\u0152p/c141 should have gone. De\ufb01ne an\narray B\u0152 1::n /c141 of 0s and 1s as follows:\nB\u0152i/c141D(\n0ifA\u0152i/c141/DC4A\u0152p/c141 ;\n1ifA\u0152i/c141 > A\u0152p/c141 :\na.Argue that A\u0152q/c141 > A\u0152p/c141 ,s ot h a t B\u0152p/c141D0andB\u0152q/c141D1.\nb.To complete the proof of the 0-1 sorting lemma, prove that algorithm X fails to\nsort array Bcorrectly.\nNow you will use the 0-1 sorting lemma to prove that a particular sorting algo-\nrithm works correctly. The algorithm, columnsort , works on a rectangular array\nofnelements. The array has rrows and scolumns (so that nDrs), subject to\nthree restrictions:\n/SIrmust be even,\n/SIsmust be a divisor of r,a n d\n/SIr/NAK2s2.\nWhen columnsort completes, the array is sorted in column-major order : reading\ndown the columns, from left to right, the elements monotonically increase.\nColumnsort operates in eight steps, regardless of the value of n. The odd steps\nare all the same: sort each column individually. Each even step is a \ufb01xed permuta-tion. Here are the steps:\n1. Sort each column.\n2. Transpose the array, but reshape it back to rrows and scolumns. In other\nwords, turn the leftmost column into the top r=srows, in order; turn the next\ncolumn into the next r=srows, in order; and so on.\n3. Sort each column.\n4. Perform the inverse of the permutation performed in step 2.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "230": {"page_number": 231, "page_information": "210 Chapter 8 Sorting in Linear Time\n10 14 5\n87 1 7\n12 1 6\n16 9 11\n41 52\n18 3 13\n(a)412\n835\n10 7 6\n12 9 11\n16 14 13\n18 15 17\n(b)48 1 0\n12 16 18\n137\n91 4 1 5\n256\n11 13 17\n(c)136\n257\n48 1 0\n91 3 1 5\n11 14 1712 16 18\n(d)141 1\n381 4\n61 01 7\n291 2\n51 31 671 51 8\n(e)\n141 1\n281 2\n391 4\n51 01 661 31 7\n71 51 8\n(f)51 01 6\n61 31 7\n71 51 8\n141 1281 2\n391 4\n(g)41 01 6\n51 11 7\n61 21 8\n171 3281 4\n391 5\n(h)171 3\n281 4\n391 5\n41 01 6\n51 11 7\n61 21 8\n(i)\nFigure 8.5 The steps of columnsort. (a)The input array with 6 rows and 3 columns. (b)After\nsorting each column in step 1. (c)After transposing and reshaping in step 2. (d)After sorting each\nc o l u m ni ns t e p3 . (e)After performing step 4, which inverts the permutation from step 2. (f)After\nsorting each column in step 5. (g)After shifting by half a column in step 6. (h)After sorting each\ncolumn in step 7. (i)After performing step 8, which inverts the permutation from step 6. The array\nis now sorted in column-major order.\n5. Sort each column.\n6. Shift the top half of each column into the bottom half of the same column, and\nshift the bottom half of each column into the top half of the next column to theright. Leave the top half of the leftmost column empty. Shift the bottom halfof the last column into the top half of a new rightmost column, and leave thebottom half of this new column empty.\n7. Sort each column.8. Perform the inverse of the permutation performed in step 6.\nFigure 8.5 shows an example of the steps of columnsort with rD6andsD3.\n(Even though this example violates the requirement that r/NAK2s\n2, it happens to\nwork.)\nc.Argue that we can treat columnsort as an oblivious compare-exchange algo-\nrithm, even if we do not know what sorting method the odd steps use.\nAlthough it might seem hard to believe that columnsort actually sorts, you will\nuse the 0-1 sorting lemma to prove that it does. The 0-1 sorting lemma appliesbecause we can treat columnsort as an oblivious compare-exchange algorithm. A", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "231": {"page_number": 232, "page_information": "Notes for Chapter 8 211\ncouple of de\ufb01nitions will help you apply the 0-1 sorting lemma. We say that an area\nof an array is clean if we know that it contains either all 0s or all 1s. Otherwise,\nthe area might contain mixed 0s and 1s, and it is dirty. From here on, assume that\nthe input array contains only 0s and 1s, and that we can treat it as an array with r\nrows and scolumns.\nd.Prove that after steps 1\u20133, the array consists of some clean rows of 0s at the top,\nsome clean rows of 1s at the bottom, and at most sdirty rows between them.\ne.Prove that after step 4, the array, read in column-major order, starts with a clean\narea of 0s, ends with a clean area of 1s, and has a dirty area of at most s2\nelements in the middle.\nf.Prove that steps 5\u20138 produce a fully sorted 0-1 output. Conclude that column-\nsort correctly sorts all inputs containing arbitrary values.\ng.Now suppose that sdoes not divide r. Prove that after steps 1\u20133, the array\nconsists of some clean rows of 0s at the top, some clean rows of 1s at thebottom, and at most 2s/NUL1dirty rows between them. How large must rbe,\ncompared with s, for columnsort to correctly sort when sdoes not divide r?\nh.Suggest a simple change to step 1 that allows us to maintain the requirement\nthatr/NAK2s\n2even when sdoes not divide r, and prove that with your change,\ncolumnsort correctly sorts.\nChapter notes\nThe decision-tree model for studying comparison sorts was introduced by Fordand Johnson [110]. Knuth\u2019s comprehensive treatise on sorting [211] covers manyvariations on the sorting problem, including the information-theoretic lower boundon the complexity of sorting given here. Ben-Or [39] studied lower bounds forsorting using generalizations of the decision-tree model.\nKnuth credits H. H. Seward with inventing counting sort in 1954, as well as with\nthe idea of combining counting sort with radix sort. Radix sorting starting with theleast signi\ufb01cant digit appears to be a folk algorithm widely used by operators ofmechanical card-sorting machines. According to Knuth, the \ufb01rst published refer-ence to the method is a 1929 document by L. J. Comrie describing punched-cardequipment. Bucket sorting has been in use since 1956, when the basic idea wasproposed by E. J. Isaac and R. C. Singleton [188].\nMunro and Raman [263] give a stable sorting algorithm that performs O.n\n1C/SI/\ncomparisons in the worst case, where 0</SI/DC41is any \ufb01xed constant. Although", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "232": {"page_number": 233, "page_information": "212 Chapter 8 Sorting in Linear Time\nany of the O.n lgn/-time algorithms make fewer comparisons, the algorithm by\nMunro and Raman moves data only O.n/ times and operates in place.\nThe case of sorting nb-bit integers in o.nlgn/time has been considered by\nmany researchers. Several positive results have been obtained, each under slightlydifferent assumptions about the model of computation and the restrictions placedon the algorithm. All the results assume that the computer memory is divided intoaddressable b-bit words. Fredman and Willard [115] introduced the fusion tree data\nstructure and used it to sort nintegers in O.n lgn=lg lgn/time. This bound was\nlater improved to O.np\nlgn/time by Andersson [16]. These algorithms require\nthe use of multiplication and several precomputed constants. Andersson, Hagerup,Nilsson, and Raman [17] have shown how to sort nintegers in O.n lg lgn/time\nwithout using multiplication, but their method requires storage that can be un-bounded in terms of n. Using multiplicative hashing, we can reduce the storage\nneeded to O.n/ , but then the O.n lg lgn/worst-case bound on the running time\nbecomes an expected-time bound. Generalizing the exponential search trees ofAndersson [16], Thorup [335] gave an O.n. lg lgn/\n2/-time sorting algorithm that\ndoes not use multiplication or randomization, and it uses linear space. Combiningthese techniques with some new ideas, Han [158] improved the bound for sortingtoO.n lg lgnlg lg lg n/time. Although these algorithms are important theoretical\nbreakthroughs, they are all fairly complicated and at the present time seem unlikely\nto compete with existing sorting algorithms in practice.\nThe columnsort algorithm in Problem 8-7 is by Leighton [227].", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "233": {"page_number": 234, "page_information": "9 Medians and Order Statistics\nTheithorder statistic of a set of nelements is the ith smallest element. For\nexample, the minimum of a set of elements is the \ufb01rst order statistic ( iD1),\nand the maximum is the nth order statistic ( iDn). Amedian , informally, is\nthe \u201chalfway point\u201d of the set. When nis odd, the median is unique, occurring at\niD.nC1/=2 .W h e n nis even, there are two medians, occurring at iDn=2and\niDn=2C1. Thus, regardless of the parity of n, medians occur at iDb.nC1/=2c\n(thelower median )a n d iDd.nC1/=2e(theupper median ). For simplicity in\nthis text, however, we consistently use the phrase \u201cthe median\u201d to refer to the lower\nmedian.\nThis chapter addresses the problem of selecting the ith order statistic from a\nset of ndistinct numbers. We assume for convenience that the set contains dis-\ntinct numbers, although virtually everything that we do extends to the situation inwhich a set contains repeated values. We formally specify the selection problem\nas follows:\nInput: A set Aofn(distinct) numbers and an integer i, with 1/DC4i/DC4n.\nOutput: The element x2Athat is larger than exactly\ni/NUL1other elements of A.\nWe can solve the selection problem in O.n lgn/time, since we can sort the num-\nbers using heapsort or merge sort and then simply index the ith element in the\noutput array. This chapter presents faster algorithms.\nIn Section 9.1, we examine the problem of selecting the minimum and maxi-\nmum of a set of elements. More interesting is the general selection problem, whichwe investigate in the subsequent two sections. Section 9.2 analyzes a practicalrandomized algorithm that achieves an O.n/ expected running time, assuming dis-\ntinct elements. Section 9.3 contains an algorithm of more theoretical interest thatachieves the O.n/ running time in the worst case.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "234": {"page_number": 235, "page_information": "214 Chapter 9 Medians and Order Statistics\n9.1 Minimum and maximum\nHow many comparisons are necessary to determine the minimum of a set of n\nelements? We can easily obtain an upper bound of n/NUL1comparisons: examine\neach element of the set in turn and keep track of the smallest element seen sofar. In the following procedure, we assume that the set resides in array A,w h e r e\nA:lengthDn.\nM\nINIMUM .A/\n1minDA\u01521/c141\n2foriD2toA:length\n3 ifmin> A\u0152i/c141\n4 minDA\u0152i/c141\n5return min\nWe can, of course, \ufb01nd the maximum with n/NUL1comparisons as well.\nIs this the best we can do? Yes, since we can obtain a lower bound of n/NUL1\ncomparisons for the problem of determining the minimum. Think of any algorithm\nthat determines the minimum as a tournament among the elements. Each compar-\nison is a match in the tournament in which the smaller of the two elements wins.Observing that every element except the winner must lose at least one match, weconclude that n/NUL1comparisons are necessary to determine the minimum. Hence,\nthe algorithm M\nINIMUM is optimal with respect to the number of comparisons\nperformed.\nSimultaneous minimum and maximum\nIn some applications, we must \ufb01nd both the minimum and the maximum of a set\nofnelements. For example, a graphics program may need to scale a set of .x; y/\ndata to \ufb01t onto a rectangular display screen or other graphical output device. To\ndo so, the program must \ufb01rst determine the minimum and maximum value of each\ncoordinate.\nAt this point, it should be obvious how to determine both the minimum and the\nmaximum of nelements using \u201a.n/ comparisons, which is asymptotically optimal:\nsimply \ufb01nd the minimum and maximum independently, using n/NUL1comparisons\nfor each, for a total of 2n/NUL2comparisons.\nIn fact, we can \ufb01nd both the minimum and the maximum using at most 3bn=2c\ncomparisons. We do so by maintaining both the minimum and maximum elementsseen thus far. Rather than processing each element of the input by comparing it\nagainst the current minimum and maximum, at a cost of 2comparisons per element,", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "235": {"page_number": 236, "page_information": "9.2 Selection in expected linear time 215\nwe process elements in pairs. We compare pairs of elements from the input \ufb01rst\nwith each other , and then we compare the smaller with the current minimum and\nthe larger to the current maximum, at a cost of 3comparisons for every 2elements.\nHow we set up initial values for the current minimum and maximum depends\non whether nis odd or even. If nis odd, we set both the minimum and maximum\nto the value of the \ufb01rst element, and then we process the rest of the elements inpairs. If nis even, we perform 1comparison on the \ufb01rst 2elements to determine\nthe initial values of the minimum and maximum, and then process the rest of the\nelements in pairs as in the case for odd n.\nLet us analyze the total number of comparisons. If nis odd, then we perform\n3bn=2ccomparisons. If nis even, we perform 1initial comparison followed by\n3.n/NUL2/=2 comparisons, for a total of 3n=2/NUL2. Thus, in either case, the total\nnumber of comparisons is at most 3bn=2c.\nExercises\n9.1-1\nShow that the second smallest of nelements can be found with nCdlgne/NUL2\ncomparisons in the worst case. ( Hint: Also \ufb01nd the smallest element.)\n9.1-2 ?\nProve the lower bound of d3n=2e/NUL2comparisons in the worst case to \ufb01nd both\nthe maximum and minimum of nnumbers. ( Hint: Consider how many numbers\nare potentially either the maximum or minimum, and investigate how a comparison\naffects these counts.)\n9.2 Selection in expected linear time\nThe general selection problem appears more dif\ufb01cult than the simple problem of\ufb01nding a minimum. Yet, surprisingly, the asymptotic running time for both prob-lems is the same: \u201a.n/ . In this section, we present a divide-and-conquer algorithm\nfor the selection problem. The algorithm R\nANDOMIZED -SELECT is modeled after\nthe quicksort algorithm of Chapter 7. As in quicksort, we partition the input arrayrecursively. But unlike quicksort, which recursively processes both sides of thepartition, R\nANDOMIZED -SELECT works on only one side of the partition. This\ndifference shows up in the analysis: whereas quicksort has an expected runningtime of \u201a.n lgn/, the expected running time of R\nANDOMIZED -SELECT is\u201a.n/ ,\nassuming that the elements are distinct.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "236": {"page_number": 237, "page_information": "216 Chapter 9 Medians and Order Statistics\nRANDOMIZED -SELECT uses the procedure R ANDOMIZED -PARTITION intro-\nduced in Section 7.3. Thus, like R ANDOMIZED -QUICKSORT , it is a randomized al-\ngorithm, since its behavior is determined in part by the output of a random-numbergenerator. The following code for R\nANDOMIZED -SELECT returns the ith smallest\nelement of the array A\u0152p : : r/c141 .\nRANDOMIZED -SELECT . A ;p;r ;i/\n1ifp==r\n2 return A\u0152p/c141\n3qDRANDOMIZED -PARTITION . A ;p;r/\n4kDq/NULpC1\n5ifi==k //the pivot value is the answer\n6 return A\u0152q/c141\n7elseif i<k\n8 return RANDOMIZED -SELECT . A ;p;q/NUL1; i/\n9else return RANDOMIZED -SELECT .A; qC1; r; i/NULk/\nThe R ANDOMIZED -SELECT procedure works as follows. Line 1 checks for the\nbase case of the recursion, in which the subarray A\u0152p : : r/c141 consists of just one\nelement. In this case, imust equal 1, and we simply return A\u0152p/c141 in line 2 as the\nith smallest element. Otherwise, the call to R ANDOMIZED -PARTITION in line 3\npartitions the array A\u0152p : : r/c141 into two (possibly empty) subarrays A\u0152p : : q/NUL1/c141\nandA\u0152qC1::r/c141 such that each element of A\u0152p : : q/NUL1/c141is less than or equal\ntoA\u0152q/c141, which in turn is less than each element of A\u0152qC1::r/c141 . As in quicksort,\nwe will refer to A\u0152q/c141 as the pivot element. Line 4 computes the number kof\nelements in the subarray A\u0152p : : q/c141 , that is, the number of elements in the low side\nof the partition, plus one for the pivot element. Line 5 then checks whether A\u0152q/c141 is\ntheith smallest element. If it is, then line 6 returns A\u0152q/c141. Otherwise, the algorithm\ndetermines in which of the two subarrays A\u0152p : : q/NUL1/c141andA\u0152qC1::r/c141 theith\nsmallest element lies. If i<k , then the desired element lies on the low side of\nthe partition, and line 8 recursively selects it from the subarray. If i>k ,h o w e v e r ,\nthen the desired element lies on the high side of the partition. Since we alreadyknow kvalues that are smaller than the ith smallest element of A\u0152p : : r/c141 \u2014namely,\nthe elements of A\u0152p : : q/c141 \u2014the desired element is the .i/NULk/th smallest element\nofA\u0152qC1::r/c141 , which line 9 \ufb01nds recursively. The code appears to allow recursive\ncalls to subarrays with 0elements, but Exercise 9.2-1 asks you to show that this\nsituation cannot happen.\nThe worst-case running time for R\nANDOMIZED -SELECT is\u201a.n2/,e v e nt o\ufb01 n d\nthe minimum, because we could be extremely unlucky and always partition aroundthe largest remaining element, and partitioning takes \u201a.n/ time. We will see that", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "237": {"page_number": 238, "page_information": "9.2 Selection in expected linear time 217\nthe algorithm has a linear expected running time, though, and because it is random-\nized, no particular input elicits the worst-case behavior.\nTo analyze the expected running time of R ANDOMIZED -SELECT , we let the run-\nning time on an input array A\u0152p : : r/c141 ofnelements be a random variable that we\ndenote by T .n/ , and we obtain an upper bound on E \u0152T .n//c141 as follows. The pro-\ncedure R ANDOMIZED -PARTITION is equally likely to return any element as the\npivot. Therefore, for each ksuch that 1/DC4k/DC4n, the subarray A\u0152p : : q/c141 haskele-\nments (all less than or equal to the pivot) with probability 1=n.F o r kD1 ;2;:::;n ,\nwe de\ufb01ne indicator random variables Xkwhere\nXkDIfthe subarray A\u0152p : : q/c141 has exactly kelementsg;\nand so, assuming that the elements are distinct, we haveE\u0152X\nk/c141D1=n : (9.1)\nWhen we call R ANDOMIZED -SELECT and choose A\u0152q/c141 as the pivot element, we\ndo not know, a priori, if we will terminate immediately with the correct answer,recurse on the subarray A\u0152p : : q/NUL1/c141, or recurse on the subarray A\u0152qC1::r/c141 .\nThis decision depends on where the ith smallest element falls relative to A\u0152q/c141.\nAssuming that T .n/ is monotonically increasing, we can upper-bound the time\nneeded for the recursive call by the time needed for the recursive call on the largest\npossible input. In other words, to obtain an upper bound, we assume that the ith\nelement is always on the side of the partition with the greater number of elements.\nFor a given call of R\nANDOMIZED -SELECT , the indicator random variable Xkhas\nthe value 1for exactly one value of k, and it is 0for all other k.W h e n XkD1,t h e\ntwo subarrays on which we might recurse have sizes k/NUL1andn/NULk. Hence, we\nhave the recurrence\nT .n//DC4nX\nkD1Xk/SOH.T .max.k/NUL1; n/NULk//CO.n//\nDnX\nkD1Xk/SOHT.max.k/NUL1; n/NULk//CO.n/ :", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "238": {"page_number": 239, "page_information": "218 Chapter 9 Medians and Order Statistics\nTaking expected values, we have\nE\u0152T .n//c141\n/DC4E\"nX\nkD1Xk/SOHT.max.k/NUL1; n/NULk//CO.n/#\nDnX\nkD1E\u0152Xk/SOHT.max.k/NUL1; n/NULk///c141CO.n/ (by linearity of expectation)\nDnX\nkD1E\u0152Xk/c141/SOHE\u0152T .max.k/NUL1; n/NULk///c141CO.n/ (by equation (C.24))\nDnX\nkD11\nn/SOHE\u0152T .max.k/NUL1; n/NULk///c141CO.n/ (by equation (9.1)) .\nIn order to apply equation (C.24), we rely on XkandT.max.k/NUL1; n/NULk//being\nindependent random variables. Exercise 9.2-2 asks you to justify this assertion.\nLet us consider the expression max .k/NUL1; n/NULk/.W eh a v e\nmax.k/NUL1; n/NULk/D(\nk/NUL1ifk>dn=2e;\nn/NULkifk/DC4dn=2e:\nIfnis even, each term from T.dn=2e/up to T. n/NUL1/appears exactly twice in\nthe summation, and if nis odd, all these terms appear twice and T.bn=2c/appears\nonce. Thus, we have\nE\u0152T .n//c141/DC42\nnn/NUL1X\nkDbn=2cE\u0152T .k//c141CO.n/ :\nWe show that E \u0152T .n//c141DO.n/ by substitution. Assume that E \u0152T .n//c141/DC4cnfor\nsome constant cthat satis\ufb01es the initial conditions of the recurrence. We assume\nthatT .n/DO.1/ fornless than some constant; we shall pick this constant later.\nWe also pick a constant asuch that the function described by the O.n/ term above\n(which describes the non-recursive component of the running time of the algo-rithm) is bounded from above by anfor all n>0 . Using this inductive hypothesis,\nwe have\nE\u0152T .n//c141/DC42\nnn/NUL1X\nkDbn=2cckCan\nD2c\nn n/NUL1X\nkD1k/NULbn=2c/NUL1X\nkD1k!\nCan", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "239": {"page_number": 240, "page_information": "9.2 Selection in expected linear time 219\nD2c\nn/DC2.n/NUL1/n\n2/NUL.bn=2c/NUL1/bn=2c\n2/DC3\nCan\n/DC42c\nn/DC2.n/NUL1/n\n2/NUL.n=2/NUL2/.n=2/NUL1/\n2/DC3\nCan\nD2c\nn/DC2n2/NULn\n2/NULn2=4/NUL3n=2C2\n2/DC3\nCan\nDc\nn/DC23n2\n4Cn\n2/NUL2/DC3\nCan\nDc/DC23n\n4C1\n2/NUL2\nn/DC3\nCan\n/DC43cn\n4Cc\n2Can\nDcn/NUL/DLEcn\n4/NULc\n2/NULan/DC1\n:\nIn order to complete the proof, we need to show that for suf\ufb01ciently large n,t h i s\nlast expression is at most cnor, equivalently, that cn=4/NULc=2/NULan/NAK0.I f w e\naddc=2to both sides and factor out n,w eg e t n.c=4/NULa//NAKc=2. As long as we\nchoose the constant cso that c=4/NULa>0 , i.e., c>4 a , we can divide both sides\nbyc=4/NULa,g i v i n g\nn/NAKc=2\nc=4/NULaD2c\nc/NUL4a:\nThus, if we assume that T .n/DO.1/ forn<2 c = . c/NUL4a/,t h e nE \u0152T .n//c141DO.n/ .\nWe conclude that we can \ufb01nd any order statistic, and in particular the median, inexpected linear time, assuming that the elements are distinct.\nExercises\n9.2-1\nShow that R\nANDOMIZED -SELECT never makes a recursive call to a 0-length array.\n9.2-2\nArgue that the indicator random variable Xkand the value T.max.k/NUL1; n/NULk//\nare independent.\n9.2-3\nWrite an iterative version of R ANDOMIZED -SELECT .", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "240": {"page_number": 241, "page_information": "220 Chapter 9 Medians and Order Statistics\n9.2-4\nSuppose we use R ANDOMIZED -SELECT to select the minimum element of the\narray ADh3; 2; 9; 0; 7; 5; 4; 8; 6; 1 i. Describe a sequence of partitions that results\nin a worst-case performance of R ANDOMIZED -SELECT .\n9.3 Selection in worst-case linear time\nWe now examine a selection algorithm whose running time is O.n/ in the worst\ncase. Like R ANDOMIZED -SELECT , the algorithm S ELECT \ufb01nds the desired ele-\nment by recursively partitioning the input array. Here, however, we guarantee a\ngood split upon partitioning the array. S ELECT uses the deterministic partitioning\nalgorithm P ARTITION from quicksort (see Section 7.1), but modi\ufb01ed to take the\nelement to partition around as an input parameter.\nThe S ELECT algorithm determines the ith smallest of an input array of n>1\ndistinct elements by executing the following steps. (If nD1,t h e nS ELECT merely\nreturns its only input value as the ith smallest.)\n1. Divide the nelements of the input array into bn=5cgroups of 5elements each\nand at most one group made up of the remaining nmod5elements.\n2. Find the median of each of the dn=5egroups by \ufb01rst insertion-sorting the ele-\nments of each group (of which there are at most 5) and then picking the median\nfrom the sorted list of group elements.\n3. Use S ELECT recursively to \ufb01nd the median xof thedn=5emedians found in\nstep 2. (If there are an even number of medians, then by our convention, xis\nthe lower median.)\n4. Partition the input array around the median-of-medians xusing the modi\ufb01ed\nversion of P ARTITION .L e t kbe one more than the number of elements on the\nlow side of the partition, so that xis the kth smallest element and there are n/NULk\nelements on the high side of the partition.\n5. If iDk, then return x. Otherwise, use S ELECT recursively to \ufb01nd the ith\nsmallest element on the low side if i<k ,o rt h e .i/NULk/th smallest element on\nthe high side if i>k .\nTo analyze the running time of S ELECT , we \ufb01rst determine a lower bound on the\nnumber of elements that are greater than the partitioning element x. Figure 9.1\nhelps us to visualize this bookkeeping. At least half of the medians found in", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "241": {"page_number": 242, "page_information": "9.3 Selection in worst-case linear time 221\nx\nFigure 9.1 Analysis of the algorithm S ELECT .T h e nelements are represented by small circles,\nand each group of 5elements occupies a column. The medians of the groups are whitened, and the\nmedian-of-medians xis labeled. (When \ufb01nding the median of an even number of elements, we use\nthe lower median.) Arrows go from larger elements to smaller, from which we can see that 3out\nof every full group of 5elements to the right of xare greater than x,a n d 3out of every group of 5\nelements to the left of xare less than x. The elements known to be greater than xappear on a shaded\nbackground.\nstep 2 are greater than or equal to the median-of-medians x.1Thus, at least half\nof thedn=5egroups contribute at least 3elements that are greater than x, except\nfor the one group that has fewer than 5elements if 5does not divide nexactly, and\nthe one group containing xitself. Discounting these two groups, it follows that the\nnumber of elements greater than xis at least\n3/DC2/CAN1\n2ln\n5m/EM\n/NUL2/DC3\n/NAK3n\n10/NUL6:\nSimilarly, at least 3n=10/NUL6elements are less than x. Thus, in the worst case,\nstep 5 calls S ELECT recursively on at most 7n=10C6elements.\nWe can now develop a recurrence for the worst-case running time T .n/ of the\nalgorithm S ELECT . Steps 1, 2, and 4 take O.n/ time. (Step 2 consists of O.n/\ncalls of insertion sort on sets of size O.1/ .) Step 3 takes time T.dn=5e/, and step 5\ntakes time at most T. 7 n = 1 0C6/, assuming that Tis monotonically increasing.\nWe make the assumption, which seems unmotivated at \ufb01rst, that any input of fewerthan 140 elements requires O.1/ time; the origin of the magic constant 140 will be\nclear shortly. We can therefore obtain the recurrence\n1Because of our assumption that the numbers are distinct, all medians except xare either greater\nthan or less than x.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "242": {"page_number": 243, "page_information": "222 Chapter 9 Medians and Order Statistics\nT .n//DC4(\nO.1/ ifn < 140 ;\nT.dn=5e/CT. 7 n = 1 0C6/CO.n/ ifn/NAK140 :\nWe show that the running time is linear by substitution. More speci\ufb01cally, we will\nshow that T .n//DC4cnfor some suitably large constant cand all n>0 .W eb e g i nb y\nassuming that T .n//DC4cnfor some suitably large constant cand all n < 140 ;t h i s\nassumption holds if cis large enough. We also pick a constant asuch that the func-\ntion described by the O.n/ term above (which describes the non-recursive compo-\nnent of the running time of the algorithm) is bounded above by anfor all n>0 .\nSubstituting this inductive hypothesis into the right-hand side of the recurrenceyields\nT .n//DC4cdn=5eCc.7n=10C6/Can\n/DC4cn=5CcC7cn=10C6cCan\nD9cn=10C7cCan\nDcnC./NULcn=10C7cCan/ ;\nwhich is at most cnif\n/NULcn=10C7cCan\n/DC40: (9.2)\nInequality (9.2) is equivalent to the inequality c/NAK10a.n=.n/NUL70// when n>7 0 .\nBecause we assume that n/NAK140,w eh a v e n=.n/NUL70//DC42, and so choos-\ningc/NAK20awill satisfy inequality (9.2). (Note that there is nothing special about\nthe constant 140; we could replace it by any integer strictly greater than 70 andthen choose caccordingly.) The worst-case running time of S\nELECT is therefore\nlinear.\nAs in a comparison sort (see Section 8.1), S ELECT and R ANDOMIZED -SELECT\ndetermine information about the relative order of elements only by comparing ele-ments. Recall from Chapter 8 that sorting requires /DEL.n lgn/time in the compari-\nson model, even on average (see Problem 8-1). The linear-time sorting algorithmsin Chapter 8 make assumptions about the input. In contrast, the linear-time se-lection algorithms in this chapter do not require any assumptions about the input.They are not subject to the /DEL.n lgn/lower bound because they manage to solve\nthe selection problem without sorting. Thus, solving the selection problem by sort-ing and indexing, as presented in the introduction to this chapter, is asymptoticallyinef\ufb01cient.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "243": {"page_number": 244, "page_information": "9.3 Selection in worst-case linear time 223\nExercises\n9.3-1\nIn the algorithm S ELECT , the input elements are divided into groups of 5. Will\nthe algorithm work in linear time if they are divided into groups of 7? Argue that\nSELECT does not run in linear time if groups of 3are used.\n9.3-2\nAnalyze S ELECT to show that if n/NAK140, then at leastdn=4eelements are greater\nthan the median-of-medians xand at leastdn=4eelements are less than x.\n9.3-3\nShow how quicksort can be made to run in O.n lgn/time in the worst case, as-\nsuming that all elements are distinct.\n9.3-4 ?\nSuppose that an algorithm uses only comparisons to \ufb01nd the ith smallest element\nin a set of nelements. Show that it can also \ufb01nd the i/NUL1smaller elements and\nthen/NULilarger elements without performing any additional comparisons.\n9.3-5\nSuppose that you have a \u201cblack-box\u201d worst-case linear-time median subroutine.Give a simple, linear-time algorithm that solves the selection problem for an arbi-trary order statistic.\n9.3-6\nThekthquantiles of an n-element set are the k/NUL1order statistics that divide the\nsorted set into kequal-sized sets (to within 1). Give an O.n lgk/-time algorithm\nto list the kth quantiles of a set.\n9.3-7\nDescribe an O.n/ -time algorithm that, given a set Sofndistinct numbers and\na positive integer k/DC4n, determines the knumbers in Sthat are closest to the\nmedian of S.\n9.3-8\nLetX\u01521::n/c141 andY\u0152 1::n /c141 be two arrays, each containing nnumbers already in\nsorted order. Give an O.lgn/-time algorithm to \ufb01nd the median of all\n2nelements\nin arrays XandY.\n9.3-9\nProfessor Olay is consulting for an oil company, which is planning a large pipelinerunning east to west through an oil \ufb01eld of nwells. The company wants to connect", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "244": {"page_number": 245, "page_information": "224 Chapter 9 Medians and Order Statistics\nFigure 9.2 Professor Olay needs to determine the position of the east-west oil pipeline that mini-\nmizes the total length of the north-south spurs.\na spur pipeline from each well directly to the main pipeline along a shortest route\n(either north or south), as shown in Figure 9.2. Given the x-a n d y-coordinates of\nthe wells, how should the professor pick the optimal location of the main pipeline,which would be the one that minimizes the total length of the spurs? Show how todetermine the optimal location in linear time.\nProblems\n9-1 Largest inumbers in sorted order\nGiven a set of nnumbers, we wish to \ufb01nd the ilargest in sorted order using a\ncomparison-based algorithm. Find the algorithm that implements each of the fol-lowing methods with the best asymptotic worst-case running time, and analyze therunning times of the algorithms in terms of nandi.\na.Sort the numbers, and list the ilargest.\nb.Build a max-priority queue from the numbers, and call E\nXTRACT -MAXitimes.\nc.Use an order-statistic algorithm to \ufb01nd the ith largest number, partition around\nthat number, and sort the ilargest numbers.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "245": {"page_number": 246, "page_information": "Problems for Chapter 9 225\n9-2 Weighted median\nForndistinct elements x1;x2;:::;x nwith positive weights w1;w2;:::;w nsuch\nthatPn\niD1wiD1,t h eweighted (lower) median is the element xksatisfying\nX\nxi<xkwi<1\n2\nand\nX\nxi>xkwi/DC41\n2:\nFor example, if the elements are 0:1; 0:35; 0:05; 0:1; 0:15; 0:05; 0:2 and each ele-\nment equals its weight (that is, wiDxiforiD1 ;2;:::;7 ), then the median is 0:1,\nbut the weighted median is 0:2.\na.Argue that the median of x1;x2;:::;x nis the weighted median of the xiwith\nweights wiD1=nforiD1 ;2;:::;n .\nb.Show how to compute the weighted median of nelements in O.n lgn/worst-\ncase time using sorting.\nc.Show how to compute the weighted median in \u201a.n/ worst-case time using a\nlinear-time median algorithm such as S ELECT from Section 9.3.\nThepost-of\ufb01ce location problem is de\ufb01ned as follows. We are given npoints\np1;p2;:::;p nwith associated weights w1;w2;:::;w n. We wish to \ufb01nd a point p\n(not necessarily one of the input points) that minimizes the sumPn\niD1wid.p;p i/,\nwhere d.a;b/ is the distance between points aandb.\nd.Argue that the weighted median is a best solution for the 1-dimensional post-\nof\ufb01ce location problem, in which points are simply real numbers and the dis-\ntance between points aandbisd.a;b/Dja/NULbj.\ne.Find the best solution for the 2-dimensional post-of\ufb01ce location problem, in\nwhich the points are .x; y/ coordinate pairs and the distance between points\naD.x1;y1/andbD.x2;y2/is the Manhattan distance given by d.a;b/D\njx1/NULx2jCjy1/NULy2j.\n9-3 Small order statistics\nWe showed that the worst-case number T .n/ of comparisons used by S ELECT\nto select the ith order statistic from nnumbers satis\ufb01es T .n/D\u201a.n/ ,b u tt h e\nconstant hidden by the \u201a-notation is rather large. When iis small relative to n,w e\ncan implement a different procedure that uses S ELECT as a subroutine but makes\nfewer comparisons in the worst case.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "246": {"page_number": 247, "page_information": "226 Chapter 9 Medians and Order Statistics\na.Describe an algorithm that uses Ui.n/comparisons to \ufb01nd the ith smallest of n\nelements, where\nUi.n/D(\nT .n/ ifi/NAKn=2 ;\nbn=2cCUi.dn=2e/CT. 2i/ otherwise :\n(Hint: Begin withbn=2cdisjoint pairwise comparisons, and recurse on the set\ncontaining the smaller element from each pair.)\nb.Show that, if i<n = 2 ,t h e n Ui.n/DnCO.T.2i/ lg.n=i// .\nc.Show that if iis a constant less than n=2,t h e n Ui.n/DnCO.lgn/.\nd.Show that if iDn=k fork/NAK2,t h e n Ui.n/DnCO.T.2n=k/ lgk/.\n9-4 Alternative analysis of randomized selection\nIn this problem, we use indicator random variables to analyze the R ANDOMIZED -\nSELECT procedure in a manner akin to our analysis of R ANDOMIZED -QUICKSORT\nin Section 7.4.2.\nAs in the quicksort analysis, we assume that all elements are distinct, and we\nrename the elements of the input array Aas\u00b41;\u00b42;:::;\u00b4 n,w h e r e \u00b4iis the ith\nsmallest element. Thus, the call R ANDOMIZED -SELECT . A ;1 ;n;k/ returns \u00b4k.\nFor1/DC4i<j/DC4n,l e t\nXij kDIf\u00b4iis compared with \u00b4jsometime during the execution of the algorithm\nto \ufb01nd \u00b4kg:\na.Give an exact expression for E \u0152Xij k/c141.(Hint: Your expression may have differ-\nent values, depending on the values of i,j,a n d k.)\nb.LetXkdenote the total number of comparisons between elements of array A\nwhen \ufb01nding \u00b4k. Show that\nE\u0152Xk/c141/DC42 kX\niD1nX\njDk1\nj/NULiC1CnX\njDkC1j/NULk/NUL1\nj/NULkC1Ck/NUL2X\niD1k/NULi/NUL1\nk/NULiC1!\n:\nc.Show that E \u0152Xk/c141/DC44n.\nd.Conclude that, assuming all elements of array Aare distinct, R ANDOMIZED -\nSELECT runs in expected time O.n/ .", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "247": {"page_number": 248, "page_information": "Notes for Chapter 9 227\nChapter notes\nThe worst-case linear-time median-\ufb01nding algorithm was devised by Blum, Floyd,\nPratt, Rivest, and Tarjan [50]. The fast randomized version is due to Hoare [169].Floyd and Rivest [108] have developed an improved randomized version that parti-tions around an element recursively selected from a small sample of the elements.\nIt is still unknown exactly how many comparisons are needed to determine the\nmedian. Bent and John [41] gave a lower bound of 2ncomparisons for median\n\ufb01nding, and Sch\u00a8 onhage, Paterson, and Pippenger [302] gave an upper bound of 3n.\nDor and Zwick have improved on both of these bounds. Their upper bound [93]is slightly less than 2:95n , and their lower bound [94] is .2C/SI/n,f o ras m a l l\npositive constant /SI, thereby improving slightly on related work by Dor et al. [92].\nPaterson [272] describes some of these results along with other related work.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "248": {"page_number": 249, "page_information": "III Data Structures", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "249": {"page_number": 250, "page_information": "Introduction\nSets are as fundamental to computer science as they are to mathematics. Whereas\nmathematical sets are unchanging, the sets manipulated by algorithms can grow,shrink, or otherwise change over time. We call such sets dynamic . The next \ufb01ve\nchapters present some basic techniques for representing \ufb01nite dynamic sets andmanipulating them on a computer.\nAlgorithms may require several different types of operations to be performed on\nsets. For example, many algorithms need only the ability to insert elements into,delete elements from, and test membership in a set. We call a dynamic set thatsupports these operations a dictionary . Other algorithms require more complicated\noperations. For example, min-priority queues, which Chapter 6 introduced in thecontext of the heap data structure, support the operations of inserting an elementinto and extracting the smallest element from a set. The best way to implement a\ndynamic set depends upon the operations that must be supported.\nElements of a dynamic set\nIn a typical implementation of a dynamic set, each element is represented by an\nobject whose attributes can be examined and manipulated if we have a pointer to\nthe object. (Section 10.3 discusses the implementation of objects and pointers in\nprogramming environments that do not contain them as basic data types.) Some\nkinds of dynamic sets assume that one of the object\u2019s attributes is an identifying\nkey. If the keys are all different, we can think of the dynamic set as being a set\nof key values. The object may contain satellite data , which are carried around in\nother object attributes but are otherwise unused by the set implementation. It may", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "250": {"page_number": 251, "page_information": "230 Part III Data Structures\nalso have attributes that are manipulated by the set operations; these attributes may\ncontain data or pointers to other objects in the set.\nSome dynamic sets presuppose that the keys are drawn from a totally ordered\nset, such as the real numbers, or the set of all words under the usual alphabeticordering. A total ordering allows us to de\ufb01ne the minimum element of the set, forexample, or to speak of the next element larger than a given element in a set.\nOperations on dynamic sets\nOperations on a dynamic set can be grouped into two categories: queries ,w h i c h\nsimply return information about the set, and modifying operations , which change\nthe set. Here is a list of typical operations. Any speci\ufb01c application will usuallyrequire only a few of these to be implemented.\nS\nEARCH .S; k/\nA query that, given a set Sa n dak e yv a l u e k, returns a pointer xto an element\ninSsuch that x:keyDk,o r NILif no such element belongs to S.\nINSERT .S; x/\nA modifying operation that augments the set Swith the element pointed to\nbyx. We usually assume that any attributes in element xneeded by the set\nimplementation have already been initialized.\nDELETE .S; x/\nA modifying operation that, given a pointer xto an element in the set S,r e -\nmoves xfrom S. (Note that this operation takes a pointer to an element x, not\nak e yv a l u e . )\nMINIMUM .S/\nA query on a totally ordered set Sthat returns a pointer to the element of S\nwith the smallest key.\nMAXIMUM .S/\nA query on a totally ordered set Sthat returns a pointer to the element of S\nwith the largest key.\nSUCCESSOR .S; x/\nA query that, given an element xwhose key is from a totally ordered set S,\nreturns a pointer to the next larger element in S,o r NILifxis the maximum\nelement.\nPREDECESSOR .S; x/\nA query that, given an element xwhose key is from a totally ordered set S,\nreturns a pointer to the next smaller element in S,o r NILifxis the minimum\nelement.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "251": {"page_number": 252, "page_information": "Part III Data Structures 231\nIn some situations, we can extend the queries S UCCESSOR and P REDECESSOR\nso that they apply to sets with nondistinct keys. For a set on nkeys, the normal\npresumption is that a call to M INIMUM followed by n/NUL1calls to S UCCESSOR\nenumerates the elements in the set in sorted order.\nWe usually measure the time taken to execute a set operation in terms of the size\nof the set. For example, Chapter 13 describes a data structure that can support anyof the operations listed above on a set of size nin time O.lgn/.\nOverview of Part III\nChapters 10\u201314 describe several data structures that we can use to implement\ndynamic sets; we shall use many of these later to construct ef\ufb01cient algorithmsfor a variety of problems. We already saw another important data structure\u2014the\nheap\u2014in Chapter 6.\nChapter 10 presents the essentials of working with simple data structures such\nas stacks, queues, linked lists, and rooted trees. It also shows how to implementobjects and pointers in programming environments that do not support them asprimitives. If you have taken an introductory programming course, then much ofthis material should be familiar to you.\nChapter 11 introduces hash tables, which support the dictionary operations I\nN-\nSERT ,DELETE ,a n dS EARCH . In the worst case, hashing requires \u201a.n/ time to per-\nform a S EARCH operation, but the expected time for hash-table operations is O.1/ .\nThe analysis of hashing relies on probability, but most of the chapter requires nobackground in the subject.\nBinary search trees, which are covered in Chapter 12, support all the dynamic-\nset operations listed above. In the worst case, each operation takes \u201a.n/ time on a\ntree with nelements, but on a randomly built binary search tree, the expected time\nfor each operation is O.lgn/. Binary search trees serve as the basis for many other\ndata structures.\nChapter 13 introduces red-black trees, which are a variant of binary search trees.\nUnlike ordinary binary search trees, red-black trees are guaranteed to perform well:operations take O.lgn/time in the worst case. A red-black tree is a balanced search\ntree; Chapter 18 in Part V presents another kind of balanced search tree, called aB-tree. Although the mechanics of red-black trees are somewhat intricate, you canglean most of their properties from the chapter without studying the mechanics indetail. Nevertheless, you probably will \ufb01nd walking through the code to be quiteinstructive.\nIn Chapter 14, we show how to augment red-black trees to support operations\nother than the basic ones listed above. First, we augment them so that we candynamically maintain order statistics for a set of keys. Then, we augment them ina different way to maintain intervals of real numbers.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "252": {"page_number": 253, "page_information": "10 Elementary Data Structures\nIn this chapter, we examine the representation of dynamic sets by simple data struc-\ntures that use pointers. Although we can construct many complex data structuresusing pointers, we present only the rudimentary ones: stacks, queues, linked lists,and rooted trees. We also show ways to synthesize objects and pointers from ar-rays.\n10.1 Stacks and queues\nStacks and queues are dynamic sets in which the element removed from the setby the D\nELETE operation is prespeci\ufb01ed. In a stack , the element deleted from\nthe set is the one most recently inserted: the stack implements a last-in, \ufb01rst-out ,\norLIFO , policy. Similarly, in a queue , the element deleted is always the one that\nhas been in the set for the longest time: the queue implements a \ufb01rst-in, \ufb01rst-out ,\norFIFO , policy. There are several ef\ufb01cient ways to implement stacks and queues\non a computer. In this section we show how to use a simple array to implementeach.\nStacks\nThe I\nNSERT operation on a stack is often called P USH,a n dt h eD ELETE opera-\ntion, which does not take an element argument, is often called P OP. These names\nare allusions to physical stacks, such as the spring-loaded stacks of plates usedin cafeterias. The order in which plates are popped from the stack is the reverseof the order in which they were pushed onto the stack, since only the top plate isaccessible.\nAs Figure 10.1 shows, we can implement a stack of at most nelements with\nan array S\u0152 1::n /c141 . The array has an attribute S:topthat indexes the most recently", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "253": {"page_number": 254, "page_information": "10.1 Stacks and queues 233\n1234567\nS1 5 6291234567\nS15 6 2 9 17 31234567\nS15 6 2 9 17 3\n(a) (b) (c)S:topD4S : topD6S : topD5\nFigure 10.1 An array implementation of a stack S. Stack elements appear only in the lightly shaded\npositions. (a)Stack Shas 4 elements. The top element is 9. (b)Stack Safter the calls P USH.S; 17/\nand P USH.S; 3/ .(c)Stack Safter the call P OP.S/has returned the element 3, which is the one most\nrecently pushed. Although element 3 still appears in the array, it is no longer in the stack; the top is\nelement 17.\ninserted element. The stack consists of elements S\u0152 1::S: top/c141,w h e r e S\u01521/c141 is the\nelement at the bottom of the stack and S\u0152S: top/c141is the element at the top.\nWhen S:topD0, the stack contains no elements and is empty . We can test to\nsee whether the stack is empty by query operation S TACK -EMPTY . If we attempt\nto pop an empty stack, we say the stack under\ufb02ows , which is normally an error.\nIfS:topexceeds n, the stack over\ufb02ows . (In our pseudocode implementation, we\ndon\u2019t worry about stack over\ufb02ow.)\nWe can implement each of the stack operations with just a few lines of code:\nSTACK -EMPTY .S/\n1ifS:top==0\n2 return TRUE\n3else return FALSE\nPUSH.S; x/\n1S:topDS:topC1\n2S\u0152S: top/c141Dx\nPOP.S/\n1ifSTACK -EMPTY .S/\n2 error \u201cunder\ufb02ow\u201d\n3elseS:topDS:top/NUL1\n4 return S\u0152S: topC1/c141\nFigure 10.1 shows the effects of the modifying operations P USH and P OP. Each of\nthe three stack operations takes O.1/ time.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "254": {"page_number": 255, "page_information": "234 Chapter 10 Elementary Data Structures\n123456789 1 0 1 1 1 2\nQ ( a ) 1 5 6984\n123456789 1 0 1 1 1 2\nQ ( b ) 1 5 6984 35 1 7\n123456789 1 0 1 1 1 2\nQ ( c ) 1 5 6984 35 1 7Q:headD7Q:headD7 Q:tailD12\nQ:tailD3Q:tailD3\nQ:headD8\nFigure 10.2 A queue implemented using an array Q\u01521 : : 12/c141 . Queue elements appear only in the\nlightly shaded positions. (a)The queue has 5 elements, in locations Q\u01527 : : 11/c141 .(b)The con\ufb01guration\nof the queue after the calls E NQUEUE .Q; 17/ ,ENQUEUE .Q; 3/ ,a n dE NQUEUE .Q; 5/ .(c)The\ncon\ufb01guration of the queue after the call D EQUEUE .Q/ returns the key value 15 formerly at the\nhead of the queue. The new head has key 6.\nQueues\nWe call the I NSERT operation on a queue E NQUEUE , and we call the D ELETE\noperation D EQUEUE ; like the stack operation P OP,DEQUEUE takes no element ar-\ngument. The FIFO property of a queue causes it to operate like a line of customerswaiting to pay a cashier. The queue has a head and atail. When an element is en-\nqueued, it takes its place at the tail of the queue, just as a newly arriving customertakes a place at the end of the line. The element dequeued is always the one atthe head of the queue, like the customer at the head of the line who has waited thelongest.\nFigure 10.2 shows one way to implement a queue of at most n/NUL1elements\nusing an array Q\u01521 : : n/c141 . The queue has an attribute Q:head that indexes, or points\nto, its head. The attribute Q:tailindexes the next location at which a newly arriv-\ning element will be inserted into the queue. The elements in the queue reside inlocations Q:head;Q :headC1 ;:::;Q : tail/NUL1, where we \u201cwrap around\u201d in the\nsense that location 1immediately follows location nin a circular order. When\nQ:headDQ:tail, the queue is empty. Initially, we have Q:headDQ:tailD1.\nIf we attempt to dequeue an element from an empty queue, the queue under\ufb02ows.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "255": {"page_number": 256, "page_information": "10.1 Stacks and queues 235\nWhen Q:headDQ:tailC1, the queue is full, and if we attempt to enqueue an\nelement, then the queue over\ufb02ows.\nIn our procedures E NQUEUE and D EQUEUE , we have omitted the error checking\nfor under\ufb02ow and over\ufb02ow. (Exercise 10.1-4 asks you to supply code that checksfor these two error conditions.) The pseudocode assumes that nDQ:length .\nE\nNQUEUE .Q; x/\n1Q\u0152Q: tail/c141Dx\n2ifQ:tail==Q:length\n3 Q:tailD1\n4elseQ:tailDQ:tailC1\nDEQUEUE .Q/\n1xDQ\u0152Q: head/c141\n2ifQ:head ==Q:length\n3 Q:headD1\n4elseQ:headDQ:headC1\n5return x\nFigure 10.2 shows the effects of the E NQUEUE and D EQUEUE operations. Each\noperation takes O.1/ time.\nExercises\n10.1-1\nUsing Figure 10.1 as a model, illustrate the result of each operation in the sequence\nPUSH.S; 4/ ,PUSH.S; 1/ ,PUSH.S; 3/ ,POP.S/,PUSH.S; 8/ ,a n dP OP.S/on an\ninitially empty stack Sstored in array S\u0152 1::6 /c141 .\n10.1-2\nExplain how to implement two stacks in one array A\u01521 : : n/c141 in such a way that\nneither stack over\ufb02ows unless the total number of elements in both stacks together\nisn.T h eP USH and P OPoperations should run in O.1/ time.\n10.1-3\nUsing Figure 10.2 as a model, illustrate the result of each operation in the\nsequence E NQUEUE .Q; 4/ ,ENQUEUE .Q; 1/ ,ENQUEUE .Q; 3/ ,D EQUEUE .Q/,\nENQUEUE .Q; 8/ ,a n dD EQUEUE .Q/ on an initially empty queue Qstored in\narray Q \u0152 1::6 /c141 .\n10.1-4\nRewrite E NQUEUE and D EQUEUE to detect under\ufb02ow and over\ufb02ow of a queue.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "256": {"page_number": 257, "page_information": "236 Chapter 10 Elementary Data Structures\n10.1-5\nWhereas a stack allows insertion and deletion of elements at only one end, and aqueue allows insertion at one end and deletion at the other end, a deque (double-\nended queue) allows insertion and deletion at both ends. Write four O.1/ -time\nprocedures to insert elements into and delete elements from both ends of a dequeimplemented by an array.\n10.1-6\nShow how to implement a queue using two stacks. Analyze the running time of the\nqueue operations.\n10.1-7\nShow how to implement a stack using two queues. Analyze the running time of thestack operations.\n10.2 Linked lists\nAlinked list is a data structure in which the objects are arranged in a linear order.\nUnlike an array, however, in which the linear order is determined by the array\nindices, the order in a linked list is determined by a pointer in each object. Linkedlists provide a simple, \ufb02exible representation for dynamic sets, supporting (thoughnot necessarily ef\ufb01ciently) all the operations listed on page 230.\nAs shown in Figure 10.3, each element of a doubly linked list Lis an object with\nan attribute keyand two other pointer attributes: next andpre/ETB. The object may\nalso contain other satellite data. Given an element xin the list, x:next points to its\nsuccessor in the linked list, and x:pre/ETBpoints to its predecessor. If x:pre/ETBD\nNIL,\nthe element xhas no predecessor and is therefore the \ufb01rst element, or head ,o f\nthe list. If x:nextDNIL, the element xhas no successor and is therefore the last\nelement, or tail, of the list. An attribute L:head points to the \ufb01rst element of the\nlist. If L:headDNIL, the list is empty.\nA list may have one of several forms. It may be either singly linked or doubly\nlinked, it may be sorted or not, and it may be circular or not. If a list is singly\nlinked ,w eo m i tt h e pre/ETBpointer in each element. If a list is sorted , the linear order\nof the list corresponds to the linear order of keys stored in elements of the list; the\nminimum element is then the head of the list, and the maximum element is the\ntail. If the list is unsorted , the elements can appear in any order. In a circular list ,\nthepre/ETBpointer of the head of the list points to the tail, and the next pointer of\nthe tail of the list points to the head. We can think of a circular list as a ring of", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "257": {"page_number": 258, "page_information": "10.2 Linked lists 237\n9 16 4 1prev key next\n(a)\n9 16 4 1 (b) 25\n9 16 1 (c) 25 L:headL:headL:head\nFigure 10.3 (a) A doubly linked list Lrepresenting the dynamic set f1; 4; 9; 16g. Each element in\nthe list is an object with attributes for the key and pointers (shown by arrows) to the next and previous\nobjects. The nextattribute of the tail and the pre/ETBattribute of the head are NIL, indicated by a diagonal\nslash. The attribute L:head points to the head. (b)Following the execution of L IST-INSERT .L; x/ ,\nwhere x:keyD25, the linked list has a new object with key 25as the new head. This new object\npoints to the old head with key 9.(c)The result of the subsequent call L IST-DELETE .L; x/ ,w h e r e x\npoints to the object with key 4.\nelements. In the remainder of this section, we assume that the lists with which we\nare working are unsorted and doubly linked.\nSearching a linked list\nThe procedure L IST-SEARCH .L; k/ \ufb01nds the \ufb01rst element with key kin list L\nby a simple linear search, returning a pointer to this element. If no object withkeykappears in the list, then the procedure returns\nNIL. For the linked list in\nFigure 10.3(a), the call L IST-SEARCH .L; 4/ returns a pointer to the third element,\nand the call L IST-SEARCH .L; 7/ returns NIL.\nLIST-SEARCH .L; k/\n1xDL:head\n2while x\u00a4NILandx:key\u00a4k\n3 xDx:next\n4return x\nTo search a list of nobjects, the L IST-SEARCH procedure takes \u201a.n/ time in the\nworst case, since it may have to search the entire list.\nInserting into a linked list\nG i v e na ne l e m e n t xwhose keyattribute has already been set, the L IST-INSERT\nprocedure \u201csplices\u201d xonto the front of the linked list, as shown in Figure 10.3(b).", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "258": {"page_number": 259, "page_information": "238 Chapter 10 Elementary Data Structures\nLIST-INSERT .L; x/\n1x:nextDL:head\n2ifL:head\u00a4NIL\n3 L:head:pre/ETBDx\n4L:headDx\n5x:pre/ETBDNIL\n(Recall that our attribute notation can cascade, so that L:head:pre/ETBdenotes the\npre/ETBattribute of the object that L:head points to.) The running time for L IST-\nINSERT on a list of nelements is O.1/ .\nDeleting from a linked list\nThe procedure L IST-DELETE removes an element xfrom a linked list L.I t m u s t\nbe given a pointer to x, and it then \u201csplices\u201d xout of the list by updating pointers.\nIf we wish to delete an element with a given key, we must \ufb01rst call L IST-SEARCH\nto retrieve a pointer to the element.\nLIST-DELETE .L; x/\n1ifx:pre/ETB\u00a4NIL\n2 x:pre/ETB:nextDx:next\n3elseL:headDx:next\n4ifx:next\u00a4NIL\n5 x:next:pre/ETBDx:pre/ETB\nFigure 10.3(c) shows how an element is deleted from a linked list. L IST-DELETE\nruns in O.1/ time, but if we wish to delete an element with a given key, \u201a.n/ time\nis required in the worst case because we must \ufb01rst call L IST-SEARCH to \ufb01nd the\nelement.\nSentinels\nThe code for L IST-DELETE would be simpler if we could ignore the boundary\nconditions at the head and tail of the list:\nLIST-DELETE0.L; x/\n1x:pre/ETB:nextDx:next\n2x:next:pre/ETBDx:pre/ETB\nAsentinel is a dummy object that allows us to simplify boundary conditions. For\nexample, suppose that we provide with list Lan object L:nilthat represents NIL", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "259": {"page_number": 260, "page_information": "10.2 Linked lists 239\n9 16 4 1\n9 16 4 1 25\n9 16 4 25(a)\n(b)\n(c)\n(d) L:nilL:nilL:nilL:nil\nFigure 10.4 A circular, doubly linked list with a sentinel. The sentinel L:nilappears between the\nhead and tail. The attribute L:head is no longer needed, since we can access the head of the list\nbyL:nil:next.(a)An empty list. (b)The linked list from Figure 10.3(a), with key 9 at the head and\nkey 1 at the tail. (c)The list after executing L IST-INSERT0.L; x/ ,w h e r e x:keyD25. The new object\nbecomes the head of the list. (d)The list after deleting the object with key 1. The new tail is the\nobject with key 4.\nbut has all the attributes of the other objects in the list. Wherever we have a ref-\nerence to NILin list code, we replace it by a reference to the sentinel L:nil.A s\nshown in Figure 10.4, this change turns a regular doubly linked list into a circu-\nlar, doubly linked list with a sentinel , in which the sentinel L:nillies between the\nhead and tail. The attribute L:nil:next points to the head of the list, and L:nil:pre/ETB\npoints to the tail. Similarly, both the next attribute of the tail and the pre/ETBat-\ntribute of the head point to L:nil.S i n c e L:nil:next points to the head, we can\neliminate the attribute L:head altogether, replacing references to it by references\ntoL:nil:next. Figure 10.4(a) shows that an empty list consists of just the sentinel,\nand both L:nil:next andL:nil:pre/ETBpoint to L:nil.\nThe code for L IST-SEARCH remains the same as before, but with the references\ntoNILandL:head changed as speci\ufb01ed above:\nLIST-SEARCH0.L; k/\n1xDL:nil:next\n2while x\u00a4L:nilandx:key\u00a4k\n3 xDx:next\n4return x\nWe use the two-line procedure L IST-DELETE0from before to delete an element\nfrom the list. The following procedure inserts an element into the list:", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "260": {"page_number": 261, "page_information": "240 Chapter 10 Elementary Data Structures\nLIST-INSERT0.L; x/\n1x:nextDL:nil:next\n2L:nil:next:pre/ETBDx\n3L:nil:nextDx\n4x:pre/ETBDL:nil\nFigure 10.4 shows the effects of L IST-INSERT0and L IST-DELETE0on a sample list.\nSentinels rarely reduce the asymptotic time bounds of data structure operations,\nbut they can reduce constant factors. The gain from using sentinels within loopsis usually a matter of clarity of code rather than speed; the linked list code, forexample, becomes simpler when we use sentinels, but we save only O.1/ time in\nthe L\nIST-INSERT0and L IST-DELETE0procedures. In other situations, however, the\nuse of sentinels helps to tighten the code in a loop, thus reducing the coef\ufb01cient of,\nsay,norn2in the running time.\nWe should use sentinels judiciously. When there are many small lists, the extra\nstorage used by their sentinels can represent signi\ufb01cant wasted memory. In thisbook, we use sentinels only when they truly simplify the code.\nExercises\n10.2-1\nCan you implement the dynamic-set operation I\nNSERT on a singly linked list\ninO.1/ time? How about D ELETE ?\n10.2-2\nImplement a stack using a singly linked list L. The operations P USH and P OP\nshould still take O.1/ time.\n10.2-3\nImplement a queue by a singly linked list L. The operations E NQUEUE and D E-\nQUEUE should still take O.1/ time.\n10.2-4\nAs written, each loop iteration in the L IST-SEARCH0procedure requires two tests:\none for x\u00a4L:niland one for x:key\u00a4k. Show how to eliminate the test for\nx\u00a4L:nilin each iteration.\n10.2-5\nImplement the dictionary operations I NSERT ,DELETE ,a n dS EARCH using singly\nlinked, circular lists. What are the running times of your procedures?", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "261": {"page_number": 262, "page_information": "10.3 Implementing pointers and objects 241\n10.2-6\nThe dynamic-set operation U NION takes two disjoint sets S1andS2as input, and\nit returns a set SDS1[S2consisting of all the elements of S1andS2.T h e\nsetsS1andS2are usually destroyed by the operation. Show how to support U NION\ninO.1/ time using a suitable list data structure.\n10.2-7\nGive a \u201a.n/ -time nonrecursive procedure that reverses a singly linked list of n\nelements. The procedure should use no more than constant storage beyond that\nneeded for the list itself.\n10.2-8 ?\nExplain how to implement doubly linked lists using only one pointer value x:npper\nitem instead of the usual two ( next andpre/ETB). Assume that all pointer values can be\ninterpreted as k-bit integers, and de\ufb01ne x:npto be x:npDx:next XOR x:pre/ETB,\nthek-bit \u201cexclusive-or\u201d of x:next andx:pre/ETB.( T h ev a l u e NILis represented by 0.)\nBe sure to describe what information you need to access the head of the list. Showhow to implement the S\nEARCH ,INSERT ,a n dD ELETE operations on such a list.\nAlso show how to reverse such a list in O.1/ time.\n10.3 Implementing pointers and objects\nHow do we implement pointers and objects in languages that do not provide them?\nIn this section, we shall see two ways of implementing linked data structures with-out an explicit pointer data type. We shall synthesize objects and pointers fromarrays and array indices.\nA multiple-array representation of objects\nWe can represent a collection of objects that have the same attributes by using an\narray for each attribute. As an example, Figure 10.5 shows how we can implementthe linked list of Figure 10.3(a) with three arrays. The array keyholds the values\nof the keys currently in the dynamic set, and the pointers reside in the arrays next\nandpre/ETB. For a given array index x, the array entries key\u0152x/c141,next\u0152x/c141,a n d pre/ETB\u0152x/c141\nrepresent an object in the linked list. Under this interpretation, a pointer xis simply\na common index into the key,next,a n d pre/ETBarrays.\nIn Figure 10.3(a), the object with key 4follows the object with key 16in the\nlinked list. In Figure 10.5, key 4appears in key\u01522/c141,a n dk e y 16appears in key\u01525/c141,\nand so next\u01525/c141D2andpre/ETB\u01522/c141D5. Although the constant\nNILappears in the next", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "262": {"page_number": 263, "page_information": "242 Chapter 10 Elementary Data Structures\n12345678\nkeynext\nprevL 7\n4 1 16 932 5\n52 7\nFigure 10.5 The linked list of Figure 10.3(a) represented by the arrays key,next,a n d pre/ETB. Each\nvertical slice of the arrays represents a single object. Stored pointers correspond to the array indices\nshown at the top; the arrows show how to interpret them. Lightly shaded object positions contain list\nelements. The variable Lkeeps the index of the head.\nattribute of the tail and the pre/ETBattribute of the head, we usually use an integer\n(such as 0or/NUL1) that cannot possibly represent an actual index into the arrays. A\nvariable Lholds the index of the head of the list.\nA single-array representation of objects\nThe words in a computer memory are typically addressed by integers from 0\ntoM/NUL1,w h e r e Mis a suitably large integer. In many programming languages,\nan object occupies a contiguous set of locations in the computer memory. A pointeris simply the address of the \ufb01rst memory location of the object, and we can addressother memory locations within the object by adding an offset to the pointer.\nWe can use the same strategy for implementing objects in programming envi-\nronments that do not provide explicit pointer data types. For example, Figure 10.6shows how to use a single array Ato store the linked list from Figures 10.3(a)\nand 10.5. An object occupies a contiguous subarray A\u0152j : : k/c141 . Each attribute of\nthe object corresponds to an offset in the range from 0tok/NULj, and a pointer to\nthe object is the index j. In Figure 10.6, the offsets corresponding to key,next,a n d\npre/ETBare 0, 1, and 2, respectively. To read the value of i:pre/ETB, given a pointer i,w e\nadd the value iof the pointer to the offset 2, thus reading A\u0152iC2/c141.\nThe single-array representation is \ufb02exible in that it permits objects of different\nlengths to be stored in the same array. The problem of managing such a heteroge-\nneous collection of objects is more dif\ufb01cult than the problem of managing a homo-\ngeneous collection, where all objects have the same attributes. Since most of the\ndata structures we shall consider are composed of homogeneous elements, it will\nbe suf\ufb01cient for our purposes to use the multiple-array representation of objects.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "263": {"page_number": 264, "page_information": "10.3 Implementing pointers and objects 243\n12345678\nAL\n4 1 16 974 49 1 01 11 21 31 41 51 61 71 81 92 02 12 22 32 4\nprev\nnextkey19\n13 13 19\nFigure 10.6 The linked list of Figures 10.3(a) and 10.5 represented in a single array A. Each list\nelement is an object that occupies a contiguous subarray of length 3 within the array. The threeattributes key,next,a n d pre/ETBcorrespond to the offsets 0, 1, and 2, respectively, within each object.\nA pointer to an object is the index of the \ufb01rst element of the object. Objects containing list elements\nare lightly shaded, and arrows show the list ordering.\nAllocating and freeing objects\nTo insert a key into a dynamic set represented by a doubly linked list, we must al-\nlocate a pointer to a currently unused object in the linked-list representation. Thus,it is useful to manage the storage of objects not currently used in the linked-listrepresentation so that one can be allocated. In some systems, a garbage collec-\ntoris responsible for determining which objects are unused. Many applications,\nhowever, are simple enough that they can bear responsibility for returning an un-\nused object to a storage manager. We shall now explore the problem of allocating\nand freeing (or deallocating) homogeneous objects using the example of a doublylinked list represented by multiple arrays.\nSuppose that the arrays in the multiple-array representation have length mand\nthat at some moment the dynamic set contains n/DC4melements. Then nobjects\nrepresent elements currently in the dynamic set, and the remaining m/NULnobjects are\nfree; the free objects are available to represent elements inserted into the dynamic\nset in the future.\nWe keep the free objects in a singly linked list, which we call the free list .T h e\nfree list uses only the next array, which stores the next pointers within the list.\nThe head of the free list is held in the global variable free. When the dynamic\nset represented by linked list Lis nonempty, the free list may be intertwined with\nlistL, as shown in Figure 10.7. Note that each object in the representation is either\nin list Lor in the free list, but not in both.\nThe free list acts like a stack: the next object allocated is the last one freed. We\ncan use a list implementation of the stack operations P\nUSH and P OPto implement\nthe procedures for allocating and freeing objects, respectively. We assume that theglobal variable freeused in the following procedures points to the \ufb01rst element of\nthe free list.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "264": {"page_number": 265, "page_information": "244 Chapter 10 Elementary Data Structures\n12345678\nkeynext\nprevL7\n4 1 16 932 5\n52 74\n86 1free\n(a)12345678\nkeynext\nprevL4\n4 1 16 932 5\n52 78\n76 1free\n(b)425\n12345678\nkeynext\nprevL4\n41 938 2\n725\n76 1free\n(c)425\nFigure 10.7 The effect of the A LLOCA TE -OBJECT and F REE-OBJECT procedures. (a)The list\nof Figure 10.5 (lightly shaded) and a free list (heavily shaded). Arrows show the free-list structure.(b)The result of calling A\nLLOCA TE -OBJECT ./(which returns index 4), setting key\u01524/c141to 25, and\ncalling L IST-INSERT .L; 4/ . The new free-list head is object 8, which had been next\u01524/c141on the free\nlist.(c)After executing L IST-DELETE .L; 5/ , we call F REE-OBJECT .5/. Object 5 becomes the new\nfree-list head, with object 8 following it on the free list.\nALLOCATE -OBJECT ./\n1iffree ==NIL\n2 error \u201cout of space\u201d\n3elsexDfree\n4 freeDx:next\n5 return x\nFREE-OBJECT .x/\n1x:nextDfree\n2freeDx\nThe free list initially contains all nunallocated objects. Once the free list has been\nexhausted, running the A LLOCATE -OBJECT procedure signals an error. We can\neven service several linked lists with just a single free list. Figure 10.8 shows twolinked lists and a free list intertwined through key,next,a n d pre/ETBarrays.\nThe two procedures run in O.1/ time, which makes them quite practical. We\ncan modify them to work for any homogeneous collection of objects by letting anyone of the attributes in the object act like a next attribute in the free list.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "265": {"page_number": 266, "page_information": "10.3 Implementing pointers and objects 245\n123456789 1 0\nnext\nkey\nprevfree\n362\n637 1 5\n79910\n4 8\n1L2\nL1k1k2k3 k5k6k7 k9\nFigure 10.8 Two linked lists, L1(lightly shaded) and L2(heavily shaded), and a free list (dark-\nened) intertwined.\nExercises\n10.3-1\nDraw a picture of the sequence h13; 4; 8; 19; 5; 11istored as a doubly linked list\nusing the multiple-array representation. Do the same for the single-array represen-\ntation.\n10.3-2\nWrite the procedures A LLOCATE -OBJECT and F REE-OBJECT for a homogeneous\ncollection of objects implemented by the single-array representation.\n10.3-3\nWhy don\u2019t we need to set or reset the pre/ETBattributes of objects in the implementa-\ntion of the A LLOCATE -OBJECT and F REE-OBJECT procedures?\n10.3-4\nIt is often desirable to keep all elements of a doubly linked list compact in storage,using, for example, the \ufb01rst mindex locations in the multiple-array representation.\n(This is the case in a paged, virtual-memory computing environment.) Explainhow to implement the procedures A\nLLOCATE -OBJECT and F REE-OBJECT so that\nthe representation is compact. Assume that there are no pointers to elements of thelinked list outside the list itself. ( Hint: Use the array implementation of a stack.)\n10.3-5\nLetLbe a doubly linked list of length nstored in arrays key,pre/ETB,a n d next of\nlength m. Suppose that these arrays are managed by A\nLLOCATE -OBJECT and\nFREE-OBJECT procedures that keep a doubly linked free list F. Suppose further\nthat of the mitems, exactly nare on list Landm/NULnare on the free list. Write\na procedure C OMPACTIFY -LIST.L; F / that, given the list Land the free list F,\nmoves the items in Lso that they occupy array positions 1 ;2;:::;n and adjusts the\nfree list Fso that it remains correct, occupying array positions nC1; nC2;:::;m .\nThe running time of your procedure should be \u201a.n/ , and it should use only a\nconstant amount of extra space. Argue that your procedure is correct.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "266": {"page_number": 267, "page_information": "246 Chapter 10 Elementary Data Structures\n10.4 Representing rooted trees\nThe methods for representing lists given in the previous section extend to any ho-\nmogeneous data structure. In this section, we look speci\ufb01cally at the problem ofrepresenting rooted trees by linked data structures. We \ufb01rst look at binary trees,and then we present a method for rooted trees in which nodes can have an arbitrary\nnumber of children.\nWe represent each node of a tree by an object. As with linked lists, we assume\nthat each node contains a keyattribute. The remaining attributes of interest are\npointers to other nodes, and they vary according to the type of tree.\nBinary trees\nFigure 10.9 shows how we use the attributes p,left,a n d right to store pointers to\nthe parent, left child, and right child of each node in a binary tree T.I fx:pD\nNIL,\nthenxis the root. If node xhas no left child, then x:leftDNIL, and similarly for\nthe right child. The root of the entire tree Tis pointed to by the attribute T:root.I f\nT:rootDNIL, then the tree is empty.\nRooted trees with unbounded branching\nWe can extend the scheme for representing a binary tree to any class of trees in\nwhich the number of children of each node is at most some constant k: we replace\ntheleftandright attributes by child 1;child 2;:::; child k. This scheme no longer\nworks when the number of children of a node is unbounded, since we do not knowhow many attributes (arrays in the multiple-array representation) to allocate in ad-vance. Moreover, even if the number of children kis bounded by a large constant\nbut most nodes have a small number of children, we may waste a lot of memory.\nFortunately, there is a clever scheme to represent trees with arbitrary numbers of\nchildren. It has the advantage of using only O.n/ space for any n-node rooted tree.\nTheleft-child, right-sibling representation appears in Figure 10.10. As before,\neach node contains a parent pointer p,a n d T:root points to the root of tree T.\nInstead of having a pointer to each of its children, however, each node xhas only\ntwo pointers:\n1.x:left-child points to the leftmost child of node x,a n d\n2.x:right -sibling points to the sibling of ximmediately to its right.\nIf node xhas no children, then x:left-childD\nNIL, and if node xis the rightmost\nchild of its parent, then x:right -siblingDNIL.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "267": {"page_number": 268, "page_information": "10.4 Representing rooted trees 247\nT:root\nFigure 10.9 The representation of a binary tree T. Each node xhas the attributes x:p(top), x:left\n(lower left), and x:right (lower right). The keyattributes are not shown.\nT:root\nFigure 10.10 The left-child, right-sibling representation of a tree T. Each node xhas attributes x:p\n(top), x:left-child (lower left), and x:right -sibling (lower right). The keyattributes are not shown.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "268": {"page_number": 269, "page_information": "248 Chapter 10 Elementary Data Structures\nOther tree representations\nWe sometimes represent rooted trees in other ways. In Chapter 6, for example,\nwe represented a heap, which is based on a complete binary tree, by a single arrayplus the index of the last node in the heap. The trees that appear in Chapter 21 aretraversed only toward the root, and so only the parent pointers are present; thereare no pointers to children. Many other schemes are possible. Which scheme isbest depends on the application.\nExercises\n10.4-1\nDraw the binary tree rooted at index 6that is represented by the following at-\ntributes:\nindex key left right\n11 2 7 3\n21 5 8 NIL\n34 1 0 NIL\n41 0 5 9\n52 NIL NIL\n61 8 1 4\n77 NIL NIL\n81 4 6 2\n92 1 NIL NIL\n10 5 NIL NIL\n10.4-2\nWrite an O.n/ -time recursive procedure that, given an n-node binary tree, prints\nout the key of each node in the tree.\n10.4-3\nWrite an O.n/ -time nonrecursive procedure that, given an n-node binary tree,\nprints out the key of each node in the tree. Use a stack as an auxiliary data structure.\n10.4-4\nWrite an O.n/ -time procedure that prints all the keys of an arbitrary rooted tree\nwithnnodes, where the tree is stored using the left-child, right-sibling representa-\ntion.\n10.4-5 ?\nWrite an O.n/ -time nonrecursive procedure that, given an n-node binary tree,\nprints out the key of each node. Use no more than constant extra space outside", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "269": {"page_number": 270, "page_information": "Problems for Chapter 10 249\nof the tree itself and do not modify the tree, even temporarily, during the proce-\ndure.\n10.4-6 ?\nThe left-child, right-sibling representation of an arbitrary rooted tree uses threepointers in each node: left-child ,right -sibling ,a n d parent . From any node, its\nparent can be reached and identi\ufb01ed in constant time and all its children can bereached and identi\ufb01ed in time linear in the number of children. Show how to useonly two pointers and one boolean value in each node so that the parent of a node\nor all of its children can be reached and identi\ufb01ed in time linear in the number of\nchildren.\nProblems\n10-1 Comparisons among listsFor each of the four types of lists in the following table, what is the asymptoticworst-case running time for each dynamic-set operation listed?\nunsorted,\n sorted,\n unsorted,\n sorted,\nsingly\n singly\n doubly\n doubly\nlinked\n linked\n linked\n linked\nSEARCH .L; k/\nINSERT .L; x/\nDELETE .L; x/\nSUCCESSOR .L; x/\nPREDECESSOR .L; x/\nMINIMUM .L/\nMAXIMUM .L/\n", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "270": {"page_number": 271, "page_information": "250 Chapter 10 Elementary Data Structures\n10-2 Mergeable heaps using linked lists\nAmergeable heap supports the following operations: M AKE-HEAP(which creates\nan empty mergeable heap), I NSERT ,M INIMUM ,EXTRACT -MIN,a n dU NION .1\nShow how to implement mergeable heaps using linked lists in each of the followingcases. Try to make each operation as ef\ufb01cient as possible. Analyze the runningtime of each operation in terms of the size of the dynamic set(s) being operated on.\na.Lists are sorted.\nb.Lists are unsorted.\nc.Lists are unsorted, and dynamic sets to be merged are disjoint.\n10-3 Searching a sorted compact list\nExercise 10.3-4 asked how we might maintain an n-element list compactly in the\n\ufb01rstnpositions of an array. We shall assume that all keys are distinct and that the\ncompact list is also sorted, that is, key\u0152i/c141 < key\u0152next\u0152i/c141/c141for all iD1 ;2;:::;n such\nthatnext\u0152i/c141\u00a4\nNIL. We will also assume that we have a variable Lthat contains\nthe index of the \ufb01rst element on the list. Under these assumptions, you will showthat we can use the following randomized algorithm to search the list in O.p\nn/\nexpected time.\nCOMPACT -LIST-SEARCH . L;n;k/\n1iDL\n2while i\u00a4NILandkey\u0152i/c141 < k\n3 jDRANDOM .1; n/\n4 ifkey\u0152i/c141 < key\u0152j /c141andkey\u0152j /c141/DC4k\n5 iDj\n6 ifkey\u0152i/c141==k\n7 return i\n8 iDnext\u0152i/c141\n9ifi==NILorkey\u0152i/c141 > k\n10 return NIL\n11else return i\nIf we ignore lines 3\u20137 of the procedure, we have an ordinary algorithm for\nsearching a sorted linked list, in which index ipoints to each position of the list in\n1Because we have de\ufb01ned a mergeable heap to support M INIMUM and E XTRACT -MIN, we can also\nrefer to it as a mergeable min-heap . Alternatively, if it supported M AXIMUM and E XTRACT -MAX,\nit would be a mergeable max-heap .", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "271": {"page_number": 272, "page_information": "Problems for Chapter 10 251\nturn. The search terminates once the index i\u201cfalls off\u201d the end of the list or once\nkey\u0152i/c141/NAKk. In the latter case, if key\u0152i/c141Dk, clearly we have found a key with the\nvalue k. If, however, key\u0152i/c141 > k , then we will never \ufb01nd a key with the value k,\nand so terminating the search was the right thing to do.\nLines 3\u20137 attempt to skip ahead to a randomly chosen position j.S u c h a s k i p\nbene\ufb01ts us if key\u0152j /c141is larger than key\u0152i/c141a n dn ol a r g e rt h a n k; in such a case, j\nmarks a position in the list that iwould have to reach during an ordinary list search.\nBecause the list is compact, we know that any choice of jbetween 1andnindexes\nsome object in the list rather than a slot on the free list.\nInstead of analyzing the performance of C OMPACT -LIST-SEARCH directly, we\nshall analyze a related algorithm, C OMPACT -LIST-SEARCH0, which executes two\nseparate loops. This algorithm takes an additional parameter twhich determines\nan upper bound on the number of iterations of the \ufb01rst loop.\nCOMPACT -LIST-SEARCH0. L;n;k;t/\n1iDL\n2forqD1tot\n3 jDRANDOM .1; n/\n4 ifkey\u0152i/c141 < key\u0152j /c141andkey\u0152j /c141/DC4k\n5 iDj\n6 ifkey\u0152i/c141==k\n7 return i\n8while i\u00a4NILandkey\u0152i/c141 < k\n9 iDnext\u0152i/c141\n10ifi==NILorkey\u0152i/c141 > k\n11 return NIL\n12else return i\nTo compare the execution of the algorithms C OMPACT -LIST-SEARCH . L;n;k/\nand C OMPACT -LIST-SEARCH0. L;n;k;t/ , assume that the sequence of integers re-\nturned by the calls of R ANDOM .1; n/ is the same for both algorithms.\na.Suppose that C OMPACT -LIST-SEARCH . L;n;k/ takes titerations of the while\nloop of lines 2\u20138. Argue that C OMPACT -LIST-SEARCH0. L;n;k;t/ returns the\nsame answer and that the total number of iterations of both the forandwhile\nloops within C OMPACT -LIST-SEARCH0is at least t.\nIn the call C OMPACT -LIST-SEARCH0. L;n;k;t/ ,l e tXtbe the random variable that\ndescribes the distance in the linked list (that is, through the chain of next pointers)\nfrom position ito the desired key kafter titerations of the forloop of lines 2\u20137\nhave occurred.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "272": {"page_number": 273, "page_information": "252 Chapter 10 Elementary Data Structures\nb.Argue that the expected running time of C OMPACT -LIST-SEARCH0. L;n;k;t/\nisO.tCE\u0152Xt/c141/.\nc.Show that E \u0152Xt/c141/DC4Pn\nrD1.1/NULr=n/t.(Hint: Use equation (C.25).)\nd.Show thatPn/NUL1\nrD0rt/DC4ntC1=.tC1/.\ne.Prove that E \u0152Xt/c141/DC4n=.tC1/.\nf.Show that C OMPACT -LIST-SEARCH0. L;n;k;t/ runs in O.tCn=t/ expected\ntime.\ng.Conclude that C OMPACT -LIST-SEARCH runs in O.p\nn/expected time.\nh.Why do we assume that all keys are distinct in C OMPACT -LIST-SEARCH ?A r -\ngue that random skips do not necessarily help asymptotically when the list con-tains repeated key values.\nChapter notes\nAho, Hopcroft, and Ullman [6] and Knuth [209] are excellent references for ele-mentary data structures. Many other texts cover both basic data structures and theirimplementation in a particular programming language. Examples of these types of\ntextbooks include Goodrich and Tamassia [147], Main [241], Shaffer [311], and\nWeiss [352, 353, 354]. Gonnet [145] provides experimental data on the perfor-mance of many data-structure operations.\nThe origin of stacks and queues as data structures in computer science is un-\nclear, since corresponding notions already existed in mathematics and paper-basedbusiness practices before the introduction of digital computers. Knuth [209] citesA. M. Turing for the development of stacks for subroutine linkage in 1947.\nPointer-based data structures also seem to be a folk invention. According to\nKnuth, pointers were apparently used in early computers with drum memories. TheA-1 language developed by G. M. Hopper in 1951 represented algebraic formulasas binary trees. Knuth credits the IPL-II language, developed in 1956 by A. Newell,J. C. Shaw, and H. A. Simon, for recognizing the importance and promoting theuse of pointers. Their IPL-III language, developed in 1957, included explicit stackoperations.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "273": {"page_number": 274, "page_information": "11 Hash Tables\nMany applications require a dynamic set that supports only the dictionary opera-\ntions I NSERT ,SEARCH ,a n dD ELETE . For example, a compiler that translates a\nprogramming language maintains a symbol table, in which the keys of elementsare arbitrary character strings corresponding to identi\ufb01ers in the language. A hashtable is an effective data structure for implementing dictionaries. Although search-ing for an element in a hash table can take as long as searching for an element in alinked list\u2014 \u201a.n/ time in the worst case\u2014in practice, hashing performs extremely\nwell. Under reasonable assumptions, the average time to search for an element in\na hash table is O.1/ .\nA hash table generalizes the simpler notion of an ordinary array. Directly ad-\ndressing into an ordinary array makes effective use of our ability to examine an\narbitrary position in an array in O.1/ time. Section 11.1 discusses direct address-\ning in more detail. We can take advantage of direct addressing when we can affordto allocate an array that has one position for every possible key.\nWhen the number of keys actually stored is small relative to the total number of\npossible keys, hash tables become an effective alternative to directly addressing anarray, since a hash table typically uses an array of size proportional to the numberof keys actually stored. Instead of using the key as an array index directly, the arrayindex is computed from the key. Section 11.2 presents the main ideas, focusing on\n\u201cchaining\u201d as a way to handle \u201ccollisions,\u201d in which more than one key maps to thesame array index. Section 11.3 describes how we can compute array indices fromkeys using hash functions. We present and analyze several variations on the basictheme. Section 11.4 looks at \u201copen addressing,\u201d which is another way to deal withcollisions. The bottom line is that hashing is an extremely effective and practicaltechnique: the basic dictionary operations require only O.1/ time on the average.\nSection 11.5 explains how \u201cperfect hashing\u201d can support searches in O.1/ worst-\ncase time, when the set of keys being stored is static (that is, when the set of keys\nnever changes once stored).", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "274": {"page_number": 275, "page_information": "254 Chapter 11 Hash Tables\n11.1 Direct-address tables\nDirect addressing is a simple technique that works well when the universe Uof\nkeys is reasonably small. Suppose that an application needs a dynamic set in whicheach element has a key drawn from the universe UDf0; 1; : : : ; m/NUL1g,w h e r e m\nis not too large. We shall assume that no two elements have the same key.\nTo represent the dynamic set, we use an array, or direct-address table , denoted\nbyT\u0152 0::m/NUL1/c141, in which each position, or slot, corresponds to a key in the uni-\nverse U. Figure 11.1 illustrates the approach; slot kpoints to an element in the set\nwith key k. If the set contains no element with key k,t h e n T\u0152 k/c141D\nNIL.\nThe dictionary operations are trivial to implement:\nDIRECT -ADDRESS -SEARCH .T; k/\n1return T\u0152 k/c141\nDIRECT -ADDRESS -INSERT .T; x/\n1T\u0152 x: key/c141Dx\nDIRECT -ADDRESS -DELETE .T; x/\n1T\u0152 x: key/c141DNIL\nEach of these operations takes only O.1/ time.\nT\nU\n(universe of keys)\nK\n(actual\nkeys)2\n3\n581940\n762\n3\n5\n8key satellite data\n20\n1\n3\n4\n5\n678\n9\nFigure 11.1 How to implement a dynamic set by a direct-address table T. Each key in the universe\nUDf0; 1; : : : ; 9gcorresponds to an index in the table. The set KDf2; 3; 5; 8gof actual keys\ndetermines the slots in the table that contain pointers to elements. The other slots, heavily shaded,\ncontain NIL.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "275": {"page_number": 276, "page_information": "11.1 Direct-address tables 255\nFor some applications, the direct-address table itself can hold the elements in the\ndynamic set. That is, rather than storing an element\u2019s key and satellite data in anobject external to the direct-address table, with a pointer from a slot in the table tothe object, we can store the object in the slot itself, thus saving space. We woulduse a special key within an object to indicate an empty slot. Moreover, it is oftenunnecessary to store the key of the object, since if we have the index of an objectin the table, we have its key. If keys are not stored, however, we must have someway to tell whether the slot is empty.\nExercises\n11.1-1\nSuppose that a dynamic set Sis represented by a direct-address table Tof length m.\nDescribe a procedure that \ufb01nds the maximum element of S. What is the worst-case\nperformance of your procedure?\n11.1-2\nAbit vector is simply an array of bits ( 0sa n d 1s). A bit vector of length mtakes\nmuch less space than an array of mpointers. Describe how to use a bit vector\nto represent a dynamic set of distinct elements with no satellite data. Dictionary\noperations should run in O.1/ time.\n11.1-3\nSuggest how to implement a direct-address table in which the keys of stored el-ements do not need to be distinct and the elements can have satellite data. Allthree dictionary operations (I\nNSERT ,DELETE ,a n dS EARCH ) should run in O.1/\ntime. (Don\u2019t forget that D ELETE takes as an argument a pointer to an object to be\ndeleted, not a key.)\n11.1-4 ?\nWe wish to implement a dictionary by using direct addressing on a huge array. At\nthe start, the array entries may contain garbage, and initializing the entire arrayis impractical because of its size. Describe a scheme for implementing a direct-address dictionary on a huge array. Each stored object should use O.1/ space;\nthe operations S\nEARCH ,INSERT ,a n dD ELETE should take O.1/ time each; and\ninitializing the data structure should take O.1/ time. ( Hint: Use an additional array,\ntreated somewhat like a stack whose size is the number of keys actually stored in\nthe dictionary, to help determine whether a given entry in the huge array is valid ornot.)", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "276": {"page_number": 277, "page_information": "256 Chapter 11 Hash Tables\n11.2 Hash tables\nThe downside of direct addressing is obvious: if the universe Uis large, storing\nat a b l e Tof sizejUjmay be impractical, or even impossible, given the memory\navailable on a typical computer. Furthermore, the set Kof keys actually stored\nmay be so small relative to Uthat most of the space allocated for Twould be\nwasted.\nWhen the set Kof keys stored in a dictionary is much smaller than the uni-\nverse Uof all possible keys, a hash table requires much less storage than a direct-\naddress table. Speci\ufb01cally, we can reduce the storage requirement to \u201a.jKj/while\nwe maintain the bene\ufb01t that searching for an element in the hash table still requiresonlyO.1/ time. The catch is that this bound is for the average-case time , whereas\nfor direct addressing it holds for the worst-case time .\nWith direct addressing, an element with key kis stored in slot k. With hashing,\nthis element is stored in slot h.k/ ; that is, we use a hash function hto compute the\nslot from the key k. Here, hmaps the universe Uof keys into the slots of a hash\ntable T\u0152 0::m/NUL1/c141:\nhWU!f0; 1; : : : ; m/NUL1g;\nwhere the size mof the hash table is typically much less than jUj. We say that an\nelement with key khashes to slot h.k/ ; we also say that h.k/ is thehash value of\nkeyk. Figure 11.2 illustrates the basic idea. The hash function reduces the range\nof array indices and hence the size of the array. Instead of a size of jUj, the array\ncan have size\nm.\nT\nU\n(universe of keys)\nK\n(actual\nkeys)0\nm\u20131k1\nk2k3k4 k5h(k1)\nh(k4)\nh(k3)h(k2) = h(k5)\nFigure 11.2 Using a hash function hto map keys to hash-table slots. Because keys k2andk5map\nto the same slot, they collide.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "277": {"page_number": 278, "page_information": "11.2 Hash tables 257\nT\nU\n(universe of keys)\nK\n(actual\nkeys)k1\nk2 k3k4 k5\nk6k7\nk8k1\nk2\nk3k4\nk5\nk6k7\nk8\nFigure 11.3 Collision resolution by chaining. Each hash-table slot T\u0152 j/c141 contains a linked list of\nall the keys whose hash value is j. For example, h.k1/Dh.k4/andh.k5/Dh.k7/Dh.k2/.\nThe linked list can be either singly or doubly linked; we show it as doubly linked because deletion isfaster that way.\nThere is one hitch: two keys may hash to the same slot. We call this situation\nacollision . Fortunately, we have effective techniques for resolving the con\ufb02ict\ncreated by collisions.\nOf course, the ideal solution would be to avoid collisions altogether. We might\ntry to achieve this goal by choosing a suitable hash function h. One idea is to\nmake happear to be \u201crandom,\u201d thus avoiding collisions or at least minimizing\ntheir number. The very term \u201cto hash,\u201d evoking images of random mixing andchopping, captures the spirit of this approach. (Of course, a hash function hmust be\ndeterministic in that a given input kshould always produce the same output h.k/ .)\nBecausejUj>m, however, there must be at least two keys that have the same hash\nvalue; avoiding collisions altogether is therefore impossible. Thus, while a well-\ndesigned, \u201crandom\u201d-looking hash function can minimize the number of collisions,\nwe still need a method for resolving the collisions that do occur.\nThe remainder of this section presents the simplest collision resolution tech-\nnique, called chaining. Section 11.4 introduces an alternative method for resolvingcollisions, called open addressing.\nCollision resolution by chaining\nInchaining , we place all the elements that hash to the same slot into the same\nlinked list, as Figure 11.3 shows. Slot jcontains a pointer to the head of the list of\nall stored elements that hash to j; if there are no such elements, slot jcontains\nNIL.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "278": {"page_number": 279, "page_information": "258 Chapter 11 Hash Tables\nThe dictionary operations on a hash table Tare easy to implement when colli-\nsions are resolved by chaining:\nCHAINED -HASH-INSERT .T; x/\n1 insert xat the head of list T\u0152 h . x: key//c141\nCHAINED -HASH-SEARCH .T; k/\n1 search for an element with key kin list T\u0152 h . k / /c141\nCHAINED -HASH-DELETE .T; x/\n1 delete xfrom the list T\u0152 h . x: key//c141\nThe worst-case running time for insertion is O.1/ . The insertion procedure is fast\nin part because it assumes that the element xbeing inserted is not already present in\nthe table; if necessary, we can check this assumption (at additional cost) by search-ing for an element whose key is x:keybefore we insert. For searching, the worst-\ncase running time is proportional to the length of the list; we shall analyze thisoperation more closely below. We can delete an element in O.1/ time if the lists\nare doubly linked, as Figure 11.3 depicts. (Note that C\nHAINED -HASH-DELETE\ntakes as input an element xand not its key k, so that we don\u2019t have to search for x\n\ufb01rst. If the hash table supports deletion, then its linked lists should be doubly linkedso that we can delete an item quickly. If the lists were only singly linked, then to\ndelete element x, we would \ufb01rst have to \ufb01nd xin the list T\u0152 h . x: key//c141so that we\ncould update the next attribute of x\u2019s predecessor. With singly linked lists, both\ndeletion and searching would have the same asymptotic running times.)\nAnalysis of hashing with chaining\nHow well does hashing with chaining perform? In particular, how long does it take\nto search for an element with a given key?\nGiven a hash table Twith mslots that stores nelements, we de\ufb01ne the load\nfactor \u02dbforTasn=m , that is, the average number of elements stored in a chain.\nOur analysis will be in terms of \u02db, which can be less than, equal to, or greater\nthan1.\nThe worst-case behavior of hashing with chaining is terrible: all nkeys hash\nto the same slot, creating a list of length n. The worst-case time for searching is\nthus\u201a.n/ plus the time to compute the hash function\u2014no better than if we used\none linked list for all the elements. Clearly, we do not use hash tables for theirworst-case performance. (Perfect hashing, described in Section 11.5, does providegood worst-case performance when the set of keys is static, however.)\nThe average-case performance of hashing depends on how well the hash func-\ntionhdistributes the set of keys to be stored among the mslots, on the average.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "279": {"page_number": 280, "page_information": "11.2 Hash tables 259\nSection 11.3 discusses these issues, but for now we shall assume that any given\nelement is equally likely to hash into any of the mslots, independently of where\nany other element has hashed to. We call this the assumption of simple uniform\nhashing .\nForjD0; 1; : : : ; m/NUL1, let us denote the length of the list T\u0152 j/c141 bynj,s ot h a t\nnDn0Cn1C/SOH/SOH/SOHC nm/NUL1; (11.1)\nand the expected value of njis E\u0152nj/c141D\u02dbDn=m .\nWe assume that O.1/ time suf\ufb01ces to compute the hash value h.k/ ,s ot h a t\nthe time required to search for an element with key kdepends linearly on the\nlength nh.k/of the list T\u0152 h . k/ /c141 . Setting aside the O.1/ time required to compute\nthe hash function and to access slot h.k/ , let us consider the expected number of\nelements examined by the search algorithm, that is, the number of elements in thelistT\u0152 h . k/ /c141 that the algorithm checks to see whether any have a key equal to k.W e\nshall consider two cases. In the \ufb01rst, the search is unsuccessful: no element in thetable has key k. In the second, the search successfully \ufb01nds an element with key k.\nTheorem 11.1\nIn a hash table in which collisions are resolved by chaining, an unsuccessful searchtakes average-case time \u201a.1C\u02db/, under the assumption of simple uniform hashing.\nProof Under the assumption of simple uniform hashing, any key knot already\nstored in the table is equally likely to hash to any of the mslots. The expected time\nto search unsuccessfully for a key kis the expected time to search to the end of\nlistT\u0152 h . k/ /c141 , which has expected length E \u0152n\nh.k//c141D\u02db. Thus, the expected number\nof elements examined in an unsuccessful search is \u02db, and the total time required\n(including the time for computing h.k/ )i s\u201a.1C\u02db/.\nThe situation for a successful search is slightly different, since each list is not\nequally likely to be searched. Instead, the probability that a list is searched is pro-portional to the number of elements it contains. Nonetheless, the expected searchtime still turns out to be \u201a.1C\u02db/.\nTheorem 11.2\nIn a hash table in which collisions are resolved by chaining, a successful searchtakes average-case time \u201a.1C\u02db/, under the assumption of simple uniform hashing.\nProof We assume that the element being searched for is equally likely to be any\nof the nelements stored in the table. The number of elements examined during a\nsuccessful search for an element xis one more than the number of elements that", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "280": {"page_number": 281, "page_information": "260 Chapter 11 Hash Tables\nappear before xinx\u2019s list. Because new elements are placed at the front of the\nlist, elements before xin the list were all inserted after xwas inserted. To \ufb01nd\nthe expected number of elements examined, we take the average, over the nele-\nments xin the table, of 1plus the expected number of elements added to x\u2019s list\nafter xwas added to the list. Let xidenote the ith element inserted into the ta-\nble, for iD1 ;2;:::;n ,a n dl e t kiDxi:key. For keys kiandkj,w ed e \ufb01 n et h e\nindicator random variable XijDIfh.k i/Dh.k j/g. Under the assumption of sim-\nple uniform hashing, we have Pr fh.k i/Dh.k j/gD1=m, and so by Lemma 5.1,\nE\u0152Xij/c141D1=m. Thus, the expected number of elements examined in a successful\nsearch is\nE\"\n1\nnnX\niD1 \n1CnX\njDiC1Xij!#\nD1\nnnX\niD1 \n1CnX\njDiC1E\u0152Xij/c141!\n(by linearity of expectation)\nD1\nnnX\niD1 \n1CnX\njDiC11\nm!\nD1C1\nnmnX\niD1.n/NULi/\nD1C1\nnm nX\niD1n/NULnX\niD1i!\nD1C1\nnm/DC2\nn2/NULn.nC1/\n2/DC3\n(by equation (A.1))\nD1Cn/NUL1\n2m\nD1C\u02db\n2/NUL\u02db\n2n:\nThus, the total time required for a successful search (including the time for com-\nputing the hash function) is \u201a.2C\u02db=2/NUL\u02db=2n/D\u201a.1C\u02db/.\nWhat does this analysis mean? If the number of hash-table slots is at least pro-\nportional to the number of elements in the table, we have nDO.m/ and, con-\nsequently, \u02dbDn=mDO.m/=mDO.1/ . Thus, searching takes constant time\non average. Since insertion takes O.1/ worst-case time and deletion takes O.1/\nworst-case time when the lists are doubly linked, we can support all dictionaryoperations in O.1/ time on average.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "281": {"page_number": 282, "page_information": "11.2 Hash tables 261\nExercises\n11.2-1\nSuppose we use a hash function hto hash ndistinct keys into an array Tof\nlength m. Assuming simple uniform hashing, what is the expected number of\ncollisions? More precisely, what is the expected cardinality of ffk;lgWk\u00a4land\nh.k/Dh.l/g?\n11.2-2\nDemonstrate what happens when we insert the keys 5; 28; 19; 15; 20; 33; 12; 17; 10\ninto a hash table with collisions resolved by chaining. Let the table have 9slots,\nand let the hash function be h.k/Dkmod9.\n11.2-3\nProfessor Marley hypothesizes that he can obtain substantial performance gains bymodifying the chaining scheme to keep each list in sorted order. How does the pro-fessor\u2019s modi\ufb01cation affect the running time for successful searches, unsuccessfulsearches, insertions, and deletions?\n11.2-4\nSuggest how to allocate and deallocate storage for elements within the hash tableitself by linking all unused slots into a free list. Assume that one slot can storea \ufb02ag and either one element plus a pointer or two pointers. All dictionary and\nfree-list operations should run in O.1/ expected time. Does the free list need to be\ndoubly linked, or does a singly linked free list suf\ufb01ce?\n11.2-5\nSuppose that we are storing a set of nkeys into a hash table of size m. Show that if\nthe keys are drawn from a universe UwithjUj>n m ,t h e n Uhas a subset of size n\nconsisting of keys that all hash to the same slot, so that the worst-case searchingtime for hashing with chaining is \u201a.n/ .\n11.2-6\nSuppose we have stored nkeys in a hash table of size m, with collisions resolved by\nchaining, and that we know the length of each chain, including the length Lof the\nlongest chain. Describe a procedure that selects a key uniformly at random fromamong the keys in the hash table and returns it in expected time O.L/SOH.1C1=\u02db// .", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "282": {"page_number": 283, "page_information": "262 Chapter 11 Hash Tables\n11.3 Hash functions\nIn this section, we discuss some issues regarding the design of good hash functions\nand then present three schemes for their creation. Two of the schemes, hashing bydivision and hashing by multiplication, are heuristic in nature, whereas the thirdscheme, universal hashing, uses randomization to provide provably good perfor-\nmance.\nWhat makes a good hash function?\nA good hash function satis\ufb01es (approximately) the assumption of simple uniform\nhashing: each key is equally likely to hash to any of the mslots, independently of\nwhere any other key has hashed to. Unfortunately, we typically have no way tocheck this condition, since we rarely know the probability distribution from whichthe keys are drawn. Moreover, the keys might not be drawn independently.\nOccasionally we do know the distribution. For example, if we know that the\nkeys are random real numbers kindependently and uniformly distributed in the\nrange 0/DC4k<1 , then the hash function\nh.k/Dbkmc\nsatis\ufb01es the condition of simple uniform hashing.\nIn practice, we can often employ heuristic techniques to create a hash function\nthat performs well. Qualitative information about the distribution of keys may be\nuseful in this design process. For example, consider a compiler\u2019s symbol table, in\nwhich the keys are character strings representing identi\ufb01ers in a program. Closely\nrelated symbols, such as ptandpts, often occur in the same program. A good\nhash function would minimize the chance that such variants hash to the same slot.\nA good approach derives the hash value in a way that we expect to be indepen-\ndent of any patterns that might exist in the data. For example, the \u201cdivision method\u201d(discussed in Section 11.3.1) computes the hash value as the remainder when thekey is divided by a speci\ufb01ed prime number. This method frequently gives goodresults, assuming that we choose a prime number that is unrelated to any patternsin the distribution of keys.\nFinally, we note that some applications of hash functions might require stronger\nproperties than are provided by simple uniform hashing. For example, we mightwant keys that are \u201cclose\u201d in some sense to yield hash values that are far apart.(This property is especially desirable when we are using linear probing, de\ufb01ned inSection 11.4.) Universal hashing, described in Section 11.3.3, often provides the\ndesired properties.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "283": {"page_number": 284, "page_information": "11.3 Hash functions 263\nInterpreting keys as natural numbers\nMost hash functions assume that the universe of keys is the set NDf0; 1; 2; : : :g\nof natural numbers. Thus, if the keys are not natural numbers, we \ufb01nd a way to\ninterpret them as natural numbers. For example, we can interpret a character stringas an integer expressed in suitable radix notation. Thus, we might interpret theidenti\ufb01er ptas the pair of decimal integers .112; 116/ ,s i n c e pD112andtD116\nin the ASCII character set; then, expressed as a radix-128 integer, ptbecomes\n.112/SOH128/C116D14452 . In the context of a given application, we can usually\ndevise some such method for interpreting each key as a (possibly large) naturalnumber. In what follows, we assume that the keys are natural numbers.\n11.3.1 The division method\nIn the division method for creating hash functions, we map a key kinto one of m\nslots by taking the remainder of kdivided by m. That is, the hash function is\nh.k/Dkmodm:\nFor example, if the hash table has size mD12and the key is kD100,t h e n\nh.k/D4. Since it requires only a single division operation, hashing by division is\nquite fast.\nWhen using the division method, we usually avoid certain values of m.F o r\nexample, mshould not be a power of 2, since if mD2\np,t h e n h.k/ is just the p\nlowest-order bits of k. Unless we know that all low-order p-bit patterns are equally\nlikely, we are better off designing the hash function to depend on all the bits of thekey. As Exercise 11.3-3 asks you to show, choosing mD2\np/NUL1when kis a\ncharacter string interpreted in radix 2pmay be a poor choice, because permuting\nthe characters of kdoes not change its hash value.\nA prime not too close to an exact power of 2 is often a good choice for m.F o r\nexample, suppose we wish to allocate a hash table, with collisions resolved bychaining, to hold roughly nD2000 character strings, where a character has 8bits.\nWe don\u2019t mind examining an average of 3elements in an unsuccessful search, and\nso we allocate a hash table of size mD701. We could choose mD701because\nit is a prime near 2000=3 but not near any power of 2. Treating each key kas an\ninteger, our hash function would be\nh.k/Dkmod701 :\n11.3.2 The multiplication method\nThemultiplication method for creating hash functions operates in two steps. First,\nwe multiply the key kby a constant Ain the range 0<A<1 and extract the", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "284": {"page_number": 285, "page_information": "264 Chapter 11 Hash Tables\n\u00d7 sDA/SOH2wwbits\nk\nr0 r1\nh.k/extract pbits\nFigure 11.4 The multiplication method of hashing. The w-bit representation of the key kis multi-\nplied by the w-bit value sDA/SOH2w.T h e phighest-order bits of the lower w-bit half of the product\nform the desired hash value h.k/ .\nfractional part of kA. Then, we multiply this value by mand take the \ufb02oor of the\nresult. In short, the hash function is\nh.k/Dbm. k A mod1/c;\nwhere \u201c kAmod1\u201d means the fractional part of kA,t h a ti s , kA/NULbkAc.\nAn advantage of the multiplication method is that the value of mis not critical.\nWe typically choose it to be a power of 2(mD2pfor some integer p), since we\ncan then easily implement the function on most computers as follows. Suppose\nthat the word size of the machine is wbits and that k\ufb01ts into a single word. We\nrestrict Ato be a fraction of the form s=2w,w h e r e sis an integer in the range\n0<s<2w. Referring to Figure 11.4, we \ufb01rst multiply kby the w-bit integer\nsDA/SOH2w. The result is a 2w-bit value r12wCr0,w h e r e r1is the high-order word\nof the product and r0is the low-order word of the product. The desired p-bit hash\nvalue consists of the pmost signi\ufb01cant bits of r0.\nAlthough this method works with any value of the constant A, it works better\nwith some values than with others. The optimal choice depends on the character-istics of the data being hashed. Knuth [211] suggests that\nA/EM.p\n5/NUL1/=2D0:6180339887 : : : (11.2)\nis likely to work reasonably well.\nAs an example, suppose we have kD123456 ,pD14,mD214D16384 ,\nandwD32. Adapting Knuth\u2019s suggestion, we choose Ato be the fraction of the\nform s=232that is closest to .p\n5/NUL1/=2 ,s ot h a t AD2654435769=232.T h e n\nk/SOHsD327706022297664 D.76300/SOH232/C17612864 ,a n ds o r1D76300\nandr0D17612864 .T h e 14most signi\ufb01cant bits of r0yield the value h.k/D67.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "285": {"page_number": 286, "page_information": "11.3 Hash functions 265\n?11.3.3 Universal hashing\nIf a malicious adversary chooses the keys to be hashed by some \ufb01xed hash function,\nthen the adversary can choose nkeys that all hash to the same slot, yielding an av-\nerage retrieval time of \u201a.n/ . Any \ufb01xed hash function is vulnerable to such terrible\nworst-case behavior; the only effective way to improve the situation is to choosethe hash function randomly in a way that is independent of the keys that are actually\ngoing to be stored. This approach, called universal hashing , can yield provably\ngood performance on average, no matter which keys the adversary chooses.\nIn universal hashing, at the beginning of execution we select the hash function\nat random from a carefully designed class of functions. As in the case of quick-sort, randomization guarantees that no single input will always evoke worst-casebehavior. Because we randomly select the hash function, the algorithm can be-have differently on each execution, even for the same input, guaranteeing goodaverage-case performance for any input. Returning to the example of a compiler\u2019s\nsymbol table, we \ufb01nd that the programmer\u2019s choice of identi\ufb01ers cannot now cause\nconsistently poor hashing performance. Poor performance occurs only when thecompiler chooses a random hash function that causes the set of identi\ufb01ers to hashpoorly, but the probability of this situation occurring is small and is the same forany set of identi\ufb01ers of the same size.\nLetHbe a \ufb01nite collection of hash functions that map a given universe Uof\nkeys into the range f0; 1; : : : ; m/NUL1g. Such a collection is said to be universal\nif for each pair of distinct keys k;l2U, the number of hash functions h2H\nfor which h.k/Dh.l/ is at mostjHj=m. In other words, with a hash function\nrandomly chosen from H, the chance of a collision between distinct keys kandl\nis no more than the chance 1=m of a collision if h.k/ andh.l/ were randomly and\nindependently chosen from the set f0; 1; : : : ; m/NUL1g.\nThe following theorem shows that a universal class of hash functions gives good\naverage-case behavior. Recall that n\nidenotes the length of list T\u0152 i/c141.\nTheorem 11.3\nSuppose that a hash function his chosen randomly from a universal collection of\nhash functions and has been used to hash nkeys into a table Tof size m,u s -\ning chaining to resolve collisions. If key kis not in the table, then the expected\nlength E \u0152nh.k//c141of the list that key khashes to is at most the load factor \u02dbDn=m .\nIf key kis in the table, then the expected length E \u0152nh.k//c141of the list containing key k\nis at most 1C\u02db.\nProof We note that the expectations here are over the choice of the hash func-\ntion and do not depend on any assumptions about the distribution of the keys.For each pair kandlof distinct keys, de\ufb01ne the indicator random variable", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "286": {"page_number": 287, "page_information": "266 Chapter 11 Hash Tables\nXklDIfh.k/Dh.l/g. Since by the de\ufb01nition of a universal collection of hash\nfunctions, a single pair of keys collides with probability at most 1=m,w eh a v e\nPrfh.k/Dh.l/g/DC41=m. By Lemma 5.1, therefore, we have E \u0152Xkl/c141/DC41=m.\nNext we de\ufb01ne, for each key k, the random variable Ykthat equals the number\nof keys other than kthat hash to the same slot as k,s ot h a t\nYkDX\nl2T\nl\u00a4kXkl:\nThus we have\nE\u0152Yk/c141DE2\n4X\nl2T\nl\u00a4kXkl3\n5\nDX\nl2T\nl\u00a4kE\u0152Xkl/c141 (by linearity of expectation)\n/DC4X\nl2T\nl\u00a4k1\nm:\nThe remainder of the proof depends on whether key kis in table T.\n/SIIfk62T,t h e n nh.k/DYkandjflWl2Tandl\u00a4kgjDn. Thus E \u0152nh.k//c141D\nE\u0152Yk/c141/DC4n=mD\u02db.\n/SIIfk2T, then because key kappears in list T\u0152 h . k/ /c141 and the count Ykdoes not\ninclude key k,w eh a v e nh.k/DYkC1andjflWl2Tandl\u00a4kgjDn/NUL1.\nThus E \u0152nh.k//c141DE\u0152Yk/c141C1/DC4.n/NUL1/=mC1D1C\u02db/NUL1=m < 1C\u02db.\nThe following corollary says universal hashing provides the desired payoff: it\nhas now become impossible for an adversary to pick a sequence of operations thatforces the worst-case running time. By cleverly randomizing the choice of hashfunction at run time, we guarantee that we can process every sequence of operationswith a good average-case running time.\nCorollary 11.4\nUsing universal hashing and collision resolution by chaining in an initially emptytable with mslots, it takes expected time \u201a.n/ to handle any sequence of nI\nNSERT ,\nSEARCH ,a n dD ELETE operations containing O.m/ INSERT operations.\nProof Since the number of insertions is O.m/ ,w eh a v e nDO.m/ and so\n\u02dbDO.1/ .T h e I NSERT and D ELETE operations take constant time and, by The-\norem 11.3, the expected time for each S EARCH operation is O.1/ . By linearity of", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "287": {"page_number": 288, "page_information": "11.3 Hash functions 267\nexpectation, therefore, the expected time for the entire sequence of noperations\nisO.n/ . Since each operation takes /DEL.1/ time, the \u201a.n/ bound follows.\nDesigning a universal class of hash functions\nIt is quite easy to design a universal class of hash functions, as a little number\ntheory will help us prove. You may wish to consult Chapter 31 \ufb01rst if you areunfamiliar with number theory.\nWe begin by choosing a prime number plarge enough so that every possible\nkeykis in the range 0top/NUL1, inclusive. Let Z\npdenote the setf0; 1; : : : ; p/NUL1g,\nand let Z/ETX\npdenote the setf1 ;2;:::;p/NUL1g.S i n c e pis prime, we can solve equa-\ntions modulo pwith the methods given in Chapter 31. Because we assume that the\nsize of the universe of keys is greater than the number of slots in the hash table, we\nhave p>m .\nWe now de\ufb01ne the hash function habfor any a2Z/ETX\npand any b2Zpusing a\nlinear transformation followed by reductions modulo pand then modulo m:\nhab.k/D..akCb/modp/modm: (11.3)\nFor example, with pD17andmD6,w eh a v e h3;4.8/D5. The family of all\nsuch hash functions is\nHpmD\u02da\nhabWa2Z/ETX\npandb2Zp/TAB\n: (11.4)\nEach hash function habmaps ZptoZm. This class of hash functions has the nice\nproperty that the size mof the output range is arbitrary\u2014not necessarily prime\u2014a\nfeature which we shall use in Section 11.5. Since we have p/NUL1choices for a\nandpchoices for b, the collection Hpmcontains p.p/NUL1/hash functions.\nTheorem 11.5\nThe class Hpmof hash functions de\ufb01ned by equations (11.3) and (11.4) is universal.\nProof Consider two distinct keys kandlfrom Zp,s ot h a t k\u00a4l.F o r a g i v e n\nhash function habwe let\nrD.akCb/modp;\nsD.alCb/modp:\nWe \ufb01rst note that r\u00a4s. Why? Observe that\nr/NULs/DC1a.k/NULl/ .mod p/ :\nIt follows that r\u00a4sbecause pis prime and both aand.k/NULl/are nonzero\nmodulo p, and so their product must also be nonzero modulo pby Theorem 31.6.\nTherefore, when computing any hab2Hpm, distinct inputs kandlmap to distinct", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "288": {"page_number": 289, "page_information": "268 Chapter 11 Hash Tables\nvalues randsmodulo p; there are no collisions yet at the \u201cmod plevel.\u201d Moreover,\neach of the possible p.p/NUL1/choices for the pair .a; b/ witha\u00a40yields a different\nresulting pair .r; s/ withr\u00a4s, since we can solve for aandbgiven rands:\naD/NUL\n.r/NULs/..k/NULl//NUL1modp//SOH\nmodp;\nbD.r/NULak/modp;\nwhere ..k/NULl//NUL1modp/denotes the unique multiplicative inverse, modulo p,\nofk/NULl. Since there are only p.p/NUL1/possible pairs .r; s/ with r\u00a4s,t h e r e\nis a one-to-one correspondence between pairs .a; b/ with a\u00a40and pairs .r; s/\nwithr\u00a4s. Thus, for any given pair of inputs kandl,i fw ep i c k .a; b/ uniformly\nat random from Z/ETX\np/STXZp, the resulting pair .r; s/ is equally likely to be any pair of\ndistinct values modulo p.\nTherefore, the probability that distinct keys kandlcollide is equal to the prob-\nability that r/DC1s.mod m/when randsare randomly chosen as distinct values\nmodulo p.F o rag i v e nv a l u eo f r,o ft h e p/NUL1possible remaining values for s,t h e\nnumber of values ssuch that s\u00a4rands/DC1r.mod m/is at most\ndp=me/NUL1/DC4..pCm/NUL1/=m//NUL1(by inequality (3.6))\nD.p/NUL1/=m :\nThe probability that scollides with rwhen reduced modulo mis at most\n..p/NUL1/=m/=.p/NUL1/D1=m.\nTherefore, for any pair of distinct values k;l2Zp,\nPrfhab.k/Dhab.l/g/DC41=m ;\nso that Hpmis indeed universal.\nExercises\n11.3-1\nSuppose we wish to search a linked list of length n, where each element contains\nak e y kalong with a hash value h.k/ . Each key is a long character string. How\nmight we take advantage of the hash values when searching the list for an elementwith a given key?\n11.3-2\nSuppose that we hash a string of rcharacters into mslots by treating it as a\nradix-128 number and then using the division method. We can easily representthe number mas a 32-bit computer word, but the string of rcharacters, treated as\na radix-128 number, takes many words. How can we apply the division method tocompute the hash value of the character string without using more than a constantnumber of words of storag eoutside the string itself?", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "289": {"page_number": 290, "page_information": "11.4 Open addressing 269\n11.3-3\nConsider a version of the division method in which h.k/Dkmodm,w h e r e\nmD2p/NUL1andkis a character string interpreted in radix 2p. Show that if we\ncan derive string xfrom string yby permuting its characters, then xandyhash to\nthe same value. Give an example of an application in which this property would beundesirable in a hash function.\n11.3-4\nConsider a hash table of size mD1000 and a corresponding hash function h.k/D\nbm. k A mod1/cforAD.p\n5/NUL1/=2 . Compute the locations to which the keys\n61,62,63,64,a n d 65are mapped.\n11.3-5 ?\nD e \ufb01 n eaf a m i l y Hof hash functions from a \ufb01nite set Uto a \ufb01nite set Bto be\n/SI-universal if for all pairs of distinct elements kandlinU,\nPrfh.k/Dh.l/g/DC4/SI;\nwhere the probability is over the choice of the hash function hdrawn at random\nfrom the family H. Show that an /SI-universal family of hash functions must have\n/SI/NAK1\njBj/NUL1\njUj:\n11.3-6 ?\nLetUbe the set of n-tuples of values drawn from Zp,a n dl e t BDZp,w h e r e p\nis prime. De\ufb01ne the hash function hbWU!Bforb2Zpon an input n-tuple\nha0;a1;:::;a n/NUL1ifrom Uas\nhb.ha0;a1;:::;a n/NUL1i/D n/NUL1X\njD0ajbj!\nmodp;\nand let HDfhbWb2Zpg. Argue that His..n/NUL1/=p/ -universal according to\nthe de\ufb01nition of /SI-universal in Exercise 11.3-5. ( Hint: See Exercise 31.4-4.)\n11.4 Open addressing\nInopen addressing , all elements occupy the hash table itself. That is, each table\nentry contains either an element of the dynamic set or NIL. When searching for\nan element, we systematically examine table slots until either we \ufb01nd the desiredelement or we have ascertained that the element is not in the table. No lists and", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "290": {"page_number": 291, "page_information": "270 Chapter 11 Hash Tables\nno elements are stored outside the table, unlike in chaining. Thus, in open ad-\ndressing, the hash table can \u201c\ufb01ll up\u201d so that no further insertions can be made; oneconsequence is that the load factor \u02dbcan never exceed 1.\nOf course, we could store the linked lists for chaining inside the hash table, in\nthe otherwise unused hash-table slots (see Exercise 11.2-4), but the advantage ofopen addressing is that it avoids pointers altogether. Instead of following pointers,wecompute the sequence of slots to be examined. The extra memory freed by not\nstoring pointers provides the hash table with a larger number of slots for the same\namount of memory, potentially yielding fewer collisions and faster retrieval.\nTo perform insertion using open addressing, we successively examine, or probe ,\nthe hash table until we \ufb01nd an empty slot in which to put the key. Instead of being\ufb01xed in the order 0; 1; : : : ; m/NUL1(which requires \u201a.n/ search time), the sequence\nof positions probed depends upon the key being inserted . To determine which slots\nto probe, we extend the hash function to include the probe number (starting from 0)\nas a second input. Thus, the hash function becomes\nhWU/STXf0; 1; : : : ; m/NUL1g!f0; 1; : : : ; m/NUL1g:\nWith open addressing, we require that for every key k,t h eprobe sequence\nhh . k;0 / ;h . k;1 / ;:::;h . k;m /NUL1/i\nbe a permutation of h0;1;: : : ;m/NUL1i, so that every hash-table position is eventually\nconsidered as a slot for a new key as the table \ufb01lls up. In the following pseudocode,we assume that the elements in the hash table Tare keys with no satellite infor-\nmation; the key kis identical to the element containing key k. Each slot contains\neither a key or\nNIL(if the slot is empty). The H ASH-INSERT procedure takes as\ninput a hash table Tand a key k. It either returns the slot number where it stores\nkeykor \ufb02ags an error because the hash table is already full.\nHASH-INSERT .T; k/\n1iD0\n2repeat\n3 jDh.k; i/\n4 ifT\u0152 j/c141 ==NIL\n5 T\u0152 j/c141Dk\n6 return j\n7 elseiDiC1\n8until i==m\n9error \u201chash table over\ufb02ow\u201d\nThe algorithm for searching for key kprobes the same sequence of slots that the\ninsertion algorithm examined when key kwas inserted. Therefore, the search can", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "291": {"page_number": 292, "page_information": "11.4 Open addressing 271\nterminate (unsuccessfully) when it \ufb01nds an empty slot, since kwould have been\ninserted there and not later in its probe sequence. (This argument assumes that keysare not deleted from the hash table.) The procedure H\nASH-SEARCH takes as input\na hash table Tand a key k, returning jif it \ufb01nds that slot jcontains key k,o r NIL\nif key kis not present in table T.\nHASH-SEARCH .T; k/\n1iD0\n2repeat\n3 jDh.k; i/\n4 ifT\u0152 j/c141 ==k\n5 return j\n6 iDiC1\n7until T\u0152 j/c141 ==NILori==m\n8return NIL\nDeletion from an open-address hash table is dif\ufb01cult. When we delete a key\nfrom slot i, we cannot simply mark that slot as empty by storing NILin it. If\nwe did, we might be unable to retrieve any key kduring whose insertion we had\nprobed slot iand found it occupied. We can solve this problem by marking the\nslot, storing in it the special value DELETED instead of NIL. We would then modify\nthe procedure H ASH-INSERT to treat such a slot as if it were empty so that we can\ninsert a new key there. We do not need to modify H ASH-SEARCH , since it will pass\nover DELETED values while searching. When we use the special value DELETED ,\nhowever, search times no longer depend on the load factor \u02db, and for this reason\nchaining is more commonly selected as a collision resolution technique when keysmust be deleted.\nIn our analysis, we assume uniform hashing : the probe sequence of each key\nis equally likely to be any of the m\u0160permutations ofh0 ; 1 ; :::; m/NUL1i.U n i -\nform hashing generalizes the notion of simple uniform hashing de\ufb01ned earlier to a\nhash function that produces not just a single number, but a whole probe sequence.\nTrue uniform hashing is dif\ufb01cult to implement, however, and in practice suitable\napproximations (such as double hashing, de\ufb01ned below) are used.\nWe will examine three commonly used techniques to compute the probe se-\nquences required for open addressing: linear probing, quadratic probing, and dou-\nble hashing. These techniques all guarantee that hh .k;0 /;h .k;1 /;:::;h .k;m /NUL1/i\nis a permutation ofh0 ;1 ;:::;m/NUL1ifor each key k. None of these techniques ful-\n\ufb01lls the assumption of uniform hashing, however, since none of them is capable ofgenerating more than m\n2different probe sequences (instead of the m\u0160that uniform\nhashing requires). Double hashing has the greatest number of probe sequences and,as one might expect, seems to give the best results.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "292": {"page_number": 293, "page_information": "272 Chapter 11 Hash Tables\nLinear probing\nGiven an ordinary hash function h0WU!f0; 1; : : : ; m/NUL1g, which we refer to as\nanauxiliary hash function , the method of linear probing uses the hash function\nh.k; i/D.h0.k/Ci/modm\nforiD0; 1; : : : ; m/NUL1.G i v e n k e y k, we \ufb01rst probe T\u0152 h0.k//c141, i.e., the slot given\nby the auxiliary hash function. We next probe slot T\u0152 h0.k/C1/c141, and so on up to\nslotT\u0152 m/NUL1/c141. Then we wrap around to slots T \u01520/c141; T \u01521/c141; : : : until we \ufb01nally probe\nslotT\u0152 h0.k//NUL1/c141. Because the initial probe determines the entire probe sequence,\nthere are only mdistinct probe sequences.\nLinear probing is easy to implement, but it suffers from a problem known as\nprimary clustering . Long runs of occupied slots build up, increasing the average\nsearch time. Clusters arise because an empty slot preceded by ifull slots gets \ufb01lled\nnext with probability .iC1/=m . Long runs of occupied slots tend to get longer,\nand the average search time increases.\nQuadratic probing\nQuadratic probing uses a hash function of the form\nh.k; i/D.h0.k/Cc1iCc2i2/modm; (11.5)\nwhere h0is an auxiliary hash function, c1andc2are positive auxiliary constants,\nandiD0; 1; : : : ; m/NUL1. The initial position probed is T\u0152 h0.k//c141; later positions\nprobed are offset by amounts that depend in a quadratic manner on the probe num-beri. This method works much better than linear probing, but to make full use of\nthe hash table, the values of c\n1,c2,a n d mare constrained. Problem 11-3 shows\none way to select these parameters. Also, if two keys have the same initial probeposition, then their probe sequences are the same, since h.k\n1;0 /Dh.k 2;0 /im-\nplies h.k 1;i/Dh.k 2;i/. This property leads to a milder form of clustering, called\nsecondary clustering . As in linear probing, the initial probe determines the entire\nsequence, and so only mdistinct probe sequences are used.\nDouble hashing\nDouble hashing offers one of the best methods available for open addressing be-\ncause the permutations produced have many of the characteristics of randomlychosen permutations. Double hashing uses a hash function of the form\nh.k; i/D.h\n1.k/Cih2.k// modm;\nwhere both h1andh2are auxiliary hash functions. The initial probe goes to posi-\ntionT\u0152 h 1.k//c141; successive probe positions are offset from previous positions by the", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "293": {"page_number": 294, "page_information": "11.4 Open addressing 273\n0\n123456789\n10111279\n69\n98\n721450\nFigure 11.5 Insertion by double hashing. Here we have a hash table of size 13with h1.k/D\nkmod13andh2.k/D1C.kmod11/.S i n c e 14/DC11.mod 13/and14/DC13.mod 11/,w ei n s e r t\nthe key 14into empty slot 9, after examining slots 1and5and \ufb01nding them to be occupied.\namount h2.k/, modulo m. Thus, unlike the case of linear or quadratic probing, the\nprobe sequence here depends in two ways upon the key k, since the initial probe\nposition, the offset, or both, may vary. Figure 11.5 gives an example of insertionby double hashing.\nThe value h\n2.k/must be relatively prime to the hash-table size mfor the entire\nhash table to be searched. (See Exercise 11.4-4.) A convenient way to ensure thiscondition is to let mbe a power of 2and to design h\n2so that it always produces an\nodd number. Another way is to let mbe prime and to design h2so that it always\nreturns a positive integer less than m. For example, we could choose mprime and\nlet\nh1.k/Dkmodm;\nh2.k/D1C.kmodm0/;\nwhere m0is chosen to be slightly less than m(say, m/NUL1). For example, if\nkD123456 ,mD701,a n d m0D700,w eh a v e h1.k/D80andh2.k/D257,s o\nthat we \ufb01rst probe position 80, and then we examine every 257th slot (modulo m)\nuntil we \ufb01nd the key or have examined every slot.\nWhen mis prime or a power of 2, double hashing improves over linear or qua-\ndratic probing in that \u201a.m2/probe sequences are used, rather than \u201a.m/ ,s i n c e\neach possible .h1.k/; h 2.k// pair yields a distinct probe sequence. As a result, for", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "294": {"page_number": 295, "page_information": "274 Chapter 11 Hash Tables\nsuch values of m, the performance of double hashing appears to be very close to\nthe performance of the \u201cideal\u201d scheme of uniform hashing.\nAlthough values of mother than primes or powers of 2could in principle be\nused with double hashing, in practice it becomes more dif\ufb01cult to ef\ufb01ciently gen-erate h\n2.k/in a way that ensures that it is relatively prime to m, in part because the\nrelative density /RS.m/=m of such numbers may be small (see equation (31.24)).\nAnalysis of open-address hashing\nAs in our analysis of chaining, we express our analysis of open addressing in terms\nof the load factor \u02dbDn=m of the hash table. Of course, with open addressing, at\nmost one element occupies each slot, and thus n/DC4m, which implies \u02db/DC41.\nWe assume that we are using uniform hashing. In this idealized scheme, the\nprobe sequencehh.k; 0/; h.k; 1/; : : : ; h.k; m /NUL1/iused to insert or search for\neach key kis equally likely to be any permutation of h0; 1; : : : ; m/NUL1i. Of course,\na given key has a unique \ufb01xed probe sequence associated with it; what we meanhere is that, considering the probability distribution on the space of keys and theoperation of the hash function on the keys, each possible probe sequence is equallylikely.\nWe now analyze the expected number of probes for hashing with open address-\ning under the assumption of uniform hashing, beginning with an analysis of the\nnumber of probes made in an unsuccessful search.\nTheorem 11.6\nGiven an open-address hash table with load factor \u02dbDn=m < 1 , the expected\nnumber of probes in an unsuccessful search is at most 1=.1/NUL\u02db/, assuming uniform\nhashing.\nProof In an unsuccessful search, every probe but the last accesses an occupied\nslot that does not contain the desired key, and the last slot probed is empty. Let usde\ufb01ne the random variable Xto be the number of probes made in an unsuccessful\nsearch, and let us also de\ufb01ne the event A\ni,f o riD1 ;2;::: , to be the event that\nanith probe occurs and it is to an occupied slot. Then the event fX/NAKigis the\nintersection of events A1\\A2\\/SOH/SOH/SOH\\ Ai/NUL1. We will bound PrfX/NAKigby bounding\nPrfA1\\A2\\/SOH/SOH/SOH\\ Ai/NUL1g. By Exercise C.2-5,\nPrfA1\\A2\\/SOH/SOH/SOH\\ Ai/NUL1gDPrfA1g/SOHPrfA2jA1g/SOHPrfA3jA1\\A2g/SOH/SOH/SOH\nPrfAi/NUL1jA1\\A2\\/SOH/SOH/SOH\\ Ai/NUL2g:\nSince there are nelements and mslots, PrfA1gDn=m .F o r j> 1 , the probability\nthat there is a jth probe and it is to an occupied slot, given that the \ufb01rst j/NUL1\nprobes were to occupied slots, is .n/NULjC1/=.m/NULjC1/. This probability follows", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "295": {"page_number": 296, "page_information": "11.4 Open addressing 275\nbecause we would be \ufb01nding one of the remaining .n/NUL.j/NUL1//elements in one\nof the .m/NUL.j/NUL1//unexamined slots, and by the assumption of uniform hashing,\nthe probability is the ratio of these quantities. Observing that n<m implies that\n.n/NULj/ = . m/NULj//DC4n=m for all jsuch that 0/DC4j< m ,w eh a v ef o ra l l isuch that\n1/DC4i/DC4m,\nPrfX/NAKigDn\nm/SOHn/NUL1\nm/NUL1/SOHn/NUL2\nm/NUL2/SOH/SOH/SOHn/NULiC2\nm/NULiC2\n/DC4/DLEn\nm/DC1i/NUL1\nD\u02dbi/NUL1:\nNow, we use equation (C.25) to bound the expected number of probes:\nE\u0152X/c141D1X\niD1PrfX/NAKig\n/DC41X\niD1\u02dbi/NUL1\nD1X\niD0\u02dbi\nD1\n1/NUL\u02db:\nThis bound of 1=.1/NUL\u02db/D1C\u02dbC\u02db2C\u02db3C/SOH/SOH/SOH has an intuitive interpretation.\nWe always make the \ufb01rst probe. With probability approximately \u02db, the \ufb01rst probe\n\ufb01nds an occupied slot, so that we need to probe a second time. With probabilityapproximately \u02db\n2, the \ufb01rst two slots are occupied so that we make a third probe,\nand so on.\nIf\u02dbis a constant, Theorem 11.6 predicts that an unsuccessful search runs in O.1/\ntime. For example, if the hash table is half full, the average number of probes in anunsuccessful search is at most 1=.1/NUL:5/D2.I fi ti s 90percent full, the average\nnumber of probes is at most 1=.1/NUL:9/D10.\nTheorem 11.6 gives us the performance of the H\nASH-INSERT procedure almost\nimmediately.\nCorollary 11.7\nInserting an element into an open-address hash table with load factor \u02dbrequires at\nmost 1=.1/NUL\u02db/probes on average, assuming uniform hashing.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "296": {"page_number": 297, "page_information": "276 Chapter 11 Hash Tables\nProof An element is inserted only if there is room in the table, and thus \u02db<1 .\nInserting a key requires an unsuccessful search followed by placing the key into the\ufb01rst empty slot found. Thus, the expected number of probes is at most 1=.1/NUL\u02db/.\nWe have to do a little more work to compute the expected number of probes for\na successful search.\nTheorem 11.8\nGiven an open-address hash table with load factor \u02db<1 , the expected number of\nprobes in a successful search is at most\n1\n\u02dbln1\n1/NUL\u02db;\nassuming uniform hashing and assuming that each key in the table is equally likely\nto be searched for.\nProof A search for a key kreproduces the same probe sequence as when the\nelement with key kwas inserted. By Corollary 11.7, if kwas the .iC1/st key\ninserted into the hash table, the expected number of probes made in a search for k\nis at most 1=.1/NULi=m/Dm=.m/NULi/. Averaging over all nkeys in the hash table\ngives us the expected number of probes in a successful search:\n1\nnn/NUL1X\niD0m\nm/NULiDm\nnn/NUL1X\niD01\nm/NULi\nD1\n\u02dbmX\nkDm/NULnC11\nk\n/DC41\n\u02dbZm\nm/NULn.1=x/ dx (by inequality (A.12))\nD1\n\u02dblnm\nm/NULn\nD1\n\u02dbln1\n1/NUL\u02db:\nIf the hash table is half full, the expected number of probes in a successful search\nis less than 1:387 . If the hash table is 90percent full, the expected number of probes\nis less than 2:559 .", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "297": {"page_number": 298, "page_information": "11.5 Perfect hashing 277\nExercises\n11.4-1\nConsider inserting the keys 10; 22; 31; 4; 15; 28; 17; 88; 59 into a hash table of\nlength mD11using open addressing with the auxiliary hash function h0.k/Dk.\nIllustrate the result of inserting these keys using linear probing, using quadratic\nprobing with c1D1andc2D3, and using double hashing with h1.k/Dkand\nh2.k/D1C.kmod.m/NUL1//.\n11.4-2\nWrite pseudocode for H ASH-DELETE as outlined in the text, and modify H ASH-\nINSERT to handle the special value DELETED .\n11.4-3\nConsider an open-address hash table with uniform hashing. Give upper boundson the expected number of probes in an unsuccessful search and on the expectednumber of probes in a successful search when the load factor is 3=4and when it\nis7=8.\n11.4-4 ?\nSuppose that we use double hashing to resolve collisions\u2014that is, we use the hashfunction h.k; i/D.h\n1.k/Cih2.k// modm. Show that if mandh2.k/have\ngreatest common divisor d/NAK1for some key k, then an unsuccessful search for\nkeykexamines .1=d/ th of the hash table before returning to slot h1.k/. Thus,\nwhen dD1,s ot h a t mandh2.k/are relatively prime, the search may examine the\nentire hash table. ( Hint: See Chapter 31.)\n11.4-5 ?\nConsider an open-address hash table with a load factor \u02db. Find the nonzero value \u02db\nfor which the expected number of probes in an unsuccessful search equals twicethe expected number of probes in a successful search. Use the upper bounds givenby Theorems 11.6 and 11.8 for these expected numbers of probes.\n?11.5 Perfect hashing\nAlthough hashing is often a good choice for its excellent average-case perfor-mance, hashing can also provide excellent worst-case performance when the set of\nkeys is static : once the keys are stored in the table, the set of keys never changes.\nSome applications naturally have static sets of keys: consider the set of reservedwords in a programming language, or the set of \ufb01le names on a CD-ROM. We", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "298": {"page_number": 299, "page_information": "278 Chapter 11 Hash Tables\n0\n1\n2\n3\n4\n5\n6\n7\n8100 1 0\n91 0 1 8 6 0 75\n0123\n100 7 00\n0\n16 23 88 40 37\n0123 4567852m2S2a2b2m0S0a0b0\nm5S5 a5b5\nm7S7 a7b7T\n4567872\n9 1 01 11 21 31 41 522\nFigure 11.6 Using perfect hashing to store the set KDf10; 22; 37; 40; 52; 60; 70; 72; 75 g.T h e\nouter hash function is h.k/D..akCb/modp/modm,w h e r e aD3,bD42,pD101,a n d\nmD9. For example, h.75/D2,a n ds ok e y 75hashes to slot 2 of table T. A secondary hash\ntable Sjstores all keys hashing to slot j. The size of hash table SjismjDn2\nj, and the associated\nhash function is hj.k/D..ajkCbj/modp/modmj.S i n c e h2.75/D7,k e y 75is stored in slot 7\nof secondary hash table S2. No collisions occur in any of the secondary hash tables, and so searching\ntakes constant time in the worst case.\ncall a hashing technique perfect hashing ifO.1/ memory accesses are required to\nperform a search in the worst case.\nTo create a perfect hashing scheme, we use two levels of hashing, with universal\nhashing at each level. Figure 11.6 illustrates the approach.\nThe \ufb01rst level is essentially the same as for hashing with chaining: we hash\nthenkeys into mslots using a hash function hcarefully selected from a family of\nuniversal hash functions.\nInstead of making a linked list of the keys hashing to slot j, however, we use a\nsmall secondary hash table Sjwith an associated hash function hj. By choosing\nthe hash functions hjcarefully, we can guarantee that there are no collisions at the\nsecondary level.\nIn order to guarantee that there are no collisions at the secondary level, however,\nwe will need to let the size mjof hash table Sjbe the square of the number njof\nkeys hashing to slot j. Although you might think that the quadratic dependence\nofmjonnjmay seem likely to cause the overall storage requirement to be exces-\nsive, we shall show that by choosing the \ufb01rst-level hash function well, we can limitthe expected total amount of space used to O.n/ .\nWe use hash functions chosen from the universal classes of hash functions of\nSection 11.3.3. The \ufb01rst-level hash function comes from the class H\npm,w h e r ea s\nin Section 11.3.3, pis a prime number greater than any key value. Those keys", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "299": {"page_number": 300, "page_information": "11.5 Perfect hashing 279\nhashing to slot jare re-hashed into a secondary hash table Sjof size mjusing a\nhash function hjchosen from the class Hp;m j.1\nWe shall proceed in two steps. First, we shall determine how to ensure that\nthe secondary tables have no collisions. Second, we shall show that the expectedamount of memory used overall\u2014for the primary hash table and all the secondaryhash tables\u2014is O.n/ .\nTheorem 11.9\nSuppose that we store nkeys in a hash table of size mDn\n2using a hash function h\nrandomly chosen from a universal class of hash functions. Then, the probability isless than 1=2that there are any collisions.\nProof There are/NUL\nn\n2/SOH\npairs of keys that may collide; each pair collides with prob-\nability 1=m ifhis chosen at random from a universal family Hof hash functions.\nLetXbe a random variable that counts the number of collisions. When mDn2,\nthe expected number of collisions is\nE\u0152X/c141D \nn\n2!\n/SOH1\nn2\nDn2/NULn\n2/SOH1\nn2\n<1 = 2 :\n(This analysis is similar to the analysis of the birthday paradox in Section 5.4.1.)\nApplying Markov\u2019s inequality (C.30), Pr fX/NAKtg/DC4E\u0152X/c141 =t , with tD1,c o m -\npletes the proof.\nIn the situation described in Theorem 11.9, where mDn2, it follows that a hash\nfunction hchosen at random from His more likely than not to have nocollisions.\nGiven the set Kofnkeys to be hashed (remember that Kis static), it is thus easy\nto \ufb01nd a collision-free hash function hwith a few random trials.\nWhen nis large, however, a hash table of size mDn2is excessive. Therefore,\nwe adopt the two-level hashing approach, and we use the approach of Theorem 11.9only to hash the entries within each slot. We use an outer, or \ufb01rst-level, hashfunction hto hash the keys into mDnslots. Then, if n\njkeys hash to slot j,w e\nuse a secondary hash table Sjof size mjDn2\njto provide collision-free constant-\ntime lookup.\n1When njDmjD1, we don\u2019t really need a hash function for slot j; when we choose a hash\nfunction hab.k/D..akCb/modp/modmjfor such a slot, we just use aDbD0.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "300": {"page_number": 301, "page_information": "280 Chapter 11 Hash Tables\nWe now turn to the issue of ensuring that the overall memory used is O.n/ .\nSince the size mjof the jth secondary hash table grows quadratically with the\nnumber njof keys stored, we run the risk that the overall amount of storage could\nbe excessive.\nIf the \ufb01rst-level table size is mDn, then the amount of memory used is O.n/\nfor the primary hash table, for the storage of the sizes mjof the secondary hash\ntables, and for the storage of the parameters ajandbjde\ufb01ning the secondary hash\nfunctions hjdrawn from the class Hp;m jof Section 11.3.3 (except when njD1\nand we use aDbD0). The following theorem and a corollary provide a bound on\nthe expected combined sizes of all the secondary hash tables. A second corollarybounds the probability that the combined size of all the secondary hash tables issuperlinear (actually, that it equals or exceeds 4n).\nTheorem 11.10\nSuppose that we store nkeys in a hash table of size mDnusing a hash function h\nrandomly chosen from a universal class of hash functions. Then, we have\nE\"\nm/NUL1X\njD0n2\nj#\n<2 n;\nwhere njis the number of keys hashing to slot j.\nProof We start with the following identity, which holds for any nonnegative inte-\ngera:\na2DaC2 \na\n2!\n: (11.6)\nWe have\nE\"m/NUL1X\njD0n2\nj#\nDE\"m/NUL1X\njD0 \nnjC2 \nnj\n2!!#\n(by equation (11.6))\nDE\"m/NUL1X\njD0nj#\nC2E\"m/NUL1X\njD0 \nnj\n2!#\n(by linearity of expectation)\nDE\u0152n/c141C2E\"m/NUL1X\njD0 \nnj\n2!#\n(by equation (11.1))", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "301": {"page_number": 302, "page_information": "11.5 Perfect hashing 281\nDnC2E\"m/NUL1X\njD0 \nnj\n2!#\n(since nis not a random variable) .\nTo evaluate the summationPm/NUL1\njD0/NULnj\n2/SOH\n, we observe that it is just the total number\nof pairs of keys in the hash table that collide. By the properties of universal hashing,the expected value of this summation is at most\n \nn\n2!\n1\nmDn.n/NUL1/\n2m\nDn/NUL1\n2;\nsince mDn. Thus,\nE\"m/NUL1X\njD0n2\nj#\n/DC4nC2n/NUL1\n2\nD2n/NUL1\n<2 n :\nCorollary 11.11\nSuppose that we store nkeys in a hash table of size mDnusing a hash func-\ntionhrandomly chosen from a universal class of hash functions, and we set the\nsize of each secondary hash table to mjDn2\njforjD0; 1; : : : ; m/NUL1. Then,\nthe expected amount of storage required for all secondary hash tables in a perfecthashing scheme is less than 2n.\nProof Since m\njDn2\njforjD0; 1; : : : ; m/NUL1, Theorem 11.10 gives\nE\"m/NUL1X\njD0mj#\nDE\"m/NUL1X\njD0n2\nj#\n<2 n ; (11.7)\nwhich completes the proof.\nCorollary 11.12\nSuppose that we store nkeys in a hash table of size mDnusing a hash function h\nrandomly chosen from a universal class of hash functions, and we set the size\nof each secondary hash table to mjDn2\njforjD0; 1; : : : ; m/NUL1. Then, the\nprobability is less than 1=2that the total storage used for secondary hash tables\nequals or exceeds 4n.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "302": {"page_number": 303, "page_information": "282 Chapter 11 Hash Tables\nProof Again we apply Markov\u2019s inequality (C.30), Pr fX/NAKtg/DC4E\u0152X/c141 =t ,t h i s\ntime to inequality (11.7), with XDPm/NUL1\njD0mjandtD4n:\nPr(m/NUL1X\njD0mj/NAK4n)\n/DC4E/STXPm/NUL1\njD0mj/ETX\n4n\n<2n\n4n\nD1=2 :\nFrom Corollary 11.12, we see that if we test a few randomly chosen hash func-\ntions from the universal family, we will quickly \ufb01nd one that uses a reasonableamount of storage.\nExercises\n11.5-1 ?\nSuppose that we insert nkeys into a hash table of size musing open addressing\nand uniform hashing. Let p.n;m/ be the probability that no collisions occur. Show\nthatp.n;m//DC4e\n/NULn.n/NUL1/=2m.(Hint: See equation (3.12).) Argue that when nex-\nceedsp\nm, the probability of avoiding collisions goes rapidly to zero.\nProblems\n11-1 Longest-probe bound for hashing\nSuppose that we use an open-addressed hash table of size mto store n/DC4m=2\nitems.\na.Assuming uniform hashing, show that for iD1 ;2;:::;n , the probability is at\nmost 2/NULkthat the ith insertion requires strictly more than kprobes.\nb.Show that for iD1 ;2;:::;n , the probability is O.1=n2/that the ith insertion\nrequires more than 2lgnprobes.\nLet the random variable Xidenote the number of probes required by the ith inser-\ntion. You have shown in part (b) that Pr fXi>2lgngDO.1=n2/. Let the random\nvariable XDmax 1/DC4i/DC4nXidenote the maximum number of probes required by\nany of the ninsertions.\nc.Show that PrfX>2 lgngDO.1=n/ .\nd.Show that the expected length E \u0152X/c141of the longest probe sequence is O.lgn/.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "303": {"page_number": 304, "page_information": "Problems for Chapter 11 283\n11-2 Slot-size bound for chaining\nSuppose that we have a hash table with nslots, with collisions resolved by chain-\ning, and suppose that nkeys are inserted into the table. Each key is equally likely\nto be hashed to each slot. Let Mbe the maximum number of keys in any slot after\nall the keys have been inserted. Your mission is to prove an O.lgn=lg lgn/upper\nbound on E \u0152M /c141, the expected value of M.\na.Argue that the probability Qkthat exactly kkeys hash to a particular slot is\ngiven by\nQkD/DC21\nn/DC3k/DC2\n1/NUL1\nn/DC3n/NULk \nn\nk!\n:\nb.LetPkbe the probability that MDk, that is, the probability that the slot\ncontaining the most keys contains kkeys. Show that Pk/DC4nQ k.\nc.Use Stirling\u2019s approximation, equation (3.18), to show that Qk<ek=kk.\nd.Show that there exists a constant c>1 such that Qk0<1 = n3fork0D\nclgn=lg lgn. Conclude that Pk<1 = n2fork/NAKk0Dclgn=lg lgn.\ne.Argue that\nE\u0152M /c141/DC4Pr/SUB\nM>clgn\nlg lgn/ESC\n/SOHnCPr/SUB\nM/DC4clgn\nlg lgn/ESC\n/SOHclgn\nlg lgn:\nConclude that E \u0152M /c141DO.lgn=lg lgn/.\n11-3 Quadratic probing\nSuppose that we are given a key kto search for in a hash table with positions\n0; 1; : : : ; m/NUL1, and suppose that we have a hash function hmapping the key space\ninto the setf0; 1; : : : ; m/NUL1g. The search scheme is as follows:\n1. Compute the value jDh.k/ , and set iD0.\n2. Probe in position jfor the desired key k. If you \ufb01nd it, or if this position is\nempty, terminate the search.\n3. Set iDiC1.I finow equals m, the table is full, so terminate the search.\nOtherwise, set jD.iCj/modm, and return to step 2.\nAssume that mi sap o w e ro f 2.\na.Show that this scheme is an instance of the general \u201cquadratic probing\u201d scheme\nby exhibiting the appropriate constants c1andc2for equation (11.5).\nb.Prove that this algorithm examines every table position in the worst case.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "304": {"page_number": 305, "page_information": "284 Chapter 11 Hash Tables\n11-4 Hashing and authentication\nLetHbe a class of hash functions in which each hash function h2Hmaps the\nuniverse Uof keys tof0; 1; : : : ; m/NUL1g. We say that Hisk-universal if, for every\n\ufb01xed sequence of kdistinct keyshx.1/;x.2/;:::;x.k/iand for any hchosen at\nrandom from H, the sequencehh.x.1//;h.x.2//;: : : ;h.x.k//iis equally likely to be\nany of the mksequences of length kwith elements drawn from f0; 1; : : : ; m/NUL1g.\na.Show that if the family Hof hash functions is 2-universal, then it is universal.\nb.Suppose that the universe Uis the set of n-tuples of values drawn from\nZpDf0; 1; : : : ; p/NUL1g,w h e r e pis prime. Consider an element xD\nhx0;x1;:::;x n/NUL1i2U.F o r a n y n-tuple aDha0;a1;:::;a n/NUL1i2U,d e -\n\ufb01ne the hash function haby\nha.x/D n/NUL1X\njD0ajxj!\nmodp:\nLetHDfhag. Show that His universal, but not 2-universal. ( Hint: Find a key\nfor which all hash functions in Hproduce the same value.)\nc.Suppose that we modify Hslightly from part (b): for any a2Uand for any\nb2Zp,d e \ufb01 n e\nh0\nab.x/D n/NUL1X\njD0ajxjCb!\nmodp\nandH0Dfh0\nabg. Argue that H0is2-universal. ( Hint: Consider \ufb01xed n-tuples\nx2Uandy2U, with xi\u00a4yifor some i. What happens to h0\nab.x/\nandh0\nab.y/asaiandbrange over Zp?)\nd.Suppose that Alice and Bob secretly agree on a hash function hfrom a\n2-universal family Hof hash functions. Each h2Hmaps from a universe of\nkeysUtoZp,w h e r e pis prime. Later, Alice sends a message mto Bob over the\nInternet, where m2U. She authenticates this message to Bob by also sending\nan authentication tag tDh.m/ , and Bob checks that the pair .m; t/ he receives\nindeed satis\ufb01es tDh.m/ . Suppose that an adversary intercepts .m; t/ en route\nand tries to fool Bob by replacing the pair .m; t/ with a different pair .m0;t0/.\nArgue that the probability that the adversary succeeds in fooling Bob into ac-cepting .m\n0;t0/is at most 1=p, no matter how much computing power the ad-\nversary has, and even if the adversary knows the family Hof hash functions\nused.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "305": {"page_number": 306, "page_information": "Notes for Chapter 11 285\nChapter notes\nKnuth [211] and Gonnet [145] are excellent references for the analysis of hash-\ning algorithms. Knuth credits H. P. Luhn (1953) for inventing hash tables, alongwith the chaining method for resolving collisions. At about the same time, G. M.Amdahl originated the idea of open addressing.\nCarter and Wegman introduced the notion of universal classes of hash functions\nin 1979 [58].\nFredman, Koml\u00b4 os, and Szemer\u00b4 edi [112] developed the perfect hashing scheme\nfor static sets presented in Section 11.5. An extension of their method to dynamicsets, handling insertions and deletions in amortized expected time O.1/ , has been\ngiven by Dietzfelbinger et al. [86].", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "306": {"page_number": 307, "page_information": "12 Binary Search Trees\nThe search tree data structure supports many dynamic-set operations, including\nSEARCH ,M INIMUM ,M AXIMUM ,PREDECESSOR ,SUCCESSOR ,INSERT ,a n d\nDELETE . Thus, we can use a search tree both as a dictionary and as a priority\nqueue.\nBasic operations on a binary search tree take time proportional to the height of\nthe tree. For a complete binary tree with nnodes, such operations run in \u201a.lgn/\nworst-case time. If the tree is a linear chain of nnodes, however, the same oper-\nations take \u201a.n/ worst-case time. We shall see in Section 12.4 that the expected\nheight of a randomly built binary search tree is O.lgn/, so that basic dynamic-set\noperations on such a tree take \u201a.lgn/time on average.\nIn practice, we can\u2019t always guarantee that binary search trees are built ran-\ndomly, but we can design variations of binary search trees with good guaranteedworst-case performance on basic operations. Chapter 13 presents one such vari-ation, red-black trees, which have height O.lgn/. Chapter 18 introduces B-trees,\nwhich are particularly good for maintaining databases on secondary (disk) storage.\nAfter presenting the basic properties of binary search trees, the following sec-\ntions show how to walk a binary search tree to print its values in sorted order, howto search for a value in a binary search tree, how to \ufb01nd the minimum or maximumelement, how to \ufb01nd the predecessor or successor of an element, and how to insertinto or delete from a binary search tree. The basic mathematical properties of treesappear in Appendix B.\n12.1 What is a binary search tree?\nA binary search tree is organized, as the name suggests, in a binary tree, as shownin Figure 12.1. We can represent such a tree by a linked data structure in whicheach node is an object. In addition to a keyand satellite data, each node contains\nattributes left,right ,a n d pthat point to the nodes corresponding to its left child,", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "307": {"page_number": 308, "page_information": "12.1 What is a binary search tree? 287\n52 55\n876\n(a)6 8752\n(b)\nFigure 12.1 Binary search trees. For any node x, the keys in the left subtree of xare at most x:key,\nand the keys in the right subtree of xare at least x:key. Different binary search trees can represent\nthe same set of values. The worst-case running time for most search-tree operations is proportional\nto the height of the tree. (a)A binary search tree on 6nodes with height 2.(b)A less ef\ufb01cient binary\nsearch tree with height 4that contains the same keys.\nits right child, and its parent, respectively. If a child or the parent is missing, the\nappropriate attribute contains the value NIL. The root node is the only node in the\nt r e ew h o s ep a r e n ti s NIL.\nThe keys in a binary search tree are always stored in such a way as to satisfy the\nbinary-search-tree property :\nLetxbe a node in a binary search tree. If yis a node in the left subtree\nofx,t h e n y:key/DC4x:key.I fyis a node in the right subtree of x,t h e n\ny:key/NAKx:key.\nThus, in Figure 12.1(a), the key of the root is 6, the keys 2,5,a n d 5in its left\nsubtree are no larger than 6,a n dt h ek e y s 7and8in its right subtree are no smaller\nthan6. The same property holds for every node in the tree. For example, the key 5\nin the root\u2019s left child is no smaller than the key 2in that node\u2019s left subtree and no\nlarger than the key 5in the right subtree.\nThe binary-search-tree property allows us to print out all the keys in a binary\nsearch tree in sorted order by a simple recursive algorithm, called an inorder tree\nwalk . This algorithm is so named because it prints the key of the root of a subtree\nbetween printing the values in its left subtree and printing those in its right subtree.\n(Similarly, a preorder tree walk prints the root before the values in either subtree,\nand a postorder tree walk prints the root after the values in its subtrees.) To use\nthe following procedure to print all the elements in a binary search tree T, we call\nINORDER -TREE-WALK.T:root/.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "308": {"page_number": 309, "page_information": "288 Chapter 12 Binary Search Trees\nINORDER -TREE-WALK.x/\n1ifx\u00a4NIL\n2I NORDER -TREE-WALK.x:left/\n3 print x:key\n4I NORDER -TREE-WALK.x:right/\nAs an example, the inorder tree walk prints the keys in each of the two binary\nsearch trees from Figure 12.1 in the order 2; 5; 5; 6; 7; 8 . The correctness of the\nalgorithm follows by induction directly from the binary-search-tree property.\nIt takes \u201a.n/ t i m et ow a l ka n n-node binary search tree, since after the ini-\ntial call, the procedure calls itself recursively exactly twice for each node in thetree\u2014once for its left child and once for its right child. The following theoremgives a formal proof that it takes linear time to perform an inorder tree walk.\nTheorem 12.1\nIfxis the root of an n-node subtree, then the call I\nNORDER -TREE-WALK.x/\ntakes \u201a.n/ time.\nProof LetT .n/ denote the time taken by I NORDER -TREE-WALK when it is\ncalled on the root of an n-node subtree. Since I NORDER -TREE-WALK visits all n\nnodes of the subtree, we have T .n/D/DEL.n/ . It remains to show that T .n/DO.n/ .\nSince I NORDER -TREE-WALK takes a small, constant amount of time on an\nempty subtree (for the test x\u00a4NIL), we have T. 0 /Dcfor some constant c>0 .\nForn>0 , suppose that I NORDER -TREE-WALK is called on a node xwhose\nleft subtree has knodes and whose right subtree has n/NULk/NUL1nodes. The time to\nperform I NORDER -TREE-WALK.x/is bounded by T .n//DC4T. k/CT. n/NULk/NUL1/Cd\nfor some constant d>0 that re\ufb02ects an upper bound on the time to execute the\nbody of I NORDER -TREE-WALK.x/, exclusive of the time spent in recursive calls.\nWe use the substitution method to show that T .n/DO.n/ by proving that\nT .n//DC4.cCd/nCc.F o r nD0,w eh a v e .cCd//SOH0CcDcDT. 0 / .F o r n>0 ,\nwe have\nT .n//DC4T. k/CT. n/NULk/NUL1/Cd\nD..cCd/kCc/C..cCd/.n/NULk/NUL1/Cc/Cd\nD.cCd/nCc/NUL.cCd/CcCd\nD.cCd/nCc;\nwhich completes the proof.\n", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "309": {"page_number": 310, "page_information": "12.2 Querying a binary search tree 289\nExercises\n12.1-1\nFor the set off1; 4; 5; 10; 16; 17; 21 gof keys, draw binary search trees of heights 2,\n3,4,5,a n d 6.\n12.1-2\nWhat is the difference between the binary-search-tree property and the min-heapproperty (see page 153)? Can the min-heap property be used to print out the keysof an n-node tree in sorted order in O.n/ time? Show how, or explain why not.\n12.1-3\nGive a nonrecursive algorithm that performs an inorder tree walk. ( Hint: An easy\nsolution uses a stack as an auxiliary data structure. A more complicated, but ele-gant, solution uses no stack but assumes that we can test two pointers for equality.)\n12.1-4\nGive recursive algorithms that perform preorder and postorder tree walks in \u201a.n/\ntime on a tree of nnodes.\n12.1-5\nArgue that since sorting nelements takes /DEL.n lgn/time in the worst case in\nthe comparison model, any comparison-based algorithm for constructing a binarysearch tree from an arbitrary list of nelements takes /DEL.n lgn/time in the worst\ncase.\n12.2 Querying a binary search tree\nWe often need to search for a key stored in a binary search tree. Besides the\nSEARCH operation, binary search trees can support such queries as M INIMUM ,\nMAXIMUM ,SUCCESSOR ,a n dP REDECESSOR . In this section, we shall examine\nthese operations and show how to support each one in time O.h/ on any binary\nsearch tree of height h.\nSearching\nWe use the following procedure to search for a node with a given key in a binary\nsearch tree. Given a pointer to the root of the tree and a key k,TREE-SEARCH\nreturns a pointer to a node with key kif one exists; otherwise, it returns NIL.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "310": {"page_number": 311, "page_information": "290 Chapter 12 Binary Search Trees\n2 43\n1376\n17 201815\n9\nFigure 12.2 Queries on a binary search tree. To search for the key 13in the tree, we follow the path\n15!6!7!13from the root. The minimum key in the tree is 2, which is found by following\nleftpointers from the root. The maximum key 20is found by following right pointers from the root.\nThe successor of the node with key 15is the node with key 17, since it is the minimum key in the\nright subtree of 15. The node with key 13has no right subtree, and thus its successor is its lowest\nancestor whose left child is also an ancestor. In this case, the node with key 15is its successor.\nTREE-SEARCH .x; k/\n1ifx==NILork==x:key\n2 return x\n3ifk<x : key\n4 return TREE-SEARCH .x:left;k/\n5else return TREE-SEARCH .x:right;k/\nThe procedure begins its search at the root and traces a simple path downward in\nthe tree, as shown in Figure 12.2. For each node xit encounters, it compares the\nkeykwithx:key. If the two keys are equal, the search terminates. If kis smaller\nthanx:key, the search continues in the left subtree of x, since the binary-search-\ntree property implies that kcould not be stored in the right subtree. Symmetrically,\nifkis larger than x:key, the search continues in the right subtree. The nodes\nencountered during the recursion form a simple path downward from the root of\nthe tree, and thus the running time of T REE-SEARCH isO.h/ ,w h e r e his the height\nof the tree.\nWe can rewrite this procedure in an iterative fashion by \u201cunrolling\u201d the recursion\ninto a while loop. On most computers, the iterative version is more ef\ufb01cient.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "311": {"page_number": 312, "page_information": "12.2 Querying a binary search tree 291\nITERATIVE -TREE-SEARCH .x; k/\n1while x\u00a4NILandk\u00a4x:key\n2 ifk<x : key\n3 xDx:left\n4 elsexDx:right\n5return x\nMinimum and maximum\nWe can always \ufb01nd an element in a binary search tree whose key is a minimum by\nfollowing leftchild pointers from the root until we encounter a NIL,a ss h o w ni n\nFigure 12.2. The following procedure returns a pointer to the minimum element in\nthe subtree rooted at a given node x, which we assume to be non- NIL:\nTREE-MINIMUM .x/\n1while x:left\u00a4NIL\n2 xDx:left\n3return x\nThe binary-search-tree property guarantees that T REE-MINIMUM is correct. If a\nnode xhas no left subtree, then since every key in the right subtree of xis at least as\nlarge as x:key, the minimum key in the subtree rooted at xisx:key. If node xhas\na left subtree, then since no key in the right subtree is smaller than x:keyand every\nkey in the left subtree is not larger than x:key, the minimum key in the subtree\nrooted at xresides in the subtree rooted at x:left.\nThe pseudocode for T REE-MAXIMUM is symmetric:\nTREE-MAXIMUM .x/\n1while x:right\u00a4NIL\n2 xDx:right\n3return x\nBoth of these procedures run in O.h/ time on a tree of height hsince, as in T REE-\nSEARCH , the sequence of nodes encountered forms a simple path downward from\nthe root.\nSuccessor and predecessor\nGiven a node in a binary search tree, sometimes we need to \ufb01nd its successor in\nthe sorted order determined by an inorder tree walk. If all keys are distinct, the", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "312": {"page_number": 313, "page_information": "292 Chapter 12 Binary Search Trees\nsuccessor of a node xis the node with the smallest key greater than x:key.T h e\nstructure of a binary search tree allows us to determine the successor of a nodewithout ever comparing keys. The following procedure returns the successor of anode xin a binary search tree if it exists, and\nNILifxhas the largest key in the\ntree:\nTREE-SUCCESSOR .x/\n1ifx:right\u00a4NIL\n2 return TREE-MINIMUM .x:right/\n3yDx:p\n4while y\u00a4NILandx==y:right\n5 xDy\n6 yDy:p\n7return y\nWe break the code for T REE-SUCCESSOR into two cases. If the right subtree\nof node xis nonempty, then the successor of xis just the leftmost node in x\u2019s\nright subtree, which we \ufb01nd in line 2 by calling T REE-MINIMUM .x:right/.F o r\nexample, the successor of the node with key 15in Figure 12.2 is the node with\nkey17.\nOn the other hand, as Exercise 12.2-6 asks you to show, if the right subtree of\nnode xis empty and xhas a successor y,t h e n yis the lowest ancestor of xwhose\nleft child is also an ancestor of x. In Figure 12.2, the successor of the node with\nkey13is the node with key 15.T o\ufb01 n d y, we simply go up the tree from xuntil we\nencounter a node that is the left child of its parent; lines 3\u20137 of T REE-SUCCESSOR\nhandle this case.\nThe running time of T REE-SUCCESSOR on a tree of height hisO.h/ ,s i n c ew e\neither follow a simple path up the tree or follow a simple path down the tree. Theprocedure T\nREE-PREDECESSOR , which is symmetric to T REE-SUCCESSOR ,a l s o\nruns in time O.h/ .\nEven if keys are not distinct, we de\ufb01ne the successor and predecessor of any\nnode xas the node returned by calls made to T REE-SUCCESSOR .x/and T REE-\nPREDECESSOR .x/, respectively.\nIn summary, we have proved the following theorem.\nTheorem 12.2\nWe can implement the dynamic-set operations S EARCH ,M INIMUM ,M AXIMUM ,\nSUCCESSOR ,a n dP REDECESSOR so that each one runs in O.h/ time on a binary\nsearch tree of height h.\n", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "313": {"page_number": 314, "page_information": "12.2 Querying a binary search tree 293\nExercises\n12.2-1\nSuppose that we have numbers between 1 and 1000 in a binary search tree, and wewant to search for the number 363. Which of the following sequences could notbe\nthe sequence of nodes examined?\na.2, 252, 401, 398, 330, 344, 397, 363.\nb.924, 220, 911, 244, 898, 258, 362, 363.\nc.925, 202, 911, 240, 912, 245, 363.\nd.2, 399, 387, 219, 266, 382, 381, 278, 363.\ne.935, 278, 347, 621, 299, 392, 358, 363.\n12.2-2\nWrite recursive versions of T\nREE-MINIMUM and T REE-MAXIMUM .\n12.2-3\nWrite the T REE-PREDECESSOR procedure.\n12.2-4\nProfessor Bunyan thinks he has discovered a remarkable property of binary searchtrees. Suppose that the search for key kin a binary search tree ends up in a leaf.\nConsider three sets: A, the keys to the left of the search path; B, the keys on the\nsearch path; and C, the keys to the right of the search path. Professor Bunyan\nclaims that any three keys a2A,b2B,a n d c2Cmust satisfy a/DC4b/DC4c.G i v e\na smallest possible counterexample to the professor\u2019s claim.\n12.2-5\nShow that if a node in a binary search tree has two children, then its successor hasno left child and its predecessor has no right child.\n12.2-6\nConsider a binary search tree Twhose keys are distinct. Show that if the right\nsubtree of a node xinTis empty and xhas a successor y,t h e n yis the lowest\nancestor of xwhose left child is also an ancestor of x. (Recall that every node is\nits own ancestor.)\n12.2-7\nAn alternative method of performing an inorder tree walk of an n-node binary\nsearch tree \ufb01nds the minimum element in the tree by calling T\nREE-MINIMUM and\nthen making n/NUL1calls to T REE-SUCCESSOR . Prove that this algorithm runs\nin\u201a.n/ time.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "314": {"page_number": 315, "page_information": "294 Chapter 12 Binary Search Trees\n12.2-8\nProve that no matter what node we start at in a height- hbinary search tree, k\nsuccessive calls to T REE-SUCCESSOR takeO.kCh/time.\n12.2-9\nLetTbe a binary search tree whose keys are distinct, let xbe a leaf node, and let y\nbe its parent. Show that y:keyis either the smallest key in Tlarger than x:keyor\nthe largest key in Tsmaller than x:key.\n12.3 Insertion and deletion\nThe operations of insertion and deletion cause the dynamic set represented by a\nbinary search tree to change. The data structure must be modi\ufb01ed to re\ufb02ect thischange, but in such a way that the binary-search-tree property continues to hold.As we shall see, modifying the tree to insert a new element is relatively straight-forward, but handling deletion is somewhat more intricate.\nInsertion\nTo insert a new value /ETBinto a binary search tree T, we use the procedure T\nREE-\nINSERT . The procedure takes a node \u00b4for which \u00b4:keyD/ETB,\u00b4:leftDNIL,\nand\u00b4:rightDNIL. It modi\ufb01es Tand some of the attributes of \u00b4in such a way that\nit inserts \u00b4into an appropriate position in the tree.\nTREE-INSERT .T; \u00b4/\n1yDNIL\n2xDT:root\n3while x\u00a4NIL\n4 yDx\n5 if\u00b4:key<x : key\n6 xDx:left\n7 elsexDx:right\n8\u00b4:pDy\n9ify==NIL\n10 T:rootD\u00b4 //treeTwas empty\n11elseif \u00b4:key<y : key\n12 y:leftD\u00b4\n13elsey:rightD\u00b4", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "315": {"page_number": 316, "page_information": "12.3 Insertion and deletion 295\n2 95\n13 1715 191812\nFigure 12.3 Inserting an item with key 13into a binary search tree. Lightly shaded nodes indicate\nthe simple path from the root down to the position where the item is inserted. The dashed lineindicates the link in the tree that is added to insert the item.\nFigure 12.3 shows how T REE-INSERT works. Just like the procedures T REE-\nSEARCH and I TERATIVE -TREE-SEARCH ,TREE-INSERT begins at the root of the\ntree and the pointer xtraces a simple path downward looking for a NILto replace\nwith the input item \u00b4. The procedure maintains the trailing pointer yas the parent\nofx. After initialization, the while loop in lines 3\u20137 causes these two pointers\nto move down the tree, going left or right depending on the comparison of \u00b4:key\nwithx:key, until xbecomes NIL.T h i s NILoccupies the position where we wish to\nplace the input item \u00b4. We need the trailing pointer y, because by the time we \ufb01nd\nthe NILwhere \u00b4belongs, the search has proceeded one step beyond the node that\nneeds to be changed. Lines 8\u201313 set the pointers that cause \u00b4to be inserted.\nLike the other primitive operations on search trees, the procedure T REE-INSERT\nruns in O.h/ time on a tree of height h.\nDeletion\nThe overall strategy for deleting a node \u00b4from a binary search tree Thas three\nbasic cases but, as we shall see, one of the cases is a bit tricky.\n/SIIf\u00b4has no children, then we simply remove it by modifying its parent to re-\nplace \u00b4with NILas its child.\n/SIIf\u00b4has just one child, then we elevate that child to take \u00b4\u2019s position in the tree\nby modifying \u00b4\u2019s parent to replace \u00b4by\u00b4\u2019s child.\n/SIIf\u00b4has two children, then we \ufb01nd \u00b4\u2019s successor y\u2014which must be in \u00b4\u2019s right\nsubtree\u2014and have ytake\u00b4\u2019s position in the tree. The rest of \u00b4\u2019s original right\nsubtree becomes y\u2019s new right subtree, and \u00b4\u2019s left subtree becomes y\u2019s new\nleft subtree. This case is the tricky one because, as we shall see, it matterswhether yis\u00b4\u2019s right child.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "316": {"page_number": 317, "page_information": "296 Chapter 12 Binary Search Trees\nThe procedure for deleting a given node \u00b4from a binary search tree Ttakes as\narguments pointers to Tand\u00b4. It organizes its cases a bit differently from the three\ncases outlined previously by considering the four cases shown in Figure 12.4.\n/SIIf\u00b4has no left child (part (a) of the \ufb01gure), then we replace \u00b4by its right child,\nwhich may or may not be NIL.W h e n \u00b4\u2019s right child is NIL, this case deals with\nthe situation in which \u00b4has no children. When \u00b4\u2019s right child is non- NIL,t h i s\ncase handles the situation in which \u00b4has just one child, which is its right child.\n/SIIf\u00b4has just one child, which is its left child (part (b) of the \ufb01gure), then we\nreplace \u00b4by its left child.\n/SIOtherwise, \u00b4has both a left and a right child. We \ufb01nd \u00b4\u2019s successor y,w h i c h\nlies in \u00b4\u2019s right subtree and has no left child (see Exercise 12.2-5). We want to\nsplice yout of its current location and have it replace \u00b4in the tree.\n/SIIfyis\u00b4\u2019s right child (part (c)), then we replace \u00b4byy, leaving y\u2019s right\nchild alone.\n/SIOtherwise, ylies within \u00b4\u2019s right subtree but is not \u00b4\u2019s right child (part (d)).\nIn this case, we \ufb01rst replace yby its own right child, and then we replace \u00b4\nbyy.\nIn order to move subtrees around within the binary search tree, we de\ufb01ne a\nsubroutine T RANSPLANT , which replaces one subtree as a child of its parent with\nanother subtree. When T RANSPLANT replaces the subtree rooted at node uwith\nthe subtree rooted at node /ETB, node u\u2019s parent becomes node /ETB\u2019s parent, and u\u2019s\nparent ends up having /ETBas its appropriate child.\nTRANSPLANT . T;u ;/ETB/\n1ifu:p==NIL\n2 T:rootD/ETB\n3elseif u==u:p:left\n4 u:p:leftD/ETB\n5elseu:p:rightD/ETB\n6if/ETB\u00a4NIL\n7 /ETB:pDu:p\nLines 1\u20132 handle the case in which uis the root of T. Otherwise, uis either a left\nchild or a right child of its parent. Lines 3\u20134 take care of updating u:p:leftifu\nis a left child, and line 5 updates u:p:right ifuis a right child. We allow /ETBto be\nNIL, and lines 6\u20137 update /ETB:pif/ETBis non- NIL. Note that T RANSPLANT does not\nattempt to update /ETB:leftand/ETB:right ; doing so, or not doing so, is the responsibility\nof T RANSPLANT \u2019s caller.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "317": {"page_number": 318, "page_information": "12.3 Insertion and deletion 297\nq q\nz (a) r\nq q\nz\nl(b)\nq\nz\nl(c)q\ny\nl y\nq\nz\nl(d)\nrq\nz\nl ryq\nl ryr\nl\nx\nx\nx y\nxx\nNILNILNILNILNIL\nFigure 12.4 Deleting a node \u00b4from a binary search tree. Node \u00b4may be the root, a left child of\nnode q, or a right child of q.(a)Node \u00b4has no left child. We replace \u00b4by its right child r,w h i c h\nmay or may not be NIL.(b)Node \u00b4has a left child lbut no right child. We replace \u00b4byl.(c)Node \u00b4\nhas two children; its left child is node l, its right child is its successor y,a n d y\u2019s right child is node x.\nWe replace \u00b4byy, updating y\u2019s left child to become l,b u tl e a v i n g xasy\u2019s right child. (d)Node \u00b4\nhas two children (left child land right child r), and its successor y\u00a4rlies within the subtree rooted\natr. We replace yby its own right child x,a n dw es e t yto be r\u2019s parent. Then, we set yto be q\u2019s\nchild and the parent of l.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "318": {"page_number": 319, "page_information": "298 Chapter 12 Binary Search Trees\nWith the T RANSPLANT procedure in hand, here is the procedure that deletes\nnode \u00b4from binary search tree T:\nTREE-DELETE .T; \u00b4/\n1if\u00b4:left==NIL\n2T RANSPLANT . T;\u00b4 ;\u00b4 : right/\n3elseif \u00b4:right ==NIL\n4T RANSPLANT . T;\u00b4 ;\u00b4 : left/\n5elseyDTREE-MINIMUM .\u00b4:right/\n6 ify:p\u00a4\u00b4\n7T RANSPLANT . T;y;y: right/\n8 y:rightD\u00b4:right\n9 y:right:pDy\n10 T RANSPLANT . T;\u00b4 ;y/\n11 y:leftD\u00b4:left\n12 y:left:pDy\nThe T REE-DELETE procedure executes the four cases as follows. Lines 1\u20132\nhandle the case in which node \u00b4has no left child, and lines 3\u20134 handle the case in\nwhich \u00b4has a left child but no right child. Lines 5\u201312 deal with the remaining two\ncases, in which \u00b4has two children. Line 5 \ufb01nds node y, which is the successor\nof\u00b4. Because \u00b4has a nonempty right subtree, its successor must be the node in\nthat subtree with the smallest key; hence the call to T REE-MINIMUM .\u00b4:right/.A s\nwe noted before, yhas no left child. We want to splice yout of its current location,\nand it should replace \u00b4in the tree. If yis\u00b4\u2019s right child, then lines 10\u201312 replace \u00b4\nas a child of its parent by yand replace y\u2019s left child by \u00b4\u2019s left child. If yis\nnot\u00b4\u2019s left child, lines 7\u20139 replace yas a child of its parent by y\u2019s right child and\nturn\u00b4\u2019s right child into y\u2019s right child, and then lines 10\u201312 replace \u00b4as a child of\nits parent by yand replace y\u2019s left child by \u00b4\u2019s left child.\nEach line of T REE-DELETE , including the calls to T RANSPLANT , takes constant\ntime, except for the call to T REE-MINIMUM in line 5. Thus, T REE-DELETE runs\ninO.h/ time on a tree of height h.\nIn summary, we have proved the following theorem.\nTheorem 12.3\nWe can implement the dynamic-set operations I NSERT and D ELETE so that each\none runs in O.h/ time on a binary search tree of height h.\n", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "319": {"page_number": 320, "page_information": "12.4 Randomly built binary search trees 299\nExercises\n12.3-1\nGive a recursive version of the T REE-INSERT procedure.\n12.3-2\nSuppose that we construct a binary search tree by repeatedly inserting distinct val-\nues into the tree. Argue that the number of nodes examined in searching for avalue in the tree is one plus the number of nodes examined when the value was\ufb01rst inserted into the tree.\n12.3-3\nWe can sort a given set of nnumbers by \ufb01rst building a binary search tree contain-\ning these numbers (using T\nREE-INSERT repeatedly to insert the numbers one by\none) and then printing the numbers by an inorder tree walk. What are the worst-case and best-case running times for this sorting algorithm?\n12.3-4\nIs the operation of deletion \u201ccommutative\u201d in the sense that deleting xand then y\nfrom a binary search tree leaves the same tree as deleting yand then x? Argue why\nit is or give a counterexample.\n12.3-5\nSuppose that instead of each node xkeeping the attribute x:p, pointing to x\u2019s\nparent, it keeps x:succ, pointing to x\u2019s successor. Give pseudocode for S\nEARCH ,\nINSERT ,a n dD ELETE on a binary search tree Tusing this representation. These\nprocedures should operate in time O.h/ ,w h e r e his the height of the tree T.(Hint:\nYou may wish to implement a subroutine that returns the parent of a node.)\n12.3-6\nWhen node \u00b4in T REE-DELETE has two children, we could choose node yas\nits predecessor rather than its successor. What other changes to T REE-DELETE\nwould be necessary if we did so? Some have argued that a fair strategy, givingequal priority to predecessor and successor, yields better empirical performance.How might T\nREE-DELETE be changed to implement such a fair strategy?\n?12.4 Randomly built binary search trees\nWe have shown that each of the basic operations on a binary search tree runsinO.h/ time, where his the height of the tree. The height of a binary search", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "320": {"page_number": 321, "page_information": "300 Chapter 12 Binary Search Trees\ntree varies, however, as items are inserted and deleted. If, for example, the nitems\nare inserted in strictly increasing order, the tree will be a chain with height n/NUL1.\nOn the other hand, Exercise B.5-4 shows that h/NAKblgnc. As with quicksort, we\ncan show that the behavior of the average case is much closer to the best case thanto the worst case.\nUnfortunately, little is known about the average height of a binary search tree\nwhen both insertion and deletion are used to create it. When the tree is createdby insertion alone, the analysis becomes more tractable. Let us therefore de\ufb01ne a\nrandomly built binary search tree onnkeys as one that arises from inserting the\nkeys in random order into an initially empty tree, where each of the n\u0160permutations\nof the input keys is equally likely. (Exercise 12.4-3 asks you to show that this notionis different from assuming that every binary search tree on nkeys is equally likely.)\nIn this section, we shall prove the following theorem.\nTheorem 12.4\nThe expected height of a randomly built binary search tree on ndistinct keys is\nO.lgn/.\nProof We start by de\ufb01ning three random variables that help measure the height\nof a randomly built binary search tree. We denote the height of a randomly built\nbinary search on nkeys by X\nn, and we de\ufb01ne the exponential height YnD2Xn.\nWhen we build a binary search tree on nkeys, we choose one key as that of the\nroot, and we let Rndenote the random variable that holds this key\u2019s rank within\nthe set of nkeys; that is, Rnholds the position that this key would occupy if the\nset of keys were sorted. The value of Rnis equally likely to be any element of the\nsetf1 ;2;:::;ng.I fRnDi, then the left subtree of the root is a randomly built\nbinary search tree on i/NUL1keys, and the right subtree is a randomly built binary\nsearch tree on n/NULikeys. Because the height of a binary tree is 1more than the\nlarger of the heights of the two subtrees of the root, the exponential height of abinary tree is twice the larger of the exponential heights of the two subtrees of theroot. If we know that R\nnDi, it follows that\nYnD2/SOHmax.Yi/NUL1;Yn/NULi/:\nAs base cases, we have that Y1D1, because the exponential height of a tree with 1\nnode is 20D1and, for convenience, we de\ufb01ne Y0D0.\nNext, de\ufb01ne indicator random variables Zn;1;Zn;2;:::;Z n;n,w h e r e\nZn;iDIfRnDig:\nBecause Rnis equally likely to be any element of f1 ;2;:::;ng, it follows that\nPrfRnDigD1=nforiD1 ;2;:::;n , and hence, by Lemma 5.1, we have\nE\u0152Zn;i/c141D1=n ; (12.1)", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "321": {"page_number": 322, "page_information": "12.4 Randomly built binary search trees 301\nforiD1 ;2;:::;n . Because exactly one value of Zn;iis1and all others are 0,w e\nalso have\nYnDnX\niD1Zn;i.2/SOHmax.Yi/NUL1;Yn/NULi// :\nWe shall show that E \u0152Yn/c141is polynomial in n, which will ultimately imply that\nE\u0152Xn/c141DO.lgn/.\nWe claim that the indicator random variable Zn;iDIfRnDigis independent\nof the values of Yi/NUL1andYn/NULi. Having chosen RnDi, the left subtree (whose\nexponential height is Yi/NUL1) is randomly built on the i/NUL1keys whose ranks are\nless than i. This subtree is just like any other randomly built binary search tree\noni/NUL1keys. Other than the number of keys it contains, this subtree\u2019s structure\nis not affected at all by the choice of RnDi, and hence the random variables\nYi/NUL1andZn;iare independent. Likewise, the right subtree, whose exponential\nheight is Yn/NULi, is randomly built on the n/NULikeys whose ranks are greater than i.\nIts structure is independent of the value of Rn, and so the random variables Yn/NULi\nandZn;iare independent. Hence, we have\nE\u0152Yn/c141DE\"nX\niD1Zn;i.2/SOHmax.Yi/NUL1;Yn/NULi//#\nDnX\niD1E\u0152Zn;i.2/SOHmax.Yi/NUL1;Yn/NULi///c141 (by linearity of expectation)\nDnX\niD1E\u0152Zn;i/c141E\u01522/SOHmax.Yi/NUL1;Yn/NULi//c141(by independence)\nDnX\niD11\nn/SOHE\u01522/SOHmax.Yi/NUL1;Yn/NULi//c141 (by equation (12.1))\nD2\nnnX\niD1E\u0152max.Yi/NUL1;Yn/NULi//c141 (by equation (C.22))\n/DC42\nnnX\niD1.E\u0152Yi/NUL1/c141CE\u0152Yn/NULi/c141/ (by Exercise C.3-4) .\nSince each term E \u0152Y0/c141;E\u0152Y1/c141;:::; E\u0152Yn/NUL1/c141appears twice in the last summation,\no n c ea sE \u0152Yi/NUL1/c141and once as E \u0152Yn/NULi/c141, we have the recurrence\nE\u0152Yn/c141/DC44\nnn/NUL1X\niD0E\u0152Yi/c141: (12.2)", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "322": {"page_number": 323, "page_information": "302 Chapter 12 Binary Search Trees\nUsing the substitution method, we shall show that for all positive integers n,t h e\nrecurrence (12.2) has the solution\nE\u0152Yn/c141/DC41\n4 \nnC3\n3!\n:\nIn doing so, we shall use the identity\nn/NUL1X\niD0 \niC3\n3!\nD \nnC3\n4!\n: (12.3)\n(Exercise 12.4-1 asks you to prove this identity.)\nFor the base cases, we note that the bounds 0DY0DE\u0152Y0/c141/DC4.1=4//NUL3\n3/SOH\nD1=4\nand1DY1DE\u0152Y1/c141/DC4.1=4//NUL1C3\n3/SOH\nD1hold. For the inductive case, we have that\nE\u0152Yn/c141/DC44\nnn/NUL1X\niD0E\u0152Yi/c141\n/DC44\nnn/NUL1X\niD01\n4 \niC3\n3!\n(by the inductive hypothesis)\nD1\nnn/NUL1X\niD0 \niC3\n3!\nD1\nn \nnC3\n4!\n(by equation (12.3))\nD1\nn/SOH.nC3/\u0160\n4\u0160 .n/NUL1/\u0160\nD1\n4/SOH.nC3/\u0160\n3\u0160 n\u0160\nD1\n4 \nnC3\n3!\n:\nWe have bounded E \u0152Yn/c141, but our ultimate goal is to bound E \u0152Xn/c141.A s E x e r -\ncise 12.4-4 asks you to show, the function f. x/D2xis convex (see page 1199).\nTherefore, we can employ Jensen\u2019s inequality (C.26), which says that\n2E\u0152Xn/c141/DC4E/STX\n2Xn/ETX\nDE\u0152Yn/c141;\nas follows:\n2E\u0152Xn/c141/DC41\n4 \nnC3\n3!", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "323": {"page_number": 324, "page_information": "Problems for Chapter 12 303\nD1\n4/SOH.nC3/.nC2/.nC1/\n6\nDn3C6n2C11nC6\n24:\nTaking logarithms of both sides gives E \u0152Xn/c141DO.lgn/.\nExercises\n12.4-1\nProve equation (12.3).\n12.4-2\nDescribe a binary search tree on nnodes such that the average depth of a node in\nthe tree is \u201a.lgn/but the height of the tree is !.lgn/. Give an asymptotic upper\nbound on the height of an n-node binary search tree in which the average depth of\na node is \u201a.lgn/.\n12.4-3\nShow that the notion of a randomly chosen binary search tree on nkeys, where\neach binary search tree of nkeys is equally likely to be chosen, is different from\nthe notion of a randomly built binary search tree given in this section. ( Hint: List\nthe possibilities when nD3.)\n12.4-4\nShow that the function f. x/D2xis convex.\n12.4-5 ?\nConsider R ANDOMIZED -QUICKSORT operating on a sequence of ndistinct input\nnumbers. Prove that for any constant k>0 ,a l lb u t O.1=nk/of the n\u0160input\npermutations yield an O.n lgn/running time.\nProblems\n12-1 Binary search trees with equal keys\nEqual keys pose a problem for the implementation of binary search trees.\na.What is the asymptotic performance of T REE-INSERT when used to insert n\nitems with identical keys into an initially empty binary search tree?\nWe propose to improve T REE-INSERT by testing before line 5 to determine whether\n\u00b4:keyDx:keyand by testing before line 11 to determine whether \u00b4:keyDy:key.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "324": {"page_number": 325, "page_information": "304 Chapter 12 Binary Search Trees\nIf equality holds, we implement one of the following strategies. For each strategy,\n\ufb01nd the asymptotic performance of inserting nitems with identical keys into an\ninitially empty binary search tree. (The strategies are described for line 5, in whichwe compare the keys of \u00b4andx. Substitute yforxto arrive at the strategies for\nline 11.)\nb.Keep a boolean \ufb02ag x:bat node x, and set xto either x:leftorx:right based\non the value of x:b, which alternates between\nFALSE and TRUE each time we\nvisitxwhile inserting a node with the same key as x.\nc.Keep a list of nodes with equal keys at x, and insert \u00b4into the list.\nd.Randomly set xto either x:leftorx:right . (Give the worst-case performance\nand informally derive the expected running time.)\n12-2 Radix trees\nGiven two strings aDa0a1:::a pandbDb0b1:::b q, where each aiand each bj\nis in some ordered set of characters, we say that string aislexicographically less\nthan string bif either\n1. there exists an integer j,w h e r e 0/DC4j/DC4min.p; q/ , such that aiDbifor all\niD0; 1; : : : ; j/NUL1andaj<b j,o r\n2.p<q andaiDbifor all iD0; 1; : : : ; p .\nFor example, if aandbare bit strings, then 10100 < 10110 by rule 1 (letting\njD3)a n d 10100 < 101000 by rule 2. This ordering is similar to that used in\nEnglish-language dictionaries.\nTheradix tree data structure shown in Figure 12.5 stores the bit strings 1011,\n10, 011, 100, and 0. When searching for a key aDa0a1:::a p,w eg ol e f ta ta\nnode of depth iifaiD0and right if aiD1.L e t Sbe a set of distinct bit strings\nwhose lengths sum to n. Show how to use a radix tree to sort Slexicographically\nin\u201a.n/ time. For the example in Figure 12.5, the output of the sort should be the\nsequence 0, 011, 10, 100, 1011.\n12-3 Average node depth in a randomly built binary search tree\nIn this problem, we prove that the average depth of a node in a randomly built\nbinary search tree with nnodes is O.lgn/. Although this result is weaker than\nthat of Theorem 12.4, the technique we shall use reveals a surprising similarity\nbetween the building of a binary search tree and the execution of R ANDOMIZED -\nQUICKSORT from Section 7.3.\nWe de\ufb01ne the total path length P.T/ of a binary tree Tas the sum, over all\nnodes xinT, of the depth of node x, which we denote by d.x;T/ .", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "325": {"page_number": 326, "page_information": "Problems for Chapter 12 305\n0110\n10010\n101101\n10\n10 1\n1\nFigure 12.5 A radix tree storing the bit strings 1011, 10, 011, 100, and 0. We can determine each\nnode\u2019s key by traversing the simple path from the root to that node. There is no need, therefore, to\nstore the keys in the nodes; the keys appear here for illustrative purposes only. Nodes are heavily\nshaded if the keys corresponding to them are not in the tree; such nodes are present only to establisha path to other nodes.\na.Argue that the average depth of a node in Tis\n1\nnX\nx2Td.x;T/D1\nnP.T/:\nThus, we wish to show that the expected value of P.T/ isO.n lgn/.\nb.LetTLandTRdenote the left and right subtrees of tree T, respectively. Argue\nthat if Thasnnodes, then\nP.T/DP.T L/CP.T R/Cn/NUL1:\nc.LetP.n/ denote the average total path length of a randomly built binary search\ntree with nnodes. Show that\nP.n/D1\nnn/NUL1X\niD0.P.i/CP.n/NULi/NUL1/Cn/NUL1/ :\nd.Show how to rewrite P.n/ as\nP.n/D2\nnn/NUL1X\nkD1P.k/C\u201a.n/ :\ne.Recalling the alternative analysis of the randomized version of quicksort given\nin Problem 7-3, conclude that P.n/DO.n lgn/.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "326": {"page_number": 327, "page_information": "306 Chapter 12 Binary Search Trees\nAt each recursive invocation of quicksort, we choose a random pivot element to\npartition the set of elements being sorted. Each node of a binary search tree parti-tions the set of elements that fall into the subtree rooted at that node.\nf.Describe an implementation of quicksort in which the comparisons to sort a set\nof elements are exactly the same as the comparisons to insert the elements intoa binary search tree. (The order in which comparisons are made may differ, butthe same comparisons must occur.)\n12-4 Number of different binary trees\nLetb\nndenote the number of different binary trees with nnodes. In this problem,\nyou will \ufb01nd a formula for bn, as well as an asymptotic estimate.\na.Show that b0D1and that, for n/NAK1,\nbnDn/NUL1X\nkD0bkbn/NUL1/NULk:\nb.Referring to Problem 4-4 for the de\ufb01nition of a generating function, let B.x/\nbe the generating function\nB.x/D1X\nnD0bnxn:\nShow that B.x/DxB.x/2C1, and hence one way to express B.x/ in closed\nform is\nB.x/D1\n2x/NUL\n1/NULp\n1/NUL4x/SOH\n:\nTheTaylor expansion off. x/ around the point xDais given by\nf. x/D1X\nkD0f.k/.a/\nk\u0160.x/NULa/k;\nwhere f.k/.x/is the kth derivative of fevaluated at x.\nc.Show that\nbnD1\nnC1 \n2n\nn!", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "327": {"page_number": 328, "page_information": "Notes for Chapter 12 307\n(thenthCatalan number ) by using the Taylor expansion ofp\n1/NUL4xaround\nxD0. (If you wish, instead of using the Taylor expansion, you may use\nthe generalization of the binomial expansion (C.4) to nonintegral exponents n,\nwhere for any real number nand for any integer k, we interpret/NULn\nk/SOH\nto be\nn.n/NUL1//SOH/SOH/SOH.n/NULkC1/=k\u0160 ifk/NAK0,a n d 0otherwise.)\nd.Show that\nbnD4n\np\n/EMn3=2.1CO.1=n// :\nChapter notes\nKnuth [211] contains a good discussion of simple binary search trees as well as\nmany variations. Binary search trees seem to have been independently discoveredby a number of people in the late 1950s. Radix trees are often called \u201ctries,\u201d whichcomes from the middle letters in the word retrieval . Knuth [211] also discusses\nthem.\nMany texts, including the \ufb01rst two editions of this book, have a somewhat sim-\npler method of deleting a node from a binary search tree when both of its children\nare present. Instead of replacing node \u00b4by its successor y, we delete node ybut\ncopy its key and satellite data into node \u00b4. The downside of this approach is that\nthe node actually deleted might not be the node passed to the delete procedure. Ifother components of a program maintain pointers to nodes in the tree, they couldmistakenly end up with \u201cstale\u201d pointers to nodes that have been deleted. Althoughthe deletion method presented in this edition of this book is a bit more complicated,it guarantees that a call to delete node \u00b4deletes node \u00b4and only node \u00b4.\nSection 15.5 will show how to construct an optimal binary search tree when\nwe know the search frequencies before constructing the tree. That is, given the\nfrequencies of searching for each key and the frequencies of searching for values\nthat fall between keys in the tree, we construct a binary search tree for which a\nset of searches that follows these frequencies examines the minimum number of\nnodes.\nThe proof in Section 12.4 that bounds the expected height of a randomly built\nbinary search tree is due to Aslam [24]. Mart\u00b4 \u0131nez and Roura [243] give randomized\nalgorithms for insertion into and deletion from binary search trees in which theresult of either operation is a random binary search tree. Their de\ufb01nition of arandom binary search tree differs\u2014only slightly\u2014from that of a randomly builtbinary search tree in this chapter, however.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "328": {"page_number": 329, "page_information": "13 Red-Black Trees\nChapter 12 showed that a binary search tree of height hcan support any of the basic\ndynamic-set operations\u2014such as S EARCH ,PREDECESSOR ,SUCCESSOR ,M INI-\nMUM ,MAXIMUM ,INSERT ,a n dD ELETE \u2014inO.h/ time. Thus, the set operations\nare fast if the height of the search tree is small. If its height is large, however, theset operations may run no faster than with a linked list. Red-black trees are oneof many search-tree schemes that are \u201cbalanced\u201d in order to guarantee that basicdynamic-set operations take O.lgn/time in the worst case.\n13.1 Properties of red-black trees\nAred-black tree is a binary search tree with one extra bit of storage per node: its\ncolor , which can be either RED orBLACK . By constraining the node colors on any\nsimple path from the root to a leaf, red-black trees ensure that no such path is morethan twice as long as any other, so that the tree is approximately balanced .\nEach node of the tree now contains the attributes color ,key,left,right ,a n d p.I f\na child or the parent of a node does not exist, the corresponding pointer attributeof the node contains the value\nNIL. We shall regard these NILs as being pointers to\nleaves (external nodes) of the binary search tree and the normal, key-bearing nodesas being internal nodes of the tree.\nA red-black tree is a binary tree that satis\ufb01es the following red-black properties :\n1. Every node is either red or black.\n2. The root is black.\n3. Every leaf (\nNIL) is black.\n4. If a node is red, then both its children are black.\n5. For each node, all simple paths from the node to descendant leaves contain the\nsame number of black nodes.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "329": {"page_number": 330, "page_information": "13.1 Properties of red-black trees 309\nFigure 13.1(a) shows an example of a red-black tree.\nAs a matter of convenience in dealing with boundary conditions in red-black\ntree code, we use a single sentinel to represent NIL(see page 238). For a red-black\ntreeT, the sentinel T:nilis an object with the same attributes as an ordinary node\nin the tree. Its color attribute is BLACK , and its other attributes\u2014 p,left,right ,\nandkey\u2014can take on arbitrary values. As Figure 13.1(b) shows, all pointers to NIL\nare replaced by pointers to the sentinel T:nil.\nWe use the sentinel so that we can treat a NILchild of a node xas an ordinary\nnode whose parent is x. Although we instead could add a distinct sentinel node\nfor each NILin the tree, so that the parent of each NILis well de\ufb01ned, that ap-\nproach would waste space. Instead, we use the one sentinel T:nilto represent all\ntheNILs\u2014all leaves and the root\u2019s parent. The values of the attributes p,left,right ,\nandkeyof the sentinel are immaterial, although we may set them during the course\nof a procedure for our convenience.\nWe generally con\ufb01ne our interest to the internal nodes of a red-black tree, since\nthey hold the key values. In the remainder of this chapter, we omit the leaves when\nwe draw red-black trees, as shown in Figure 13.1(c).\nWe call the number of black nodes on any simple path from, but not including, a\nnode xdown to a leaf the black-height of the node, denoted bh .x/. By property 5,\nthe notion of black-height is well de\ufb01ned, since all descending simple paths fromthe node have the same number of black nodes. We de\ufb01ne the black-height of ared-black tree to be the black-height of its root.\nThe following lemma shows why red-black trees make good search trees.\nLemma 13.1\nA red-black tree with ninternal nodes has height at most 2lg.nC1/.\nProof We start by showing that the subtree rooted at any node xcontains at least\n2\nbh.x//NUL1internal nodes. We prove this claim by induction on the height of x.I f\nthe height of xis0,t h e n xmust be a leaf ( T:nil), and the subtree rooted at xindeed\ncontains at least 2bh.x//NUL1D20/NUL1D0internal nodes. For the inductive step,\nconsider a node xthat has positive height and is an internal node with two children.\nEach child has a black-height of either bh .x/or bh.x//NUL1, depending on whether\nits color is red or black, respectively. Since the height of a child of xis less than\nthe height of xitself, we can apply the inductive hypothesis to conclude that each\nchild has at least 2bh.x//NUL1/NUL1internal nodes. Thus, the subtree rooted at xcontains\nat least .2bh.x//NUL1/NUL1/C.2bh.x//NUL1/NUL1/C1D2bh.x//NUL1internal nodes, which proves\nthe claim.\nTo complete the proof of the lemma, let hbe the height of the tree. According\nto property 4, at least half the nodes on any simple path from the root to a leaf, not", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "330": {"page_number": 331, "page_information": "310 Chapter 13 Red-Black Trees\nNIL NILNIL NIL NIL NIL NILNIL NIL\nNIL NILNIL NIL NIL NIL\nNIL NIL NIL NILNIL NIL26\n41\n47 30\n28 38\n35 3917\n21\n23 19\n2014\n16\n1510\n12 7\n3 1112\n112\n11123\n111 12123\n(a)\n26\n41\n47 30\n28 38\n35 3917\n21\n23 19\n2014\n16\n1510\n12 7\n3\n(b)\n26\n41\n47 30\n28 38\n35 3917\n21\n23 19\n2014\n16\n1510\n12 7\n3(c)T:nil\nFigure 13.1 A red-black tree with black nodes darkened and red nodes shaded. Every node in a\nred-black tree is either red or black, the children of a red node are both black, and every simple pathfrom a node to a descendant leaf contains the same number of black nodes. (a)Every leaf, shown\nas a\nNIL, is black. Each non- NILnode is marked with its black-height; NILs have black-height 0.\n(b)The same red-black tree but with each NILreplaced by the single sentinel T:nil, which is always\nblack, and with black-heights omitted. The root\u2019s parent is also the sentinel. (c)The same red-black\ntree but with leaves and the root\u2019s parent omitted entirely. We shall use this drawing style in the\nremainder of this chapter.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "331": {"page_number": 332, "page_information": "13.1 Properties of red-black trees 311\nincluding the root, must be black. Consequently, the black-height of the root must\nbe at least h=2; thus,\nn/NAK2h=2/NUL1:\nMoving the 1to the left-hand side and taking logarithms on both sides yields\nlg.nC1//NAKh=2,o rh/DC42lg.nC1/.\nAs an immediate consequence of this lemma, we can implement the dynamic-set\noperations S EARCH ,M INIMUM ,M AXIMUM ,SUCCESSOR ,a n dP REDECESSOR\ninO.lgn/time on red-black trees, since each can run in O.h/ time on a binary\nsearch tree of height h(as shown in Chapter 12) and any red-black tree on nnodes\nis a binary search tree with height O.lgn/. (Of course, references to NILin the\nalgorithms of Chapter 12 would have to be replaced by T:nil.) Although the al-\ngorithms T REE-INSERT and T REE-DELETE from Chapter 12 run in O.lgn/time\nwhen given a red-black tree as input, they do not directly support the dynamic-setoperations I\nNSERT and D ELETE , since they do not guarantee that the modi\ufb01ed bi-\nnary search tree will be a red-black tree. We shall see in Sections 13.3 and 13.4,however, how to support these two operations in O.lgn/time.\nExercises\n13.1-1\nIn the style of Figure 13.1(a), draw the complete binary search tree of height 3on\nthe keysf1 ;2;:::;1 5g.A d d t h e\nNILleaves and color the nodes in three different\nways such that the black-heights of the resulting red-black trees are 2,3,a n d 4.\n13.1-2\nDraw the red-black tree that results after T REE-INSERT is called on the tree in\nFigure 13.1 with key 36. If the inserted node is colored red, is the resulting tree a\nred-black tree? What if it is colored black?\n13.1-3\nLet us de\ufb01ne a relaxed red-black tree as a binary search tree that satis\ufb01es red-\nblack properties 1, 3, 4, and 5. In other words, the root may be either red or black.Consider a relaxed red-black tree Twhose root is red. If we color the root of T\nblack but make no other changes to T, is the resulting tree a red-black tree?\n13.1-4\nSuppose that we \u201cabsorb\u201d every red node in a red-black tree into its black parent,so that the children of the red node become children of the black parent. (Ignore\nwhat happens to the keys.) What are the possible degrees of a black node after all", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "332": {"page_number": 333, "page_information": "312 Chapter 13 Red-Black Trees\nits red children are absorbed? What can you say about the depths of the leaves of\nthe resulting tree?\n13.1-5\nShow that the longest simple path from a node xin a red-black tree to a descendant\nleaf has length at most twice that of the shortest simple path from node xto a\ndescendant leaf.\n13.1-6\nWhat is the largest possible number of internal nodes in a red-black tree with black-\nheight k? What is the smallest possible number?\n13.1-7\nDescribe a red-black tree on nkeys that realizes the largest possible ratio of red in-\nternal nodes to black internal nodes. What is this ratio? What tree has the smallestpossible ratio, and what is the ratio?\n13.2 Rotations\nThe search-tree operations T REE-INSERT and T REE-DELETE , when run on a red-\nblack tree with nkeys, take O.lgn/time. Because they modify the tree, the result\nmay violate the red-black properties enumerated in Section 13.1. To restore theseproperties, we must change the colors of some of the nodes in the tree and alsochange the pointer structure.\nWe change the pointer structure through rotation , which is a local operation in\na search tree that preserves the binary-search-tree property. Figure 13.2 shows thetwo kinds of rotations: left rotations and right rotations. When we do a left rotationon a node x, we assume that its right child yis not T:nil;xmay be any node in\nthe tree whose right child is not T:nil. The left rotation \u201cpivots\u201d around the link\nfrom xtoy. It makes ythe new root of the subtree, with xasy\u2019s left child and y\u2019s\nleft child as x\u2019s right child.\nThe pseudocode for L\nEFT-ROTATE assumes that x:right\u00a4T:niland that the\nroot\u2019s parent is T:nil.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "333": {"page_number": 334, "page_information": "13.2 Rotations 313\ny\nx\n\u03b1\u03b2\u03b3x\ny \u03b1\n\u03b2\u03b3LEFT-ROTATE (T,x)\nRIGHT-ROTATE (T,y)\nFigure 13.2 The rotation operations on a binary search tree. The operation L EFT-ROTATE .T; x/\ntransforms the con\ufb01guration of the two nodes on the right into the con\ufb01guration on the left by chang-\ning a constant number of pointers. The inverse operation R IGHT -ROTATE .T; y/ transforms the con-\n\ufb01guration on the left into the con\ufb01guration on the right. The letters \u02db,\u02c7,a n d /CRrepresent arbitrary\nsubtrees. A rotation operation preserves the binary-search-tree property: the keys in \u02dbprecede x:key,\nwhich precedes the keys in \u02c7, which precede y:key, which precedes the keys in /CR.\nLEFT-ROTATE .T; x/\n1yDx:right //sety\n2x:rightDy:left //turny\u2019s left subtree into x\u2019s right subtree\n3ify:left\u00a4T:nil\n4 y:left:pDx\n5y:pDx:p //linkx\u2019s parent to y\n6ifx:p==T:nil\n7 T:rootDy\n8elseif x==x:p:left\n9 x:p:leftDy\n10elsex:p:rightDy\n11y:leftDx //putxony\u2019s left\n12x:pDy\nFigure 13.3 shows an example of how L EFT-ROTATE modi\ufb01es a binary search\ntree. The code for R IGHT -ROTATE is symmetric. Both L EFT-ROTATE and R IGHT -\nROTATE run in O.1/ time. Only pointers are changed by a rotation; all other\nattributes in a node remain the same.\nExercises\n13.2-1\nWrite pseudocode for R IGHT -ROTATE .\n13.2-2\nArgue that in every n-node binary search tree, there are exactly n/NUL1possible\nrotations.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "334": {"page_number": 335, "page_information": "314 Chapter 13 Red-Black Trees\n234\n67\n11\n91 8\n14\n12 1719\n22\n20x\ny\n234\n67\n18\n19\n14\n12 1722\n20xy\n11\n9LEFT-ROTATE (T,x)\nFigure 13.3 An example of how the procedure L EFT-ROTATE .T; x/ modi\ufb01es a binary search tree.\nInorder tree walks of the input tree and the modi\ufb01ed tree produce the same listing of key values.\n13.2-3\nLeta,b,a n d cbe arbitrary nodes in subtrees \u02db,\u02c7,a n d /CR, respectively, in the left\ntree of Figure 13.2. How do the depths of a,b,a n d cchange when a left rotation\nis performed on node xin the \ufb01gure?\n13.2-4\nShow that any arbitrary n-node binary search tree can be transformed into any other\narbitrary n-node binary search tree using O.n/ rotations. ( Hint: First show that at\nmost n/NUL1right rotations suf\ufb01ce to transform the tree into a right-going chain.)\n13.2-5 ?\nWe say that a binary search tree T1can be right-converted to binary search tree T2\nif it is possible to obtain T2from T1via a series of calls to R IGHT -ROTATE .G i v e\nan example of two trees T1andT2such that T1cannot be right-converted to T2.\nThen, show that if a tree T1can be right-converted to T2, it can be right-converted\nusing O.n2/calls to R IGHT -ROTATE .", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "335": {"page_number": 336, "page_information": "13.3 Insertion 315\n13.3 Insertion\nWe can insert a node into an n-node red-black tree in O.lgn/time. To do so, we\nuse a slightly modi\ufb01ed version of the T REE-INSERT procedure (Section 12.3) to\ninsert node \u00b4into the tree Tas if it were an ordinary binary search tree, and then we\ncolor \u00b4red. (Exercise 13.3-1 asks you to explain why we choose to make node \u00b4\nred rather than black.) To guarantee that the red-black properties are preserved, we\nthen call an auxiliary procedure RB-I NSERT -FIXUP to recolor nodes and perform\nrotations. The call RB-I NSERT .T; \u00b4/ inserts node \u00b4, whose keyis assumed to have\nalready been \ufb01lled in, into the red-black tree T.\nRB-I NSERT .T; \u00b4/\n1yDT:nil\n2xDT:root\n3while x\u00a4T:nil\n4 yDx\n5 if\u00b4:key<x : key\n6 xDx:left\n7 elsexDx:right\n8\u00b4:pDy\n9ify==T:nil\n10 T:rootD\u00b4\n11elseif \u00b4:key<y : key\n12 y:leftD\u00b4\n13elsey:rightD\u00b4\n14\u00b4:leftDT:nil\n15\u00b4:rightDT:nil\n16\u00b4:colorDRED\n17 RB-I NSERT -FIXUP.T; \u00b4/\nThe procedures T REE-INSERT and RB-I NSERT differ in four ways. First, all\ninstances of NILin T REE-INSERT are replaced by T:nil. Second, we set \u00b4:left\nand\u00b4:right toT:nilin lines 14\u201315 of RB-I NSERT , in order to maintain the\nproper tree structure. Third, we color \u00b4red in line 16. Fourth, because col-\noring \u00b4red may cause a violation of one of the red-black properties, we call\nRB-I NSERT -FIXUP.T; \u00b4/ in line 17 of RB-I NSERT to restore the red-black prop-\nerties.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "336": {"page_number": 337, "page_information": "316 Chapter 13 Red-Black Trees\nRB-I NSERT -FIXUP .T; \u00b4/\n1while \u00b4:p:color ==RED\n2 if\u00b4:p==\u00b4:p:p:left\n3 yD\u00b4:p:p:right\n4 ify:color ==RED\n5 \u00b4:p:colorDBLACK //case 1\n6 y:colorDBLACK //case 1\n7 \u00b4:p:p:colorDRED //case 1\n8 \u00b4D\u00b4:p:p //case 1\n9 else if \u00b4==\u00b4:p:right\n10 \u00b4D\u00b4:p //case 2\n11 L EFT-ROTATE .T; \u00b4/ //case 2\n12 \u00b4:p:colorDBLACK //case 3\n13 \u00b4:p:p:colorDRED //case 3\n14 R IGHT -ROTATE .T; \u00b4: p:p/ //case 3\n15 else(same as then clause\nwith \u201cright\u201d and \u201cleft\u201d exchanged)\n16T:root:colorDBLACK\nTo understand how RB-I NSERT -FIXUP works, we shall break our examination\nof the code into three major steps. First, we shall determine what violations ofthe red-black properties are introduced in RB-I\nNSERT when node \u00b4is inserted\nand colored red. Second, we shall examine the overall goal of the while loop in\nlines 1\u201315. Finally, we shall explore each of the three cases1within the while\nloop\u2019s body and see how they accomplish the goal. Figure 13.4 shows how RB-\nINSERT -FIXUP operates on a sample red-black tree.\nWhich of the red-black properties might be violated upon the call to RB-\nINSERT -FIXUP ? Property 1 certainly continues to hold, as does property 3, since\nboth children of the newly inserted red node are the sentinel T:nil. Property 5,\nwhich says that the number of black nodes is the same on every simple path froma given node, is satis\ufb01ed as well, because node \u00b4replaces the (black) sentinel, and\nnode \u00b4is red with sentinel children. Thus, the only properties that might be vi-\nolated are property 2, which requires the root to be black, and property 4, whichsays that a red node cannot have a red child. Both possible violations are due to \u00b4\nbeing colored red. Property 2 is violated if \u00b4is the root, and property 4 is violated\nif\u00b4\u2019s parent is red. Figure 13.4(a) shows a violation of property 4 after the node \u00b4\nhas been inserted.\n1Case 2 falls through into case 3, and so these two cases are not mutually exclusive.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "337": {"page_number": 338, "page_information": "13.3 Insertion 317\nzy11\n2\n17\n5\n4814\n15\nzy11\n2\n1 7\n5\n4814\n15(a)\n(b)Case 1\nzy11\n7\n2 8\n414\n15 (c)Case 2\n154\nz7\n2\n1511\n14 (d)Case 3\n48\n15\nFigure 13.4 The operation of RB-I NSERT -FIXUP .(a)A node \u00b4after insertion. Because both \u00b4\nand its parent \u00b4:pare red, a violation of property 4 occurs. Since \u00b4\u2019s uncle yis red, case 1 in the\ncode applies. We recolor nodes and move the pointer \u00b4up the tree, resulting in the tree shown in (b).\nOnce again, \u00b4and its parent are both red, but \u00b4\u2019s uncle yis black. Since \u00b4is the right child of \u00b4:p,\ncase2applies. We perform a left rotation, and the tree that results is shown in (c).N o w , \u00b4is the left\nchild of its parent, and case 3 applies. Recoloring and right rotation yield the tree in (d),w h i c hi sa\nlegal red-black tree.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "338": {"page_number": 339, "page_information": "318 Chapter 13 Red-Black Trees\nThewhile loop in lines 1\u201315 maintains the following three-part invariant at the\nstart of each iteration of the loop:\na. Node \u00b4is red.\nb. If\u00b4:pis the root, then \u00b4:pis black.\nc. If the tree violates any of the red-black properties, then it violates at most\none of them, and the violation is of either property 2 or property 4. If thetree violates property 2, it is because \u00b4is the root and is red. If the tree\nviolates property 4, it is because both \u00b4and\u00b4:pare red.\nPart (c), which deals with violations of red-black properties, is more central to\nshowing that RB-I\nNSERT -FIXUP restores the red-black properties than parts (a)\nand (b), which we use along the way to understand situations in the code. Becausewe\u2019ll be focusing on node \u00b4and nodes near it in the tree, it helps to know from\npart (a) that \u00b4is red. We shall use part (b) to show that the node \u00b4:p:pexists when\nwe reference it in lines 2, 3, 7, 8, 13, and 14.\nRecall that we need to show that a loop invariant is true prior to the \ufb01rst itera-\ntion of the loop, that each iteration maintains the loop invariant, and that the loop\ninvariant gives us a useful property at loop termination.\nWe start with the initialization and termination arguments. Then, as we exam-\nine how the body of the loop works in more detail, we shall argue that the loop\nmaintains the invariant upon each iteration. Along the way, we shall also demon-strate that each iteration of the loop has two possible outcomes: either the pointer \u00b4\nmoves up the tree, or we perform some rotations and then the loop terminates.\nInitialization: Prior to the \ufb01rst iteration of the loop, we started with a red-black\ntree with no violations, and we added a red node \u00b4. We show that each part of\nthe invariant holds at the time RB-I\nNSERT -FIXUP is called:\na. When RB-I NSERT -FIXUP is called, \u00b4is the red node that was added.\nb. If\u00b4:pis the root, then \u00b4:pstarted out black and did not change prior to the\ncall of RB-I NSERT -FIXUP .\nc. We have already seen that properties 1, 3, and 5 hold when RB-I NSERT -\nFIXUP is called.\nIf the tree violates property 2, then the red root must be the newly added\nnode \u00b4, which is the only internal node in the tree. Because the parent and\nboth children of \u00b4are the sentinel, which is black, the tree does not also\nviolate property 4. Thus, this violation of property 2 is the only violation ofred-black properties in the entire tree.\nIf the tree violates property 4, then, because the children of node \u00b4are black\nsentinels and the tree had no other violations prior to \u00b4being added, the", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "339": {"page_number": 340, "page_information": "13.3 Insertion 319\nviolation must be because both \u00b4and\u00b4:pare red. Moreover, the tree violates\nno other red-black properties.\nTermination: When the loop terminates, it does so because \u00b4:pis black. (If \u00b4is\nthe root, then \u00b4:pis the sentinel T:nil, which is black.) Thus, the tree does not\nviolate property 4 at loop termination. By the loop invariant, the only propertythat might fail to hold is property 2. Line 16 restores this property, too, so thatwhen RB-I\nNSERT -FIXUP terminates, all the red-black properties hold.\nMaintenance: We actually need to consider six cases in the while loop, but three\nof them are symmetric to the other three, depending on whether line 2 deter-mines \u00b4\u2019s parent \u00b4:pto be a left child or a right child of \u00b4\u2019s grandparent \u00b4:p:p.\nWe have given the code only for the situation in which \u00b4:pis a left child. The\nnode \u00b4:p:pexists, since by part (b) of the loop invariant, if \u00b4:pis the root,\nthen\u00b4:pis black. Since we enter a loop iteration only if \u00b4:pis red, we know\nthat\u00b4:pcannot be the root. Hence, \u00b4:p:pexists.\nWe distinguish case 1 from cases 2 and 3 by the color of \u00b4\u2019s parent\u2019s sibling,\nor \u201cuncle.\u201d Line 3 makes ypoint to \u00b4\u2019s uncle \u00b4:p:p:right , and line 4 tests y\u2019s\ncolor. If yis red, then we execute case 1. Otherwise, control passes to cases 2\nand 3. In all three cases, \u00b4\u2019s grandparent \u00b4:p:pis black, since its parent \u00b4:pis\nred, and property 4 is violated only between \u00b4and\u00b4:p.\nCase 1: \u00b4\u2019s uncle yis red\nFigure 13.5 shows the situation for case 1 (lines 5\u20138), which occurs when\nboth\u00b4:pandyare red. Because \u00b4:p:pis black, we can color both\n\u00b4:pandy\nblack, thereby \ufb01xing the problem of \u00b4and\u00b4:pboth being red, and we can\ncolor \u00b4:p:pred, thereby maintaining property 5. We then repeat the while loop\nwith\u00b4:p:pas the new node \u00b4. The pointer \u00b4moves up two levels in the tree.\nNow, we show that case 1 maintains the loop invariant at the start of the next\niteration. We use \u00b4to denote node \u00b4in the current iteration, and \u00b40D\u00b4:p:p\nto denote the node that will be called node \u00b4at the test in line 1 upon the next\niteration.\na. Because this iteration colors \u00b4:p:pred, node \u00b40is red at the start of the next\niteration.\nb. The node \u00b40:pis\u00b4:p:p:pin this iteration, and the color of this node does not\nchange. If this node is the root, it was black prior to this iteration, and itremains black at the start of the next iteration.\nc. We have already argued that case 1 maintains property 5, and it does not\nintroduce a violation of properties 1 or 3.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "340": {"page_number": 341, "page_information": "320 Chapter 13 Red-Black Trees\nzyC\nD A\nB \u03b1\n\u03b2\u03b3\u03b4\u03b5(a)C\nD A\nB \u03b1\n\u03b2\u03b3\u03b4\u03b5new z\nyC\nD B\n\u03b4\u03b5C\nD B\nA\n\u03b1\u03b2\u03b3\u03b4 \u03b5new z\n(b)\nA\n\u03b1\u03b2\u03b3 z\nFigure 13.5 Case 1 of the procedure RB-I NSERT -FIXUP . Property 4 is violated, since \u00b4and its\nparent \u00b4:pare both red. We take the same action whether (a)\u00b4is a right child or (b)\u00b4is a left\nchild. Each of the subtrees \u02db,\u02c7,/CR,\u0131,a n d \"has a black root, and each has the same black-height.\nThe code for case 1 changes the colors of some nodes, preserving property 5: all downward simple\npaths from a node to a leaf have the same number of blacks. The while loop continues with node \u00b4\u2019s\ngrandparent \u00b4:p:pas the new \u00b4. Any violation of property 4 can now occur only between the new \u00b4,\nwhich is red, and its parent, if it is red as well.\nIf node \u00b40is the root at the start of the next iteration, then case 1 corrected\nthe lone violation of property 4 in this iteration. Since \u00b40is red and it is the\nroot, property 2 becomes the only one that is violated, and this violation isdue to \u00b4\n0.\nIf node \u00b40is not the root at the start of the next iteration, then case 1 has\nnot created a violation of property 2. Case 1 corrected the lone violationof property 4 that existed at the start of this iteration. It then made \u00b4\n0red\nand left \u00b40:palone. If \u00b40:pwas black, there is no violation of property 4.\nIf\u00b40:pwas red, coloring \u00b40red created one violation of property 4 between \u00b40\nand\u00b40:p.\nCase 2: \u00b4\u2019s uncle yis black and \u00b4is a right child\nCase 3: \u00b4\u2019s uncle yis black and \u00b4is a left child\nIn cases 2 and 3, the color of \u00b4\u2019s uncle yis black. We distinguish the two cases\naccording to whether \u00b4is a right or left child of \u00b4:p. Lines 10\u201311 constitute\ncase 2, which is shown in Figure 13.6 together with case 3. In case 2, node \u00b4\nis a right child of its parent. We immediately use a left rotation to transformthe situation into case 3 (lines 12\u201314), in which node \u00b4is a left child. Because", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "341": {"page_number": 342, "page_information": "13.3 Insertion 321\nC\nA\nB \u03b1\n\u03b2\u03b3\u03b4\nCase 2zy B\nA\n\u03b1\u03b2\u03b3\u03b4\nCase 3zy zAB\nC\n\u03b1\u03b2 \u03b3 \u03b4C\nFigure 13.6 Cases 2 and 3 of the procedure RB-I NSERT -FIXUP . As in case 1, property 4 is violated\nin either case 2 or case 3 because \u00b4and its parent \u00b4:pare both red. Each of the subtrees \u02db,\u02c7,/CR,a n d \u0131\nhas a black root ( \u02db,\u02c7,a n d /CRfrom property 4, and \u0131because otherwise we would be in case 1), and\neach has the same black-height. We transform case 2 into case 3 by a left rotation, which preserves\nproperty 5: all downward simple paths from a node to a leaf have the same number of blacks. Case 3\ncauses some color changes and a right rotation, which also preserve property 5. The while loop then\nterminates, because property 4 is satis\ufb01ed: there are no longer two red nodes in a row.\nboth \u00b4and\u00b4:pare red, the rotation affects neither the black-height of nodes\nnor property 5. Whether we enter case 3 directly or through case 2, \u00b4\u2019s uncle y\nis black, since otherwise we would have executed case 1. Additionally, thenode \u00b4:p:pexists, since we have argued that this node existed at the time that\nlines 2 and 3 were executed, and after moving \u00b4up one level in line 10 and then\ndown one level in line 11, the identity of \u00b4:p:premains unchanged. In case 3,\nwe execute some color changes and a right rotation, which preserve property 5,\nand then, since we no longer have two red nodes in a row, we are done. Thewhile loop does not iterate another time, since \u00b4:pis now black.\nWe now show that cases 2 and 3 maintain the loop invariant. (As we have just\nargued, \u00b4:pwill be black upon the next test in line 1, and the loop body will not\nexecute again.)\na. Case 2 makes \u00b4point to \u00b4:p, which is red. No further change to \u00b4or its color\noccurs in cases 2 and 3.\nb. Case 3 makes \u00b4:pblack, so that if \u00b4:pis the root at the start of the next\niteration, it is black.\nc. As in case 1, properties 1, 3, and 5 are maintained in cases 2 and 3.\nSince node \u00b4is not the root in cases 2 and 3, we know that there is no viola-\ntion of property 2. Cases 2 and 3 do not introduce a violation of property 2,\nsince the only node that is made red becomes a child of a black node by the\nrotation in case 3.\nCases 2 and 3 correct the lone violation of property 4, and they do not intro-\nduce another violation.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "342": {"page_number": 343, "page_information": "322 Chapter 13 Red-Black Trees\nHaving shown that each iteration of the loop maintains the invariant, we have\nshown that RB-I NSERT -FIXUP correctly restores the red-black properties.\nAnalysis\nWhat is the running time of RB-I NSERT ? Since the height of a red-black tree on n\nnodes is O.lgn/, lines 1\u201316 of RB-I NSERT takeO.lgn/time. In RB-I NSERT -\nFIXUP ,t h ewhile loop repeats only if case 1 occurs, and then the pointer \u00b4moves\ntwo levels up the tree. The total number of times the while loop can be executed\nis therefore O.lgn/. Thus, RB-I NSERT takes a total of O.lgn/time. Moreover, it\nnever performs more than two rotations, since the while loop terminates if case 2\nor case 3 is executed.\nExercises\n13.3-1\nIn line 16 of RB-I NSERT , we set the color of the newly inserted node \u00b4to red.\nObserve that if we had chosen to set \u00b4\u2019s color to black, then property 4 of a red-\nblack tree would not be violated. Why didn\u2019t we choose to set \u00b4\u2019s color to black?\n13.3-2\nShow the red-black trees that result after successively inserting the keys 41; 38; 31;\n12; 19; 8 into an initially empty red-black tree.\n13.3-3\nSuppose that the black-height of each of the subtrees \u02db;\u02c7;/CR;\u0131;\" in Figures 13.5\nand 13.6 is k. Label each node in each \ufb01gure with its black-height to verify that\nthe indicated transformation preserves property 5.\n13.3-4\nProfessor Teach is concerned that RB-I NSERT -FIXUP might set T:nil:color to\nRED, in which case the test in line 1 would not cause the loop to terminate when \u00b4\nis the root. Show that the professor\u2019s concern is unfounded by arguing that RB-\nINSERT -FIXUP never sets T:nil:color toRED.\n13.3-5\nConsider a red-black tree formed by inserting nnodes with RB-I NSERT . Argue\nthat if n>1 , the tree has at least one red node.\n13.3-6\nSuggest how to implement RB-I NSERT ef\ufb01ciently if the representation for red-\nblack trees includes no storage for parent pointers.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "343": {"page_number": 344, "page_information": "13.4 Deletion 323\n13.4 Deletion\nLike the other basic operations on an n-node red-black tree, deletion of a node takes\ntimeO.lgn/. Deleting a node from a red-black tree is a bit more complicated than\ninserting a node.\nThe procedure for deleting a node from a red-black tree is based on the T REE-\nDELETE procedure (Section 12.3). First, we need to customize the T RANSPLANT\nsubroutine that T REE-DELETE calls so that it applies to a red-black tree:\nRB-T RANSPLANT . T;u ;/ETB/\n1ifu:p==T:nil\n2 T:rootD/ETB\n3elseif u==u:p:left\n4 u:p:leftD/ETB\n5elseu:p:rightD/ETB\n6/ETB:pDu:p\nThe procedure RB-T RANSPLANT differs from T RANSPLANT in two ways. First,\nline 1 references the sentinel T:nilinstead of NIL. Second, the assignment to /ETB:pin\nline 6 occurs unconditionally: we can assign to /ETB:peven if /ETBpoints to the sentinel.\nIn fact, we shall exploit the ability to assign to /ETB:pwhen /ETBDT:nil.\nThe procedure RB-D ELETE is like the T REE-DELETE procedure, but with ad-\nditional lines of pseudocode. Some of the additional lines keep track of a node y\nthat might cause violations of the red-black properties. When we want to deletenode \u00b4and\u00b4has fewer than two children, then \u00b4is removed from the tree, and we\nwant yto be \u00b4.W h e n \u00b4has two children, then yshould be \u00b4\u2019s successor, and y\nmoves into \u00b4\u2019s position in the tree. We also remember y\u2019s color before it is re-\nmoved from or moved within the tree, and we keep track of the node xthat moves\nintoy\u2019s original position in the tree, because node xmight also cause violations\nof the red-black properties. After deleting node \u00b4, RB-D\nELETE calls an auxiliary\nprocedure RB-D ELETE -FIXUP , which changes colors and performs rotations to\nrestore the red-black properties.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "344": {"page_number": 345, "page_information": "324 Chapter 13 Red-Black Trees\nRB-D ELETE .T; \u00b4/\n1yD\u00b4\n2y-original -colorDy:color\n3if\u00b4:left==T:nil\n4 xD\u00b4:right\n5 RB-T RANSPLANT . T;\u00b4 ;\u00b4 : right/\n6elseif \u00b4:right ==T:nil\n7 xD\u00b4:left\n8 RB-T RANSPLANT . T;\u00b4 ;\u00b4 : left/\n9elseyDTREE-MINIMUM .\u00b4:right/\n10 y-original -colorDy:color\n11 xDy:right\n12 ify:p==\u00b4\n13 x:pDy\n14 elseRB-T RANSPLANT . T;y;y: right/\n15 y:rightD\u00b4:right\n16 y:right:pDy\n17 RB-T RANSPLANT . T;\u00b4 ;y/\n18 y:leftD\u00b4:left\n19 y:left:pDy\n20 y:colorD\u00b4:color\n21ify-original -color ==BLACK\n22 RB-D ELETE -FIXUP .T; x/\nAlthough RB-D ELETE contains almost twice as many lines of pseudocode as\nTREE-DELETE , the two procedures have the same basic structure. You can \ufb01nd\neach line of T REE-DELETE within RB-D ELETE (with the changes of replacing\nNILbyT:niland replacing calls to T RANSPLANT by calls to RB-T RANSPLANT ),\nexecuted under the same conditions.\nHere are the other differences between the two procedures:\n/SIWe maintain node yas the node either removed from the tree or moved within\nthe tree. Line 1 sets yto point to node \u00b4when \u00b4has fewer than two children\nand is therefore removed. When \u00b4has two children, line 9 sets yto point to \u00b4\u2019s\nsuccessor, just as in T REE-DELETE ,a n d ywill move into \u00b4\u2019s position in the\ntree.\n/SIBecause node y\u2019s color might change, the variable y-original -color stores y\u2019s\ncolor before any changes occur. Lines 2 and 10 set this variable immediately\nafter assignments to y.W h e n \u00b4has two children, then y\u00a4\u00b4and node y\nmoves into node \u00b4\u2019s original position in the red-black tree; line 20 gives ythe\nsame color as \u00b4. We need to save y\u2019s original color in order to test it at the", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "345": {"page_number": 346, "page_information": "13.4 Deletion 325\nend of RB-D ELETE ; if it was black, then removing or moving ycould cause\nviolations of the red-black properties.\n/SIAs discussed, we keep track of the node xthat moves into node y\u2019s original\nposition. The assignments in lines 4, 7, and 11 set xto point to either y\u2019s only\nchild or, if yhas no children, the sentinel T:nil. (Recall from Section 12.3\nthatyhas no left child.)\n/SISince node xmoves into node y\u2019s original position, the attribute x:pis always\nset to point to the original position in the tree of y\u2019s parent, even if xis, in fact,\nthe sentinel T:nil. Unless \u00b4isy\u2019s original parent (which occurs only when \u00b4has\ntwo children and its successor yis\u00b4\u2019s right child), the assignment to x:ptakes\nplace in line 6 of RB-T RANSPLANT . (Observe that when RB-T RANSPLANT\nis called in lines 5, 8, or 14, the second parameter passed is the same as x.)\nWhen y\u2019s original parent is \u00b4, however, we do not want x:pto point to y\u2019s orig-\ninal parent, since we are removing that node from the tree. Because node ywill\nmove up to take \u00b4\u2019s position in the tree, setting x:ptoyin line 13 causes x:p\nto point to the original position of y\u2019s parent, even if xDT:nil.\n/SIFinally, if node ywas black, we might have introduced one or more violations\nof the red-black properties, and so we call RB-D ELETE -FIXUP in line 22 to\nrestore the red-black properties. If ywas red, the red-black properties still hold\nwhen yis removed or moved, for the following reasons:\n1. No black-heights in the tree have changed.\n2. No red nodes have been made adjacent. Because ytakes \u00b4\u2019s place in the\ntree, along with \u00b4\u2019s color, we cannot have two adjacent red nodes at y\u2019s new\nposition in the tree. In addition, if ywas not \u00b4\u2019s right child, then y\u2019s original\nright child xreplaces yin the tree. If yis red, then xmust be black, and so\nreplacing ybyxcannot cause two red nodes to become adjacent.\n3. Since ycould not have been the root if it was red, the root remains black.\nIf node ywas black, three problems may arise, which the call of RB-D ELETE -\nFIXUP will remedy. First, if yhad been the root and a red child of ybecomes the\nnew root, we have violated property 2. Second, if both xandx:pare red, then\nwe have violated property 4. Third, moving ywithin the tree causes any simple\npath that previously contained yto have one fewer black node. Thus, property 5\nis now violated by any ancestor of yin the tree. We can correct the violation\nof property 5 by saying that node x, now occupying y\u2019s original position, has an\n\u201cextra\u201d black. That is, if we add 1to the count of black nodes on any simple path\nthat contains x, then under this interpretation, property 5 holds. When we remove\nor move the black node y, we \u201cpush\u201d its blackness onto node x. The problem is\nthat now node xis neither red nor black, thereby violating property 1. Instead,", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "346": {"page_number": 347, "page_information": "326 Chapter 13 Red-Black Trees\nnode xis either \u201cdoubly black\u201d or \u201cred-and-black,\u201d and it contributes either 2or1,\nrespectively, to the count of black nodes on simple paths containing x.T h e color\nattribute of xwill still be either RED (ifxis red-and-black) or BLACK (ifxis\ndoubly black). In other words, the extra black on a node is re\ufb02ected in x\u2019s pointing\nto the node rather than in the color attribute.\nWe can now see the procedure RB-D ELETE -FIXUP and examine how it restores\nthe red-black properties to the search tree.\nRB-D ELETE -FIXUP .T; x/\n1while x\u00a4T:root andx:color ==BLACK\n2 ifx==x:p:left\n3 wDx:p:right\n4 ifw:color ==RED\n5 w:colorDBLACK //case 1\n6 x:p:colorDRED //case 1\n7L EFT-ROTATE .T; x: p/ //case 1\n8 wDx:p:right //case 1\n9 ifw:left:color ==BLACK andw:right:color ==BLACK\n10 w:colorDRED //case 2\n11 xDx:p //case 2\n12 else if w:right:color ==BLACK\n13 w:left:colorDBLACK //case 3\n14 w:colorDRED //case 3\n15 R IGHT -ROTATE .T; w/ //case 3\n16 wDx:p:right //case 3\n17 w:colorDx:p:color //case 4\n18 x:p:colorDBLACK //case 4\n19 w:right:colorDBLACK //case 4\n20 L EFT-ROTATE .T; x: p/ //case 4\n21 xDT:root //case 4\n22 else(same as then clause with \u201cright\u201d and \u201cleft\u201d exchanged)\n23x:colorDBLACK\nThe procedure RB-D ELETE -FIXUP restores properties 1, 2, and 4. Exercises\n13.4-1 and 13.4-2 ask you to show that the procedure restores properties 2 and 4,\nand so in the remainder of this section, we shall focus on property 1. The goal of\nthewhile loop in lines 1\u201322 is to move the extra black up the tree until\n1.xpoints to a red-and-black node, in which case we color x(singly) black in\nline 23;\n2.xpoints to the root, in which case we simply \u201cremove\u201d the extra black; or\n3. having performed suitable rotations and recolorings, we exit the loop.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "347": {"page_number": 348, "page_information": "13.4 Deletion 327\nWithin the while loop, xalways points to a nonroot doubly black node. We\ndetermine in line 2 whether xis a left child or a right child of its parent x:p.( W e\nhave given the code for the situation in which xis a left child; the situation in\nwhich xis a right child\u2014line 22\u2014is symmetric.) We maintain a pointer wto\nthe sibling of x. Since node xis doubly black, node wcannot be T:nil, because\notherwise, the number of blacks on the simple path from x:pto the (singly black)\nleafwwould be smaller than the number on the simple path from x:ptox.\nThe four cases2in the code appear in Figure 13.7. Before examining each case\nin detail, let\u2019s look more generally at how we can verify that the transformation\nin each of the cases preserves property 5. The key idea is that in each case, thetransformation applied preserves the number of black nodes (including x\u2019s extra\nblack) from (and including) the root of the subtree shown to each of the subtrees\u02db ;\u02c7 ;:::;/DLE . Thus, if property 5 holds prior to the transformation, it continues to\nhold afterward. For example, in Figure 13.7(a), which illustrates case 1, the num-ber of black nodes from the root to either subtree \u02dbor\u02c7is 3, both before and after\nthe transformation. (Again, remember that node xadds an extra black.) Similarly,\nthe number of black nodes from the root to any of /CR,\u0131,\",a n d /DLEis 2, both be-\nfore and after the transformation. In Figure 13.7(b), the counting must involve the\nvalue cof the color attribute of the root of the subtree shown, which can be either\nRED orBLACK . If we de\ufb01ne count .RED/D0and count .BLACK /D1, then the\nnumber of black nodes from the root to \u02dbis2Ccount .c/, both before and after\nthe transformation. In this case, after the transformation, the new node xhascolor\nattribute c, but this node is really either red-and-black (if cDRED) or doubly black\n(ifcDBLACK ). You can verify the other cases similarly (see Exercise 13.4-5).\nCase 1: x\u2019s sibling wis red\nCase 1 (lines 5\u20138 of RB-D ELETE -FIXUP and Figure 13.7(a)) occurs when node w,\nthe sibling of node x, is red. Since wmust have black children, we can switch the\ncolors of wandx:pand then perform a left-rotation on x:pwithout violating any\nof the red-black properties. The new sibling of x, which is one of w\u2019s children\nprior to the rotation, is now black, and thus we have converted case 1 into case 2,3, or 4.\nCases 2, 3, and 4 occur when node wis black; they are distinguished by the\ncolors of w\u2019s children.\n2As in RB-I NSERT -FIXUP , the cases in RB-D ELETE -FIXUP are not mutually exclusive.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "348": {"page_number": 349, "page_information": "328 Chapter 13 Red-Black Trees\nCase 2: x\u2019s sibling wis black, and both of w\u2019s children are black\nIn case 2 (lines 10\u201311 of RB-D ELETE -FIXUP and Figure 13.7(b)), both of w\u2019s\nchildren are black. Since wis also black, we take one black off both xandw,\nleaving xwith only one black and leaving wred. To compensate for removing\none black from xandw, we would like to add an extra black to x:p,w h i c hw a s\noriginally either red or black. We do so by repeating the while loop with x:pas\nthe new node x. Observe that if we enter case 2 through case 1, the new node x\nis red-and-black, since the original x:pwas red. Hence, the value cof the color\nattribute of the new node xisRED, and the loop terminates when it tests the loop\ncondition. We then color the new node x(singly) black in line 23.\nCase 3: x\u2019s sibling wis black, w\u2019s left child is red, and w\u2019s right child is black\nCase 3 (lines 13\u201316 and Figure 13.7(c)) occurs when wis black, its left child\nis red, and its right child is black. We can switch the colors of wand its left\nchild w:leftand then perform a right rotation on wwithout violating any of the\nred-black properties. The new sibling wofxis now a black node with a red right\nchild, and thus we have transformed case 3 into case 4.\nCase 4: x\u2019s sibling wis black, and w\u2019s right child is red\nCase 4 (lines 17\u201321 and Figure 13.7(d)) occurs when node x\u2019s sibling wis black\nandw\u2019s right child is red. By making some color changes and performing a left ro-\ntation on x:p, we can remove the extra black on x, making it singly black, without\nviolating any of the red-black properties. Setting xto be the root causes the while\nloop to terminate when it tests the loop condition.\nAnalysis\nWhat is the running time of RB-D ELETE ? Since the height of a red-black tree of n\nnodes is O.lgn/, the total cost of the procedure without the call to RB-D ELETE -\nFIXUP takes O.lgn/time. Within RB-D ELETE -FIXUP , each of cases 1, 3, and 4\nlead to termination after performing a constant number of color changes and atmost three rotations. Case 2 is the only case in which the while loop can be re-\npeated, and then the pointer xmoves up the tree at most O.lgn/times, performing\nno rotations. Thus, the procedure RB-D\nELETE -FIXUP takes O.lgn/time and per-\nforms at most three rotations, and the overall time for RB-D ELETE is therefore\nalsoO.lgn/.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "349": {"page_number": 350, "page_information": "13.4 Deletion 329\nAB\nD\nCE \u03b1\u03b2\n\u03b3\u03b4 \u03b5\u03b6xw\nAB\nCD\nE\nx new w\n\u03b1\u03b2 \u03b3 \u03b4\u03b5\u03b6\nAB\nD\nCE \u03b1\u03b2\n\u03b3\u03b4 \u03b5\u03b6xwc\nAB\nD\nCE \u03b1\u03b2\n\u03b3\u03b4 \u03b5\u03b6c new x\nAB\nD\nC E \u03b1\u03b2\n\u03b3\u03b4 \u03b5\u03b6xwc\nAB\nC\nD \u03b1\u03b2 \u03b3\n\u03b4\n\u03b5\u03b6xc\nnew w\nAB\nD\nCE \u03b1\u03b2\n\u03b3\u03b4\u03b5\u03b6xwc c\n\u03b1\u03b2AB\nCD\nE (d)(c)(b)(a)\n\u03b3\u03b4 \u03b5\u03b6Case 4Case 3Case 2Case 1 E\nc\u2032 c\u2032\nnewxDT:root\nFigure 13.7 The cases in the while loop of the procedure RB-D ELETE -FIXUP . Darkened nodes\nhave color attributes BLACK , heavily shaded nodes have color attributes RED, and lightly shaded\nnodes have color attributes represented by candc0, which may be either RED orBLACK . The letters\n\u02db ;\u02c7 ;:::;/DLE represent arbitrary subtrees. Each case transforms the con\ufb01guration on the left into the\ncon\ufb01guration on the right by changing some colors and/or performing a rotation. Any node pointed\nto by xhas an extra black and is either doubly black or red-and-black. Only case 2 causes the loop to\nrepeat. (a)Case 1 is transformed to case 2, 3, or 4 by exchanging the colors of nodes BandDand\nperforming a left rotation. (b)In case 2, the extra black represented by the pointer xmoves up the\ntree by coloring node Dred and setting xto point to node B. If we enter case 2 through case 1, the\nwhile loop terminates because the new node xis red-and-black, and therefore the value cof its color\nattribute is RED.(c)Case 3 is transformed to case 4 by exchanging the colors of nodes CandDand\nperforming a right rotation. (d)Case 4 removes the extra black represented by xby changing some\ncolors and performing a left rotation (without violating the red-black properties), and then the loop\nterminates.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "350": {"page_number": 351, "page_information": "330 Chapter 13 Red-Black Trees\nExercises\n13.4-1\nArgue that after executing RB-D ELETE -FIXUP , the root of the tree must be black.\n13.4-2\nArgue that if in RB-D ELETE bothxandx:pare red, then property 4 is restored by\nthe call to RB-D ELETE -FIXUP .T; x/ .\n13.4-3\nIn Exercise 13.3-2, you found the red-black tree that results from successivelyinserting the keys 41; 38; 31; 12; 19; 8 into an initially empty tree. Now show the\nred-black trees that result from the successive deletion of the keys in the order8; 12; 19; 31; 38; 41 .\n13.4-4\nIn which lines of the code for RB-D\nELETE -FIXUP might we examine or modify\nthe sentinel T:nil?\n13.4-5\nIn each of the cases of Figure 13.7, give the count of black nodes from the root ofthe subtree shown to each of the subtrees \u02db ;\u02c7 ;:::;/DLE , and verify that each count\nremains the same after the transformation. When a node has a color attribute c\norc\n0, use the notation count .c/or count .c0/symbolically in your count.\n13.4-6\nProfessors Skelton and Baron are concerned that at the start of case 1 of RB-\nDELETE -FIXUP , the node x:pmight not be black. If the professors are correct,\nthen lines 5\u20136 are wrong. Show that x:pmust be black at the start of case 1, so that\nthe professors have nothing to worry about.\n13.4-7\nSuppose that a node xis inserted into a red-black tree with RB-I NSERT and then\nis immediately deleted with RB-D ELETE . Is the resulting red-black tree the same\nas the initial red-black tree? Justify your answer.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "351": {"page_number": 352, "page_information": "Problems for Chapter 13 331\nProblems\n13-1 Persistent dynamic sets\nDuring the course of an algorithm, we sometimes \ufb01nd that we need to maintain pastversions of a dynamic set as it is updated. We call such a set persistent .O n ew a yt o\nimplement a persistent set is to copy the entire set whenever it is modi\ufb01ed, but this\napproach can slow down a program and also consume much space. Sometimes, we\ncan do much better.\nConsider a persistent set Swith the operations I\nNSERT ,DELETE ,a n dS EARCH ,\nwhich we implement using binary search trees as shown in Figure 13.8(a). Wemaintain a separate root for every version of the set. In order to insert the key 5\ninto the set, we create a new node with key 5. This node becomes the left child\nof a new node with key 7, since we cannot modify the existing node with key 7.\nSimilarly, the new node with key 7becomes the left child of a new node with\nkey8whose right child is the existing node with key 10. The new node with key 8\nbecomes, in turn, the right child of a new root r\n0with key 4whose left child is the\nexisting node with key 3. We thus copy only part of the tree and share some of the\nnodes with the original tree, as shown in Figure 13.8(b).\nAssume that each tree node has the attributes key,left,a n d right but no parent.\n(See also Exercise 13.3-6.)\n4\n3\n28\n71 04\n3\n28\n71 04\n8\n7\n5\n(b) (a)rr r \u2032\nFigure 13.8 (a) A binary search tree with keys 2; 3; 4; 7; 8; 10 .(b)The persistent binary search\ntree that results from the insertion of key 5. The most recent version of the set consists of the nodes\nreachable from the root r0, and the previous version consists of the nodes reachable from r. Heavily\nshaded nodes are added when key 5is inserted.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "352": {"page_number": 353, "page_information": "332 Chapter 13 Red-Black Trees\na.For a general persistent binary search tree, identify the nodes that we need to\nchange to insert a key kor delete a node y.\nb.Write a procedure P ERSISTENT -TREE-INSERT that, given a persistent tree T\nand a key kto insert, returns a new persistent tree T0that is the result of insert-\ningkintoT.\nc.If the height of the persistent binary search tree Tish, what are the time and\nspace requirements of your implementation of P ERSISTENT -TREE-INSERT ?\n(The space requirement is proportional to the number of new nodes allocated.)\nd.Suppose that we had included the parent attribute in each node. In this case,\nPERSISTENT -TREE-INSERT would need to perform additional copying. Prove\nthat P ERSISTENT -TREE-INSERT would then require /DEL.n/ time and space,\nwhere nis the number of nodes in the tree.\ne.Show how to use red-black trees to guarantee that the worst-case running time\nand space are O.lgn/per insertion or deletion.\n13-2 Join operation on red-black trees\nThejoin operation takes two dynamic sets S1andS2a n da ne l e m e n t xsuch that\nfor any x12S1andx22S2,w eh a v e x1:key/DC4x:key/DC4x2:key. It returns a set\nSDS1[fxg[S2. In this problem, we investigate how to implement the join\noperation on red-black trees.\na.Given a red-black tree T, let us store its black-height as the new attribute T:bh.\nArgue that RB-I NSERT and RB-D ELETE can maintain the bhattribute with-\nout requiring extra storage in the nodes of the tree and without increasing theasymptotic running times. Show that while descending through T, we can de-\ntermine the black-height of each node we visit in O.1/ time per node visited.\nWe wish to implement the operation RB-J\nOIN.T1;x;T 2/, which destroys T1andT2\nand returns a red-black tree TDT1[fxg[T2.L e t nbe the total number of nodes\ninT1andT2.\nb.Assume that T1:bh/NAKT2:bh. Describe an O.lgn/-time algorithm that \ufb01nds a\nblack node yinT1with the largest key from among those nodes whose black-\nheight is T2:bh.\nc.LetTybe the subtree rooted at y. Describe how Ty[fxg[T2can replace Ty\ninO.1/ time without destroying the binary-search-tree property.\nd.What color should we make xso that red-black properties 1, 3, and 5 are main-\ntained? Describe how to enforce properties 2 and 4 in O.lgn/time.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "353": {"page_number": 354, "page_information": "Problems for Chapter 13 333\ne.Argue that no generality is lost by making the assumption in part (b). Describe\nthe symmetric situation that arises when T1:bh/DC4T2:bh.\nf.Argue that the running time of RB-J OINisO.lgn/.\n13-3 AVL trees\nAnAVL tree is a binary search tree that is height balanced : for each node x,t h e\nheights of the left and right subtrees of xdiffer by at most 1. To implement an A VL\ntree, we maintain an extra attribute in each node: x:his the height of node x.A s\nfor any other binary search tree T, we assume that T:root points to the root node.\na.Prove that an AVL tree with nnodes has height O.lgn/.(Hint: Prove that\nan AVL tree of height hhas at least Fhnodes, where Fhis the hth Fibonacci\nnumber.)\nb.To insert into an AVL tree, we \ufb01rst place a node into the appropriate place in bi-\nnary search tree order. Afterward, the tree might no longer be height balanced.Speci\ufb01cally, the heights of the left and right children of some node might differ\nby2. Describe a procedure B\nALANCE .x/, which takes a subtree rooted at x\nwhose left and right children are height balanced and have heights that differby at most 2, i.e.,jx:right:h/NULx:left:hj/DC42, and alters the subtree rooted at x\nto be height balanced. ( Hint: Use rotations.)\nc.Using part (b), describe a recursive procedure AVL-I\nNSERT .x; \u00b4/ that takes\na node xwithin an AVL tree and a newly created node \u00b4(whose key has al-\nready been \ufb01lled in), and adds \u00b4to the subtree rooted at x, maintaining the\nproperty that xis the root of an AVL tree. As in T REE-INSERT from Sec-\ntion 12.3, assume that \u00b4:keyhas already been \ufb01lled in and that \u00b4:leftDNIL\nand\u00b4:rightDNIL; also assume that \u00b4:hD0. Thus, to insert the node \u00b4into\nthe AVL tree T, we call AVL-I NSERT .T:root;\u00b4 /.\nd.Show that AVL-I NSERT , run on an n-node AVL tree, takes O.lgn/time and\nperforms O.1/ rotations.\n13-4 Treaps\nIf we insert a set of nitems into a binary search tree, the resulting tree may be\nhorribly unbalanced, leading to long search times. As we saw in Section 12.4,however, randomly built binary search trees tend to be balanced. Therefore, onestrategy that, on average, builds a balanced tree for a \ufb01xed set of items would be torandomly permute the items and then insert them in that order into the tree.\nWhat if we do not have all the items at once? If we receive the items one at a\ntime, can we still randomly build a binary search tree out of them?", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "354": {"page_number": 355, "page_information": "334 Chapter 13 Red-Black Trees\nG: 4\nB: 7 H: 5\nA: 10 E: 23 K: 65\nI: 73\nFigure 13.9 A treap. Each node xis labeled with x:key:x:priority . For example, the root has\nkeyGand priority 4.\nWe will examine a data structure that answers this question in the af\ufb01rmative. A\ntreap is a binary search tree with a modi\ufb01ed way of ordering the nodes. Figure 13.9\nshows an example. As usual, each node xin the tree has a key value x:key.I n\naddition, we assign x:priority , which is a random number chosen independently\nfor each node. We assume that all priorities are distinct and also that all keys aredistinct. The nodes of the treap are ordered so that the keys obey the binary-search-\ntree property and the priorities obey the min-heap order property:\n/SIIf/ETBis a left child of u,t h e n /ETB:key<u : key.\n/SIIf/ETBis a right child of u,t h e n /ETB:key>u : key.\n/SIIf/ETBis a child of u,t h e n /ETB:priority >u : priority .\n(This combination of properties is why the tree is called a \u201ctreap\u201d: it has features\nof both a binary search tree and a heap.)\nIt helps to think of treaps in the following way. Suppose that we insert nodes\nx1;x2;:::;x n, with associated keys, into a treap. Then the resulting treap is the\ntree that would have been formed if the nodes had been inserted into a normal\nbinary search tree in the order given by their (randomly chosen) priorities, i.e.,\nxi:priority <x j:priority means that we had inserted xibefore xj.\na.Show that given a set of nodes x1;x2;:::;x n, with associated keys and priori-\nties, all distinct, the treap associated with these nodes is unique.\nb.Show that the expected height of a treap is \u201a.lgn/, and hence the expected time\nto search for a value in the treap is \u201a.lgn/.\nLet us see how to insert a new node into an existing treap. The \ufb01rst thing we do\nis assign to the new node a random priority. Then we call the insertion algorithm,\nwhich we call T REAP -INSERT , whose operation is illustrated in Figure 13.10.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "355": {"page_number": 356, "page_information": "Problems for Chapter 13 335\nG: 4\nB: 7 H: 5\nA: 10 E: 23 K: 65\nI: 73G: 4\nB: 7 H: 5\nA: 10 E: 23 K: 65\nI: 73C: 25\nC: 25\n(a) (b)\nG: 4\nB: 7 H: 5\nA: 10 E: 23 K: 65\nI: 73 C: 25\n(c)D: 9\nD: 9G: 4\nB: 7 H: 5\nA: 10 E: 23 K: 65\nI: 73\n(d)D: 9\nC: 25\nG: 4\nB: 7 H: 5\nA: 10 K: 65\nI: 73\n(e)D: 9\nC: 25 E: 23B: 7\nA: 10\n(f)D: 9\nC: 25 E: 23F: 2\nI: 73K: 65H: 5G: 4F: 2\n\u2026\nFigure 13.10 The operation of T REAP -INSERT .(a)The original treap, prior to insertion. (b)The\ntreap after inserting a node with key Cand priority 25. (c)\u2013(d) Intermediate stages when inserting a\nnode with key Dand priority 9. (e)The treap after the insertion of parts (c) and (d) is done. (f)The\ntreap after inserting a node with key Fand priority 2.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "356": {"page_number": 357, "page_information": "336 Chapter 13 Red-Black Trees\n15\n9 18\n3 12 25\n21 6\n(a)15\n9 18\n3 12 25\n21 6\n(b)\nFigure 13.11 Spines of a binary search tree. The left spine is shaded in (a), and the right spine is\nshaded in (b).\nc.Explain how T REAP -INSERT works. Explain the idea in English and give pseu-\ndocode. ( Hint: Execute the usual binary-search-tree insertion procedure and\nthen perform rotations to restore the min-heap order property.)\nd.Show that the expected running time of T REAP -INSERT is\u201a.lgn/.\nTREAP -INSERT performs a search and then a sequence of rotations. Although\nthese two operations have the same expected running time, they have differentcosts in practice. A search reads information from the treap without modifying it.In contrast, a rotation changes parent and child pointers within the treap. On mostcomputers, read operations are much faster than write operations. Thus we wouldlike T\nREAP -INSERT to perform few rotations. We will show that the expected\nnumber of rotations performed is bounded by a constant.\nIn order to do so, we will need some de\ufb01nitions, which Figure 13.11 depicts.\nTheleft spine of a binary search tree Tis the simple path from the root to the node\nwith the smallest key. In other words, the left spine is the simple path from the\nroot that consists of only left edges. Symmetrically, the right spine ofTis the\nsimple path from the root consisting of only right edges. The length of a spine is\nthe number of nodes it contains.\ne.Consider the treap Timmediately after T REAP -INSERT has inserted node x.\nLetCbe the length of the right spine of the left subtree of x.L e t Dbe the\nlength of the left spine of the right subtree of x. Prove that the total number of\nrotations that were performed during the insertion of xis equal to CCD.\nWe will now calculate the expected values of CandD. Without loss of generality,\nwe assume that the keys are 1 ;2;:::;n , since we are comparing them only to one\nanother.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "357": {"page_number": 358, "page_information": "Notes for Chapter 13 337\nFor nodes xandyin treap T,w h e r e y\u00a4x,l e tkDx:keyandiDy:key.W e\nde\ufb01ne indicator random variables\nXikDIfyis in the right spine of the left subtree of xg:\nf.Show that XikD1if and only if y:priority >x : priority ,y:key<x : key, and,\nfor every \u00b4such that y:key<\u00b4 : key<x : key,w eh a v e y:priority <\u00b4 : priority .\ng.Show that\nPrfXikD1gD.k/NULi/NUL1/\u0160\n.k/NULiC1/\u0160\nD1\n.k/NULiC1/.k/NULi/:\nh.Show that\nE\u0152C /c141Dk/NUL1X\njD11\nj.jC1/\nD1/NUL1\nk:\ni.Use a symmetry argument to show that\nE\u0152D/c141D1/NUL1\nn/NULkC1:\nj.Conclude that the expected number of rotations performed when inserting a\nnode into a treap is less than 2.\nChapter notes\nThe idea of balancing a search tree is due to Adel\u2019son-Vel\u2019ski\u02d8 \u0131 and Landis [2], who\nintroduced a class of balanced search trees called \u201cAVL trees\u201d in 1962, described inProblem 13-3. Another class of search trees, called \u201c2-3 trees,\u201d was introduced byJ. E. Hopcroft (unpublished) in 1970. A 2-3 tree maintains balance by manipulatingthe degrees of nodes in the tree. Chapter 18 covers a generalization of 2-3 treesintroduced by Bayer and McCreight [35], called \u201cB-trees.\u201d\nRed-black trees were invented by Bayer [34] under the name \u201csymmetric binary\nB-trees.\u201d Guibas and Sedgewick [155] studied their properties at length and in-troduced the red/black color convention. Andersson [15] gives a simpler-to-code", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "358": {"page_number": 359, "page_information": "338 Chapter 13 Red-Black Trees\nvariant of red-black trees. Weiss [351] calls this variant AA-trees. An AA-tree is\nsimilar to a red-black tree except that left children may never be red.\nTreaps, the subject of Problem 13-4, were proposed by Seidel and Aragon [309].\nThey are the default implementation of a dictionary in LEDA [253], which is awell-implemented collection of data structures and algorithms.\nThere are many other variations on balanced binary trees, including weight-\nbalanced trees [264], k-neighbor trees [245], and scapegoat trees [127]. Perhaps\nthe most intriguing are the \u201csplay trees\u201d introduced by Sleator and Tarjan [320],\nwhich are \u201cself-adjusting.\u201d (See Tarjan [330] for a good description of splay trees.)\nSplay trees maintain balance without any explicit balance condition such as color.Instead, \u201csplay operations\u201d (which involve rotations) are performed within the treeevery time an access is made. The amortized cost (see Chapter 17) of each opera-t i o no na n n-node tree is O.lgn/.\nSkip lists [286] provide an alternative to balanced binary trees. A skip list is a\nlinked list that is augmented with a number of additional pointers. Each dictionary\noperation runs in expected time O.lgn/on a skip list of nitems.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "359": {"page_number": 360, "page_information": "14 Augmenting Data Structures\nSome engineering situations require no more than a \u201ctextbook\u201d data struc-\nture\u2014such as a doubly linked list, a hash table, or a binary search tree\u2014but manyothers require a dash of creativity. Only in rare situations will you need to cre-ate an entirely new type of data structure, though. More often, it will suf\ufb01ce toaugment a textbook data structure by storing additional information in it. You canthen program new operations for the data structure to support the desired applica-tion. Augmenting a data structure is not always straightforward, however, since theadded information must be updated and maintained by the ordinary operations onthe data structure.\nThis chapter discusses two data structures that we construct by augmenting red-\nblack trees. Section 14.1 describes a data structure that supports general order-\nstatistic operations on a dynamic set. We can then quickly \ufb01nd the ith smallest\nnumber in a set or the rank of a given element in the total ordering of the set.Section 14.2 abstracts the process of augmenting a data structure and provides a\ntheorem that can simplify the process of augmenting red-black trees. Section 14.3\nuses this theorem to help design a data structure for maintaining a dynamic set ofintervals, such as time intervals. Given a query interval, we can then quickly \ufb01ndan interval in the set that overlaps it.\n14.1 Dynamic order statistics\nChapter 9 introduced the notion of an order statistic. Speci\ufb01cally, the ith order\nstatistic of a set of nelements, where i2f1 ;2;:::;ng, is simply the element in the\nset with the ith smallest key. We saw how to determine any order statistic in O.n/\ntime from an unordered set. In this section, we shall see how to modify red-black\ntrees so that we can determine any order statistic for a dynamic set in O.lgn/time.\nWe shall also see how to compute the rank of an element\u2014its position in the linear\norder of the set\u2014in O.lgn/time.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "360": {"page_number": 361, "page_information": "340 Chapter 14 Augmenting Data Structures\n1371 210\n141614\n21 12 47\n2019 212117\n28\n35 393847 304126\n121412\n1\n1135 1720\nkey\nsize\nFigure 14.1 An order-statistic tree, which is an augmented red-black tree. Shaded nodes are red,\nand darkened nodes are black. In addition to its usual attributes, each node xhas an attribute x:size,\nwhich is the number of nodes, other than the sentinel, in the subtree rooted at x.\nFigure 14.1 shows a data structure that can support fast order-statistic operations.\nAnorder-statistic tree Tis simply a red-black tree with additional information\nstored in each node. Besides the usual red-black tree attributes x:key,x:color ,x:p,\nx:left,a n d x:right in a node x, we have another attribute, x:size. This attribute\ncontains the number of (internal) nodes in the subtree rooted at x(including x\nitself), that is, the size of the subtree. If we de\ufb01ne the sentinel\u2019s size to be 0\u2014that\nis, we set T:nil:sizeto be 0\u2014then we have the identity\nx:sizeDx:left:sizeCx:right:sizeC1:\nWe do not require keys to be distinct in an order-statistic tree. (For example, the\ntree in Figure 14.1 has two keys with value 14 and two keys with value 21.) In thepresence of equal keys, the above notion of rank is not well de\ufb01ned. We removethis ambiguity for an order-statistic tree by de\ufb01ning the rank of an element as theposition at which it would be printed in an inorder walk of the tree. In Figure 14.1,for example, the key 14 stored in a black node has rank 5, and the key 14 stored ina red node has rank 6.\nRetrieving an element with a given rank\nBefore we show how to maintain this size information during insertion and dele-\ntion, let us examine the implementation of two order-statistic queries that use thisadditional information. We begin with an operation that retrieves an element witha given rank. The procedure OS-S\nELECT .x; i/ returns a pointer to the node con-\ntaining the ith smallest key in the subtree rooted at x. To \ufb01nd the node with the ith\nsmallest key in an order-statistic tree T, we call OS-S ELECT .T:root;i/.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "361": {"page_number": 362, "page_information": "14.1 Dynamic order statistics 341\nOS-S ELECT .x; i/\n1rDx:left:sizeC1\n2ifi==r\n3 return x\n4elseif i<r\n5 return OS-S ELECT .x:left;i/\n6else return OS-S ELECT .x:right;i/NULr/\nIn line 1 of OS-S ELECT , we compute r, the rank of node xwithin the subtree\nrooted at x.T h e v a l u e o f x:left:sizeis the number of nodes that come before x\nin an inorder tree walk of the subtree rooted at x. Thus, x:left:sizeC1is the\nrank of xwithin the subtree rooted at x.I fiDr, then node xis the ith smallest\nelement, and so we return xin line 3. If i<r , then the ith smallest element\nresides in x\u2019s left subtree, and so we recurse on x:leftin line 5. If i>r ,t h e n\ntheith smallest element resides in x\u2019s right subtree. Since the subtree rooted at x\ncontains relements that come before x\u2019s right subtree in an inorder tree walk, the\nith smallest element in the subtree rooted at xis the .i/NULr/th smallest element in\nthe subtree rooted at x:right . Line 6 determines this element recursively.\nTo see how OS-S ELECT operates, consider a search for the 17th smallest ele-\nment in the order-statistic tree of Figure 14.1. We begin with xas the root, whose\nkey is 26, and with iD17. Since the size of 26\u2019s left subtree is 12, its rank is 13.\nThus, we know that the node with rank 17 is the 17/NUL13D4th smallest element\nin 26\u2019s right subtree. After the recursive call, xis the node with key 41, and iD4.\nSince the size of 41\u2019s left subtree is 5, its rank within its subtree is 6. Thus, weknow that the node with rank 4 is the 4th smallest element in 41\u2019s left subtree. Af-ter the recursive call, xis the node with key 30, and its rank within its subtree is 2.\nThus, we recurse once again to \ufb01nd the 4/NUL2D2nd smallest element in the subtree\nrooted at the node with key 38. We now \ufb01nd that its left subtree has size 1, which\nmeans it is the second smallest element. Thus, the procedure returns a pointer tothe node with key 38.\nBecause each recursive call goes down one level in the order-statistic tree, the\ntotal time for OS-S\nELECT is at worst proportional to the height of the tree. Since\nthe tree is a red-black tree, its height is O.lgn/,w h e r e nis the number of nodes.\nThus, the running time of OS-S ELECT isO.lgn/for a dynamic set of nelements.\nDetermining the rank of an element\nGiven a pointer to a node xin an order-statistic tree T, the procedure OS-R ANK\nreturns the position of xin the linear order determined by an inorder tree walk\nofT.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "362": {"page_number": 363, "page_information": "342 Chapter 14 Augmenting Data Structures\nOS-R ANK.T; x/\n1rDx:left:sizeC1\n2yDx\n3while y\u00a4T:root\n4 ify==y:p:right\n5 rDrCy:p:left:sizeC1\n6 yDy:p\n7return r\nThe procedure works as follows. We can think of node x\u2019s rank as the number of\nnodes preceding xin an inorder tree walk, plus 1 for xitself. OS-R ANK maintains\nthe following loop invariant:\nAt the start of each iteration of the while loop of lines 3\u20136, ris the rank\nofx:keyin the subtree rooted at node y.\nWe use this loop invariant to show that OS-R ANK works correctly as follows:\nInitialization: Prior to the \ufb01rst iteration, line 1 sets rto be the rank of x:keywithin\nthe subtree rooted at x. Setting yDxin line 2 makes the invariant true the\n\ufb01rst time the test in line 3 executes.\nMaintenance: At the end of each iteration of the while loop, we set yDy:p.\nThus we must show that if ris the rank of x:keyin the subtree rooted at yat the\nstart of the loop body, then ris the rank of x:keyin the subtree rooted at y:p\nat the end of the loop body. In each iteration of the while loop, we consider\nthe subtree rooted at y:p. We have already counted the number of nodes in the\nsubtree rooted at node ythat precede xin an inorder walk, and so we must add\nthe nodes in the subtree rooted at y\u2019s sibling that precede xin an inorder walk,\nplus1fory:pif it, too, precedes x.I fyis a left child, then neither y:pnor any\nnode in y:p\u2019s right subtree precedes x,a n ds ow el e a v e ralone. Otherwise, yis\na right child and all the nodes in y:p\u2019s left subtree precede x, as does y:pitself.\nThus, in line 5, we add y:p:left:sizeC1to the current value of r.\nTermination: The loop terminates when yDT:root, so that the subtree rooted\natyis the entire tree. Thus, the value of ris the rank of x:keyin the entire tree.\nAs an example, when we run OS-R ANK on the order-statistic tree of Figure 14.1\nto \ufb01nd the rank of the node with key 38, we get the following sequence of valuesofy:keyandrat the top of the while loop:\niteration y:key r\n13 8 2\n23 0 4\n34 1 442 6 1 7", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "363": {"page_number": 364, "page_information": "14.1 Dynamic order statistics 343\nThe procedure returns the rank 17.\nSince each iteration of the while loop takes O.1/ time, and ygoes up one level in\nthe tree with each iteration, the running time of OS-R ANK is at worst proportional\nto the height of the tree: O.lgn/on an n-node order-statistic tree.\nMaintaining subtree sizes\nGiven the size attribute in each node, OS-S ELECT and OS-R ANK can quickly\ncompute order-statistic information. But unless we can ef\ufb01ciently maintain theseattributes within the basic modifying operations on red-black trees, our work willhave been for naught. We shall now show how to maintain subtree sizes for bothinsertion and deletion without affecting the asymptotic running time of either op-eration.\nWe noted in Section 13.3 that insertion into a red-black tree consists of two\nphases. The \ufb01rst phase goes down the tree from the root, inserting the new nodeas a child of an existing node. The second phase goes up the tree, changing colorsand performing rotations to maintain the red-black properties.\nTo maintain the subtree sizes in the \ufb01rst phase, we simply increment x:sizefor\neach node xon the simple path traversed from the root down toward the leaves. The\nnew node added gets a sizeof 1. Since there are O.lgn/nodes on the traversed\npath, the additional cost of maintaining the sizeattributes is O.lgn/.\nIn the second phase, the only structural changes to the underlying red-black tree\nare caused by rotations, of which there are at most two. Moreover, a rotation isa local operation: only two nodes have their sizeattributes invalidated. The link\naround which the rotation is performed is incident on these two nodes. Referringto the code for L\nEFT-ROTATE .T; x/ in Section 13.2, we add the following lines:\n13y:sizeDx:size\n14x:sizeDx:left:sizeCx:right:sizeC1\nFigure 14.2 illustrates how the attributes are updated. The change to R IGHT -\nROTATE is symmetric.\nSince at most two rotations are performed during insertion into a red-black tree,\nwe spend only O.1/ additional time updating sizeattributes in the second phase.\nThus, the total time for insertion into an n-node order-statistic tree is O.lgn/,\nwhich is asymptotically the same as for an ordinary red-black tree.\nDeletion from a red-black tree also consists of two phases: the \ufb01rst operates\non the underlying search tree, and the second causes at most three rotations andotherwise performs no structural changes. (See Section 13.4.) The \ufb01rst phaseeither removes one node yfrom the tree or moves upward it within the tree. To\nupdate the subtree sizes, we simply traverse a simple path from node y(starting\nfrom its original position within the tree) up to the root, decrementing the size", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "364": {"page_number": 365, "page_information": "344 Chapter 14 Augmenting Data Structures\nLEFT-ROTATE (T,x)\nRIGHT-ROTATE (T,y)93\n19y\n42\n11x\n6 479342\n19\n12\n6\n4 7x\ny\nFigure 14.2 Updating subtree sizes during rotations. The link around which we rotate is incident\non the two nodes whose sizeattributes need to be updated. The updates are local, requiring only the\nsizeinformation stored in x,y, and the roots of the subtrees shown as triangles.\nattribute of each node on the path. Since this path has length O.lgn/in an n-\nnode red-black tree, the additional time spent maintaining sizeattributes in the \ufb01rst\nphase is O.lgn/. We handle the O.1/ rotations in the second phase of deletion\nin the same manner as for insertion. Thus, both insertion and deletion, includingmaintaining the sizeattributes, take O.lgn/time for an n-node order-statistic tree.\nExercises\n14.1-1\nShow how OS-S\nELECT .T:root; 10/ operates on the red-black tree Tof Fig-\nure 14.1.\n14.1-2\nShow how OS-R ANK.T; x/ operates on the red-black tree Tof Figure 14.1 and\nthe node xwithx:keyD35.\n14.1-3\nWrite a nonrecursive version of OS-S ELECT .\n14.1-4\nWrite a recursive procedure OS-K EY-RANK.T; k/ that takes as input an order-\nstatistic tree Tand a key kand returns the rank of kin the dynamic set represented\nbyT. Assume that the keys of Tare distinct.\n14.1-5\nGiven an element xin an n-node order-statistic tree and a natural number i,h o w\ncan we determine the ith successor of xin the linear order of the tree in O.lgn/\ntime?", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "365": {"page_number": 366, "page_information": "14.2 How to augment a data structure 345\n14.1-6\nObserve that whenever we reference the size attribute of a node in either OS-\nSELECT or OS-R ANK, we use it only to compute a rank. Accordingly, suppose\nwe store in each node its rank in the subtree of which it is the root. Show how tomaintain this information during insertion and deletion. (Remember that these twooperations can cause rotations.)\n14.1-7\nShow how to use an order-statistic tree to count the number of inversions (see\nProblem 2-4) in an array of size nin time O.n lgn/.\n14.1-8 ?\nConsider nchords on a circle, each de\ufb01ned by its endpoints. Describe an O.n lgn/-\ntime algorithm to determine the number of pairs of chords that intersect inside thecircle. (For example, if the nchords are all diameters that meet at the center, then\nthe correct answer is/NUL\nn\n2/SOH\n.) Assume that no two chords share an endpoint.\n14.2 How to augment a data structure\nThe process of augmenting a basic data structure to support additional functionality\noccurs quite frequently in algorithm design. We shall use it again in the next sectionto design a data structure that supports operations on intervals. In this section, weexamine the steps involved in such augmentation. We shall also prove a theoremthat allows us to augment red-black trees easily in many cases.\nWe can break the process of augmenting a data structure into four steps:\n1. Choose an underlying data structure.\n2. Determine additional information to maintain in the underlying data structure.3. Verify that we can maintain the additional information for the basic modifying\noperations on the underlying data structure.\n4. Develop new operations.\nAs with any prescriptive design method, you should not blindly follow the steps\nin the order given. Most design work contains an element of trial and error, and\nprogress on all steps usually proceeds in parallel. There is no point, for example, in\ndetermining additional information and developing new operations (steps 2 and 4)\nif we will not be able to maintain the additional information ef\ufb01ciently. Neverthe-\nless, this four-step method provides a good focus for your efforts in augmentinga data structure, and it is also a good way to organize the documentation of anaugmented data structure.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "366": {"page_number": 367, "page_information": "346 Chapter 14 Augmenting Data Structures\nWe followed these steps in Section 14.1 to design our order-statistic trees. For\nstep 1, we chose red-black trees as the underlying data structure. A clue to thesuitability of red-black trees comes from their ef\ufb01cient support of other dynamic-set operations on a total order, such as M\nINIMUM ,M AXIMUM ,SUCCESSOR ,a n d\nPREDECESSOR .\nFor step 2, we added the sizeattribute, in which each node xstores the size of the\nsubtree rooted at x. Generally, the additional information makes operations more\nef\ufb01cient. For example, we could have implemented OS-S ELECT and OS-R ANK\nusing just the keys stored in the tree, but they would not have run in O.lgn/time.\nSometimes, the additional information is pointer information rather than data, asin Exercise 14.2-1.\nFor step 3, we ensured that insertion and deletion could maintain the sizeat-\ntributes while still running in O.lgn/time. Ideally, we should need to update only\na few elements of the data structure in order to maintain the additional information.For example, if we simply stored in each node its rank in the tree, the OS-S\nELECT\nand OS-R ANK procedures would run quickly, but inserting a new minimum ele-\nment would cause a change to this information in every node of the tree. When we\nstore subtree sizes instead, inserting a new element causes information to change\nin only O.lgn/nodes.\nFor step 4, we developed the operations OS-S ELECT and OS-R ANK. After all,\nthe need for new operations is why we bother to augment a data structure in the \ufb01rstplace. Occasionally, rather than developing new operations, we use the additional\ninformation to expedite existing ones, as in Exercise 14.2-1.\nAugmenting red-black trees\nWhen red-black trees underlie an augmented data structure, we can prove that in-\nsertion and deletion can always ef\ufb01ciently maintain certain kinds of additional in-\nformation, thereby making step 3 very easy. The proof of the following theorem issimilar to the argument from Section 14.1 that we can maintain the sizeattribute\nfor order-statistic trees.\nTheorem 14.1 (Augmenting a red-black tree)\nLetfbe an attribute that augments a red-black tree Tofnnodes, and suppose that\nthe value of ffor each node xdepends on only the information in nodes x,x:left,\nandx:right , possibly including x:left:fandx:right:f. Then, we can maintain the\nvalues of fin all nodes of Tduring insertion and deletion without asymptotically\naffecting the O.lgn/performance of these operations.\nProof The main idea of the proof is that a change to an fattribute in a node x\npropagates only to ancestors of xin the tree. That is, changing x:fmay re-", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "367": {"page_number": 368, "page_information": "14.2 How to augment a data structure 347\nquire x:p:fto be updated, but nothing else; updating x:p:fmay require x:p:p:f\nto be updated, but nothing else; and so on up the tree. Once we have updatedT:root:f, no other node will depend on the new value, and so the process termi-\nnates. Since the height of a red-black tree is O.lgn/, changing an fattribute in a\nnode costs O.lgn/time in updating all nodes that depend on the change.\nInsertion of a node xintoTconsists of two phases. (See Section 13.3.) The\n\ufb01rst phase inserts xas a child of an existing node x:p. We can compute the value\nofx:finO.1/ time since, by supposition, it depends only on information in the\nother attributes of xitself and the information in x\u2019s children, but x\u2019s children are\nboth the sentinel T:nil. Once we have computed x:f, the change propagates up\nthe tree. Thus, the total time for the \ufb01rst phase of insertion is O.lgn/. During the\nsecond phase, the only structural changes to the tree come from rotations. Sinceonly two nodes change in a rotation, the total time for updating the fattributes\nisO.lgn/per rotation. Since the number of rotations during insertion is at most\ntwo, the total time for insertion is O.lgn/.\nLike insertion, deletion has two phases. (See Section 13.4.) In the \ufb01rst phase,\nchanges to the tree occur when the deleted node is removed from the tree. If the\ndeleted node had two children at the time, then its successor moves into the position\nof the deleted node. Propagating the updates to fcaused by these changes costs\nat most O.lgn/, since the changes modify the tree locally. Fixing up the red-black\ntree during the second phase requires at most three rotations, and each rotationrequires at most O.lgn/time to propagate the updates to f. Thus, like insertion,\nthe total time for deletion is O.lgn/.\nIn many cases, such as maintaining the sizeattributes in order-statistic trees, the\ncost of updating after a rotation is O.1/ , rather than the O.lgn/derived in the proof\nof Theorem 14.1. Exercise 14.2-3 gives an example.\nExercises\n14.2-1\nShow, by adding pointers to the nodes, how to support each of the dynamic-setqueries M\nINIMUM ,MAXIMUM ,SUCCESSOR ,a n dP REDECESSOR inO.1/ worst-\ncase time on an augmented order-statistic tree. The asymptotic performance ofother operations on order-statistic trees should not be affected.\n14.2-2\nCan we maintain the black-heights of nodes in a red-black tree as attributes in the\nnodes of the tree without affecting the asymptotic performance of any of the red-\nblack tree operations? Show how, or argue why not. How about maintaining thedepths of nodes?", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "368": {"page_number": 369, "page_information": "348 Chapter 14 Augmenting Data Structures\n14.2-3 ?\nLet\u02ddbe an associative binary operator, and let abe an attribute maintained in each\nnode of a red-black tree. Suppose that we want to include in each node xan addi-\ntional attribute fsuch that x:fDx1:a\u02ddx2:a\u02dd/SOH/SOH/SOH\u02dd xm:a,w h e r e x1;x2;:::;x m\nis the inorder listing of nodes in the subtree rooted at x. Show how to update the f\nattributes in O.1/ time after a rotation. Modify your argument slightly to apply it\nto the sizeattributes in order-statistic trees.\n14.2-4 ?\nWe wish to augment red-black trees with an operation RB-E NUMERATE . x;a;b/\nthat outputs all the keys ksuch that a/DC4k/DC4bin a red-black tree rooted at x.\nDescribe how to implement RB-E NUMERATE in\u201a.mClgn/time, where mis the\nnumber of keys that are output and nis the number of internal nodes in the tree.\n(Hint: You do not need to add new attributes to the red-black tree.)\n14.3 Interval trees\nIn this section, we shall augment red-black trees to support operations on dynamic\nsets of intervals. A closed interval is an ordered pair of real numbers \u0152t1;t2/c141, with\nt1/DC4t2. The interval \u0152t1;t2/c141represents the setft2RWt1/DC4t/DC4t2g.Open and\nhalf-open intervals omit both or one of the endpoints from the set, respectively. In\nthis section, we shall assume that intervals are closed; extending the results to openand half-open intervals is conceptually straightforward.\nIntervals are convenient for representing events that each occupy a continuous\nperiod of time. We might, for example, wish to query a database of time intervalsto \ufb01nd out what events occurred during a given interval. The data structure in thissection provides an ef\ufb01cient means for maintaining such an interval database.\nWe can represent an interval \u0152t\n1;t2/c141as an object i, with attributes i:lowDt1\n(thelow endpoint )a n d i:highDt2(thehigh endpoint ). We say that intervals i\nandi0overlap ifi\\i0\u00a4;,t h a ti s ,i f i:low/DC4i0:high andi0:low/DC4i:high.A s\nFigure 14.3 shows, any two intervals iandi0satisfy the interval trichotomy ;t h a t\nis, exactly one of the following three properties holds:\na.iandi0overlap,\nb.iis to the left of i0(i.e.,i:high<i0:low),\nc.iis to the right of i0(i.e.,i0:high<i :low).\nAninterval tree is a red-black tree that maintains a dynamic set of elements, with\neach element xcontaining an interval x:int. Interval trees support the following\noperations:", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "369": {"page_number": 370, "page_information": "14.3 Interval trees 349\niii i\n(a)\ni\n(b)i\n(c)i\u2032 i\u2032 i\u2032 i\u2032\ni\u2032i\u2032\nFigure 14.3 The interval trichotomy for two closed intervals iandi0.(a)Ifiandi0overlap, there\nare four situations; in each, i:low/DC4i0:high andi0:low/DC4i:high.(b)The intervals do not overlap,\nandi:high<i0:low.(c)The intervals do not overlap, and i0:high<i :low.\nINTERVAL -INSERT .T; x/ adds the element x, whose intattribute is assumed to\ncontain an interval, to the interval tree T.\nINTERVAL -DELETE .T; x/ removes the element xfrom the interval tree T.\nINTERVAL -SEARCH .T; i/ returns a pointer to an element xin the interval tree T\nsuch that x:intoverlaps interval i, or a pointer to the sentinel T:nilif no such\nelement is in the set.\nFigure 14.4 shows how an interval tree represents a set of intervals. We shall track\nthe four-step method from Section 14.2 as we review the design of an interval treeand the operations that run on it.\nStep 1: Underlying data structure\nWe choose a red-black tree in which each node xcontains an interval x:intand the\nkey of xis the low endpoint, x:int:low, of the interval. Thus, an inorder tree walk\nof the data structure lists the intervals in sorted order by low endpoint.\nStep 2: Additional information\nIn addition to the intervals themselves, each node xcontains a value x:max,w h i c h\nis the maximum value of any interval endpoint stored in the subtree rooted at x.\nStep 3: Maintaining the information\nWe must verify that insertion and deletion take O.lgn/time on an interval tree\nofnnodes. We can determine x:max given interval x:intand the max values of\nnode x\u2019s children:", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "370": {"page_number": 371, "page_information": "350 Chapter 14 Augmenting Data Structures\n0 5 10 15 20 25 300568151617192526 26\n30\n20\n19\n21\n23\n9\n10\n8\n3(a)\n[0,3]\n3[6,10]\n10[5,8]\n10[8,9]\n23\n[15,23]\n23[16,21]\n30\n[17,19]\n20[26,26]\n26\n[19,20]\n20(b)[25,30]\n30int\nmax\nFigure 14.4 An interval tree. (a)A set of 10 intervals, shown sorted bottom to top by left endpoint.\n(b)The interval tree that represents them. Each node xcontains an interval, shown above the dashed\nline, and the maximum value of any interval endpoint in the subtree rooted at x, shown below the\ndashed line. An inorder tree walk of the tree lists the nodes in sorted order by left endpoint.\nx:maxDmax.x:int:high;x:left:max;x:right:max/:\nThus, by Theorem 14.1, insertion and deletion run in O.lgn/time. In fact, we\ncan update the max attributes after a rotation in O.1/ time, as Exercises 14.2-3\nand 14.3-1 show.\nStep 4: Developing new operations\nThe only new operation we need is I NTERVAL -SEARCH .T; i/ , which \ufb01nds a node\nin tree Twhose interval overlaps interval i. If there is no interval that overlaps iin\nthe tree, the procedure returns a pointer to the sentinel T:nil.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "371": {"page_number": 372, "page_information": "14.3 Interval trees 351\nINTERVAL -SEARCH .T; i/\n1xDT:root\n2while x\u00a4T:nilandidoes not overlap x:int\n3 ifx:left\u00a4T:nilandx:left:max/NAKi:low\n4 xDx:left\n5 elsexDx:right\n6return x\nThe search for an interval that overlaps istarts with xat the root of the tree and\nproceeds downward. It terminates when either it \ufb01nds an overlapping interval or x\npoints to the sentinel T:nil. Since each iteration of the basic loop takes O.1/ time,\nand since the height of an n-node red-black tree is O.lgn/,t h eI NTERVAL -SEARCH\nprocedure takes O.lgn/time.\nBefore we see why I NTERVAL -SEARCH is correct, let\u2019s examine how it works\non the interval tree in Figure 14.4. Suppose we wish to \ufb01nd an interval that overlapsthe interval iD\u015222; 25/c141 . We begin with xas the root, which contains \u015216; 21/c141 and\ndoes not overlap i.S i n c e x:left:maxD23is greater than i:lowD22, the loop\ncontinues with xas the left child of the root\u2014the node containing \u01528; 9/c141 , which also\ndoes not overlap i. This time, x:left:maxD10is less than i:lowD22,a n ds ot h e\nloop continues with the right child of xas the new x. Because the interval \u015215; 23/c141\nstored in this node overlaps i, the procedure returns this node.\nAs an example of an unsuccessful search, suppose we wish to \ufb01nd an interval\nthat overlaps iD\u015211; 14/c141 in the interval tree of Figure 14.4. We once again be-\ngin with xas the root. Since the root\u2019s interval \u015216; 21/c141 does not overlap i,a n d\nsince x:left:maxD23is greater than i:lowD11, we go left to the node con-\ntaining \u01528; 9/c141 .I n t e r v a l \u01528; 9/c141 does not overlap i,a n d x:left:maxD10is less than\ni:lowD11, and so we go right. (Note that no interval in the left subtree over-\nlapsi\n.) Interval \u015215; 23/c141 does not overlap i, and its left child is T:nil,s oa g a i nw e\ngo right, the loop terminates, and we return the sentinel T:nil.\nTo see why I NTERVAL -SEARCH is correct, we must understand why it suf\ufb01ces\nto examine a single path from the root. The basic idea is that at any node x,\nifx:intdoes not overlap i, the search always proceeds in a safe direction: the\nsearch will de\ufb01nitely \ufb01nd an overlapping interval if the tree contains one. Thefollowing theorem states this property more precisely.\nTheorem 14.2\nAny execution of I\nNTERVAL -SEARCH .T; i/ either returns a node whose interval\noverlaps i, or it returns T:niland the tree Tcontains no node whose interval over-\nlapsi.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "372": {"page_number": 373, "page_information": "352 Chapter 14 Augmenting Data Structures\ni\n(a) (b)i\u2032\ni\u2032 ii \u2032i\u2032\u2032i\u2032\u2032i\u2032\u2032\nFigure 14.5 Intervals in the proof of Theorem 14.2. The value of x:left:max is shown in each case\nas a dashed line. (a)The search goes right. No interval i0inx\u2019s left subtree can overlap i.(b)The\nsearch goes left. The left subtree of xcontains an interval that overlaps i(situation not shown),\norx\u2019s left subtree contains an interval i0such that i0:highDx:left:max.S i n c e idoes not overlap i0,\nneither does it overlap any interval i00inx\u2019s right subtree, since i0:low/DC4i00:low.\nProof Thewhile loop of lines 2\u20135 terminates either when xDT:niloriover-\nlapsx:int. In the latter case, it is certainly correct to return x. Therefore, we focus\non the former case, in which the while loop terminates because xDT:nil.\nWe use the following invariant for the while loop of lines 2\u20135:\nIf tree Tcontains an interval that overlaps i, then the subtree rooted at x\ncontains such an interval.\nWe use this loop invariant as follows:\nInitialization: Prior to the \ufb01rst iteration, line 1 sets xto be the root of T,s ot h a t\nthe invariant holds.\nMaintenance: Each iteration of the while loop executes either line 4 or line 5. We\nshall show that both cases maintain the loop invariant.\nIf line 5 is executed, then because of the branch condition in line 3, we\nhave x:leftDT:nil,o rx:left:max <i : low.I fx:leftDT:nil, the subtree\nrooted at x:leftclearly contains no interval that overlaps i, and so setting x\ntox:right maintains the invariant. Suppose, therefore, that x:left\u00a4T:niland\nx:left:max<i : low. As Figure 14.5(a) shows, for each interval i0inx\u2019s left\nsubtree, we have\ni0:high/DC4x:left:max\n<i : low:\nBy the interval trichotomy, therefore, i0andido not overlap. Thus, the left\nsubtree of xcontains no intervals that overlap i, so that setting xtox:right\nmaintains the invariant.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "373": {"page_number": 374, "page_information": "14.3 Interval trees 353\nIf, on the other hand, line 4 is executed, then we will show that the contrapos-\nitive of the loop invariant holds. That is, if the subtree rooted at x:leftcon-\ntains no interval overlapping i, then no interval anywhere in the tree overlaps i.\nSince line 4 is executed, then because of the branch condition in line 3, wehave x:left:max/NAKi:low. Moreover, by de\ufb01nition of the max attribute, x\u2019s left\nsubtree must contain some interval i\n0such that\ni0:highDx:left:max\n/NAKi:low:\n(Figure 14.5(b) illustrates the situation.) Since iandi0do not overlap, and\nsince it is not true that i0:high <i : low, it follows by the interval trichotomy\nthati:high<i0:low. Interval trees are keyed on the low endpoints of intervals,\nand thus the search-tree property implies that for any interval i00inx\u2019s right\nsubtree,\ni:high <i0:low\n/DC4i00:low:\nBy the interval trichotomy, iandi00do not overlap. We conclude that whether\nor not any interval in x\u2019s left subtree overlaps i, setting xtox:leftmaintains\nthe invariant.\nTermination: If the loop terminates when xDT:nil, then the subtree rooted at x\ncontains no interval overlapping i. The contrapositive of the loop invariant\nimplies that Tcontains no interval that overlaps i. Hence it is correct to return\nxDT:nil.\nThus, the I NTERVAL -SEARCH procedure works correctly.\nExercises\n14.3-1\nWrite pseudocode for L EFT-ROTATE that operates on nodes in an interval tree and\nupdates the max attributes in O.1/ time.\n14.3-2\nRewrite the code for I NTERVAL -SEARCH so that it works properly when all inter-\nvals are open.\n14.3-3\nDescribe an ef\ufb01cient algorithm that, given an interval i, returns an interval over-\nlapping ithat has the minimum low endpoint, or T:nilif no such interval exists.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "374": {"page_number": 375, "page_information": "354 Chapter 14 Augmenting Data Structures\n14.3-4\nG i v e na ni n t e r v a lt r e e Tand an interval i, describe how to list all intervals in T\nthat overlap iinO.min.n; k lgn//time, where kis the number of intervals in the\noutput list. ( Hint: One simple method makes several queries, modifying the tree\nbetween queries. A slightly more complicated method does not modify the tree.)\n14.3-5\nSuggest modi\ufb01cations to the interval-tree procedures to support the new opera-tion I\nNTERVAL -SEARCH -EXACTLY .T; i/ ,w h e r e Tis an interval tree and iis\nan interval. The operation should return a pointer to a node xinTsuch that\nx:int:lowDi:lowandx:int:highDi:high,o rT:nilifTcontains no such node.\nAll operations, including I NTERVAL -SEARCH -EXACTLY , should run in O.lgn/\ntime on an n-node interval tree.\n14.3-6\nShow how to maintain a dynamic set Qof numbers that supports the operation\nMIN-GAP, which gives the magnitude of the difference of the two closest num-\nbers in Q. For example, if QDf1; 5; 9; 15; 18; 22g,t h e nM IN-GAP.Q/ returns\n18/NUL15D3,s i n c e 15and18are the two closest numbers in Q. Make the op-\nerations I NSERT ,DELETE ,SEARCH ,a n dM IN-GAPas ef\ufb01cient as possible, and\nanalyze their running times.\n14.3-7 ?\nVLSI databases commonly represent an integrated circuit as a list of rectan-gles. Assume that each rectangle is rectilinearly oriented (sides parallel to thex-a n d y-axes), so that we represent a rectangle by its minimum and maximum x-\nandy-coordinates. Give an O.n lgn/-time algorithm to decide whether or not a set\nofnrectangles so represented contains two rectangles that overlap. Your algorithm\nneed not report all intersecting pairs, but it must report that an overlap exists if onerectangle entirely covers another, even if the boundary lines do not intersect. ( Hint:\nMove a \u201csweep\u201d line across the set of rectangles.)\nProblems\n14-1 Point of maximum overlapSuppose that we wish to keep track of a point of maximum overlap in a set of\nintervals\u2014a point with the largest number of intervals in the set that overlap it.\na.Show that there will always be a point of maximum overlap that is an endpoint\nof one of the segments.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "375": {"page_number": 376, "page_information": "Notes for Chapter 14 355\nb.Design a data structure that ef\ufb01ciently supports the operations I NTERVAL -\nINSERT ,INTERVAL -DELETE ,a n dF IND-POM, which returns a point of max-\nimum overlap. ( Hint: Keep a red-black tree of all the endpoints. Associate\na value ofC1with each left endpoint, and associate a value of /NUL1with each\nright endpoint. Augment each node of the tree with some extra information tomaintain the point of maximum overlap.)\n14-2 Josephus permutation\nWe de\ufb01ne the Josephus problem as follows. Suppose that npeople form a circle\nand that we are given a positive integer m/DC4n. Beginning with a designated\n\ufb01rst person, we proceed around the circle, removing every mth person. After each\nperson is removed, counting continues around the circle that remains. This processcontinues until we have removed all npeople. The order in which the people are\nremoved from the circle de\ufb01nes the .n; m/ -Josephus permutation of the integers\n1 ;2;:::;n . For example, the .7; 3/ -Josephus permutation is h3; 6; 2; 7; 5; 1; 4i.\na.Suppose that mis a constant. Describe an O.n/ -time algorithm that, given an\ninteger n, outputs the .n; m/ -Josephus permutation.\nb.Suppose that mis not a constant. Describe an O.n lgn/-time algorithm that,\ngiven integers nandm, outputs the .n; m/ -Josephus permutation.\nChapter notes\nIn their book, Preparata and Shamos [282] describe several of the interval trees\nthat appear in the literature, citing work by H. Edelsbrunner (1980) and E. M.McCreight (1981). The book details an interval tree that, given a static databaseofnintervals, allows us to enumerate all kintervals that overlap a given query\ninterval in O.kClgn/time.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "376": {"page_number": 377, "page_information": "IV Advanced Design and Analysis Techniques", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "377": {"page_number": 378, "page_information": "Introduction\nThis part covers three important techniques used in designing and analyzing ef\ufb01-\ncient algorithms: dynamic programming (Chapter 15), greedy algorithms (Chap-\nter 16), and amortized analysis (Chapter 17). Earlier parts have presented otherwidely applicable techniques, such as divide-and-conquer, randomization, and howto solve recurrences. The techniques in this part are somewhat more sophisticated,but they help us to attack many computational problems. The themes introduced inthis part will recur later in this book.\nDynamic programming typically applies to optimization problems in which we\nmake a set of choices in order to arrive at an optimal solution. As we make\neach choice, subproblems of the same form often arise. Dynamic programming\nis effective when a given subproblem may arise from more than one partial set of\nchoices; the key technique is to store the solution to each such subproblem in case itshould reappear. Chapter 15 shows how this simple idea can sometimes transformexponential-time algorithms into polynomial-time algorithms.\nLike dynamic-programming algorithms, greedy algorithms typically apply to\noptimization problems in which we make a set of choices in order to arrive at an\noptimal solution. The idea of a greedy algorithm is to make each choice in a locallyoptimal manner. A simple example is coin-changing: to minimize the number ofU.S. coins needed to make change for a given amount, we can repeatedly selectthe largest-denomination coin that is not larger than the amount that remains. Agreedy approach provides an optimal solution for many such problems much morequickly than would a dynamic-programming approach. We cannot always easilytell whether a greedy approach will be effective, however. Chapter 16 introduces", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "378": {"page_number": 379, "page_information": "358 Part IV Advanced Design and Analysis Techniques\nmatroid theory, which provides a mathematical basis that can help us to show that\na greedy algorithm yields an optimal solution.\nWe use amortized analysis to analyze certain algorithms that perform a sequence\nof similar operations. Instead of bounding the cost of the sequence of operationsby bounding the actual cost of each operation separately, an amortized analysisprovides a bound on the actual cost of the entire sequence. One advantage of thisapproach is that although some operations might be expensive, many others mightbe cheap. In other words, many of the operations might run in well under the worst-\ncase time. Amortized analysis is not just an analysis tool, however; it is also a way\nof thinking about the design of algorithms, since the design of an algorithm and theanalysis of its running time are often closely intertwined. Chapter 17 introducesthree ways to perform an amortized analysis of an algorithm.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "379": {"page_number": 380, "page_information": "15 Dynamic Programming\nDynamic programming, like the divide-and-conquer method, solves problems by\ncombining the solutions to subproblems. (\u201cProgramming\u201d in this context refersto a tabular method, not to writing computer code.) As we saw in Chapters 2and 4, divide-and-conquer algorithms partition the problem into disjoint subprob-lems, solve the subproblems recursively, and then combine their solutions to solvethe original problem. In contrast, dynamic programming applies when the subprob-lems overlap\u2014that is, when subproblems share subsubproblems. In this context,a divide-and-conquer algorithm does more work than necessary, repeatedly solv-ing the common subsubproblems. A dynamic-programming algorithm solves eachsubsubproblem just once and then saves its answer in a table, thereby avoiding thework of recomputing the answer every time it solves each subsubproblem.\nWe typically apply dynamic programming to optimization problems . Such prob-\nlems can have many possible solutions. Each solution has a value, and we wish to\ufb01nd a solution with the optimal (minimum or maximum) value. We call such a\nsolution anoptimal solution to the problem, as opposed to theoptimal solution,\nsince there may be several solutions that achieve the optimal value.\nWhen developing a dynamic-programming algorithm, we follow a sequence of\nfour steps:\n1. Characterize the structure of an optimal solution.\n2. Recursively de\ufb01ne the value of an optimal solution.\n3. Compute the value of an optimal solution, typically in a bottom-up fashion.\n4. Construct an optimal solution from computed information.\nSteps 1\u20133 form the basis of a dynamic-programming solution to a problem. If we\nneed only the value of an optimal solution, and not the solution itself, then wecan omit step 4. When we do perform step 4, we sometimes maintain additionalinformation during step 3 so that we can easily construct an optimal solution.\nThe sections that follow use the dynamic-programming method to solve some\noptimization problems. Section 15.1 examines the problem of cutting a rod into", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "380": {"page_number": 381, "page_information": "360 Chapter 15 Dynamic Programming\nrods of smaller length in way that maximizes their total value. Section 15.2 asks\nhow we can multiply a chain of matrices while performing the fewest total scalarmultiplications. Given these examples of dynamic programming, Section 15.3 dis-cusses two key characteristics that a problem must have for dynamic programmingto be a viable solution technique. Section 15.4 then shows how to \ufb01nd the longestcommon subsequence of two sequences via dynamic programming. Finally, Sec-tion 15.5 uses dynamic programming to construct binary search trees that are opti-mal, given a known distribution of keys to be looked up.\n15.1 Rod cutting\nOur \ufb01rst example uses dynamic programming to solve a simple problem in decid-ing where to cut steel rods. Serling Enterprises buys long steel rods and cuts theminto shorter rods, which it then sells. Each cut is free. The management of SerlingEnterprises wants to know the best way to cut up the rods.\nWe assume that we know, for iD1 ;2;::: , the price p\niin dollars that Serling\nEnterprises charges for a rod of length iinches. Rod lengths are always an integral\nnumber of inches. Figure 15.1 gives a sample price table.\nTherod-cutting problem is the following. Given a rod of length ninches and a\ntable of prices piforiD1 ;2;:::;n , determine the maximum revenue rnobtain-\nable by cutting up the rod and selling the pieces. Note that if the price pnfor a rod\nof length nis large enough, an optimal solution may require no cutting at all.\nConsider the case when nD4. Figure 15.2 shows all the ways to cut up a rod\nof4inches in length, including the way with no cuts at all. We see that cutting a\n4-inch rod into two 2-inch pieces produces revenue p2Cp2D5C5D10,w h i c h\nis optimal.\nWe can cut up a rod of length nin2n/NUL1different ways, since we have an in-\ndependent option of cutting, or not cutting, at distance iinches from the left end,\nlength i\n1234 5 6 7 8 9 1 0\nprice pi\n15891 01 71 72 02 43 0\nFigure 15.1 A sample price table for rods. Each rod of length iinches earns the company pi\ndollars of revenue.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "381": {"page_number": 382, "page_information": "15.1 Rod cutting 361\n9\n(a)1\n(b)8\n(c) (d)\n(e) (f) (g)1\n(h)11155 1 8\n5 1 15 1 15 1 1\nFigure 15.2 The8possible ways of cutting up a rod of length 4. Above each piece is the\nvalue of that piece, according to the sample price chart of Figure 15.1. The optimal strategy ispart (c)\u2014cutting the rod into two pieces of length 2\u2014which has total value 10.\nforiD1 ;2;:::;n/NUL1.1We denote a decomposition into pieces using ordinary\nadditive notation, so that 7D2C2C3indicates that a rod of length 7is cut into\nthree pieces\u2014two of length 2and one of length 3. If an optimal solution cuts the\nrod into kpieces, for some 1/DC4k/DC4n, then an optimal decomposition\nnDi1Ci2C/SOH/SOH/SOHC ik\nof the rod into pieces of lengths i1,i2, ..., ikprovides maximum corresponding\nrevenue\nrnDpi1Cpi2C/SOH/SOH/SOHC pik:\nFor our sample problem, we can determine the optimal revenue \ufb01gures ri,f o r\niD1 ;2;:::;1 0 , by inspection, with the corresponding optimal decompositions\n1If we required the pieces to be cut in order of nondecreasing size, there would be fewer ways\nto consider. For nD4, we would consider only 5such ways: parts (a), (b), (c), (e), and (h)\nin Figure 15.2. The number of ways is called the partition function ; it is approximately equal to\ne/EMp\n2n=3=4np\n3. This quantity is less than 2n/NUL1, but still much greater than any polynomial in n.\nWe shall not pursue this line of inquiry further, however.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "382": {"page_number": 383, "page_information": "362 Chapter 15 Dynamic Programming\nr1D1from solution 1D1(no cuts) ;\nr2D5from solution 2D2(no cuts) ;\nr3D8from solution 3D3(no cuts) ;\nr4D10from solution 4D2C2;\nr5D13from solution 5D2C3;\nr6D17from solution 6D6(no cuts) ;\nr7D18from solution 7D1C6or7D2C2C3;\nr8D22from solution 8D2C6;\nr9D25from solution 9D3C6;\nr10D30from solution 10D10 (no cuts) :\nMore generally, we can frame the values rnforn/NAK1in terms of optimal rev-\nenues from shorter rods:\nrnDmax.pn;r1Crn/NUL1;r2Crn/NUL2;:::;r n/NUL1Cr1/: (15.1)\nThe \ufb01rst argument, pn, corresponds to making no cuts at all and selling the rod of\nlength nas is. The other n/NUL1arguments to max correspond to the maximum rev-\nenue obtained by making an initial cut of the rod into two pieces of size iandn/NULi,\nfor each iD1 ;2;:::;n/NUL1, and then optimally cutting up those pieces further,\nobtaining revenues riandrn/NULifrom those two pieces. Since we don\u2019t know ahead\nof time which value of ioptimizes revenue, we have to consider all possible values\nforiand pick the one that maximizes revenue. We also have the option of picking\nnoiat all if we can obtain more revenue by selling the rod uncut.\nNote that to solve the original problem of size n, we solve smaller problems of\nthe same type, but of smaller sizes. Once we make the \ufb01rst cut, we may considerthe two pieces as independent instances of the rod-cutting problem. The overalloptimal solution incorporates optimal solutions to the two related subproblems,maximizing revenue from each of those two pieces. We say that the rod-cuttingproblem exhibits optimal substructure : optimal solutions to a problem incorporate\noptimal solutions to related subproblems, which we may solve independently.\nIn a related, but slightly simpler, way to arrange a recursive structure for the rod-\ncutting problem, we view a decomposition as consisting of a \ufb01rst piece of length i\ncut off the left-hand end, and then a right-hand remainder of length n/NULi.O n l y\nthe remainder, and not the \ufb01rst piece, may be further divided. We may view everydecomposition of a length- nrod in this way: as a \ufb01rst piece followed by some\ndecomposition of the remainder. When doing so, we can couch the solution withno cuts at all as saying that the \ufb01rst piece has size iDnand revenue p\nnand that\nthe remainder has size 0with corresponding revenue r0D0. We thus obtain the\nfollowing simpler version of equation (15.1):\nrnDmax\n1/DC4i/DC4n.piCrn/NULi/: (15.2)", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "383": {"page_number": 384, "page_information": "15.1 Rod cutting 363\nIn this formulation, an optimal solution embodies the solution to only onerelated\nsubproblem\u2014the remainder\u2014rather than two.\nRecursive top-down implementation\nThe following procedure implements the computation implicit in equation (15.2)\nin a straightforward, top-down, recursive manner.\nCUT-ROD.p; n/\n1ifn==0\n2 return 0\n3qD/NUL1\n4foriD1ton\n5 qDmax.q; p\u0152i/c141CCUT-ROD.p; n/NULi//\n6return q\nProcedure C UT-RODtakes as input an array p\u01521::n/c141 of prices and an integer n,\nand it returns the maximum revenue possible for a rod of length n.I fnD0,n o\nrevenue is possible, and so C UT-RODreturns 0in line 2. Line 3 initializes the\nmaximum revenue qto/NUL1, so that the forloop in lines 4\u20135 correctly computes\nqDmax 1/DC4i/DC4n.piCCUT-ROD.p; n/NULi//; line 6 then returns this value. A simple\ninduction on nproves that this answer is equal to the desired answer rn,u s i n g\nequation (15.2).\nIf you were to code up C UT-RODin your favorite programming language and run\nit on your computer, you would \ufb01nd that once the input size becomes moderatelylarge, your program would take a long time to run. For nD40, you would \ufb01nd that\nyour program takes at least several minutes, and most likely more than an hour. Infact, you would \ufb01nd that each time you increase nby1, your program\u2019s running\ntime would approximately double.\nWhy is C\nUT-RODso inef\ufb01cient? The problem is that C UT-RODcalls itself\nrecursively over and over again with the same parameter values; it solves thesame subproblems repeatedly. Figure 15.3 illustrates what happens for nD4:\nC\nUT-ROD.p; n/ calls C UT-ROD.p; n/NULi/foriD1 ;2;:::;n . Equivalently,\nCUT-ROD.p; n/ calls C UT-ROD.p; j / for each jD0; 1; : : : ; n/NUL1. When this\nprocess unfolds recursively, the amount of work done, as a function of n,g r o w s\nexplosively.\nTo analyze the running time of C UT-ROD,l e tT .n/ denote the total number of\ncalls made to C UT-RODwhen called with its second parameter equal to n.T h i s\nexpression equals the number of nodes in a subtree whose root is labeled nin the\nrecursion tree. The count includes the initial call at its root. Thus, T. 0 /D1and", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "384": {"page_number": 385, "page_information": "364 Chapter 15 Dynamic Programming\n3\n1 0\n0\n00 12 0\n0120104\nFigure 15.3 The recursion tree showing recursive calls resulting from a call C UT-ROD.p; n/ for\nnD4. Each node label gives the size nof the corresponding subproblem, so that an edge from\na parent with label sto a child with label tcorresponds to cutting off an initial piece of size s/NULt\nand leaving a remaining subproblem of size t. A path from the root to a leaf corresponds to one of\nthe2n/NUL1ways of cutting up a rod of length n. In general, this recursion tree has 2nnodes and 2n/NUL1\nleaves.\nT .n/D1Cn/NUL1X\njD0T. j/: (15.3)\nThe initial 1is for the call at the root, and the term T. j/ counts the number of calls\n(including recursive calls) due to the call C UT-ROD.p; n/NULi/,w h e r e jDn/NULi.\nAs Exercise 15.1-1 asks you to show,\nT .n/D2n; (15.4)\nand so the running time of C UT-RODis exponential in n.\nIn retrospect, this exponential running time is not so surprising. C UT-RODex-\nplicitly considers all the 2n/NUL1possible ways of cutting up a rod of length n.T h e\ntree of recursive calls has 2n/NUL1leaves, one for each possible way of cutting up the\nrod. The labels on the simple path from the root to a leaf give the sizes of eachremaining right-hand piece before making each cut. That is, the labels give thecorresponding cut points, measured from the right-hand end of the rod.\nUsing dynamic programming for optimal rod cutting\nWe now show how to convert C\nUT-RODinto an ef\ufb01cient algorithm, using dynamic\nprogramming.\nThe dynamic-programming method works as follows. Having observed that a\nnaive recursive solution is inef\ufb01cient because it solves the same subproblems re-\npeatedly, we arrange for each subproblem to be solved only once, saving its solu-\ntion. If we need to refer to this subproblem\u2019s solution again later, we can just look it", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "385": {"page_number": 386, "page_information": "15.1 Rod cutting 365\nup, rather than recompute it. Dynamic programming thus uses additional memory\nto save computation time; it serves an example of a time-memory trade-off .T h e\nsavings may be dramatic: an exponential-time solution may be transformed into apolynomial-time solution. A dynamic-programming approach runs in polynomialtime when the number of distinct subproblems involved is polynomial in the input\nsize and we can solve each such subproblem in polynomial time.\nThere are usually two equivalent ways to implement a dynamic-programming\napproach. We shall illustrate both of them with our rod-cutting example.\nThe \ufb01rst approach is top-down with memoization .\n2In this approach, we write\nthe procedure recursively in a natural manner, but modi\ufb01ed to save the result ofeach subproblem (usually in an array or hash table). The procedure now \ufb01rst checksto see whether it has previously solved this subproblem. If so, it returns the savedvalue, saving further computation at this level; if not, the procedure computes thevalue in the usual manner. We say that the recursive procedure has been memoized ;\nit \u201cremembers\u201d what results it has computed previously.\nThe second approach is the bottom-up method . This approach typically depends\non some natural notion of the \u201csize\u201d of a subproblem, such that solving any par-\nticular subproblem depends only on solving \u201csmaller\u201d subproblems. We sort the\nsubproblems by size and solve them in size order, smallest \ufb01rst. When solving aparticular subproblem, we have already solved all of the smaller subproblems itssolution depends upon, and we have saved their solutions. We solve each sub-problem only once, and when we \ufb01rst see it, we have already solved all of its\nprerequisite subproblems.\nThese two approaches yield algorithms with the same asymptotic running time,\nexcept in unusual circumstances where the top-down approach does not actuallyrecurse to examine all possible subproblems. The bottom-up approach often hasmuch better constant factors, since it has less overhead for procedure calls.\nHere is the the pseudocode for the top-down C\nUT-RODprocedure, with memo-\nization added:\nMEMOIZED -CUT-ROD.p; n/\n1l e t r\u0152 0::n /c141 be a new array\n2foriD0ton\n3 r\u0152i/c141D/NUL1\n4return MEMOIZED -CUT-ROD-AUX. p;n;r/\n2This is not a misspelling. The word really is memoization , not memorization .Memoization comes\nfrom memo , since the technique consists of recording a value so that we can look it up later.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "386": {"page_number": 387, "page_information": "366 Chapter 15 Dynamic Programming\nMEMOIZED -CUT-ROD-AUX. p;n;r/\n1ifr\u0152n/c141/NAK0\n2 return r\u0152n/c141\n3ifn==0\n4 qD0\n5elseqD/NUL1\n6 foriD1ton\n7 qDmax.q; p\u0152i/c141CMEMOIZED -CUT-ROD-AUX.p; n/NULi;r//\n8r\u0152n/c141Dq\n9return q\nHere, the main procedure M EMOIZED -CUT-RODinitializes a new auxiliary ar-\nrayr\u0152 0::n /c141 with the value/NUL1, a convenient choice with which to denote \u201cun-\nknown.\u201d (Known revenue values are always nonnegative.) It then calls its helper\nroutine, M EMOIZED -CUT-ROD-AUX.\nThe procedure M EMOIZED -CUT-ROD-AUXis just the memoized version of our\nprevious procedure, C UT-ROD. It \ufb01rst checks in line 1 to see whether the desired\nvalue is already known and, if it is, then line 2 returns it. Otherwise, lines 3\u20137compute the desired value qin the usual manner, line 8 saves it in r\u0152n/c141, and line 9\nreturns it.\nThe bottom-up version is even simpler:\nB\nOTTOM -UP-CUT-ROD.p; n/\n1l e t r\u0152 0::n /c141 b ean e wa r r a y\n2r\u01520/c141D0\n3forjD1ton\n4 qD/NUL1\n5 foriD1toj\n6 qDmax.q; p\u0152i/c141Cr\u0152j/NULi/c141/\n7 r\u0152j/c141Dq\n8return r\u0152n/c141\nFor the bottom-up dynamic-programming approach, B OTTOM -UP-CUT-ROD\nuses the natural ordering of the subproblems: a problem of size iis \u201csmaller\u201d\nthan a subproblem of size jifi<j . Thus, the procedure solves subproblems of\nsizes jD0; 1; : : : ; n ,i nt h a to r d e r .\nLine 1 of procedure B OTTOM -UP-CUT-RODcreates a new array r\u0152 0::n /c141 in\nwhich to save the results of the subproblems, and line 2 initializes r\u01520/c141to0,s i n c e\na rod of length 0earns no revenue. Lines 3\u20136 solve each subproblem of size j,f o r\njD1 ;2;:::;n , in order of increasing size. The approach used to solve a problem\nof a particular size jis the same as that used by C UT-ROD, except that line 6 now", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "387": {"page_number": 388, "page_information": "15.1 Rod cutting 367\n3\n0124\nFigure 15.4 The subproblem graph for the rod-cutting problem with nD4. The vertex labels\ngive the sizes of the corresponding subproblems. A directed edge .x; y/ indicates that we need a\nsolution to subproblem ywhen solving subproblem x. This graph is a reduced version of the tree of\nFigure 15.3, in which all nodes with the same label are collapsed into a single vertex and all edges\ngo from parent to child.\ndirectly references array entry r\u0152j/NULi/c141instead of making a recursive call to solve\nthe subproblem of size j/NULi. Line 7 saves in r\u0152j/c141 the solution to the subproblem\nof size j. Finally, line 8 returns r\u0152n/c141, which equals the optimal value rn.\nThe bottom-up and top-down versions have the same asymptotic running time.\nThe running time of procedure B OTTOM -UP-CUT-RODis\u201a.n2/, due to its\ndoubly-nested loop structure. The number of iterations of its inner forloop, in\nlines 5\u20136, forms an arithmetic series. The running time of its top-down counterpart,\nMEMOIZED -CUT-ROD,i sa l s o \u201a.n2/, although this running time may be a little\nharder to see. Because a recursive call to solve a previously solved subproblemreturns immediately, M\nEMOIZED -CUT-RODsolves each subproblem just once. It\nsolves subproblems for sizes 0; 1; : : : ; n . To solve a subproblem of size n,t h efor\nloop of lines 6\u20137 iterates ntimes. Thus, the total number of iterations of this for\nloop, over all recursive calls of M EMOIZED -CUT-ROD, forms an arithmetic series,\ngiving a total of \u201a.n2/iterations, just like the inner forloop of B OTTOM -UP-\nCUT-ROD. (We actually are using a form of aggregate analysis here. We shall see\naggregate analysis in detail in Section 17.1.)\nSubproblem graphs\nWhen we think about a dynamic-programming problem, we should understand the\nset of subproblems involved and how subproblems depend on one another.\nThesubproblem graph for the problem embodies exactly this information. Fig-\nure 15.4 shows the subproblem graph for the rod-cutting problem with nD4.I t\nis a directed graph, containing one vertex for each distinct subproblem. The sub-", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "388": {"page_number": 389, "page_information": "368 Chapter 15 Dynamic Programming\nproblem graph has a directed edge from the vertex for subproblem xto the vertex\nfor subproblem yif determining an optimal solution for subproblem xinvolves\ndirectly considering an optimal solution for subproblem y. For example, the sub-\nproblem graph contains an edge from xtoyif a top-down recursive procedure for\nsolving xdirectly calls itself to solve y. We can think of the subproblem graph\nas a \u201creduced\u201d or \u201ccollapsed\u201d version of the recursion tree for the top-down recur-sive method, in which we coalesce all nodes for the same subproblem into a singlevertex and direct all edges from parent to child.\nThe bottom-up method for dynamic programming considers the vertices of the\nsubproblem graph in such an order that we solve the subproblems yadjacent to\na given subproblem xbefore we solve subproblem x. (Recall from Section B.4\nthat the adjacency relation is not necessarily symmetric.) Using the terminologyfrom Chapter 22, in a bottom-up dynamic-programming algorithm, we consider thevertices of the subproblem graph in an order that is a \u201creverse topological sort,\u201d ora \u201ctopological sort of the transpose\u201d (see Section 22.4) of the subproblem graph. Inother words, no subproblem is considered until all of the subproblems it dependsupon have been solved. Similarly, using notions from the same chapter, we canview the top-down method (with memoization) for dynamic programming as a\u201cdepth-\ufb01rst search\u201d of the subproblem graph (see Section 22.3).\nThe size of the subproblem graph GD.V; E/ can help us determine the running\ntime of the dynamic programming algorithm. Since we solve each subproblem justonce, the running time is the sum of the times needed to solve each subproblem.\nTypically, the time to compute the solution to a subproblem is proportional to the\ndegree (number of outgoing edges) of the corresponding vertex in the subproblemgraph, and the number of subproblems is equal to the number of vertices in the sub-problem graph. In this common case, the running time of dynamic programmingis linear in the number of vertices and edges.\nReconstructing a solution\nOur dynamic-programming solutions to the rod-cutting problem return the value of\nan optimal solution, but they do not return an actual solution: a list of piece sizes.We can extend the dynamic-programming approach to record not only the optimalvalue computed for each subproblem, but also a choice that led to the optimal\nvalue. With this information, we can readily print an optimal solution.\nHere is an extended version of B\nOTTOM -UP-CUT-RODthat computes, for each\nrod size j, not only the maximum revenue rj, but also sj, the optimal size of the\n\ufb01rst piece to cut off:", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "389": {"page_number": 390, "page_information": "15.1 Rod cutting 369\nEXTENDED -BOTTOM -UP-CUT-ROD.p; n/\n1l e t r\u0152 0::n /c141 ands\u01520:: n/c141 be new arrays\n2r\u01520/c141D0\n3forjD1ton\n4 qD/NUL1\n5 foriD1toj\n6 ifq<p \u0152 i /c141Cr\u0152j/NULi/c141\n7 qDp\u0152i/c141Cr\u0152j/NULi/c141\n8 s\u0152j/c141Di\n9 r\u0152j/c141Dq\n10return rands\nThis procedure is similar to B OTTOM -UP-CUT-ROD, except that it creates the ar-\nraysin line 1, and it updates s\u0152j/c141 in line 8 to hold the optimal size iof the \ufb01rst\npiece to cut off when solving a subproblem of size j.\nThe following procedure takes a price table pand a rod size n, and it calls\nEXTENDED -BOTTOM -UP-CUT-RODto compute the array s\u01521:: n/c141 of optimal\n\ufb01rst-piece sizes and then prints out the complete list of piece sizes in an optimaldecomposition of a rod of length n:\nP\nRINT -CUT-ROD-SOLUTION .p; n/\n1.r; s/DEXTENDED -BOTTOM -UP-CUT-ROD.p; n/\n2while n>0\n3 print s\u0152n/c141\n4 nDn/NULs\u0152n/c141\nIn our rod-cutting example, the call E XTENDED -BOTTOM -UP-CUT-ROD.p; 10/\nwould return the following arrays:\ni\n0 1 2 3 456789 1 0\nr\u0152i/c141\n 0 1 5 8 10 13 17 18 22 25 30\ns\u0152i/c141\n 0 1 2 3 226123 1 0\nA call to P RINT -CUT-ROD-SOLUTION .p; 10/ would print just 10, but a call with\nnD7would print the cuts 1and6, corresponding to the \ufb01rst optimal decomposi-\ntion for r7given earlier.\nExercises\n15.1-1\nShow that equation (15.4) follows from equation (15.3) and the initial conditionT. 0 /D1.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "390": {"page_number": 391, "page_information": "370 Chapter 15 Dynamic Programming\n15.1-2\nShow, by means of a counterexample, that the following \u201cgreedy\u201d strategy doesnot always determine an optimal way to cut rods. De\ufb01ne the density of a rod of\nlength ito be p\ni=i, that is, its value per inch. The greedy strategy for a rod of\nlength ncuts off a \ufb01rst piece of length i,w h e r e 1/DC4i/DC4n, having maximum\ndensity. It then continues by applying the greedy strategy to the remaining piece oflength n/NULi.\n15.1-3\nConsider a modi\ufb01cation of the rod-cutting problem in which, in addition to a\nprice p\nifor each rod, each cut incurs a \ufb01xed cost of c. The revenue associated with\na solution is now the sum of the prices of the pieces minus the costs of making thecuts. Give a dynamic-programming algorithm to solve this modi\ufb01ed problem.\n15.1-4\nModify M\nEMOIZED -CUT-RODto return not only the value but the actual solution,\ntoo.\n15.1-5\nThe Fibonacci numbers are de\ufb01ned by recurrence (3.22). Give an O.n/ -time\ndynamic-programming algorithm to compute the nth Fibonacci number. Draw the\nsubproblem graph. How many vertices and edges are in the graph?\n15.2 Matrix-chain multiplication\nOur next example of dynamic programming is an algorithm that solves the problemof matrix-chain multiplication. We are given a sequence (chain) hA\n1;A2;:::;A ni\nofnmatrices to be multiplied, and we wish to compute the product\nA1A2/SOH/SOH/SOHAn: (15.5)\nWe can evaluate the expression (15.5) using the standard algorithm for multiply-\ning pairs of matrices as a subroutine once we have parenthesized it to resolve all\nambiguities in how the matrices are multiplied together. Matrix multiplication is\nassociative, and so all parenthesizations yield the same product. A product of ma-trices is fully parenthesized if it is either a single matrix or the product of two fully\nparenthesized matrix products, surrounded by parentheses. For example, if thechain of matrices is hA\n1;A2;A3;A4i, then we can fully parenthesize the product\nA1A2A3A4in \ufb01ve distinct ways:", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "391": {"page_number": 392, "page_information": "15.2 Matrix-chain multiplication 371\n.A1.A2.A3A4/// ;\n.A1..A 2A3/A4// ;\n..A 1A2/.A 3A4// ;\n..A 1.A2A3//A 4/;\n...A 1A2/A3/A4/:\nHow we parenthesize a chain of matrices can have a dramatic impact on the cost\nof evaluating the product. Consider \ufb01rst the cost of multiplying two matrices. Thestandard algorithm is given by the following pseudocode, which generalizes the\nS\nQUARE -MATRIX -MULTIPLY procedure from Section 4.2. The attributes rows\nandcolumns are the numbers of rows and columns in a matrix.\nMATRIX -MULTIPLY .A; B/\n1ifA:columns\u00a4B:rows\n2 error \u201cincompatible dimensions\u201d\n3elseletCb ean e w A:rows/STXB:columns matrix\n4 foriD1toA:rows\n5 forjD1toB:columns\n6 cijD0\n7 forkD1toA:columns\n8 cijDcijCaik/SOHbkj\n9 return C\nWe can multiply two matrices AandBonly if they are compatible : the number of\ncolumns of Amust equal the number of rows of B.I fAis ap/STXqmatrix and Bis\naq/STXrmatrix, the resulting matrix Cis ap/STXrmatrix. The time to compute Cis\ndominated by the number of scalar multiplications in line 8, which is pqr.I nw h a t\nfollows, we shall express costs in terms of the number of scalar multiplications.\nTo illustrate the different costs incurred by different parenthesizations of a matrix\nproduct, consider the problem of a chain hA1;A2;A3iof three matrices. Suppose\nthat the dimensions of the matrices are 10/STX100,100/STX5,a n d 5/STX50, respec-\ntively. If we multiply according to the parenthesization ..A 1A2/A3/, we perform\n10/SOH100/SOH5D5000 scalar multiplications to compute the 10/STX5matrix prod-\nuctA1A2, plus another 10/SOH5/SOH50D2500 scalar multiplications to multiply this\nmatrix by A3, for a total of 7500 scalar multiplications. If instead we multiply\naccording to the parenthesization .A1.A2A3//, we perform 100/SOH5/SOH50D25,000\nscalar multiplications to compute the 100/STX50matrix product A2A3, plus another\n10/SOH100/SOH50D50,000 scalar multiplications to multiply A1by this matrix, for a\ntotal of 75,000 scalar multiplications. Thus, computing the product according tothe \ufb01rst parenthesization is 10times faster.\nWe state the matrix-chain multiplication problem as follows: given a chain\nhA\n1;A2;:::;A niofnmatrices, where for iD1 ;2;:::;n , matrix Aihas dimension", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "392": {"page_number": 393, "page_information": "372 Chapter 15 Dynamic Programming\npi/NUL1/STXpi, fully parenthesize the product A1A2/SOH/SOH/SOHAnin a way that minimizes the\nnumber of scalar multiplications.\nNote that in the matrix-chain multiplication problem, we are not actually multi-\nplying matrices. Our goal is only to determine an order for multiplying matricesthat has the lowest cost. Typically, the time invested in determining this optimalorder is more than paid for by the time saved later on when actually performing thematrix multiplications (such as performing only 7500 scalar multiplications insteadof 75,000).\nCounting the number of parenthesizations\nBefore solving the matrix-chain multiplication problem by dynamic programming,\nlet us convince ourselves that exhaustively checking all possible parenthesizations\ndoes not yield an ef\ufb01cient algorithm. Denote the number of alternative parenthe-\nsizations of a sequence of nmatrices by P.n/ .W h e n nD1, we have just one\nmatrix and therefore only one way to fully parenthesize the matrix product. Whenn/NAK2, a fully parenthesized matrix product is the product of two fully parenthe-\nsized matrix subproducts, and the split between the two subproducts may occurbetween the kth and .kC1/st matrices for any kD1 ;2;:::;n/NUL1. Thus, we\nobtain the recurrence\nP.n/D\n/c128\n1 ifnD1;\nn/NUL1X\nkD1P.k/P.n/NULk/ifn/NAK2:(15.6)\nProblem 12-4 asked you to show that the solution to a similar recurrence is the\nsequence of Catalan numbers , which grows as /DEL.4n=n3=2/. A simpler exercise\n(see Exercise 15.2-3) is to show that the solution to the recurrence (15.6) is /DEL.2n/.\nThe number of solutions is thus exponential in n, and the brute-force method of\nexhaustive search makes for a poor strategy when determining how to optimally\nparenthesize a matrix chain.\nApplying dynamic programming\nWe shall use the dynamic-programming method to determine how to optimally\nparenthesize a matrix chain. In so doing, we shall follow the four-step sequence\nthat we stated at the beginning of this chapter:\n1. Characterize the structure of an optimal solution.\n2. Recursively de\ufb01ne the value of an optimal solution.\n3. Compute the value of an optimal solution.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "393": {"page_number": 394, "page_information": "15.2 Matrix-chain multiplication 373\n4. Construct an optimal solution from computed information.\nWe shall go through these steps in order, demonstrating clearly how we apply each\nstep to the problem.\nStep 1: The structure of an optimal parenthesization\nFor our \ufb01rst step in the dynamic-programming paradigm, we \ufb01nd the optimal sub-\nstructure and then use it to construct an optimal solution to the problem from opti-mal solutions to subproblems. In the matrix-chain multiplication problem, we canperform this step as follows. For convenience, let us adopt the notation A\ni::j,w h e r e\ni/DC4j, for the matrix that results from evaluating the product AiAiC1/SOH/SOH/SOHAj.O b -\nserve that if the problem is nontrivial, i.e., i<j , then to parenthesize the product\nAiAiC1/SOH/SOH/SOHAj, we must split the product between AkandAkC1for some integer k\nin the range i/DC4k<j . That is, for some value of k, we \ufb01rst compute the matrices\nAi:: kandAkC1::jand then multiply them together to produce the \ufb01nal product Ai::j.\nThe cost of parenthesizing this way is the cost of computing the matrix Ai:: k,p l u s\nthe cost of computing AkC1::j, plus the cost of multiplying them together.\nThe optimal substructure of this problem is as follows. Suppose that to op-\ntimally parenthesize AiAiC1/SOH/SOH/SOHAj, we split the product between AkandAkC1.\nThen the way we parenthesize the \u201cpre\ufb01x\u201d subchain AiAiC1/SOH/SOH/SOHAkwithin this\noptimal parenthesization of AiAiC1/SOH/SOH/SOHAjmust be an optimal parenthesization of\nAiAiC1/SOH/SOH/SOHAk. Why? If there were a less costly way to parenthesize AiAiC1/SOH/SOH/SOHAk,\nthen we could substitute that parenthesization in the optimal parenthesizationofA\niAiC1/SOH/SOH/SOHAjto produce another way to parenthesize AiAiC1/SOH/SOH/SOHAjwhose cost\nwas lower than the optimum: a contradiction. A similar observation holds for howwe parenthesize the subchain A\nkC1AkC2/SOH/SOH/SOHAjin the optimal parenthesization of\nAiAiC1/SOH/SOH/SOHAj: it must be an optimal parenthesization of AkC1AkC2/SOH/SOH/SOHAj.\nNow we use our optimal substructure to show that we can construct an optimal\nsolution to the problem from optimal solutions to subproblems. We have seen thatany solution to a nontrivial instance of the matrix-chain multiplication problemrequires us to split the product, and that any optimal solution contains within it op-timal solutions to subproblem instances. Thus, we can build an optimal solution toan instance of the matrix-chain multiplication problem by splitting the problem into\ntwo subproblems (optimally parenthesizing A\niAiC1/SOH/SOH/SOHAkandAkC1AkC2/SOH/SOH/SOHAj),\n\ufb01nding optimal solutions to subproblem instances, and then combining these op-timal subproblem solutions. We must ensure that when we search for the correctplace to split the product, we have considered all possible places, so that we aresure of having examined the optimal one.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "394": {"page_number": 395, "page_information": "374 Chapter 15 Dynamic Programming\nStep 2: A recursive solution\nNext, we de\ufb01ne the cost of an optimal solution recursively in terms of the optimal\nsolutions to subproblems. For the matrix-chain multiplication problem, we pick asour subproblems the problems of determining the minimum cost of parenthesizingA\niAiC1/SOH/SOH/SOHAjfor1/DC4i/DC4j/DC4n.L e t m\u0152i; j /c141 be the minimum number of scalar\nmultiplications needed to compute the matrix Ai::j; for the full problem, the lowest-\ncost way to compute A1::nwould thus be m\u01521; n/c141 .\nWe can de\ufb01ne m\u0152i; j /c141 recursively as follows. If iDj, the problem is trivial;\nthe chain consists of just one matrix Ai::iDAi, so that no scalar multiplications\nare necessary to compute the product. Thus, m\u0152i; i/c141D0foriD1 ;2;:::;n .T o\ncompute m\u0152i; j /c141 when i<j , we take advantage of the structure of an optimal\nsolution from step 1. Let us assume that to optimally parenthesize, we split theproduct A\niAiC1/SOH/SOH/SOHAjbetween AkandAkC1,w h e r e i/DC4k<j . Then, m\u0152i; j /c141\nequals the minimum cost for computing the subproducts Ai:: kandAkC1::j,p l u st h e\ncost of multiplying these two matrices together. Recalling that each matrix Aiis\npi/NUL1/STXpi, we see that computing the matrix product Ai::kAkC1::jtakes pi/NUL1pkpj\nscalar multiplications. Thus, we obtain\nm\u0152i; j /c141Dm\u0152i; k/c141Cm\u0152kC1; j /c141Cpi/NUL1pkpj:\nThis recursive equation assumes that we know the value of k, which we do not.\nThere are only j/NULipossible values for k, however, namely kDi;iC1 ;:::;j/NUL1.\nSince the optimal parenthesization must use one of these values for k, we need only\ncheck them all to \ufb01nd the best. Thus, our recursive de\ufb01nition for the minimum costof parenthesizing the product A\niAiC1/SOH/SOH/SOHAjbecomes\nm\u0152i; j /c141D(0 ifiDj;\nmin\ni/DC4k<jfm\u0152i; k/c141Cm\u0152kC1; j /c141Cpi/NUL1pkpjgifi<j:(15.7)\nThem\u0152i; j /c141 values give the costs of optimal solutions to subproblems, but they\ndo not provide all the information we need to construct an optimal solution. Tohelp us do so, we de\ufb01ne s\u0152i;j/c141 to be a value of kat which we split the product\nA\niAiC1/SOH/SOH/SOHAjin an optimal parenthesization. That is, s\u0152i;j/c141 equals a value ksuch\nthatm\u0152i; j /c141Dm\u0152i; k/c141Cm\u0152kC1; j /c141Cpi/NUL1pkpj.\nStep 3: Computing the optimal costs\nAt this point, we could easily write a recursive algorithm based on recurrence (15.7)\nto compute the minimum cost m\u01521; n/c141 for multiplying A1A2/SOH/SOH/SOHAn.A sw es a wf o r\nthe rod-cutting problem, and as we shall see in Section 15.3, this recursive algo-rithm takes exponential time, which is no better than the brute-force method ofchecking each way of parenthesizing the product.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "395": {"page_number": 396, "page_information": "15.2 Matrix-chain multiplication 375\nObserve that we have relatively few distinct subproblems: one subproblem for\neach choice of iandjsatisfying 1/DC4i/DC4j/DC4n,o r/NULn\n2/SOH\nCnD\u201a.n2/in all.\nA recursive algorithm may encounter each subproblem many times in differentbranches of its recursion tree. This property of overlapping subproblems is thesecond hallmark of when dynamic programming applies (the \ufb01rst hallmark beingoptimal substructure).\nInstead of computing the solution to recurrence (15.7) recursively, we compute\nthe optimal cost by using a tabular, bottom-up approach. (We present the corre-\nsponding top-down approach using memoization in Section 15.3.)\nWe shall implement the tabular, bottom-up method in the procedure M\nATRIX -\nCHAIN -ORDER , which appears below. This procedure assumes that matrix Ai\nhas dimensions pi/NUL1/STXpiforiD1 ;2;:::;n . Its input is a sequence pD\nhp0;p1;:::;p ni,w h e r e p:lengthDnC1. The procedure uses an auxiliary\ntable m \u0152 1::n ;1::n /c141 for storing the m\u0152i; j /c141 costs and another auxiliary table\ns\u0152 1::n/NUL1 ;2::n /c141 that records which index of kachieved the optimal cost in com-\nputing m\u0152i; j /c141 . We shall use the table sto construct an optimal solution.\nIn order to implement the bottom-up approach, we must determine which entries\nof the table we refer to when computing m\u0152i; j /c141 . Equation (15.7) shows that the\ncostm\u0152i; j /c141 of computing a matrix-chain product of j/NULiC1matrices depends only\non the costs of computing matrix-chain products of fewer than j/NULiC1matrices.\nThat is, for kDi;iC1 ;:::;j/NUL1, the matrix Ai::kis a product of k/NULiC1<\nj/NULiC1matrices and the matrix AkC1::jis a product of j/NULk<j/NULiC1\nmatrices. Thus, the algorithm should \ufb01ll in the table min a manner that corresponds\nto solving the parenthesization problem on matrix chains of increasing length. Forthe subproblem of optimally parenthesizing the chain A\niAiC1/SOH/SOH/SOHAj, we consider\nthe subproblem size to be the length j/NULiC1of the chain.\nMATRIX -CHAIN -ORDER .p/\n1nDp:length/NUL1\n2l e t m \u0152 1::n ;1::n /c141 ands\u0152 1::n/NUL1 ;2::n /c141 be new tables\n3foriD1ton\n4 m\u0152i; i/c141D0\n5forlD2ton //lis the chain length\n6 foriD1ton/NULlC1\n7 jDiCl/NUL1\n8 m\u0152i; j /c141D1\n9 forkDitoj/NUL1\n10 qDm\u0152i; k/c141Cm\u0152kC1; j /c141Cpi/NUL1pkpj\n11 ifq<m \u0152 i ; j /c141\n12 m\u0152i; j /c141Dq\n13 s\u0152i;j/c141Dk\n14return mands", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "396": {"page_number": 397, "page_information": "376 Chapter 15 Dynamic Programming\nA6 A5 A4 A3 A2 A100000015,750 2,625 750 1,000 5,0007,875 4,375 2,500 3,5009,375 7,125 5,37511,875 10,50015,125\n1234561\n2\n3\n4\n5\n6jim\n123451335333333\n234561\n2\n3\n4\n5jis\nFigure 15.5 Themandstables computed by M AT RIX -CHAIN -ORDER fornD6and the follow-\ni n gm a t r i xd i m e n s i o n s :\nmatrix\n A1 A2 A3 A4 A5 A6\ndimension\n 30/STX35 35/STX15 15/STX55/STX10 10/STX20 20/STX25\nThe tables are rotated so that the main diagonal runs horizontally. The mtable uses only the main\ndiagonal and upper triangle, and the stable uses only the upper triangle. The minimum number of\nscalar multiplications to multiply the 6 matrices is m\u01521; 6/c141D15,125. Of the darker entries, the pairs\nthat have the same shading are taken together in line 10 when computing\nm\u01522; 5/c141Dmin8\n\u02c6<\n\u02c6:m\u01522; 2/c141Cm\u01523; 5/c141Cp1p2p5D0C2500C35/SOH15/SOH20D13,000 ;\nm\u01522; 3/c141Cm\u01524; 5/c141Cp1p3p5D2625C1000C35/SOH5/SOH20D7125 ;\nm\u01522; 4/c141Cm\u01525; 5/c141Cp1p4p5D4375C0C35/SOH10/SOH20D11,375\nD7125 :\nThe algorithm \ufb01rst computes m\u0152i; i/c141D0foriD1 ;2;:::;n (the minimum\ncosts for chains of length 1) in lines 3\u20134. It then uses recurrence (15.7) to compute\nm\u0152i; iC1/c141foriD1 ;2;:::;n/NUL1(the minimum costs for chains of length lD2)\nduring the \ufb01rst execution of the forloop in lines 5\u201313. The second time through the\nloop, it computes m\u0152i; iC2/c141foriD1 ;2;:::;n/NUL2(the minimum costs for chains of\nlength lD3), and so forth. At each step, the m\u0152i; j /c141 cost computed in lines 10\u201313\ndepends only on table entries m\u0152i; k/c141 andm\u0152kC1; j /c141 already computed.\nFigure 15.5 illustrates this procedure on a chain of nD6matrices. Since\nwe have de\ufb01ned m\u0152i; j /c141 only for i/DC4j, only the portion of the table mstrictly\nabove the main diagonal is used. The \ufb01gure shows the table rotated to make themain diagonal run horizontally. The matrix chain is listed along the bottom. Us-ing this layout, we can \ufb01nd the minimum cost m\u0152i; j /c141 for multiplying a subchain\nA\niAiC1/SOH/SOH/SOHAjof matrices at the intersection of lines running northeast from Aiand", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "397": {"page_number": 398, "page_information": "15.2 Matrix-chain multiplication 377\nnorthwest from Aj. Each horizontal row in the table contains the entries for matrix\nchains of the same length. M ATRIX -CHAIN -ORDER computes the rows from bot-\ntom to top and from left to right within each row. It computes each entry m\u0152i; j /c141\nusing the products pi/NUL1pkpjforkDi;iC1 ;:::;j/NUL1and all entries southwest\nand southeast from m\u0152i; j /c141 .\nA simple inspection of the nested loop structure of M ATRIX -CHAIN -ORDER\nyields a running time of O.n3/for the algorithm. The loops are nested three deep,\nand each loop index ( l,i,a n d k) takes on at most n/NUL1values. Exercise 15.2-5 asks\nyou to show that the running time of this algorithm is in fact also /DEL.n3/.T h e a l -\ngorithm requires \u201a.n2/space to store the mandstables. Thus, M ATRIX -CHAIN -\nORDER is much more ef\ufb01cient than the exponential-time method of enumerating\nall possible parenthesizations and checking each one.\nStep 4: Constructing an optimal solution\nAlthough M ATRIX -CHAIN -ORDER determines the optimal number of scalar mul-\ntiplications needed to compute a matrix-chain product, it does not directly showhow to multiply the matrices. The table s\u01521:: n/NUL1 ;2::n /c141 gives us the informa-\ntion we need to do so. Each entry s\u0152i;j/c141 records a value of ksuch that an op-\ntimal parenthesization of A\niAiC1/SOH/SOH/SOHAjsplits the product between AkandAkC1.\nThus, we know that the \ufb01nal matrix multiplication in computing A1::noptimally\nisA1::s\u01521;n/c141 As\u01521;n/c141 C1::n. We can determine the earlier matrix multiplications recur-\nsively, since s\u01521;s\u01521;n/c141/c141 determines the last matrix multiplication when computing\nA1::s\u01521;n/c141 ands\u0152s\u01521;n/c141C1; n/c141 determines the last matrix multiplication when com-\nputing As\u01521;n/c141 C1::n. The following recursive procedure prints an optimal parenthe-\nsization ofhAi;AiC1;:::;A ji,g i v e nt h e stable computed by M ATRIX -CHAIN -\nORDER and the indices iandj. The initial call P RINT -OPTIMAL -PARENS . s ;1 ;n /\nprints an optimal parenthesization of hA1;A2;:::;A ni.\nPRINT -OPTIMAL -PARENS . s ;i;j/\n1ifi==j\n2 print \u201c A\u201di\n3elseprint \u201c(\u201d\n4P RINT -OPTIMAL -PARENS . s ;i;s\u0152 i;j/c141 /\n5P RINT -OPTIMAL -PARENS . s ;s\u0152 i;j/c141C1; j /\n6 print \u201c)\u201d\nIn the example of Figure 15.5, the call P RINT -OPTIMAL -PARENS . s ;1 ;6 / prints\nthe parenthesization ..A 1.A2A3//..A 4A5/A6//.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "398": {"page_number": 399, "page_information": "378 Chapter 15 Dynamic Programming\nExercises\n15.2-1\nFind an optimal parenthesization of a matrix-chain product whose sequence ofdimensions ish5; 10; 3; 12; 5; 50; 6i.\n15.2-2\nGive a recursive algorithm M\nATRIX -CHAIN -MULTIPLY . A ;s ;i;j/ that actually\nperforms the optimal matrix-chain multiplication, given the sequence of matriceshA\n1;A2;:::;A ni,t h estable computed by M ATRIX -CHAIN -ORDER , and the in-\ndices iandj. (The initial call would be M ATRIX -CHAIN -MULTIPLY . A ;s ;1 ;n / .)\n15.2-3\nUse the substitution method to show that the solution to the recurrence (15.6)is/DEL.2\nn/.\n15.2-4\nDescribe the subproblem graph for matrix-chain multiplication with an input chainof length n. How many vertices does it have? How many edges does it have, and\nwhich edges are they?\n15.2-5\nLetR.i;j/ be the number of times that table entry m\u0152i; j /c141 is referenced while\ncomputing other table entries in a call of M\nATRIX -CHAIN -ORDER . Show that the\ntotal number of references for the entire table is\nnX\niD1nX\njDiR.i;j/Dn3/NULn\n3:\n(Hint: You may \ufb01nd equation (A.3) useful.)\n15.2-6\nShow that a full parenthesization of an n-element expression has exactly n/NUL1pairs\nof parentheses.\n15.3 Elements of dynamic programming\nAlthough we have just worked through two examples of the dynamic-programming\nmethod, you might still be wondering just when the method applies. From an en-\ngineering perspective, when should we look for a dynamic-programming solutionto a problem? In this section, we examine the two key ingredients that an opti-", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "399": {"page_number": 400, "page_information": "15.3 Elements of dynamic programming 379\nmization problem must have in order for dynamic programming to apply: optimal\nsubstructure and overlapping subproblems. We also revisit and discuss more fullyhow memoization might help us take advantage of the overlapping-subproblemsproperty in a top-down recursive approach.\nOptimal substructure\nThe \ufb01rst step in solving an optimization problem by dynamic programming is to\ncharacterize the structure of an optimal solution. Recall that a problem exhibitsoptimal substructure if an optimal solution to the problem contains within it opti-\nmal solutions to subproblems. Whenever a problem exhibits optimal substructure,we have a good clue that dynamic programming might apply. (As Chapter 16 dis-cusses, it also might mean that a greedy strategy applies, however.) In dynamic\nprogramming, we build an optimal solution to the problem from optimal solutions\nto subproblems. Consequently, we must take care to ensure that the range of sub-problems we consider includes those used in an optimal solution.\nWe discovered optimal substructure in both of the problems we have examined\nin this chapter so far. In Section 15.1, we observed that the optimal way of cut-ting up a rod of length n(if we make any cuts at all) involves optimally cutting\nup the two pieces resulting from the \ufb01rst cut. In Section 15.2, we observed that\nan optimal parenthesization of A\niAiC1/SOH/SOH/SOHAjthat splits the product between Ak\nandAkC1contains within it optimal solutions to the problems of parenthesizing\nAiAiC1/SOH/SOH/SOHAkandAkC1AkC2/SOH/SOH/SOHAj.\nYou will \ufb01nd yourself following a common pattern in discovering optimal sub-\nstructure:\n1. You show that a solution to the problem consists of making a choice, such as\nchoosing an initial cut in a rod or choosing an index at which to split the matrixchain. Making this choice leaves one or more subproblems to be solved.\n2. You suppose that for a given problem, you are given the choice that leads to an\noptimal solution. You do not concern yourself yet with how to determine thischoice. You just assume that it has been given to you.\n3. Given this choice, you determine which subproblems ensue and how to best\ncharacterize the resulting space of subproblems.\n4. You show that the solutions to the subproblems used within an optimal solution\nto the problem must themselves be optimal by using a \u201ccut-and-paste\u201d tech-nique. You do so by supposing that each of the subproblem solutions is notoptimal and then deriving a contradiction. In particular, by \u201ccutting out\u201d thenonoptimal solution to each subproblem and \u201cpasting in\u201d the optimal one, youshow that you can get a better solution to the original problem, thus contradict-ing your supposition that you already had an optimal solution. If an optimal", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "400": {"page_number": 401, "page_information": "380 Chapter 15 Dynamic Programming\nsolution gives rise to more than one subproblem, they are typically so similar\nthat you can modify the cut-and-paste argument for one to apply to the otherswith little effort.\nTo characterize the space of subproblems, a good rule of thumb says to try to\nkeep the space as simple as possible and then expand it as necessary. For example,the space of subproblems that we considered for the rod-cutting problem containedthe problems of optimally cutting up a rod of length ifor each size i. This sub-\nproblem space worked well, and we had no need to try a more general space ofsubproblems.\nConversely, suppose that we had tried to constrain our subproblem space for\nmatrix-chain multiplication to matrix products of the form A\n1A2/SOH/SOH/SOHAj. As before,\nan optimal parenthesization must split this product between AkandAkC1for some\n1/DC4k<j . Unless we could guarantee that kalways equals j/NUL1, we would \ufb01nd\nthat we had subproblems of the form A1A2/SOH/SOH/SOHAkandAkC1AkC2/SOH/SOH/SOHAj,a n dt h a t\nthe latter subproblem is not of the form A1A2/SOH/SOH/SOHAj. For this problem, we needed\nto allow our subproblems to vary at \u201cboth ends,\u201d that is, to allow both iandjto\nvary in the subproblem AiAiC1/SOH/SOH/SOHAj.\nOptimal substructure varies across problem domains in two ways:\n1. how many subproblems an optimal solution to the original problem uses, and\n2. how many choices we have in determining which subproblem(s) to use in an\noptimal solution.\nIn the rod-cutting problem, an optimal solution for cutting up a rod of size n\nuses just one subproblem (of size n/NULi), but we must consider nchoices for i\nin order to determine which one yields an optimal solution. Matrix-chain mul-tiplication for the subchain A\niAiC1/SOH/SOH/SOHAjserves as an example with two sub-\nproblems and j/NULichoices. For a given matrix Akat which we split the prod-\nuct, we have two subproblems\u2014parenthesizing AiAiC1/SOH/SOH/SOHAkand parenthesizing\nAkC1AkC2/SOH/SOH/SOHAj\u2014and we must solve both of them optimally. Once we determine\nthe optimal solutions to subproblems, we choose from among j/NULicandidates for\nthe index k.\nInformally, the running time of a dynamic-programming algorithm depends on\nthe product of two factors: the number of subproblems overall and how manychoices we look at for each subproblem. In rod cutting, we had \u201a.n/ subproblems\noverall, and at most nchoices to examine for each, yielding an O.n\n2/running time.\nMatrix-chain multiplication had \u201a.n2/subproblems overall, and in each we had at\nmost n/NUL1choices, giving an O.n3/running time (actually, a \u201a.n3/running time,\nby Exercise 15.2-5).\nUsually, the subproblem graph gives an alternative way to perform the same\nanalysis. Each vertex corresponds to a subproblem, and the choices for a sub-", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "401": {"page_number": 402, "page_information": "15.3 Elements of dynamic programming 381\nproblem are the edges incident to that subproblem. Recall that in rod cutting,\nthe subproblem graph had nvertices and at most nedges per vertex, yielding an\nO.n2/running time. For matrix-chain multiplication, if we were to draw the sub-\nproblem graph, it would have \u201a.n2/vertices and each vertex would have degree at\nmost n/NUL1, giving a total of O.n3/vertices and edges.\nDynamic programming often uses optimal substructure in a bottom-up fashion.\nThat is, we \ufb01rst \ufb01nd optimal solutions to subproblems and, having solved the sub-problems, we \ufb01nd an optimal solution to the problem. Finding an optimal solu-\ntion to the problem entails making a choice among subproblems as to which we\nwill use in solving the problem. The cost of the problem solution is usually thesubproblem costs plus a cost that is directly attributable to the choice itself. Inrod cutting, for example, \ufb01rst we solved the subproblems of determining optimalways to cut up rods of length iforiD0; 1; : : : ; n/NUL1, and then we determined\nwhich such subproblem yielded an optimal solution for a rod of length n,u s i n g\nequation (15.2). The cost attributable to the choice itself is the term p\niin equa-\ntion (15.2). In matrix-chain multiplication, we determined optimal parenthesiza-\ntions of subchains of AiAiC1/SOH/SOH/SOHAj, and then we chose the matrix Akat which to\nsplit the product. The cost attributable to the choice itself is the term pi/NUL1pkpj.\nIn Chapter 16, we shall examine \u201cgreedy algorithms,\u201d which have many similar-\nities to dynamic programming. In particular, problems to which greedy algorithmsapply have optimal substructure. One major difference between greedy algorithmsand dynamic programming is that instead of \ufb01rst \ufb01nding optimal solutions to sub-\nproblems and then making an informed choice, greedy algorithms \ufb01rst make a\n\u201cgreedy\u201d choice\u2014the choice that looks best at the time\u2014and then solve a resultingsubproblem, without bothering to solve all possible related smaller subproblems.Surprisingly, in some cases this strategy works!\nSubtleties\nYou should be careful not to assume that optimal substructure applies when it doesnot. Consider the following two problems in which we are given a directed graphGD.V; E/ and vertices u; /ETB2V.\nUnweighted shortest path:\n3Find a path from uto/ETBconsisting of the fewest\nedges. Such a path must be simple, since removing a cycle from a path pro-duces a path with fewer edges.\n3We use the term \u201cunweighted\u201d to distinguish this problem from that of \ufb01nding shortest paths with\nweighted edges, which we shall see in Chapters 24 and 25. We can use the breadth-\ufb01rst searchtechnique of Chapter 22 to solve the unweighted problem.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "402": {"page_number": 403, "page_information": "382 Chapter 15 Dynamic Programming\nq r\ns t\nFigure 15.6 A directed graph showing that the problem of \ufb01nding a longest simple path in an\nunweighted directed graph does not have optimal substructure. The path q!r!tis a longest\nsimple path from qtot, but the subpath q!ris not a longest simple path from qtor, nor is the\nsubpath r!ta longest simple path from rtot.\nUnweighted longest simple path: Find a simple path from uto/ETBconsisting of\nthe most edges. We need to include the requirement of simplicity because other-\nwise we can traverse a cycle as many times as we like to create paths with anarbitrarily large number of edges.\nThe unweighted shortest-path problem exhibits optimal substructure, as follows.\nSuppose that u\u00a4/ETB, so that the problem is nontrivial. Then, any path pfrom u\nto/ETBmust contain an intermediate vertex, say w. (Note that wmay be uor/ETB.)\nThus, we can decompose the path up;/ETBinto subpaths up1;wp2;/ETB. Clearly, the\nnumber of edges in pequals the number of edges in p1plus the number of edges\ninp2. We claim that if pis an optimal (i.e., shortest) path from uto/ETB,t h e n p1\nmust be a shortest path from utow. Why? We use a \u201ccut-and-paste\u201d argument:\nif there were another path, say p0\n1, from utowwith fewer edges than p1,t h e nw e\ncould cut out p1and paste in p0\n1to produce a path up0\n1;wp2;/ETBwith fewer edges\nthanp, thus contradicting p\u2019s optimality. Symmetrically, p2must be a shortest\npath from wto/ETB. Thus, we can \ufb01nd a shortest path from uto/ETBby considering\nall intermediate vertices w, \ufb01nding a shortest path from utowand a shortest path\nfrom wto/ETB, and choosing an intermediate vertex wthat yields the overall shortest\npath. In Section 25.2, we use a variant of this observation of optimal substructureto \ufb01nd a shortest path between every pair of vertices on a weighted, directed graph.\nYou might be tempted to assume that the problem of \ufb01nding an unweighted\nlongest simple path exhibits optimal substructure as well. After all, if we decom-\npose a longest simple path up;/ETBinto subpaths up1;wp2;/ETB, then mustn\u2019t p1\nbe a longest simple path from utow, and mustn\u2019t p2be a longest simple path\nfrom wto/ETB? The answer is no! Figure 15.6 supplies an example. Consider the\npathq!r!t, which is a longest simple path from qtot.I sq!ra longest\nsimple path from qtor? No, for the path q!s!t!ri sas i m p l ep a t h\nthat is longer. Is r!ta longest simple path from rtot? No again, for the path\nr!q!s!tis a simple path that is longer.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "403": {"page_number": 404, "page_information": "15.3 Elements of dynamic programming 383\nThis example shows that for longest simple paths, not only does the problem\nlack optimal substructure, but we cannot necessarily assemble a \u201clegal\u201d solutionto the problem from solutions to subproblems. If we combine the longest simplepaths q!s!t!randr!q!s!t, we get the path q!s!t!r!\nq!s!t, which is not simple. Indeed, the problem of \ufb01nding an unweighted\nlongest simple path does not appear to have any sort of optimal substructure. Noef\ufb01cient dynamic-programming algorithm for this problem has ever been found. Infact, this problem is NP-complete, which\u2014as we shall see in Chapter 34\u2014means\nthat we are unlikely to \ufb01nd a way to solve it in polynomial time.\nWhy is the substructure of a longest simple path so different from that of a short-\nest path? Although a solution to a problem for both longest and shortest paths usestwo subproblems, the subproblems in \ufb01nding the longest simple path are not inde-\npendent , whereas for shortest paths they are. What do we mean by subproblems\nbeing independent? We mean that the solution to one subproblem does not affectthe solution to another subproblem of the same problem. For the example of Fig-ure 15.6, we have the problem of \ufb01nding a longest simple path from qtotwith two\nsubproblems: \ufb01nding longest simple paths from qtorand from rtot. For the \ufb01rst\nof these subproblems, we choose the path q!s!t!r, and so we have also\nused the vertices sandt. We can no longer use these vertices in the second sub-\nproblem, since the combination of the two solutions to subproblems would yield apath that is not simple. If we cannot use vertex tin the second problem, then we\ncannot solve it at all, since tis required to be on the path that we \ufb01nd, and it is\nnot the vertex at which we are \u201csplicing\u201d together the subproblem solutions (that\nvertex being r). Because we use vertices sandtin one subproblem solution, we\ncannot use them in the other subproblem solution. We must use at least one of themto solve the other subproblem, however, and we must use both of them to solve itoptimally. Thus, we say that these subproblems are not independent. Looked atanother way, using resources in solving one subproblem (those resources beingvertices) renders them unavailable for the other subproblem.\nWhy, then, are the subproblems independent for \ufb01nding a shortest path? The\nanswer is that by nature, the subproblems do not share resources. We claim thatif a vertex wis on a shortest path pfrom uto/ETB, then we can splice together any\nshortest path u\np1;wandanyshortest path wp2;/ETBto produce a shortest path from u\nto/ETB. We are assured that, other than w, no vertex can appear in both paths p1\nandp2. Why? Suppose that some vertex x\u00a4wappears in both p1andp2,s ot h a t\nwe can decompose p1asupux;x;wandp2asw;xpx/ETB;/ETB. By the optimal\nsubstructure of this problem, path phas as many edges as p1andp2together; let\u2019s\nsay that phaseedges. Now let us construct a path p0Dupux;xpx/ETB;/ETBfrom uto/ETB.\nBecause we have excised the paths from xtowand from wtox, each of which\ncontains at least one edge, path p0contains at most e/NUL2edges, which contradicts", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "404": {"page_number": 405, "page_information": "384 Chapter 15 Dynamic Programming\nthe assumption that pis a shortest path. Thus, we are assured that the subproblems\nfor the shortest-path problem are independent.\nBoth problems examined in Sections 15.1 and 15.2 have independent subprob-\nlems. In matrix-chain multiplication, the subproblems are multiplying subchainsA\niAiC1/SOH/SOH/SOHAkandAkC1AkC2/SOH/SOH/SOHAj. These subchains are disjoint, so that no ma-\ntrix could possibly be included in both of them. In rod cutting, to determine thebest way to cut up a rod of length n, we look at the best ways of cutting up rods\nof length iforiD0; 1; : : : ; n/NUL1. Because an optimal solution to the length- n\nproblem includes just one of these subproblem solutions (after we have cut off the\n\ufb01rst piece), independence of subproblems is not an issue.\nOverlapping subproblems\nThe second ingredient that an optimization problem must have for dynamic pro-\ngramming to apply is that the space of subproblems must be \u201csmall\u201d in the sensethat a recursive algorithm for the problem solves the same subproblems over andover, rather than always generating new subproblems. Typically, the total numberof distinct subproblems is a polynomial in the input size. When a recursive algo-rithm revisits the same problem repeatedly, we say that the optimization problemhasoverlapping subproblems .\n4In contrast, a problem for which a divide-and-\nconquer approach is suitable usually generates brand-new problems at each step\nof the recursion. Dynamic-programming algorithms typically take advantage of\noverlapping subproblems by solving each subproblem once and then storing thesolution in a table where it can be looked up when needed, using constant time perlookup.\nIn Section 15.1, we brie\ufb02y examined how a recursive solution to rod cut-\nting makes exponentially many calls to \ufb01nd solutions of smaller subproblems.\nOur dynamic-programming solution takes an exponential-time recursive algorithm\ndown to quadratic time.\nTo illustrate the overlapping-subproblems property in greater detail, let us re-\nexamine the matrix-chain multiplication problem. Referring back to Figure 15.5,observe that M\nATRIX -CHAIN -ORDER repeatedly looks up the solution to subprob-\nlems in lower rows when solving subproblems in higher rows. For example, itreferences entry m\u01523; 4/c141 four times: during the computations of m\u01522; 4/c141 ,m\u01521; 4/c141 ,\n4It may seem strange that dynamic programming relies on subproblems being both independent\nand overlapping. Although these requirements may sound contradictory, they describe two differentnotions, rather than two points on the same axis. Two subproblems of the same problem are inde-\npendent if they do not share resources. Two subproblems are overlapping if they are really the same\nsubproblem that occurs as a subproblem of different problems.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "405": {"page_number": 406, "page_information": "15.3 Elements of dynamic programming 385\n1..4\n1..1 2..4 1..2 3..4 1..3 4..4\n2..2 3..4 2..3 4..4 1..1 2..2 3..3 4..4 1..1 2..3 1..2 3..33..3 4..4 2..2 3..3 2..2 3..3 1..1 2..2\nFigure 15.7 The recursion tree for the computation of R ECURSIVE -MAT RIX -CHAIN. p ;1 ;4 / .\nEach node contains the parameters iandj. The computations performed in a shaded subtree are\nreplaced by a single table lookup in M EMOIZED -MAT RIX -CHAIN .\nm\u01523; 5/c141 ,a n d m\u01523; 6/c141 . If we were to recompute m\u01523; 4/c141 each time, rather than just\nlooking it up, the running time would increase dramatically. To see how, considerthe following (inef\ufb01cient) recursive procedure that determines m\u0152i; j /c141 , the mini-\nmum number of scalar multiplications needed to compute the matrix-chain productA\ni:: jDAiAiC1/SOH/SOH/SOHAj. The procedure is based directly on the recurrence (15.7).\nRECURSIVE -MATRIX -CHAIN . p;i;j/\n1ifi==j\n2 return 0\n3m\u0152i; j /c141D1\n4forkDitoj/NUL1\n5 qDRECURSIVE -MATRIX -CHAIN . p;i;k/\nCRECURSIVE -MATRIX -CHAIN .p; kC1; j /\nCpi/NUL1pkpj\n6 ifq<m \u0152 i ; j /c141\n7 m\u0152i; j /c141Dq\n8return m\u0152i; j /c141\nFigure 15.7 shows the recursion tree produced by the call R ECURSIVE -MATRIX -\nCHAIN . p;1 ;4 / . Each node is labeled by the values of the parameters iandj.\nObserve that some pairs of values occur many times.\nIn fact, we can show that the time to compute m\u01521; n/c141 by this recursive proce-\ndure is at least exponential in n.L e t T .n/ denote the time taken by R ECURSIVE -\nMATRIX -CHAIN to compute an optimal parenthesization of a chain of nmatrices.\nBecause the execution of lines 1\u20132 and of lines 6\u20137 each take at least unit time, as", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "406": {"page_number": 407, "page_information": "386 Chapter 15 Dynamic Programming\ndoes the multiplication in line 5, inspection of the procedure yields the recurrence\nT. 1 //NAK1;\nT .n//NAK1Cn/NUL1X\nkD1.T .k/CT. n/NULk/C1/ forn>1:\nNoting that for iD1 ;2;:::;n/NUL1, each term T. i/ appears once as T. k/ and once\nasT. n/NULk/, and collecting the n/NUL11s in the summation together with the 1out\nfront, we can rewrite the recurrence as\nT .n//NAK2n/NUL1X\niD1T. i/Cn: (15.8)\nWe shall prove that T .n/D/DEL.2n/using the substitution method. Speci\ufb01-\ncally, we shall show that T .n//NAK2n/NUL1for all n/NAK1. The basis is easy, since\nT. 1 //NAK1D20. Inductively, for n/NAK2we have\nT .n//NAK2n/NUL1X\niD12i/NUL1Cn\nD2n/NUL2X\niD02iCn\nD2.2n/NUL1/NUL1/Cn(by equation (A.5))\nD2n/NUL2Cn\n/NAK2n/NUL1;\nwhich completes the proof. Thus, the total amount of work performed by the call\nRECURSIVE -MATRIX -CHAIN . p;1 ;n / is at least exponential in n.\nCompare this top-down, recursive algorithm (without memoization) with the\nbottom-up dynamic-programming algorithm. The latter is more ef\ufb01cient because\nit takes advantage of the overlapping-subproblems property. Matrix-chain mul-\ntiplication has only \u201a.n2/distinct subproblems, and the dynamic-programming\nalgorithm solves each exactly once. The recursive algorithm, on the other hand,\nmust again solve each subproblem every time it reappears in the recursion tree.Whenever a recursion tree for the natural recursive solution to a problem contains\nthe same subproblem repeatedly, and the total number of distinct subproblems is\nsmall, dynamic programming can improve ef\ufb01ciency, sometimes dramatically.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "407": {"page_number": 408, "page_information": "15.3 Elements of dynamic programming 387\nReconstructing an optimal solution\nAs a practical matter, we often store which choice we made in each subproblem in\na table so that we do not have to reconstruct this information from the costs that westored.\nFor matrix-chain multiplication, the table s\u0152i;j/c141 saves us a signi\ufb01cant amount of\nwork when reconstructing an optimal solution. Suppose that we did not maintainthes\u0152i;j/c141 table, having \ufb01lled in only the table m\u0152i; j /c141 containing optimal subprob-\nlem costs. We choose from among j/NULipossibilities when we determine which\nsubproblems to use in an optimal solution to parenthesizing A\niAiC1/SOH/SOH/SOHAj,a n d\nj/NULiis not a constant. Therefore, it would take \u201a.j/NULi/D!.1/ time to recon-\nstruct which subproblems we chose for a solution to a given problem. By storingins\u0152i;j/c141 the index of the matrix at which we split the product A\niAiC1/SOH/SOH/SOHAj,w e\ncan reconstruct each choice in O.1/ time.\nMemoization\nAs we saw for the rod-cutting problem, there is an alternative approach to dy-\nnamic programming that often offers the ef\ufb01ciency of the bottom-up dynamic-programming approach while maintaining a top-down strategy. The idea is to\nmemoize the natural, but inef\ufb01cient, recursive algorithm. As in the bottom-up ap-\nproach, we maintain a table with subproblem solutions, but the control structurefor \ufb01lling in the table is more like the recursive algorithm.\nA memoized recursive algorithm maintains an entry in a table for the solution to\neach subproblem. Each table entry initially contains a special value to indicate thatthe entry has yet to be \ufb01lled in. When the subproblem is \ufb01rst encountered as therecursive algorithm unfolds, its solution is computed and then stored in the table.Each subsequent time that we encounter this subproblem, we simply look up thevalue stored in the table and return it.\n5\nHere is a memoized version of R ECURSIVE -MATRIX -CHAIN . Note where it\nresembles the memoized top-down method for the rod-cutting problem.\n5This approach presupposes that we know the set of all possible subproblem parameters and that we\nhave established the relationship between table positions and subproblems. Another, more general,\napproach is to memoize by using hashing with the subproblem parameters as keys.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "408": {"page_number": 409, "page_information": "388 Chapter 15 Dynamic Programming\nMEMOIZED -MATRIX -CHAIN .p/\n1nDp:length/NUL1\n2l e t m \u0152 1::n;1::n /c141 be a new table\n3foriD1ton\n4 forjDiton\n5 m\u0152i; j /c141D1\n6return LOOKUP -CHAIN . m;p;1 ;n /\nLOOKUP -CHAIN . m;p;i;j/\n1ifm\u0152i; j /c141 <1\n2 return m\u0152i; j /c141\n3ifi==j\n4 m\u0152i; j /c141D0\n5else for kDitoj/NUL1\n6 qDLOOKUP -CHAIN . m;p;i;k/\nCLOOKUP -CHAIN . m;p;kC1; j /Cpi/NUL1pkpj\n7 ifq<m \u0152 i ; j /c141\n8 m\u0152i; j /c141Dq\n9return m\u0152i; j /c141\nThe M EMOIZED -MATRIX -CHAIN procedure, like M ATRIX -CHAIN -ORDER ,\nmaintains a table m \u0152 1::n ;1::n /c141 of computed values of m\u0152i; j /c141 , the minimum num-\nber of scalar multiplications needed to compute the matrix Ai::j. Each table entry\ninitially contains the value 1to indicate that the entry has yet to be \ufb01lled in. Upon\ncalling L OOKUP -CHAIN . m;p;i;j/ , if line 1 \ufb01nds that m\u0152i; j /c141 <1, then the pro-\ncedure simply returns the previously computed cost m\u0152i; j /c141 in line 2. Otherwise,\nthe cost is computed as in R ECURSIVE -MATRIX -CHAIN , stored in m\u0152i; j /c141 ,a n d\nreturned. Thus, L OOKUP -CHAIN . m;p;i;j/ always returns the value of m\u0152i; j /c141 ,\nbut it computes it only upon the \ufb01rst call of L OOKUP -CHAIN with these speci\ufb01c\nvalues of iandj.\nFigure 15.7 illustrates how M EMOIZED -MATRIX -CHAIN saves time compared\nwith R ECURSIVE -MATRIX -CHAIN . Shaded subtrees represent values that it looks\nup rather than recomputes.\nLike the bottom-up dynamic-programming algorithm M ATRIX -CHAIN -ORDER ,\nthe procedure M EMOIZED -MATRIX -CHAIN runs in O.n3/time. Line 5 of\nMEMOIZED -MATRIX -CHAIN executes \u201a.n2/times. We can categorize the calls\nof L OOKUP -CHAIN into two types:\n1. calls in which m\u0152i; j /c141D1 , so that lines 3\u20139 execute, and\n2. calls in which m\u0152i; j /c141 <1,s ot h a tL OOKUP -CHAIN simply returns in line 2.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "409": {"page_number": 410, "page_information": "15.3 Elements of dynamic programming 389\nThere are \u201a.n2/calls of the \ufb01rst type, one per table entry. All calls of the sec-\nond type are made as recursive calls by calls of the \ufb01rst type. Whenever a givencall of L\nOOKUP -CHAIN makes recursive calls, it makes O.n/ of them. There-\nfore, there are O.n3/calls of the second type in all. Each call of the second type\ntakes O.1/ time, and each call of the \ufb01rst type takes O.n/ time plus the time spent\nin its recursive calls. The total time, therefore, is O.n3/. Memoization thus turns\nan/DEL.2n/-time algorithm into an O.n3/-time algorithm.\nIn summary, we can solve the matrix-chain multiplication problem by either a\ntop-down, memoized dynamic-programming algorithm or a bottom-up dynamic-\nprogramming algorithm in O.n3/time. Both methods take advantage of the\noverlapping-subproblems property. There are only \u201a.n2/distinct subproblems in\ntotal, and either of these methods computes the solution to each subproblem onlyonce. Without memoization, the natural recursive algorithm runs in exponentialtime, since solved subproblems are repeatedly solved.\nIn general practice, if all subproblems must be solved at least once, a bottom-up\ndynamic-programming algorithm usually outperforms the corresponding top-down\nmemoized algorithm by a constant factor, because the bottom-up algorithm has no\noverhead for recursion and less overhead for maintaining the table. Moreover, for\nsome problems we can exploit the regular pattern of table accesses in the dynamic-programming algorithm to reduce time or space requirements even further. Alter-natively, if some subproblems in the subproblem space need not be solved at all,the memoized solution has the advantage of solving only those subproblems that\nare de\ufb01nitely required.\nExercises\n15.3-1\nWhich is a more ef\ufb01cient way to determine the optimal number of multiplicationsin a matrix-chain multiplication problem: enumerating all the ways of parenthesiz-ing the product and computing the number of multiplications for each, or running\nR\nECURSIVE -MATRIX -CHAIN ? Justify your answer.\n15.3-2\nDraw the recursion tree for the M ERGE -SORT procedure from Section 2.3.1 on an\narray of 16elements. Explain why memoization fails to speed up a good divide-\nand-conquer algorithm such as M ERGE -SORT.\n15.3-3\nConsider a variant of the matrix-chain multiplication problem in which the goal isto parenthesize the sequence of matrices so as to maximize, rather than minimize,", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "410": {"page_number": 411, "page_information": "390 Chapter 15 Dynamic Programming\nthe number of scalar multiplications. Does this problem exhibit optimal substruc-\nture?\n15.3-4\nAs stated, in dynamic programming we \ufb01rst solve the subproblems and then choosewhich of them to use in an optimal solution to the problem. Professor Capuletclaims that we do not always need to solve all the subproblems in order to \ufb01nd anoptimal solution. She suggests that we can \ufb01nd an optimal solution to the matrix-chain multiplication problem by always choosing the matrix A\nkat which to split\nthe subproduct AiAiC1/SOH/SOH/SOHAj(by selecting kto minimize the quantity pi/NUL1pkpj)\nbefore solving the subproblems. Find an instance of the matrix-chain multiplica-\ntion problem for which this greedy approach yields a suboptimal solution.\n15.3-5\nSuppose that in the rod-cutting problem of Section 15.1, we also had limit lion the\nnumber of pieces of length ithat we are allowed to produce, for iD1 ;2;:::;n .\nShow that the optimal-substructure property described in Section 15.1 no longerholds.\n15.3-6\nImagine that you wish to exchange one currency for another. You realize thatinstead of directly exchanging one currency for another, you might be better offmaking a series of trades through other currencies, winding up with the currencyyou want. Suppose that you can trade ndifferent currencies, numbered 1 ;2;:::;n ,\nwhere you start with currency 1and wish to wind up with currency n.Y o u a r e\ngiven, for each pair of currencies iandj, an exchange rate r\nij, meaning that if\nyou start with dunits of currency i, you can trade for drijunits of currency j.\nA sequence of trades may entail a commission, which depends on the number oftrades you make. Let c\nkbe the commission that you are charged when you make k\ntrades. Show that, if ckD0for all kD1 ;2;:::;n , then the problem of \ufb01nding the\nbest sequence of exchanges from currency 1to currency nexhibits optimal sub-\nstructure. Then show that if commissions ckare arbitrary values, then the problem\nof \ufb01nding the best sequence of exchanges from currency 1to currency ndoes not\nnecessarily exhibit optimal substructure.\n15.4 Longest common subsequence\nBiological applications often need to compare the DNA of two (or more) dif-ferent organisms. A strand of DNA consists of a string of molecules called", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "411": {"page_number": 412, "page_information": "15.4 Longest common subsequence 391\nbases , where the possible bases are adenine, guanine, cytosine, and thymine.\nRepresenting each of these bases by its initial letter, we can express a strandof DNA as a string over the \ufb01nite set fA;C;G;Tg. (See Appendix C for\nthe de\ufb01nition of a string.) For example, the DNA of one organism may beS\n1DACCGGTCGAGTGCGCGGAAGCCGGCCGAA , and the DNA of another organ-\nism may be S2DGTCGTTCGGAATGCCGTTGCTCTGTAAA . One reason to com-\npare two strands of DNA is to determine how \u201csimilar\u201d the two strands are, as somemeasure of how closely related the two organisms are. We can, and do, de\ufb01ne sim-\nilarity in many different ways. For example, we can say that two DNA strands are\nsimilar if one is a substring of the other. (Chapter 32 explores algorithms to solvethis problem.) In our example, neither S\n1norS2is a substring of the other. Alter-\nnatively, we could say that two strands are similar if the number of changes neededto turn one into the other is small. (Problem 15-5 looks at this notion.) Yet anotherway to measure the similarity of strands S\n1andS2is by \ufb01nding a third strand S3\nin which the bases in S3appear in each of S1andS2; these bases must appear\nin the same order, but not necessarily consecutively. The longer the strand S3we\ncan \ufb01nd, the more similar S1andS2are. In our example, the longest strand S3is\nGTCGTCGGAAGCCGGCCGAA .\nWe formalize this last notion of similarity as the longest-common-subsequence\nproblem. A subsequence of a given sequence is just the given sequence with zero or\nmore elements left out. Formally, given a sequence XDhx1;x2;:::;x mi, another\nsequence ZDh\u00b41;\u00b42;:::;\u00b4 kiis asubsequence ofXif there exists a strictly\nincreasing sequence hi1;i2;:::;i kiof indices of Xsuch that for all jD1 ;2;:::;k ,\nwe have xijD\u00b4j. For example, ZDhB; C; D; Biis a subsequence of XD\nhA;B;C;B;D;A;B iwith corresponding index sequence h2; 3; 5; 7i.\nGiven two sequences XandY, we say that a sequence Zis acommon sub-\nsequence ofXandYifZis a subsequence of both XandY. For example, if\nXDhA;B;C;B;D;A;B iandYDhB;D;C;A;B;Ai, the sequencehB;C;Aiis\na common subsequence of both XandY. The sequencehB;C;Aiis not a longest\ncommon subsequence (LCS) of XandY, however, since it has length 3and the\nsequencehB;C;B;Ai, which is also common to both XandY, has length 4.T h e\nsequencehB; C; B; Aiis an LCS of XandY, as is the sequence hB; D; A; Bi,\nsince XandYhave no common subsequence of length 5or greater.\nIn the longest-common-subsequence problem , we are given two sequences\nXDhx1;x2;:::;x miandYDhy1;y2;:::;y nia n dw i s ht o\ufb01 n dam a x i m u m -\nlength common subsequence of XandY. This section shows how to ef\ufb01ciently\nsolve the LCS problem using dynamic programming.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "412": {"page_number": 413, "page_information": "392 Chapter 15 Dynamic Programming\nStep 1: Characterizing a longest common subsequence\nIn a brute-force approach to solving the LCS problem, we would enumerate all\nsubsequences of Xand check each subsequence to see whether it is also a subse-\nquence of Y, keeping track of the longest subsequence we \ufb01nd. Each subsequence\nofXcorresponds to a subset of the indices f1 ;2;:::;mgofX. Because Xhas2m\nsubsequences, this approach requires exponential time, making it impractical for\nlong sequences.\nThe LCS problem has an optimal-substructure property, however, as the follow-\ning theorem shows. As we shall see, the natural classes of subproblems corre-spond to pairs of \u201cpre\ufb01xes\u201d of the two input sequences. To be precise, given asequence XDhx\n1;x2;:::;x mi,w ed e \ufb01 n et h e ithpre\ufb01x ofX,f o riD0; 1; : : : ; m ,\nasXiDhx1;x2;:::;x ii. For example, if XDhA; B; C; B; D; A; B i,t h e n\nX4DhA; B; C; BiandX0is the empty sequence.\nTheorem 15.1 (Optimal substructure of an LCS)\nLetXDhx1;x2;:::;x miandYDhy1;y2;:::;y nibe sequences, and let ZD\nh\u00b41;\u00b42;:::;\u00b4 kibe any LCS of XandY.\n1. If xmDyn,t h e n \u00b4kDxmDynandZk/NUL1is an LCS of Xm/NUL1andYn/NUL1.\n2. If xm\u00a4yn,t h e n \u00b4k\u00a4xmimplies that Zis an LCS of Xm/NUL1andY.\n3. If xm\u00a4yn,t h e n \u00b4k\u00a4ynimplies that Zis an LCS of XandYn/NUL1.\nProof (1) If \u00b4k\u00a4xm, then we could append xmDyntoZto obtain a common\nsubsequence of XandYof length kC1, contradicting the supposition that Zis\nalongest common subsequence of XandY. Thus, we must have \u00b4kDxmDyn.\nNow, the pre\ufb01x Zk/NUL1is a length- .k/NUL1/common subsequence of Xm/NUL1andYn/NUL1.\nWe wish to show that it is an LCS. Suppose for the purpose of contradictionthat there exists a common subsequence WofX\nm/NUL1andYn/NUL1with length greater\nthank/NUL1. Then, appending xmDyntoWproduces a common subsequence of\nXandYwhose length is greater than k, which is a contradiction.\n(2) If \u00b4k\u00a4xm,t h e n Zis a common subsequence of Xm/NUL1andY. If there were a\ncommon subsequence WofXm/NUL1andYwith length greater than k,t h e n Wwould\nalso be a common subsequence of XmandY, contradicting the assumption that Z\nis an LCS of XandY.\n(3) The proof is symmetric to (2).\nThe way that Theorem 15.1 characterizes longest common subsequences tells\nus that an LCS of two sequences contains within it an LCS of pre\ufb01xes of the two\nsequences. Thus, the LCS problem has an optimal-substructure property. A recur-", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "413": {"page_number": 414, "page_information": "15.4 Longest common subsequence 393\nsive solution also has the overlapping-subproblems property, as we shall see in a\nmoment.\nStep 2: A recursive solution\nTheorem 15.1 implies that we should examine either one or two subproblems when\n\ufb01nding an LCS of XDhx1;x2;:::;x miandYDhy1;y2;:::;y ni.I fxmDyn,\nwe must \ufb01nd an LCS of Xm/NUL1andYn/NUL1. Appending xmDynto this LCS yields\nan LCS of XandY.I fxm\u00a4yn, then we must solve two subproblems: \ufb01nding an\nLCS of Xm/NUL1andYand \ufb01nding an LCS of XandYn/NUL1. Whichever of these two\nLCSs is longer is an LCS of XandY. Because these cases exhaust all possibilities,\nwe know that one of the optimal subproblem solutions must appear within an LCSofXandY.\nWe can readily see the overlapping-subproblems property in the LCS problem.\nTo \ufb01nd an LCS of XandY, we may need to \ufb01nd the LCSs of XandY\nn/NUL1and\nofXm/NUL1andY. But each of these subproblems has the subsubproblem of \ufb01nding\nan LCS of Xm/NUL1andYn/NUL1. Many other subproblems share subsubproblems.\nAs in the matrix-chain multiplication problem, our recursive solution to the LCS\nproblem involves establishing a recurrence for the value of an optimal solution.\nLet us de\ufb01ne c\u0152i;j/c141 to be the length of an LCS of the sequences XiandYj.I f\neither iD0orjD0, one of the sequences has length 0, and so the LCS has\nlength 0. The optimal substructure of the LCS problem gives the recursive formula\nc\u0152i;j/c141D/c128\n0 ifiD0orjD0;\nc\u0152i/NUL1; j/NUL1/c141C1 ifi;j > 0 andxiDyj;\nmax.c\u0152i; j/NUL1/c141; c\u0152i/NUL1; j /c141/ ifi;j > 0 andxi\u00a4yj:(15.9)\nObserve that in this recursive formulation, a condition in the problem restricts\nwhich subproblems we may consider. When xiDyj, we can and should consider\nthe subproblem of \ufb01nding an LCS of Xi/NUL1andYj/NUL1. Otherwise, we instead con-\nsider the two subproblems of \ufb01nding an LCS of XiandYj/NUL1and of Xi/NUL1andYj.I n\nthe previous dynamic-programming algorithms we have examined\u2014for rod cuttingand matrix-chain multiplication\u2014we ruled out no subproblems due to conditionsin the problem. Finding an LCS is not the only dynamic-programming algorithmthat rules out subproblems based on conditions in the problem. For example, theedit-distance problem (see Problem 15-5) has this characteristic.\nStep 3: Computing the length of an LCS\nBased on equation (15.9), we could easily write an exponential-time recursive al-\ngorithm to compute the length of an LCS of two sequences. Since the LCS problem", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "414": {"page_number": 415, "page_information": "394 Chapter 15 Dynamic Programming\nhas only \u201a.mn/ distinct subproblems, however, we can use dynamic programming\nto compute the solutions bottom up.\nProcedure LCS-L ENGTH takes two sequences XDhx1;x2; :::; x miand\nYDhy1;y2;:::;y nias inputs. It stores the c\u0152i;j/c141 values in a table c\u0152 0::m;0::n /c141 ,\nand it computes the entries in row-major order. (That is, the procedure \ufb01lls in the\n\ufb01rst row of cfrom left to right, then the second row, and so on.) The procedure also\nmaintains the table b\u0152 1::m;1::n /c141 to help us construct an optimal solution. Intu-\nitively, b\u0152i;j/c141 points to the table entry corresponding to the optimal subproblem\nsolution chosen when computing c\u0152i;j/c141 . The procedure returns the bandctables;\nc\u0152m;n/c141 contains the length of an LCS of XandY.\nLCS-L ENGTH .X; Y /\n1mDX:length\n2nDY:length\n3l e t b\u0152 1::m;1::n /c141 andc\u0152 0::m ;0::n /c141 be new tables\n4foriD1tom\n5 c\u0152i;0/c141D0\n6forjD0ton\n7 c\u01520;j/c141D0\n8foriD1tom\n9 forjD1ton\n10 ifxi==yj\n11 c\u0152i;j/c141Dc\u0152i/NUL1; j/NUL1/c141C1\n12 b\u0152i;j/c141D\u201c-\u201d\n13 elseif c\u0152i/NUL1; j /c141/NAKc\u0152i;j/NUL1/c141\n14 c\u0152i;j/c141Dc\u0152i/NUL1; j /c141\n15 b\u0152i;j/c141D\u201c\"\u201d\n16 elsec\u0152i;j/c141Dc\u0152i;j/NUL1/c141\n17 b\u0152i;j/c141D\u201c \u201d\n18return candb\nFigure 15.8 shows the tables produced by LCS-L ENGTH on the sequences XD\nhA; B; C; B; D; A; B iandYDhB; D; C; A; B; Ai. The running time of the\nprocedure is \u201a.mn/ , since each table entry takes \u201a.1/ time to compute.\nStep 4: Constructing an LCS\nThebtable returned by LCS-L ENGTH enables us to quickly construct an LCS of\nXDhx1;x2;:::;x miandYDhy1;y2;:::;y ni. We simply begin at b\u0152m;n/c141 and\ntrace through the table by following the arrows. Whenever we encounter a \u201c -\u201di n\nentry b\u0152i;j/c141 , it implies that xiDyjis an element of the LCS that LCS-L ENGTH", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "415": {"page_number": 416, "page_information": "15.4 Longest common subsequence 395\n0 0 0 0 0 0 0\n0 0 0 0 1 1 1\n0 1 1 1 2 2\n0 1 1 2 2 2\n0 1 1 2 2 3\n0 1 2 2 2 3 3\n0 1 2 2 3 3\n0 1 2 2 3 4 41\n2\n3\n4BDCABA123456 0\nA\nB\nC\nB\nD\nAB1\n23\n4\n5670j\ni\nxiyj\nFigure 15.8 Thecandbtables computed by LCS-L ENGTH on the sequences XDhA; B; C; B;\nD;A;BiandYDhB;D;C;A;B;Ai. The square in row iand column jcontains the value of c\u0152i; j/c141\nand the appropriate arrow for the value of b\u0152i;j/c141 .T h ee n t r y 4inc\u01527;6/c141 \u2014the lower right-hand corner\nof the table\u2014is the length of an LCS hB; C; B; AiofXandY.F o r i;j > 0 ,e n t r y c\u0152i;j/c141 depends\nonly on whether xiDyjand the values in entries c\u0152i/NUL1; j /c141,c\u0152i;j/NUL1/c141,a n d c\u0152i/NUL1; j/NUL1/c141,w h i c h\nare computed before c\u0152i;j/c141 . To reconstruct the elements of an LCS, follow the b\u0152i;j/c141 arrows from\nthe lower right-hand corner; the sequence is shaded. Each \u201c -\u201d on the shaded sequence corresponds\nto an entry (highlighted) for which xiDyji sam e m b e ro fa nL C S .\nfound. With this method, we encounter the elements of this LCS in reverse order.\nThe following recursive procedure prints out an LCS of XandYin the proper,\nforward order. The initial call is P RINT -LCS . b;X;X: length ;Y:length /.\nPRINT -LCS . b;X;i;j/\n1ifi==0orj==0\n2 return\n3ifb\u0152i;j/c141 ==\u201c-\u201d\n4P RINT -LCS . b;X;i/NUL1; j/NUL1/\n5 print xi\n6elseif b\u0152i;j/c141 ==\u201c\"\u201d\n7P RINT -LCS . b;X;i/NUL1; j /\n8elsePRINT -LCS . b;X;i;j/NUL1/\nFor the btable in Figure 15.8, this procedure prints BCBA . The procedure takes\ntimeO.mCn/, since it decrements at least one of iandjin each recursive call.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "416": {"page_number": 417, "page_information": "396 Chapter 15 Dynamic Programming\nImproving the code\nOnce you have developed an algorithm, you will often \ufb01nd that you can improve\non the time or space it uses. Some changes can simplify the code and improveconstant factors but otherwise yield no asymptotic improvement in performance.Others can yield substantial asymptotic savings in time and space.\nIn the LCS algorithm, for example, we can eliminate the btable altogether. Each\nc\u0152i;j/c141 entry depends on only three other ctable entries: c\u0152i/NUL1; j/NUL1/c141,c\u0152i/NUL1; j /c141,\nandc\u0152i;j/NUL1/c141. Given the value of c\u0152i;j/c141 , we can determine in O.1/ time which of\nthese three values was used to compute c\u0152i;j/c141 , without inspecting table b. Thus, we\ncan reconstruct an LCS in O.mCn/time using a procedure similar to P\nRINT -LCS.\n(Exercise 15.4-2 asks you to give the pseudocode.) Although we save \u201a.mn/ space\nby this method, the auxiliary space requirement for computing an LCS does notasymptotically decrease, since we need \u201a.mn/ space for the ctable anyway.\nWe can, however, reduce the asymptotic space requirements for LCS-L\nENGTH ,\nsince it needs only two rows of table cat a time: the row being computed and the\nprevious row. (In fact, as Exercise 15.4-4 asks you to show, we can use only slightlymore than the space for one row of cto compute the length of an LCS.) This\nimprovement works if we need only the length of an LCS; if we need to reconstruct\nthe elements of an LCS, the smaller table does not keep enough information to\nretrace our steps in O.mCn/time.\nExercises\n15.4-1\nDetermine an LCS of h1; 0; 0; 1; 0; 1; 0; 1iandh0; 1; 0; 1; 1; 0; 1; 1; 0 i.\n15.4-2\nGive pseudocode to reconstruct an LCS from the completed ctable and the original\nsequences XDhx\n1;x2;:::;x miandYDhy1;y2;:::;y niinO.mCn/time,\nwithout using the btable.\n15.4-3\nGive a memoized version of LCS-L ENGTH that runs in O.mn/ time.\n15.4-4\nShow how to compute the length of an LCS using only 2/SOHmin.m; n/ entries in the c\ntable plus O.1/ additional space. Then show how to do the same thing, but using\nmin.m; n/ entries plus O.1/ additional space.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "417": {"page_number": 418, "page_information": "15.5 Optimal binary search trees 397\n15.4-5\nGive an O.n2/-time algorithm to \ufb01nd the longest monotonically increasing subse-\nquence of a sequence of nnumbers.\n15.4-6 ?\nGive an O.n lgn/-time algorithm to \ufb01nd the longest monotonically increasing sub-\nsequence of a sequence of nnumbers. ( Hint: Observe that the last element of a\ncandidate subsequence of length iis at least as large as the last element of a can-\ndidate subsequence of length i/NUL1. Maintain candidate subsequences by linking\nthem through the input sequence.)\n15.5 Optimal binary search trees\nSuppose that we are designing a program to translate text from English to French.\nFor each occurrence of each English word in the text, we need to look up its Frenchequivalent. We could perform these lookup operations by building a binary searchtree with nEnglish words as keys and their French equivalents as satellite data.\nBecause we will search the tree for each individual word in the text, we want the\ntotal time spent searching to be as low as possible. We could ensure an O.lgn/\nsearch time per occurrence by using a red-black tree or any other balanced binarysearch tree. Words appear with different frequencies, however, and a frequentlyused word such as themay appear far from the root while a rarely used word such\nasmachicolation appears near the root. Such an organization would slow down the\ntranslation, since the number of nodes visited when searching for a key in a binarysearch tree equals one plus the depth of the node containing the key. We wantwords that occur frequently in the text to be placed nearer the root.\n6Moreover,\nsome words in the text might have no French translation,7and such words would\nnot appear in the binary search tree at all. How do we organize a binary search treeso as to minimize the number of nodes visited in all searches, given that we knowhow often each word occurs?\nWhat we need is known as an optimal binary search tree . Formally, we are\ngiven a sequence KDhk\n1;k2;:::;k niofndistinct keys in sorted order (so that\nk1<k 2</SOH/SOH/SOH<k n), and we wish to build a binary search tree from these keys.\nFor each key ki, we have a probability pithat a search will be for ki.S o m e\nsearches may be for values not in K, and so we also have nC1\u201cdummy keys\u201d\n6If the subject of the text is castle architecture, we might want machicolation to appear near the root.\n7Yes, machicolation has a French counterpart: m\u02c6achicoulis .", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "418": {"page_number": 419, "page_information": "398 Chapter 15 Dynamic Programming\nk2\nk1 k4\nk3 k5 d0 d1\nd2 d3 d4 d5\n(a)k2\nk1\nk4\nk3k5\nd0 d1\nd2 d3d4d5\n(b)\nFigure 15.9 Two binary search trees for a set of nD5keys with the following probabilities:\ni\n 012345\npi\n 0.15 0.10 0.05 0.10 0.20\nqi\n0.05 0.10 0.05 0.05 0.05 0.10\n(a)A binary search tree with expected search cost 2.80. (b)A binary search tree with expected search\ncost 2.75. This tree is optimal.\nd0;d1;d2;:::;d nrepresenting values not in K. In particular, d0represents all val-\nues less than k1,dnrepresents all values greater than kn,a n df o r iD1 ;2;:::;n/NUL1,\nthe dummy key direpresents all values between kiandkiC1. For each dummy\nkeydi, we have a probability qithat a search will correspond to di. Figure 15.9\nshows two binary search trees for a set of nD5keys. Each key kiis an internal\nnode, and each dummy key diis a leaf. Every search is either successful (\ufb01nding\nsome key ki) or unsuccessful (\ufb01nding some dummy key di) ,a n ds ow eh a v e\nnX\niD1piCnX\niD0qiD1: (15.10)\nBecause we have probabilities of searches for each key and each dummy key,\nwe can determine the expected cost of a search in a given binary search tree T.L e t\nus assume that the actual cost of a search equals the number of nodes examined,i.e., the depth of the node found by the search in T, plus 1. Then the expected cost\nof a search in Tis\nE\u0152search cost in T/c141D nX\niD1.depthT.ki/C1//SOHpiCnX\niD0.depthT.di/C1//SOHqi\nD1CnX\niD1depthT.ki//SOHpiCnX\niD0depthT.di//SOHqi; (15.11)", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "419": {"page_number": 420, "page_information": "15.5 Optimal binary search trees 399\nwhere depthTdenotes a node\u2019s depth in the tree T. The last equality follows from\nequation (15.10). In Figure 15.9(a), we can calculate the expected search cost nodeby node:\nnode depth probability contribution\nk1 1 0.15 0.30\nk2 0 0.10 0.10\nk3 2 0.05 0.15\nk4 1 0.10 0.20\nk5 2 0.20 0.60\nd0 2 0.05 0.15\nd1 2 0.10 0.30\nd2 3 0.05 0.20\nd3 3 0.05 0.20\nd4 3 0.05 0.20\nd5 3 0.10 0.40\nTotal 2.80\nFor a given set of probabilities, we wish to construct a binary search tree whose\nexpected search cost is smallest. We call such a tree an optimal binary search tree .\nFigure 15.9(b) shows an optimal binary search tree for the probabilities given inthe \ufb01gure caption; its expected cost is 2.75. This example shows that an optimalbinary search tree is not necessarily a tree whose overall height is smallest. Norcan we necessarily construct an optimal binary search tree by always putting the\nkey with the greatest probability at the root. Here, key k\n5has the greatest search\nprobability of any key, yet the root of the optimal binary search tree shown is k2.\n(The lowest expected cost of any binary search tree with k5at the root is 2.85.)\nAs with matrix-chain multiplication, exhaustive checking of all possibilities fails\nto yield an ef\ufb01cient algorithm. We can label the nodes of any n-node binary tree\nwith the keys k1;k2;:::;k nto construct a binary search tree, and then add in the\ndummy keys as leaves. In Problem 12-4, we saw that the number of binary treeswith nnodes is /DEL.4\nn=n3=2/, and so we would have to examine an exponential\nnumber of binary search trees in an exhaustive search. Not surprisingly, we shallsolve this problem with dynamic programming.\nStep 1: The structure of an optimal binary search tree\nTo characterize the optimal substructure of optimal binary search trees, we start\nwith an observation about subtrees. Consider any subtree of a binary search tree.It must contain keys in a contiguous range k\ni;:::;k j,f o rs o m e 1/DC4i/DC4j/DC4n.\nIn addition, a subtree that contains keys ki;:::;k jmust also have as its leaves the\ndummy keys di/NUL1;:::;d j.\nNow we can state the optimal substructure: if an optimal binary search tree T\nhas a subtree T0containing keys ki;:::;k j, then this subtree T0must be optimal as", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "420": {"page_number": 421, "page_information": "400 Chapter 15 Dynamic Programming\nwell for the subproblem with keys ki;:::;k jand dummy keys di/NUL1;:::;d j.T h e\nusual cut-and-paste argument applies. If there were a subtree T00whose expected\ncost is lower than that of T0, then we could cut T0out of Tand paste in T00,\nresulting in a binary search tree of lower expected cost than T, thus contradicting\nthe optimality of T.\nWe need to use the optimal substructure to show that we can construct an opti-\nmal solution to the problem from optimal solutions to subproblems. Given keysk\ni;:::;k j, one of these keys, say kr(i/DC4r/DC4j), is the root of an optimal\nsubtree containing these keys. The left subtree of the root krcontains the keys\nki;:::;k r/NUL1(and dummy keys di/NUL1;:::;d r/NUL1), and the right subtree contains the\nkeyskrC1;:::;k j(and dummy keys dr;:::;d j). As long as we examine all candi-\ndate roots kr,w h e r e i/DC4r/DC4j, and we determine all optimal binary search trees\ncontaining ki;:::;k r/NUL1and those containing krC1;:::;k j, we are guaranteed that\nwe will \ufb01nd an optimal binary search tree.\nThere is one detail worth noting about \u201cempty\u201d subtrees. Suppose that in a\nsubtree with keys ki;:::;k j, we select kias the root. By the above argument, ki\u2019s\nleft subtree contains the keys ki;:::;k i/NUL1. We interpret this sequence as containing\nno keys. Bear in mind, however, that subtrees also contain dummy keys. We adopt\nthe convention that a subtree containing keys ki;:::;k i/NUL1has no actual keys but\ndoes contain the single dummy key di/NUL1. Symmetrically, if we select kjas the root,\nthenkj\u2019s right subtree contains the keys kjC1;:::;k j; this right subtree contains\nno actual keys, but it does contain the dummy key dj.\nStep 2: A recursive solution\nWe are ready to de\ufb01ne the value of an optimal solution recursively. We pick our\nsubproblem domain as \ufb01nding an optimal binary search tree containing the keys\nki;:::;k j,w h e r e i/NAK1,j/DC4n,a n d j/NAKi/NUL1.( W h e n jDi/NUL1,t h e r e\nare no actual keys; we have just the dummy key di/NUL1.) Let us de\ufb01ne e\u0152i;j/c141 as\nthe expected cost of searching an optimal binary search tree containing the keysk\ni;:::;k j. Ultimately, we wish to compute e\u01521;n/c141 .\nThe easy case occurs when jDi/NUL1. Then we have just the dummy key di/NUL1.\nThe expected search cost is e\u0152i;i/NUL1/c141Dqi/NUL1.\nWhen j/NAKi, we need to select a root krfrom among ki;:::;k ja n dt h e nm a k ea n\noptimal binary search tree with keys ki;:::;k r/NUL1as its left subtree and an optimal\nbinary search tree with keys krC1;:::;k jas its right subtree. What happens to the\nexpected search cost of a subtree when it becomes a subtree of a node? The depthof each node in the subtree increases by 1. By equation (15.11), the expected searchcost of this subtree increases by the sum of all the probabilities in the subtree. Fora subtree with keys k\ni;:::;k j, let us denote this sum of probabilities as", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "421": {"page_number": 422, "page_information": "15.5 Optimal binary search trees 401\nw.i;j/DjX\nlDiplCjX\nlDi/NUL1ql: (15.12)\nThus, if kris the root of an optimal subtree containing keys ki;:::;k j,w eh a v e\ne\u0152i;j/c141DprC.e\u0152i; r/NUL1/c141Cw.i;r/NUL1//C.e\u0152rC1; j /c141Cw.rC1; j // :\nNoting that\nw.i;j/Dw.i;r/NUL1/CprCw.rC1; j / ;\nwe rewrite e\u0152i;j/c141 as\ne\u0152i;j/c141De\u0152i;r/NUL1/c141Ce\u0152rC1; j /c141Cw.i;j/ : (15.13)\nThe recursive equation (15.13) assumes that we know which node krto use as\nthe root. We choose the root that gives the lowest expected search cost, giving usour \ufb01nal recursive formulation:\ne\u0152i;j/c141D(\nq\ni/NUL1 ifjDi/NUL1;\nmin\ni/DC4r/DC4jfe\u0152i;r/NUL1/c141Ce\u0152rC1; j /c141Cw.i;j/gifi/DC4j:(15.14)\nThee\u0152i;j/c141 values give the expected search costs in optimal binary search trees.\nTo help us keep track of the structure of optimal binary search trees, we de\ufb01neroot\u0152i; j /c141 ,f o r 1/DC4i/DC4j/DC4n, to be the index rfor which k\nris the root of an\noptimal binary search tree containing keys ki;:::;k j. Although we will see how\nto compute the values of root\u0152i; j /c141 , we leave the construction of an optimal binary\nsearch tree from these values as Exercise 15.5-1.\nStep 3: Computing the expected search cost of an optimal binary search tree\nAt this point, you may have noticed some similarities between our characterizations\nof optimal binary search trees and matrix-chain multiplication. For both problemdomains, our subproblems consist of contiguous index subranges. A direct, recur-sive implementation of equation (15.14) would be as inef\ufb01cient as a direct, recur-sive matrix-chain multiplication algorithm. Instead, we store the e\u0152i;j/c141 values in a\ntable e\u01521::nC1 ;0::n /c141 . The \ufb01rst index needs to run to nC1rather than nbecause\nin order to have a subtree containing only the dummy key d\nn, we need to compute\nand store e\u0152nC1; n/c141. The second index needs to start from 0because in order to\nhave a subtree containing only the dummy key d0, we need to compute and store\ne\u01521; 0/c141 . We use only the entries e\u0152i;j/c141 for which j/NAKi/NUL1. We also use a table\nroot\u0152i; j /c141 , for recording the root of the subtree containing keys ki;:::;k j.T h i s\ntable uses only the entries for which 1/DC4i/DC4j/DC4n.\nWe will need one other table for ef\ufb01ciency. Rather than compute the value\nofw.i;j/ from scratch every time we are computing e\u0152i;j/c141 \u2014which would take", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "422": {"page_number": 423, "page_information": "402 Chapter 15 Dynamic Programming\n\u201a.j/NULi/additions\u2014we store these values in a table w\u01521::nC1 ;0::n /c141 .F o rt h e\nbase case, we compute w\u0152i;i/NUL1/c141Dqi/NUL1for1/DC4i/DC4nC1.F o r j/NAKi,w e\ncompute\nw\u0152i;j/c141Dw\u0152i;j/NUL1/c141CpjCqj: (15.15)\nThus, we can compute the \u201a.n2/values of w\u0152i;j/c141 in\u201a.1/ time each.\nThe pseudocode that follows takes as inputs the probabilities p1;:::;p nand\nq0;:::;q nand the size n, and it returns the tables eandroot.\nOPTIMAL -BST . p;q;n /\n1l e t e\u01521::nC1 ;0::n /c141 ,w\u01521::nC1 ;0::n /c141 ,\nandroot\u0152 1::n ;1::n /c141 be new tables\n2foriD1tonC1\n3 e\u0152i;i/NUL1/c141Dqi/NUL1\n4 w\u0152i;i/NUL1/c141Dqi/NUL1\n5forlD1ton\n6 foriD1ton/NULlC1\n7 jDiCl/NUL1\n8 e\u0152i;j/c141D1\n9 w\u0152i;j/c141Dw\u0152i;j/NUL1/c141CpjCqj\n10 forrDitoj\n11 tDe\u0152i;r/NUL1/c141Ce\u0152rC1; j /c141Cw\u0152i;j/c141\n12 ift<e \u0152 i ; j /c141\n13 e\u0152i;j/c141Dt\n14 root\u0152i; j /c141Dr\n15return eandroot\nFrom the description above and the similarity to the M ATRIX -CHAIN -ORDER pro-\ncedure in Section 15.2, you should \ufb01nd the operation of this procedure to be fairlystraightforward. The forloop of lines 2\u20134 initializes the values of e\u0152i;i/NUL1/c141\nandw\u0152i;i/NUL1/c141.T h e forloop of lines 5\u201314 then uses the recurrences (15.14)\nand (15.15) to compute e\u0152i;j/c141 andw\u0152i;j/c141 for all 1/DC4i/DC4j/DC4n. In the \ufb01rst itera-\ntion, when lD1, the loop computes e\u0152i;i/c141 andw\u0152i;i/c141 foriD1 ;2;:::;n . The sec-\nond iteration, with lD2, computes e\u0152i;iC1/c141andw\u0152i;iC1/c141foriD1 ;2;:::;n/NUL1,\nand so forth. The innermost forloop, in lines 10\u201314, tries each candidate index r\nto determine which key k\nrto use as the root of an optimal binary search tree con-\ntaining keys ki;:::;k j.T h i s forloop saves the current value of the index rin\nroot\u0152i; j /c141 whenever it \ufb01nds a better key to use as the root.\nFigure 15.10 shows the tables e\u0152i;j/c141 ,w\u0152i;j/c141 ,a n d root\u0152i; j /c141 computed by the\nprocedure O PTIMAL -BST on the key distribution shown in Figure 15.9. As in the\nmatrix-chain multiplication example of Figure 15.5, the tables are rotated to make", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "423": {"page_number": 424, "page_information": "15.5 Optimal binary search trees 403\n2.75\n1.75\n1.25\n0.90\n0.45\n0.052.00\n1.20\n0.70\n0.40\n0.101.30\n0.60\n0.25\n0.050.90\n0.30\n0.050.50\n0.05 0.10e\n012345\n654321\nji 1.00\n0.70\n0.55\n0.45\n0.30\n0.050.80\n0.50\n0.35\n0.25\n0.100.60\n0.30\n0.15\n0.050.50\n0.20\n0.050.35\n0.05 0.10w\n012345\n654321\nji\n2\n2\n2\n1\n14\n2\n2\n25\n4\n35\n4 5root\n12345\n54321\nji\nFigure 15.10 The tables e\u0152i;j/c141 ,w\u0152i;j/c141 ,a n d root\u0152i; j /c141 computed by O PTIMAL -BST on the key\ndistribution shown in Figure 15.9. The tables are rotated so that the diagonals run horizontally.\nthe diagonals run horizontally. O PTIMAL -BST computes the rows from bottom to\ntop and from left to right within each row.\nThe O PTIMAL -BST procedure takes \u201a.n3/time, just like M ATRIX -CHAIN -\nORDER . We can easily see that its running time is O.n3/, since its forloops are\nnested three deep and each loop index takes on at most nvalues. The loop indices in\nOPTIMAL -BST do not have exactly the same bounds as those in M ATRIX -CHAIN -\nORDER , but they are within at most 1 in all directions. Thus, like M ATRIX -CHAIN -\nORDER ,t h eO PTIMAL -BST procedure takes /DEL.n3/time.\nExercises\n15.5-1\nWrite pseudocode for the procedure C ONSTRUCT -OPTIMAL -BST .root/which,\ngiven the table root, outputs the structure of an optimal binary search tree. For the\nexample in Figure 15.10, your procedure should print out the structure", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "424": {"page_number": 425, "page_information": "404 Chapter 15 Dynamic Programming\nk2is the root\nk1is the left child of k2\nd0is the left child of k1\nd1is the right child of k1\nk5is the right child of k2\nk4is the left child of k5\nk3is the left child of k4\nd2is the left child of k3\nd3is the right child of k3\nd4is the right child of k4\nd5is the right child of k5\ncorresponding to the optimal binary search tree shown in Figure 15.9(b).\n15.5-2\nDetermine the cost and structure of an optimal binary search tree for a set of nD7\nkeys with the following probabilities:\ni\n 01234567\npi\n 0.04 0.06 0.08 0.02 0.10 0.12 0.14\nqi\n0.06 0.06 0.06 0.06 0.05 0.05 0.05 0.05\n15.5-3\nSuppose that instead of maintaining the table w\u0152i;j/c141 , we computed the value\nofw.i;j/ directly from equation (15.12) in line 9 of O PTIMAL -BST and used this\ncomputed value in line 11. How would this change affect the asymptotic runningtime of O\nPTIMAL -BST?\n15.5-4 ?\nKnuth [212] has shown that there are always roots of optimal subtrees such thatroot\u0152i; j/NUL1/c141/DC4root\u0152i; j /c141/DC4root\u0152iC1; j /c141 for all 1/DC4i<j/DC4n. Use this fact to\nmodify the O\nPTIMAL -BST procedure to run in \u201a.n2/time.\nProblems\n15-1 Longest simple path in a directed acyclic graph\nSuppose that we are given a directed acyclic graph GD.V; E/ with real-\nvalued edge weights and two distinguished vertices sandt. Describe a dynamic-\nprogramming approach for \ufb01nding a longest weighted simple path from stot.\nWhat does the subproblem graph look like? What is the ef\ufb01ciency of your algo-rithm?", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "425": {"page_number": 426, "page_information": "Problems for Chapter 15 405\n(a) (b)\nFigure 15.11 Seven points in the plane, shown on a unit grid. (a)The shortest closed tour, with\nlength approximately 24:89 . This tour is not bitonic. (b)T h es h o r t e s tb i t o n i ct o u rf o rt h es a m es e to f\npoints. Its length is approximately 25:58 .\n15-2 Longest palindrome subsequence\nApalindrome is a nonempty string over some alphabet that reads the same for-\nward and backward. Examples of palindromes are all strings of length 1,civic ,\nracecar ,a n daibohphobia (fear of palindromes).\nGive an ef\ufb01cient algorithm to \ufb01nd the longest palindrome that is a subsequence\nof a given input string. For example, given the input character , your algorithm\nshould return carac . What is the running time of your algorithm?\n15-3 Bitonic euclidean traveling-salesman problem\nIn the euclidean traveling-salesman problem ,w ea r eg i v e nas e to f npoints in\nthe plane, and we wish to \ufb01nd the shortest closed tour that connects all npoints.\nFigure 15.11(a) shows the solution to a 7-point problem. The general problem is\nNP-hard, and its solution is therefore believed to require more than polynomialtime (see Chapter 34).\nJ. L. Bentley has suggested that we simplify the problem by restricting our at-\ntention to bitonic tours , that is, tours that start at the leftmost point, go strictly\nrightward to the rightmost point, and then go strictly leftward back to the startingpoint. Figure 15.11(b) shows the shortest bitonic tour of the same 7points. In this\ncase, a polynomial-time algorithm is possible.\nDescribe an O.n\n2/-time algorithm for determining an optimal bitonic tour. You\nmay assume that no two points have the same x-coordinate and that all operations\non real numbers take unit time. ( Hint: Scan left to right, maintaining optimal pos-\nsibilities for the two parts of the tour.)\n15-4 Printing neatly\nConsider the problem of neatly printing a paragraph with a monospaced font (allcharacters having the same width) on a printer. The input text is a sequence of n", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "426": {"page_number": 427, "page_information": "406 Chapter 15 Dynamic Programming\nwords of lengths l1;l2;:::;l n, measured in characters. We want to print this para-\ngraph neatly on a number of lines that hold a maximum of Mcharacters each. Our\ncriterion of \u201cneatness\u201d is as follows. If a given line contains words ithrough j,\nwhere i/DC4j, and we leave exactly one space between words, the number of extra\nspace characters at the end of the line is M/NULjCi/NULPj\nkDilk, which must be\nnonnegative so that the words \ufb01t on the line. We wish to minimize the sum, overall lines except the last, of the cubes of the numbers of extra space characters at theends of lines. Give a dynamic-programming algorithm to print a paragraph of n\nwords neatly on a printer. Analyze the running time and space requirements of\nyour algorithm.\n15-5 Edit distance\nIn order to transform one source string of text x\u0152 1::m /c141 to a target string y\u0152 1::n /c141 ,\nwe can perform various transformation operations. Our goal is, given xandy,\nto produce a series of transformations that change xtoy. We use an ar-\nray\u00b4\u2014assumed to be large enough to hold all the characters it will need\u2014to hold\nthe intermediate results. Initially, \u00b4is empty, and at termination, we should have\n\u00b4\u0152j /c141Dy\u0152j/c141 forjD1 ;2;:::;n . We maintain current indices iintoxandjinto\u00b4,\nand the operations are allowed to alter \u00b4and these indices. Initially, iDjD1.\nWe are required to examine every character in xduring the transformation, which\nmeans that at the end of the sequence of transformation operations, we must have\niDmC1.\nWe may choose from among six transformation operations:\nCopy a character from xto\u00b4by setting \u00b4\u0152j /c141Dx\u0152i/c141and then incrementing both i\nandj. This operation examines x\u0152i/c141.\nReplace a character from xby another character c, by setting \u00b4\u0152j /c141Dc,a n dt h e n\nincrementing both iandj. This operation examines x\u0152i/c141.\nDelete a character from xby incrementing i\nbut leaving jalone. This operation\nexamines x\u0152i/c141.\nInsert the character cinto\u00b4by setting \u00b4\u0152j /c141Dcand then incrementing j,b u t\nleaving ialone. This operation examines no characters of x.\nTwiddle (i.e., exchange) the next two characters by copying them from xto\u00b4but\nin the opposite order; we do so by setting \u00b4\u0152j /c141Dx\u0152iC1/c141and\u00b4\u0152jC1/c141Dx\u0152i/c141\nand then setting iDiC2andjDjC2. This operation examines x\u0152i/c141\nandx\u0152iC1/c141.\nKillthe remainder of xby setting iDmC1. This operation examines all char-\nacters in xthat have not yet been examined. This operation, if performed, must\nbe the \ufb01nal operation.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "427": {"page_number": 428, "page_information": "Problems for Chapter 15 407\nAs an example, one way to transform the source string algorithm to the target\nstring altruistic is to use the following sequence of operations, where the\nunderlined characters are x\u0152i/c141and\u00b4\u0152j /c141 after the operation:\nOperation x\u00b4\ninitial strings a\nlgorithm\ncopy al\ngorithm a\ncopy alg\norithm al\nreplace by t algo\n rithm alt\ndelete algor\n ithm alt\ncopy algori\n thm altr\ninsert u algori\n thm altru\ninsert i algori\n thm altrui\ninsert s algori\n thm altruis\ntwiddle algorith\n m altruisti\ninsert c algorith\n m altruistic\nkill algorithm\n altruistic\nNote that there are several other sequences of transformation operations that trans-\nformalgorithm toaltruistic .\nEach of the transformation operations has an associated cost. The cost of an\noperation depends on the speci\ufb01c application, but we assume that each operation\u2019scost is a constant that is known to us. We also assume that the individual costs ofthe copy and replace operations are less than the combined costs of the delete andinsert operations; otherwise, the copy and replace operations would not be used.\nThe cost of a given sequence of transformation operations is the sum of the costs\nof the individual operations in the sequence. For the sequence above, the cost oftransforming algorithm toaltruistic is\n.3/SOHcost.copy//Ccost.replace /Ccost.delete /C.4/SOHcost.insert //\nCcost.twiddle /Ccost.kill/:\na.Given two sequences x\u01521::m/c141 andy\u0152 1::n /c141 and set of transformation-operation\ncosts, the edit distance from xtoyis the cost of the least expensive operation\nsequence that transforms xtoy. Describe a dynamic-programming algorithm\nthat \ufb01nds the edit distance from x\u01521::m/c141 toy\u0152 1::n /c141 and prints an optimal op-\neration sequence. Analyze the running time and space requirements of your\nalgorithm.\nThe edit-distance problem generalizes the problem of aligning two DNA sequences\n(see, for example, Setubal and Meidanis [310, Section 3.2]). There are severalmethods for measuring the similarity of two DNA sequences by aligning them.One such method to align two sequences xandyconsists of inserting spaces at", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "428": {"page_number": 429, "page_information": "408 Chapter 15 Dynamic Programming\narbitrary locations in the two sequences (including at either end) so that the result-\ning sequences x0andy0have the same length but do not have a space in the same\nposition (i.e., for no position jare both x0\u0152j /c141andy0\u0152j /c141a space). Then we assign a\n\u201cscore\u201d to each position. Position jreceives a score as follows:\n/SIC1ifx0\u0152j /c141Dy0\u0152j /c141and neither is a space,\n/SI/NUL1ifx0\u0152j /c141\u00a4y0\u0152j /c141and neither is a space,\n/SI/NUL2if either x0\u0152j /c141ory0\u0152j /c141is a space.\nThe score for the alignment is the sum of the scores of the individual positions. For\nexample, given the sequences xDGATCGGCAT andyDCAATGTGAATC , one\nalignment is\nG ATCG GCAT\nCAAT GTGAATC-*++*+*+-++ *\nA+under a position indicates a score of C1for that position, a -indicates a score\nof/NUL1,a n da *indicates a score of /NUL2, so that this alignment has a total score of\n6/SOH1/NUL2/SOH1/NUL4/SOH2D/NUL4.\nb.Explain how to cast the problem of \ufb01nding an optimal alignment as an edit\ndistance problem using a subset of the transformation operations copy, replace,\ndelete, insert, twiddle, and kill.\n15-6 Planning a company party\nProfessor Stewart is consulting for the president of a corporation that is planninga company party. The company has a hierarchical structure; that is, the supervisorrelation forms a tree rooted at the president. The personnel of\ufb01ce has ranked eachemployee with a conviviality rating, which is a real number. In order to make the\nparty fun for all attendees, the president does not want both an employee and his\nor her immediate supervisor to attend.\nProfessor Stewart is given the tree that describes the structure of the corporation,\nusing the left-child, right-sibling representation described in Section 10.4. Eachnode of the tree holds, in addition to the pointers, the name of an employee andthat employee\u2019s conviviality ranking. Describe an algorithm to make up a guestlist that maximizes the sum of the conviviality ratings of the guests. Analyze therunning time of your algorithm.\n15-7 Viterbi algorithm\nWe can use dynamic programming on a directed graph GD.V; E/ for speech\nrecognition. Each edge .u; /ETB/2Eis labeled with a sound /ESC.u;/ETB/ from a \ufb01-\nnite set \u2020of sounds. The labeled graph is a formal model of a person speaking", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "429": {"page_number": 430, "page_information": "Problems for Chapter 15 409\na restricted language. Each path in the graph starting from a distinguished ver-\ntex/ETB02Vcorresponds to a possible sequence of sounds produced by the model.\nWe de\ufb01ne the label of a directed path to be the concatenation of the labels of theedges on that path.\na.Describe an ef\ufb01cient algorithm that, given an edge-labeled graph Gwith dis-\ntinguished vertex /ETB\n0and a sequence sDh/ESC1;/ESC2;:::;/ESC kiof sounds from \u2020,\nreturns a path in Gthat begins at /ETB0and has sas its label, if any such path exists.\nOtherwise, the algorithm should return NO-SUCH -PATH . Analyze the running\ntime of your algorithm. ( Hint: You may \ufb01nd concepts from Chapter 22 useful.)\nNow, suppose that every edge .u; /ETB/2Ehas an associated nonnegative proba-\nbility p.u;/ETB/ of traversing the edge .u; /ETB/ from vertex uand thus producing the\ncorresponding sound. The sum of the probabilities of the edges leaving any vertexequals 1. The probability of a path is de\ufb01ned to be the product of the probabil-\nities of its edges. We can view the probability of a path beginning at /ETB\n0as the\nprobability that a \u201crandom walk\u201d beginning at /ETB0will follow the speci\ufb01ed path,\nwhere we randomly choose which edge to take leaving a vertex uaccording to the\nprobabilities of the available edges leaving u.\nb.Extend your answer to part (a) so that if a path is returned, it is a most prob-\nable path starting at /ETB0and having label s. Analyze the running time of your\nalgorithm.\n15-8 Image compression by seam carving\nWe are given a color picture consisting of an m/STXnarray A\u01521 : : m; 1 : : n/c141 of pixels,\nwhere each pixel speci\ufb01es a triple of red, green, and blue (RGB) intensities. Sup-pose that we wish to compress this picture slightly. Speci\ufb01cally, we wish to remove\none pixel from each of the mrows, so that the whole picture becomes one pixel\nnarrower. To avoid disturbing visual effects, however, we require that the pixelsremoved in two adjacent rows be in the same or adjacent columns; the pixels re-moved form a \u201cseam\u201d from the top row to the bottom row where successive pixelsin the seam are adjacent vertically or diagonally.\na.Show that the number of such possible seams grows at least exponentially in m,\nassuming that n>1 .\nb.Suppose now that along with each pixel A\u0152i; j /c141 , we have calculated a real-\nvalued disruption measure d\u0152i;j/c141 , indicating how disruptive it would be to\nremove pixel A\u0152i; j /c141 . Intuitively, the lower a pixel\u2019s disruption measure, the\nmore similar the pixel is to its neighbors. Suppose further that we de\ufb01ne thedisruption measure of a seam to be the sum of the disruption measures of itspixels.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "430": {"page_number": 431, "page_information": "410 Chapter 15 Dynamic Programming\nGive an algorithm to \ufb01nd a seam with the lowest disruption measure. How\nef\ufb01cient is your algorithm?\n15-9 Breaking a string\nA certain string-processing language allows a programmer to break a string intotwo pieces. Because this operation copies the string, it costs ntime units to break\na string of ncharacters into two pieces. Suppose a programmer wants to break\na string into many pieces. The order in which the breaks occur can affect thetotal amount of time used. For example, suppose that the programmer wants tobreak a 20-character string after characters 2,8,a n d 10(numbering the characters\nin ascending order from the left-hand end, starting from 1). If she programs the\nbreaks to occur in left-to-right order, then the \ufb01rst break costs 20time units, the\nsecond break costs 18time units (breaking the string from characters 3to20at\ncharacter 8), and the third break costs 12time units, totaling 50time units. If she\nprograms the breaks to occur in right-to-left order, however, then the \ufb01rst breakcosts 20time units, the second break costs 10time units, and the third break costs\n8time units, totaling 38time units. In yet another order, she could break \ufb01rst at 8\n(costing 20), then break the left piece at 2(costing 8), and \ufb01nally the right piece\nat10(costing 12), for a total cost of 40.\nDesign an algorithm that, given the numbers of characters after which to break,\ndetermines a least-cost way to sequence those breaks. More formally, given astring Swithncharacters and an array L \u0152 1::m /c141 containing the break points, com-\npute the lowest cost for a sequence of breaks, along with a sequence of breaks thatachieves this cost.\n15-10 Planning an investment strategy\nYour knowledge of algorithms helps you obtain an exciting job with the AcmeComputer Company, along with a $10,000 signing bonus. You decide to investthis money with the goal of maximizing your return at the end of 10years. You\ndecide to use the Amalgamated Investment Company to manage your investments.\nAmalgamated Investments requires you to observe the following rules. It offers n\ndifferent investments, numbered 1through n. In each year j, investment iprovides\na return rate of r\nij. In other words, if you invest ddollars in investment iin year j,\nthen at the end of year j, you have drijdollars. The return rates are guaranteed,\nthat is, you are given all the return rates for the next 10years for each investment.\nYou make investment decisions only once per year. At the end of each year, youcan leave the money made in the previous year in the same investments, or youcan shift money to other investments, by either shifting money between existinginvestments or moving money to a new investement. If you do not move yourmoney between two consecutive years, you pay a fee of f\n1dollars, whereas if you\nswitch your money, you pay a fee of f2dollars, where f2>f 1.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "431": {"page_number": 432, "page_information": "Problems for Chapter 15 411\na.The problem, as stated, allows you to invest your money in multiple investments\nin each year. Prove that there exists an optimal investment strategy that, ineach year, puts all the money into a single investment. (Recall that an optimalinvestment strategy maximizes the amount of money after 10years and is not\nconcerned with any other objectives, such as minimizing risk.)\nb.Prove that the problem of planning your optimal investment strategy exhibits\noptimal substructure.\nc.Design an algorithm that plans your optimal investment strategy. What is the\nrunning time of your algorithm?\nd.Suppose that Amalgamated Investments imposed the additional restriction that,\nat any point, you can have no more than $15,000 in any one investment. Showthat the problem of maximizing your income at the end of 10years no longer\nexhibits optimal substructure.\n15-11 Inventory planning\nThe Rinky Dink Company makes machines that resurface ice rinks. The demandfor such products varies from month to month, and so the company needs to de-velop a strategy to plan its manufacturing given the \ufb02uctuating, but predictable,demand. The company wishes to design a plan for the next nmonths. For each\nmonth i, the company knows the demand d\ni, that is, the number of machines that\nit will sell. Let DDPn\niD1dibe the total demand over the next nmonths. The\ncompany keeps a full-time staff who provide labor to manufacture up to mma-\nchines per month. If the company needs to make more than mmachines in a given\nmonth, it can hire additional, part-time labor, at a cost that works out to cdollars\nper machine. Furthermore, if, at the end of a month, the company is holding anyunsold machines, it must pay inventory costs. The cost for holding jmachines is\ngiven as a function h.j / forjD1 ;2;:::;D ,w h e r e h.j //NAK0for1/DC4j/DC4Dand\nh.j //DC4h.jC1/for1/DC4j/DC4D/NUL1.\nGive an algorithm that calculates a plan for the company that minimizes its costs\nwhile ful\ufb01lling all the demand. The running time should be polyomial in nandD.\n15-12 Signing free-agent baseball players\nSuppose that you are the general manager for a major-league baseball team. During\nthe off-season, you need to sign some free-agent players for your team. The team\nowner has given you a budget of $ Xto spend on free agents. You are allowed to\nspend less than $ Xaltogether, but the owner will \ufb01re you if you spend any more\nthan $ X.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "432": {"page_number": 433, "page_information": "412 Chapter 15 Dynamic Programming\nYou are considering Ndifferent positions, and for each position, Pfree-agent\nplayers who play that position are available.8Because you do not want to overload\nyour roster with too many players at any position, for each position you may signat most one free agent who plays that position. (If you do not sign any players at aparticular position, then you plan to stick with the players you already have at thatposition.)\nTo determine how valuable a player is going to be, you decide to use a sabermet-\nric statistic\n9known as \u201cVORP,\u201d or \u201cvalue over replacement player.\u201d A player with\na higher VORP is more valuable than a player with a lower VORP. A player with a\nhigher VORP is not necessarily more expensive to sign than a player with a lowerVORP, because factors other than a player\u2019s value determine how much it costs tosign him.\nFor each available free-agent player, you have three pieces of information:\n/SIthe player\u2019s position,\n/SIthe amount of money it will cost to sign the player, and\n/SIthe player\u2019s VORP.\nDevise an algorithm that maximizes the total VORP of the players you sign while\nspending no more than $ Xaltogether. You may assume that each player signs for a\nmultiple of $100,000. Your algorithm should output the total VORP of the players\nyou sign, the total amount of money you spend, and a list of which players you\nsign. Analyze the running time and space requirement of your algorithm.\nChapter notes\nR. Bellman began the systematic study of dynamic programming in 1955. The\nword \u201cprogramming,\u201d both here and in linear programming, refers to using a tab-ular solution method. Although optimization techniques incorporating elements ofdynamic programming were known earlier, Bellman provided the area with a solidmathematical basis [37].\n8Although there are nine positions on a baseball team, Nis not necesarily equal to 9because some\ngeneral managers have particular ways of thinking about positions. For example, a general managermight consider right-handed pitchers and left-handed pitchers to be separate \u201cpositions,\u201d as well as\nstarting pitchers, long relief pitchers (relief pitchers who can pitch several innings), and short relief\npitchers (relief pitchers who normally pitch at most only one inning).\n9Sabermetrics is the application of statistical analysis to baseball records. It provides several ways\nto compare the relative values of individual players.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "433": {"page_number": 434, "page_information": "Notes for Chapter 15 413\nGalil and Park [125] classify dynamic-programming algorithms according to the\nsize of the table and the number of other table entries each entry depends on. Theycall a dynamic-programming algorithm tD=eD if its table size is O.n\nt/and each\nentry depends on O.ne/other entries. For example, the matrix-chain multiplication\nalgorithm in Section 15.2 would be 2D=1D , and the longest-common-subsequence\nalgorithm in Section 15.4 would be 2D=0D .\nHu and Shing [182, 183] give an O.n lgn/-time algorithm for the matrix-chain\nmultiplication problem.\nTheO.mn/ -time algorithm for the longest-common-subsequence problem ap-\npears to be a folk algorithm. Knuth [70] posed the question of whether subquadraticalgorithms for the LCS problem exist. Masek and Paterson [244] answered thisquestion in the af\ufb01rmative by giving an algorithm that runs in O.mn= lgn/time,\nwhere n/DC4mand the sequences are drawn from a set of bounded size. For the\nspecial case in which no element appears more than once in an input sequence,Szymanski [326] shows how to solve the problem in O..nCm/lg.nCm//time.\nMany of these results extend to the problem of computing string edit distances\n(Problem 15-5).\nAn early paper on variable-length binary encodings by Gilbert and Moore [133]\nhad applications to constructing optimal binary search trees for the case in which allprobabilities p\niare0; this paper contains an O.n3/-time algorithm. Aho, Hopcroft,\nand Ullman [5] present the algorithm from Section 15.5. Exercise 15.5-4 is due toKnuth [212]. Hu and Tucker [184] devised an algorithm for the case in which all\nprobabilities p\niare0that uses O.n2/time and O.n/ space; subsequently, Knuth\n[211] reduced the time to O.n lgn/.\nProblem 15-8 is due to Avidan and Shamir [27], who have posted on the Web a\nwonderful video illustrating this image-compression technique.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "434": {"page_number": 435, "page_information": "16 Greedy Algorithms\nAlgorithms for optimization problems typically go through a sequence of steps,\nwith a set of choices at each step. For many optimization problems, using dynamicprogramming to determine the best choices is overkill; simpler, more ef\ufb01cient al-gorithms will do. A greedy algorithm always makes the choice that looks best at\nthe moment. That is, it makes a locally optimal choice in the hope that this choicewill lead to a globally optimal solution. This chapter explores optimization prob-lems for which greedy algorithms provide optimal solutions. Before reading thischapter, you should read about dynamic programming in Chapter 15, particularlySection 15.3.\nGreedy algorithms do not always yield optimal solutions, but for many problems\nthey do. We shall \ufb01rst examine, in Section 16.1, a simple but nontrivial problem,\nthe activity-selection problem, for which a greedy algorithm ef\ufb01ciently computesan optimal solution. We shall arrive at the greedy algorithm by \ufb01rst consider-ing a dynamic-programming approach and then showing that we can always make\ngreedy choices to arrive at an optimal solution. Section 16.2 reviews the basic\nelements of the greedy approach, giving a direct approach for proving greedy al-gorithms correct. Section 16.3 presents an important application of greedy tech-niques: designing data-compression (Huffman) codes. In Section 16.4, we inves-tigate some of the theory underlying combinatorial structures called \u201cmatroids,\u201dfor which a greedy algorithm always produces an optimal solution. Finally, Sec-tion 16.5 applies matroids to solve a problem of scheduling unit-time tasks withdeadlines and penalties.\nThe greedy method is quite powerful and works well for a wide range of prob-\nlems. Later chapters will present many algorithms that we can view as applica-tions of the greedy method, including minimum-spanning-tree algorithms (Chap-ter 23), Dijkstra\u2019s algorithm for shortest paths from a single source (Chapter 24),and Chv\u00b4 atal\u2019s greedy set-covering heuristic (Chapter 35). Minimum-spanning-tree\nalgorithms furnish a classic example of the greedy method. Although you can read", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "435": {"page_number": 436, "page_information": "16.1 An activity-selection problem 415\nthis chapter and Chapter 23 independently of each other, you might \ufb01nd it useful\nto read them together.\n16.1 An activity-selection problem\nOur \ufb01rst example is the problem of scheduling several competing activities that re-quire exclusive use of a common resource, with a goal of selecting a maximum-sizeset of mutually compatible activities. Suppose we have a set SDfa\n1;a2;:::;a ng\nofnproposed activities that wish to use a resource, such as a lecture hall, which\ncan serve only one activity at a time. Each activity aihas astart time siand a\ufb01nish\ntimefi,w h e r e 0/DC4si<f i<1. If selected, activity aitakes place during the\nhalf-open time interval \u0152si;fi/. Activities aiandajarecompatible if the intervals\n\u0152si;fi/and\u0152sj;fj/do not overlap. That is, aiandajare compatible if si/NAKfj\norsj/NAKfi.I n t h e activity-selection problem , we wish to select a maximum-size\nsubset of mutually compatible activities. We assume that the activities are sortedin monotonically increasing order of \ufb01nish time:\nf\n1/DC4f2/DC4f3/DC4/SOH/SOH/SOH/DC4 fn/NUL1/DC4fn: (16.1)\n(We shall see later the advantage that this assumption provides.) For example,\nconsider the following set Sof activities:\ni\n 123456 7 8 9 1 01 1\nsi\n130535 6 8 8 2 1 2\nfi\n4567991 01 11 21 41 6\nFor this example, the subset fa3;a9;a11gconsists of mutually compatible activities.\nIt is not a maximum subset, however, since the subset fa1;a4;a8;a11gis larger. In\nfact,fa1;a4;a8;a11gis a largest subset of mutually compatible activities; another\nlargest subset isfa2;a4;a9;a11g.\nWe shall solve this problem in several steps. We start by thinking about a\ndynamic-programming solution, in which we consider several choices when deter-mining which subproblems to use in an optimal solution. We shall then observe thatwe need to consider only one choice\u2014the greedy choice\u2014and that when we makethe greedy choice, only one subproblem remains. Based on these observations, weshall develop a recursive greedy algorithm to solve the activity-scheduling prob-lem. We shall complete the process of developing a greedy solution by convertingthe recursive algorithm to an iterative one. Although the steps we shall go throughin this section are slightly more involved than is typical when developing a greedyalgorithm, they illustrate the relationship between greedy algorithms and dynamic\nprogramming.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "436": {"page_number": 437, "page_information": "416 Chapter 16 Greedy Algorithms\nThe optimal substructure of the activity-selection problem\nWe can easily verify that the activity-selection problem exhibits optimal substruc-\nture. Let us denote by Sijthe set of activities that start after activity ai\ufb01nishes and\nthat \ufb01nish before activity ajstarts. Suppose that we wish to \ufb01nd a maximum set of\nmutually compatible activities in Sij, and suppose further that such a maximum set\nisAij, which includes some activity ak. By including akin an optimal solution, we\nare left with two subproblems: \ufb01nding mutually compatible activities in the set Sik\n(activities that start after activity ai\ufb01nishes and that \ufb01nish before activity akstarts)\nand \ufb01nding mutually compatible activities in the set Skj(activities that start after\nactivity ak\ufb01nishes and that \ufb01nish before activity ajstarts). Let AikDAij\\Sik\nandAkjDAij\\Skj,s ot h a t Aikcontains the activities in Aijthat \ufb01nish before ak\nstarts and Akjcontains the activities in Aijthat start after ak\ufb01nishes. Thus, we\nhave AijDAik[fakg[Akj, and so the maximum-size set Aijof mutually com-\npatible activities in Sijconsists ofjAijjDjAikjCjAkjjC1activities.\nThe usual cut-and-paste argument shows that the optimal solution Aijmust also\ninclude optimal solutions to the two subproblems for SikandSkj. If we could\n\ufb01nd a set A0\nkjof mutually compatible activities in SkjwherejA0\nkjj>jAkjj,t h e n\nwe could use A0\nkj, rather than Akj, in a solution to the subproblem for Sij.W e\nwould have constructed a set of jAikjCjA0\nkjjC1>jAikjCjAkjjC1DjAijj\nmutually compatible activities, which contradicts the assumption that Aijis an\noptimal solution. A symmetric argument applies to the activities in Sik.\nThis way of characterizing optimal substructure suggests that we might solve\nthe activity-selection problem by dynamic programming. If we denote the size ofan optimal solution for the set S\nijbyc\u0152i;j/c141 , then we would have the recurrence\nc\u0152i;j/c141Dc\u0152i;k/c141Cc\u0152k;j/c141C1:\nOf course, if we did not know that an optimal solution for the set Sijincludes\nactivity ak, we would have to examine all activities in Sijto \ufb01nd which one to\nchoose, so that\nc\u0152i;j/c141D(0 ifSijD;;\nmax\nak2Sijfc\u0152i;k/c141Cc\u0152k;j/c141C1gifSij\u00a4;:(16.2)\nWe could then develop a recursive algorithm and memoize it, or we could work\nbottom-up and \ufb01ll in table entries as we go along. But we would be overlookinganother important characteristic of the activity-selection problem that we can use\nto great advantage.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "437": {"page_number": 438, "page_information": "16.1 An activity-selection problem 417\nMaking the greedy choice\nWhat if we could choose an activity to add to our optimal solution without having\nto \ufb01rst solve all the subproblems? That could save us from having to consider allthe choices inherent in recurrence (16.2). In fact, for the activity-selection problem,we need consider only one choice: the greedy choice.\nWhat do we mean by the greedy choice for the activity-selection problem? Intu-\nition suggests that we should choose an activity that leaves the resource availablefor as many other activities as possible. Now, of the activities we end up choos-ing, one of them must be the \ufb01rst one to \ufb01nish. Our intuition tells us, therefore,to choose the activity in Swith the earliest \ufb01nish time, since that would leave the\nresource available for as many of the activities that follow it as possible. (If morethan one activity in Shas the earliest \ufb01nish time, then we can choose any such\nactivity.) In other words, since the activities are sorted in monotonically increasingorder by \ufb01nish time, the greedy choice is activity a\n1. Choosing the \ufb01rst activity\nto \ufb01nish is not the only way to think of making a greedy choice for this problem;\nExercise 16.1-3 asks you to explore other possibilities.\nIf we make the greedy choice, we have only one remaining subproblem to solve:\n\ufb01nding activities that start after a1\ufb01nishes. Why don\u2019t we have to consider ac-\ntivities that \ufb01nish before a1starts? We have that s1<f 1,a n d f1is the earliest\n\ufb01nish time of any activity, and therefore no activity can have a \ufb01nish time less than\nor equal to s1. Thus, all activities that are compatible with activity a1must start\naftera1\ufb01nishes.\nFurthermore, we have already established that the activity-selection problem ex-\nhibits optimal substructure. Let SkDfai2SWsi/NAKfkgbe the set of activities that\nstart after activity ak\ufb01nishes. If we make the greedy choice of activity a1,t h e n S1\nremains as the only subproblem to solve.1Optimal substructure tells us that if a1\nis in the optimal solution, then an optimal solution to the original problem consists\nof activity a1and all the activities in an optimal solution to the subproblem S1.\nOne big question remains: is our intuition correct? Is the greedy choice\u2014in\nwhich we choose the \ufb01rst activity to \ufb01nish\u2014always part of some optimal solution?The following theorem shows that it is.\n1We sometimes refer to the sets Skas subproblems rather than as just sets of activities. It will always\nbe clear from the context whether we are referring to Skas a set of activities or as a subproblem\nwhose input is that set.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "438": {"page_number": 439, "page_information": "418 Chapter 16 Greedy Algorithms\nTheorem 16.1\nConsider any nonempty subproblem Sk,a n dl e t ambe an activity in Skwith the\nearliest \ufb01nish time. Then amis included in some maximum-size subset of mutually\ncompatible activities of Sk.\nProof LetAkbe a maximum-size subset of mutually compatible activities in Sk,\nand let ajbe the activity in Akwith the earliest \ufb01nish time. If ajDam,w ea r e\ndone, since we have shown that amis in some maximum-size subset of mutually\ncompatible activities of Sk.I faj\u00a4am, let the set A0\nkDAk/NULfajg[famgbeAk\nbut substituting amforaj. The activities in A0\nkare disjoint, which follows because\nthe activities in Akare disjoint, ajis the \ufb01rst activity in Akto \ufb01nish, and fm/DC4fj.\nSincejA0\nkjDjAkj, we conclude that A0\nkis a maximum-size subset of mutually\ncompatible activities of Sk, and it includes am.\nThus, we see that although we might be able to solve the activity-selection prob-\nlem with dynamic programming, we don\u2019t need to. (Besides, we have not yetexamined whether the activity-selection problem even has overlapping subprob-lems.) Instead, we can repeatedly choose the activity that \ufb01nishes \ufb01rst, keep onlythe activities compatible with this activity, and repeat until no activities remain.Moreover, because we always choose the activity with the earliest \ufb01nish time, the\ufb01nish times of the activities we choose must strictly increase. We can considereach activity just once overall, in monotonically increasing order of \ufb01nish times.\nAn algorithm to solve the activity-selection problem does not need to work\nbottom-up, like a table-based dynamic-programming algorithm. Instead, it can\nwork top-down, choosing an activity to put into the optimal solution and then solv-ing the subproblem of choosing activities from those that are compatible with thosealready chosen. Greedy algorithms typically have this top-down design: make achoice and then solve a subproblem, rather than the bottom-up technique of solvingsubproblems before making a choice.\nA recursive greedy algorithm\nNow that we have seen how to bypass the dynamic-programming approach and in-\nstead use a top-down, greedy algorithm, we can write a straightforward, recursiveprocedure to solve the activity-selection problem. The procedure R\nECURSIVE -\nACTIVITY -SELECTOR takes the start and \ufb01nish times of the activities, represented\nas arrays sandf,2the index kthat de\ufb01nes the subproblem Skit is to solve, and\n2Because the pseudocode takes sandfas arrays, it indexes into them with square brackets rather\nthan subscripts.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "439": {"page_number": 440, "page_information": "16.1 An activity-selection problem 419\nthe size nof the original problem. It returns a maximum-size set of mutually com-\npatible activities in Sk. We assume that the ninput activities are already ordered\nby monotonically increasing \ufb01nish time, according to equation (16.1). If not, wecan sort them into this order in O.n lgn/time, breaking ties arbitrarily. In order\nto start, we add the \ufb01ctitious activity a\n0with f0D0, so that subproblem S0is\nthe entire set of activities S. The initial call, which solves the entire problem, is\nRECURSIVE -ACTIVITY -SELECTOR . s ;f ;0 ;n / .\nRECURSIVE -ACTIVITY -SELECTOR . s ;f ;k;n /\n1mDkC1\n2while m/DC4nands\u0152m/c141 < f \u0152k/c141 //\ufb01nd the \ufb01rst activity in Skto \ufb01nish\n3 mDmC1\n4ifm/DC4n\n5 returnfamg[RECURSIVE -ACTIVITY -SELECTOR . s ;f ;m;n /\n6else return;\nFigure 16.1 shows the operation of the algorithm. In a given recursive call\nRECURSIVE -ACTIVITY -SELECTOR . s ;f ;k;n / ,t h ewhile loop of lines 2\u20133 looks\nfor the \ufb01rst activity in Skto \ufb01nish. The loop examines akC1;akC2;:::;a n, un-\ntil it \ufb01nds the \ufb01rst activity amthat is compatible with ak; such an activity has\nsm/NAKfk. If the loop terminates because it \ufb01nds such an activity, line 5 returns\nthe union offamgand the maximum-size subset of Smreturned by the recursive\ncall R ECURSIVE -ACTIVITY -SELECTOR . s ;f ;m;n / . Alternatively, the loop may\nterminate because m>n , in which case we have examined all activities in Sk\nwithout \ufb01nding one that is compatible with ak. In this case, SkD;,a n ds ot h e\nprocedure returns;in line 6.\nAssuming that the activities have already been sorted by \ufb01nish times, the running\ntime of the call R ECURSIVE -ACTIVITY -SELECTOR . s ;f ;0 ;n / is\u201a.n/ ,w h i c hw e\ncan see as follows. Over all recursive calls, each activity is examined exactly oncein the while loop test of line 2. In particular, activity a\niis examined in the last call\nmade in which k<i .\nAn iterative greedy algorithm\nWe easily can convert our recursive procedure to an iterative one. The procedure\nRECURSIVE -ACTIVITY -SELECTOR is almost \u201ctail recursive\u201d (see Problem 7-4):\nit ends with a recursive call to itself followed by a union operation. It is usually astraightforward task to transform a tail-recursive procedure to an iterative form; infact, some compilers for certain programming languages perform this task automat-ically. As written, R\nECURSIVE -ACTIVITY -SELECTOR works for subproblems Sk,\ni.e., subproblems that consist of the last activities to \ufb01nish.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "440": {"page_number": 441, "page_information": "420 Chapter 16 Greedy Algorithms\n0123456789 1 0 1 1 1 2 1 3 1 4time235\n306\n457\n539\n659\n76 1 0\n88 1 1\n98 1 2\n1 021 4\n11 12 16114k skfk\na1a2\na1a3\na1a4\na1 a4a5\na1 a4a6\na1 a4a7\na1 a4a8\na1 a4 a8a9\na1 a4 a8a10\na1 a4 a8a11\na1 a4 a8 a110\u20130\na1\na0a0\nRECURSIVE -ACTIVITY -SELECTOR (s,f, 0, 11)\nRECURSIVE -ACTIVITY -SELECTOR (s,f, 1, 11)\nRECURSIVE -ACTIVITY -SELECTOR (s,f, 4, 11)\nRECURSIVE -ACTIVITY -SELECTOR (s,f, 8, 11)m = 1\nm = 4\nm = 8\nm = 11\nRECURSIVE -ACTIVITY -SELECTOR (s,f, 11, 11)\n15 16\nFigure 16.1 The operation of R ECURSIVE -ACTIVITY -SELECTOR on the 11activities given ear-\nlier. Activities considered in each recursive call appear between horizontal lines. The \ufb01ctitious\nactivity a0\ufb01nishes at time 0, and the initial call R ECURSIVE -ACTIVITY -SELECTOR . s;f ;0 ;1 1 / ,s e -\nlects activity a1. In each recursive call, the activities that have already been selected are shaded,\nand the activity shown in white is being considered. If the starting time of an activity occurs before\nthe \ufb01nish time of the most recently added activity (t he arrow between them points left), it is re-\njected. Otherwise (the arro w points directly up or to the right), it is selected. The last recursive call,\nRECURSIVE -ACTIVITY -SELECTOR .s; f; 11; 11/ , returns;. The resulting set of selected activities is\nfa1;a4;a8;a11g.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "441": {"page_number": 442, "page_information": "16.1 An activity-selection problem 421\nThe procedure G REEDY -ACTIVITY -SELECTOR is an iterative version of the pro-\ncedure R ECURSIVE -ACTIVITY -SELECTOR . It also assumes that the input activi-\nties are ordered by monotonically increasing \ufb01nish time. It collects selected activ-ities into a set Aand returns this set when it is done.\nG\nREEDY -ACTIVITY -SELECTOR .s; f /\n1nDs:length\n2ADfa1g\n3kD1\n4formD2ton\n5 ifs\u0152m/c141/NAKf\u0152 k /c141\n6 ADA[famg\n7 kDm\n8return A\nThe procedure works as follows. The variable kindexes the most recent addition\ntoA, corresponding to the activity akin the recursive version. Since we consider\nthe activities in order of monotonically increasing \ufb01nish time, fkis always the\nmaximum \ufb01nish time of any activity in A.T h a ti s ,\nfkDmaxffiWai2Ag: (16.3)\nLines 2\u20133 select activity a1, initialize Ato contain just this activity, and initialize k\nto index this activity. The forloop of lines 4\u20137 \ufb01nds the earliest activity in Skto\n\ufb01nish. The loop considers each activity amin turn and adds amtoAif it is compat-\nible with all previously selected activities; such an activity is the earliest in Skto\n\ufb01nish. To see whether activity amis compatible with every activity currently in A,\nit suf\ufb01ces by equation (16.3) to check (in line 5) that its start time smis not earlier\nthan the \ufb01nish time fkof the activity most recently added to A. If activity amis\ncompatible, then lines 6\u20137 add activity amtoAand set ktom. The set Areturned\nby the call G REEDY -ACTIVITY -SELECTOR .s; f / is precisely the set returned by\nthe call R ECURSIVE -ACTIVITY -SELECTOR . s ;f ;0 ;n / .\nLike the recursive version, G REEDY -ACTIVITY -SELECTOR schedules a set of n\nactivities in \u201a.n/ time, assuming that the activities were already sorted initially by\ntheir \ufb01nish times.\nExercises\n16.1-1\nGive a dynamic-programming algorithm for the activity-selection problem, basedon recurrence (16.2). Have your algorithm compute the sizes c\u0152i;j/c141 as de\ufb01ned\nabove and also produce the maximum-size subset of mutually compatible activities.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "442": {"page_number": 443, "page_information": "422 Chapter 16 Greedy Algorithms\nAssume that the inputs have been sorted as in equation (16.1). Compare the running\ntime of your solution to the running time of G REEDY -ACTIVITY -SELECTOR .\n16.1-2\nSuppose that instead of always selecting the \ufb01rst activity to \ufb01nish, we instead selectthe last activity to start that is compatible with all previously selected activities. De-scribe how this approach is a greedy algorithm, and prove that it yields an optimalsolution.\n16.1-3\nNot just any greedy approach to the activity-selection problem produces a max-\nimum-size set of mutually compatible activities. Give an example to show thatthe approach of selecting the activity of least duration from among those that arecompatible with previously selected activities does not work. Do the same forthe approaches of always selecting the compatible activity that overlaps the fewestother remaining activities and always selecting the compatible remaining activitywith the earliest start time.\n16.1-4\nSuppose that we have a set of activities to schedule among a large number of lecturehalls, where any activity can take place in any lecture hall. We wish to scheduleall the activities using as few lecture halls as possible. Give an ef\ufb01cient greedyalgorithm to determine which activity should use which lecture hall.\n(This problem is also known as the interval-graph coloring problem . We can\ncreate an interval graph whose vertices are the given activities and whose edgesconnect incompatible activities. The smallest number of colors required to color\nevery vertex so that no two adjacent vertices have the same color corresponds to\n\ufb01nding the fewest lecture halls needed to schedule all of the given activities.)\n16.1-5\nConsider a modi\ufb01cation to the activity-selection problem in which each activity a\ni\nhas, in addition to a start and \ufb01nish time, a value /ETBi. The objective is no longer\nto maximize the number of activities scheduled, but instead to maximize the totalvalue of the activities scheduled. That is, we wish to choose a set Aof compatible\nactivities such thatP\nak2A/ETBkis maximized. Give a polynomial-time algorithm for\nthis problem.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "443": {"page_number": 444, "page_information": "16.2 Elements of the greedy strategy 423\n16.2 Elements of the greedy strategy\nA greedy algorithm obtains an optimal solution to a problem by making a sequence\nof choices. At each decision point, the algorithm makes choice that seems best atthe moment. This heuristic strategy does not always produce an optimal solution,but as we saw in the activity-selection problem, sometimes it does. This section\ndiscusses some of the general properties of greedy methods.\nThe process that we followed in Section 16.1 to develop a greedy algorithm was\na bit more involved than is typical. We went through the following steps:\n1. Determine the optimal substructure of the problem.\n2. Develop a recursive solution. (For the activity-selection problem, we formu-\nlated recurrence (16.2), but we bypassed developing a recursive algorithm basedon this recurrence.)\n3. Show that if we make the greedy choice, then only one subproblem remains.\n4. Prove that it is always safe to make the greedy choice. (Steps 3 and 4 can occur\nin either order.)\n5. Develop a recursive algorithm that implements the greedy strategy.\n6. Convert the recursive algorithm to an iterative algorithm.\nIn going through these steps, we saw in great detail the dynamic-programming un-\nderpinnings of a greedy algorithm. For example, in the activity-selection problem,we \ufb01rst de\ufb01ned the subproblems S\nij, where both iandjvaried. We then found\nthat if we always made the greedy choice, we could restrict the subproblems to beof the form S\nk.\nAlternatively, we could have fashioned our optimal substructure with a greedy\nchoice in mind, so that the choice leaves just one subproblem to solve. In the\nactivity-selection problem, we could have started by dropping the second subscript\nand de\ufb01ning subproblems of the form Sk. Then, we could have proven that a greedy\nchoice (the \ufb01rst activity amto \ufb01nish in Sk), combined with an optimal solution to\nthe remaining set Smof compatible activities, yields an optimal solution to Sk.\nMore generally, we design greedy algorithms according to the following sequenceof steps:\n1. Cast the optimization problem as one in which we make a choice and are left\nwith one subproblem to solve.\n2. Prove that there is always an optimal solution to the original problem that makes\nthe greedy choice, so that the greedy choice is always safe.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "444": {"page_number": 445, "page_information": "424 Chapter 16 Greedy Algorithms\n3. Demonstrate optimal substructure by showing that, having made the greedy\nchoice, what remains is a subproblem with the property that if we combine anoptimal solution to the subproblem with the greedy choice we have made, wearrive at an optimal solution to the original problem.\nWe shall use this more direct process in later sections of this chapter. Neverthe-\nless, beneath every greedy algorithm, there is almost always a more cumbersomedynamic-programming solution.\nHow can we tell whether a greedy algorithm will solve a particular optimization\nproblem? No way works all the time, but the greedy-choice property and optimalsubstructure are the two key ingredients. If we can demonstrate that the problemhas these properties, then we are well on the way to developing a greedy algorithmfor it.\nGreedy-choice property\nThe \ufb01rst key ingredient is the greedy-choice property : we can assemble a globally\noptimal solution by making locally optimal (greedy) choices. In other words, whenwe are considering which choice to make, we make the choice that looks best inthe current problem, without considering results from subproblems.\nHere is where greedy algorithms differ from dynamic programming. In dynamic\nprogramming, we make a choice at each step, but the choice usually depends on thesolutions to subproblems. Consequently, we typically solve dynamic-programmingproblems in a bottom-up manner, progressing from smaller subproblems to largersubproblems. (Alternatively, we can solve them top down, but memoizing. Ofcourse, even though the code works top down, we still must solve the subprob-lems before making a choice.) In a greedy algorithm, we make whatever choiceseems best at the moment and then solve the subproblem that remains. The choice\nmade by a greedy algorithm may depend on choices so far, but it cannot depend on\nany future choices or on the solutions to subproblems. Thus, unlike dynamic pro-gramming, which solves the subproblems before making the \ufb01rst choice, a greedyalgorithm makes its \ufb01rst choice before solving any subproblems. A dynamic-programming algorithm proceeds bottom up, whereas a greedy strategy usuallyprogresses in a top-down fashion, making one greedy choice after another, reduc-ing each given problem instance to a smaller one.\nOf course, we must prove that a greedy choice at each step yields a globally\noptimal solution. Typically, as in the case of Theorem 16.1, the proof examinesa globally optimal solution to some subproblem. It then shows how to modifythe solution to substitute the greedy choice for some other choice, resulting in onesimilar, but smaller, subproblem.\nWe can usually make the greedy choice more ef\ufb01ciently than when we have to\nconsider a wider set of choices. For example, in the activity-selection problem, as-", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "445": {"page_number": 446, "page_information": "16.2 Elements of the greedy strategy 425\nsuming that we had already sorted the activities in monotonically increasing order\nof \ufb01nish times, we needed to examine each activity just once. By preprocessing theinput or by using an appropriate data structure (often a priority queue), we oftencan make greedy choices quickly, thus yielding an ef\ufb01cient algorithm.\nOptimal substructure\nA problem exhibits optimal substructure if an optimal solution to the problem\ncontains within it optimal solutions to subproblems. This property is a key in-gredient of assessing the applicability of dynamic programming as well as greedyalgorithms. As an example of optimal substructure, recall how we demonstrated inSection 16.1 that if an optimal solution to subproblem S\nijincludes an activity ak,\nthen it must also contain optimal solutions to the subproblems SikandSkj.G i v e n\nthis optimal substructure, we argued that if we knew which activity to use as ak,w e\ncould construct an optimal solution to Sijby selecting akalong with all activities\nin optimal solutions to the subproblems SikandSkj. Based on this observation of\noptimal substructure, we were able to devise the recurrence (16.2) that describedthe value of an optimal solution.\nWe usually use a more direct approach regarding optimal substructure when\napplying it to greedy algorithms. As mentioned above, we have the luxury of\nassuming that we arrived at a subproblem by having made the greedy choice in\nthe original problem. All we really need to do is argue that an optimal solution to\nthe subproblem, combined with the greedy choice already made, yields an optimalsolution to the original problem. This scheme implicitly uses induction on thesubproblems to prove that making the greedy choice at every step produces anoptimal solution.\nGreedy versus dynamic programming\nBecause both the greedy and dynamic-programming strategies exploit optimal sub-\nstructure, you might be tempted to generate a dynamic-programming solution to aproblem when a greedy solution suf\ufb01ces or, conversely, you might mistakenly think\nthat a greedy solution works when in fact a dynamic-programming solution is re-\nquired. To illustrate the subtleties between the two techniques, let us investigate\ntwo variants of a classical optimization problem.\nThe0-1 knapsack problem is the following. A thief robbing a store \ufb01nds n\nitems. The ith item is worth /ETB\nidollars and weighs wipounds, where /ETBiandwiare\nintegers. The thief wants to take as valuable a load as possible, but he can carry atmost Wpounds in his knapsack, for some integer W. Which items should he take?\n(We call this the 0-1 knapsack problem because for each item, the thief must either", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "446": {"page_number": 447, "page_information": "426 Chapter 16 Greedy Algorithms\ntake it or leave it behind; he cannot take a fractional amount of an item or take an\nitem more than once.)\nIn the fractional knapsack problem , the setup is the same, but the thief can take\nfractions of items, rather than having to make a binary (0-1) choice for each item.You can think of an item in the 0-1 knapsack problem as being like a gold ingotand an item in the fractional knapsack problem as more like gold dust.\nBoth knapsack problems exhibit the optimal-substructure property. For the 0-1\nproblem, consider the most valuable load that weighs at most Wpounds. If we\nremove item jfrom this load, the remaining load must be the most valuable load\nweighing at most W/NULw\njthat the thief can take from the n/NUL1original items\nexcluding j. For the comparable fractional problem, consider that if we remove\na weight wof one item jfrom the optimal load, the remaining load must be the\nmost valuable load weighing at most W/NULwthat the thief can take from the n/NUL1\noriginal items plus wj/NULwpounds of item j.\nAlthough the problems are similar, we can solve the fractional knapsack problem\nby a greedy strategy, but we cannot solve the 0-1 problem by such a strategy. To\nsolve the fractional problem, we \ufb01rst compute the value per pound /ETBi=wifor each\nitem. Obeying a greedy strategy, the thief begins by taking as much as possible of\nthe item with the greatest value per pound. If the supply of that item is exhaustedand he can still carry more, he takes as much as possible of the item with the nextgreatest value per pound, and so forth, until he reaches his weight limit W. Thus,\nby sorting the items by value per pound, the greedy algorithm runs in O.n lgn/\ntime. We leave the proof that the fractional knapsack problem has the greedy-\nchoice property as Exercise 16.2-1.\nTo see that this greedy strategy does not work for the 0-1 knapsack problem,\nconsider the problem instance illustrated in Figure 16.2(a). This example has 3\nitems and a knapsack that can hold 50pounds. Item 1weighs 10pounds and\nis worth 60dollars. Item 2weighs 20pounds and is worth 100dollars. Item 3\nweighs 30pounds and is worth 120dollars. Thus, the value per pound of item 1is\n6dollars per pound, which is greater than the value per pound of either item 2(5\ndollars per pound) or item 3(4dollars per pound). The greedy strategy, therefore,\nwould take item 1\ufb01rst. As you can see from the case analysis in Figure 16.2(b),\nhowever, the optimal solution takes items 2and3, leaving item 1behind. The two\npossible solutions that take item 1are both suboptimal.\nFor the comparable fractional problem, however, the greedy strategy, which\ntakes item 1\ufb01rst, does yield an optimal solution, as shown in Figure 16.2(c). Tak-\ning item 1doesn\u2019t work in the 0-1 problem because the thief is unable to \ufb01ll his\nknapsack to capacity, and the empty space lowers the effective value per pound ofhis load. In the 0-1 problem, when we consider whether to include an item in theknapsack, we must compare the solution to the subproblem that includes the itemwith the solution to the subproblem that excludes the item before we can make the", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "447": {"page_number": 448, "page_information": "16.2 Elements of the greedy strategy 427\n10\n$60item 120\n$100item 2\n30\n$120item 3\n50\nknapsack\n(a)+$120\n$100\n= $220+\n$60$100\n= $160+\n$60$120\n= $180\n(b)+\n$60$100\n= $240$80\n+\n(c)2030\n1020\n1030\n102020\n30\nFigure 16.2 An example showing that the greedy strategy does not work for the 0-1 knapsack\nproblem. (a)The thief must select a subset of the three items shown whose weight must not exceed\n50pounds. (b)The optimal subset includes items 2and3. Any solution with item 1is suboptimal,\neven though item 1has the greatest value per pound. (c)For the fractional knapsack problem, taking\nthe items in order of greatest value per pound yields an optimal solution.\nchoice. The problem formulated in this way gives rise to many overlapping sub-\nproblems\u2014a hallmark of dynamic programming, and indeed, as Exercise 16.2-2\nasks you to show, we can use dynamic programming to solve the 0-1 problem.\nExercises\n16.2-1\nProve that the fractional knapsack problem has the greedy-choice property.\n16.2-2\nGive a dynamic-programming solution to the 0-1 knapsack problem that runs inO.nW / time, where nis the number of items and Wis the maximum weight of\nitems that the thief can put in his knapsack.\n16.2-3\nSuppose that in a 0-1 knapsack problem, the order of the items when sorted byincreasing weight is the same as their order when sorted by decreasing value. Givean ef\ufb01cient algorithm to \ufb01nd an optimal solution to this variant of the knapsackproblem, and argue that your algorithm is correct.\n16.2-4\nProfessor Gekko has always dreamed of inline skating across North Dakota. Heplans to cross the state on highway U.S. 2, which runs from Grand Forks, on theeastern border with Minnesota, to Williston, near the western border with Montana.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "448": {"page_number": 449, "page_information": "428 Chapter 16 Greedy Algorithms\nThe professor can carry two liters of water, and he can skate mmiles before running\nout of water. (Because North Dakota is relatively \ufb02at, the professor does not haveto worry about drinking water at a greater rate on uphill sections than on \ufb02at ordownhill sections.) The professor will start in Grand Forks with two full liters ofwater. His of\ufb01cial North Dakota state map shows all the places along U.S. 2 atwhich he can re\ufb01ll his water and the distances between these locations.\nThe professor\u2019s goal is to minimize the number of water stops along his route\nacross the state. Give an ef\ufb01cient method by which he can determine which water\nstops he should make. Prove that your strategy yields an optimal solution, and give\nits running time.\n16.2-5\nDescribe an ef\ufb01cient algorithm that, given a set fx\n1;x2;:::;x ngof points on the\nreal line, determines the smallest set of unit-length closed intervals that containsall of the given points. Argue that your algorithm is correct.\n16.2-6 ?\nShow how to solve the fractional knapsack problem in O.n/ time.\n16.2-7\nSuppose you are given two sets AandB, each containing npositive integers. You\ncan choose to reorder each set however you like. After reordering, let a\nibe the ith\nelement of set A,a n dl e t bibe the ith element of set B. You then receive a payoff\nofQn\niD1aibi. Give an algorithm that will maximize your payoff. Prove that your\nalgorithm maximizes the payoff, and state its running time.\n16.3 Huffman codes\nHuffman codes compress data very effectively: savings of 20% to 90% are typical,depending on the characteristics of the data being compressed. We consider thedata to be a sequence of characters. Huffman\u2019s greedy algorithm uses a table givinghow often each character occurs (i.e., its frequency) to build up an optimal way ofrepresenting each character as a binary string.\nSuppose we have a 100,000-character data \ufb01le that we wish to store compactly.\nWe observe that the characters in the \ufb01le occur with the frequencies given by Fig-\nure 16.3. That is, only 6different characters appear, and the character aoccurs\n45,000 times.\nWe have many options for how to represent such a \ufb01le of information. Here,\nwe consider the problem of designing a binary character code (orcode for short)", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "449": {"page_number": 450, "page_information": "16.3 Huffman codes 429\nabcd e f\nFrequency (in thousands) 45 13 12 16 9 5\nFixed-length codeword 000 001 010 011 100 101\nVariable-length codeword 0 101 100 111 1101 1100\nFigure 16.3 A character-coding problem. A data \ufb01le of 100,000 characters contains only the char-\nacters a\u2013f, with the frequencies indicated. If we assign each character a 3-bit codeword, we can\nencode the \ufb01le in 300,000 bits. Using the variable-length code shown, we can encode the \ufb01le in only\n224,000 bits.\nin which each character is represented by a unique binary string, which we call a\ncodeword .I fw eu s ea \ufb01xed-length code , we need 3bits to represent 6characters:\na= 000, b= 001, ...,f= 101. This method requires 300,000 bits to code the\nentire \ufb01le. Can we do better?\nAvariable-length code can do considerably better than a \ufb01xed-length code, by\ngiving frequent characters short codewords and infrequent characters long code-words. Figure 16.3 shows such a code; here the 1-bit string 0represents a,a n dt h e\n4-bit string 1100 represents f. This code requires\n.45/SOH1C13/SOH3C12/SOH3C16/SOH3C9/SOH4C5/SOH4//SOH1,000D224,000 bits\nto represent the \ufb01le, a savings of approximately 25%. In fact, this is an optimal\ncharacter code for this \ufb01le, as we shall see.\nPre\ufb01x codes\nWe consider here only codes in which no codeword is also a pre\ufb01x of some other\ncodeword. Such codes are called pre\ufb01x codes .\n3Although we won\u2019t prove it here, a\npre\ufb01x code can always achieve the optimal data compression among any charactercode, and so we suffer no loss of generality by restricting our attention to pre\ufb01xcodes.\nEncoding is always simple for any binary character code; we just concatenate the\ncodewords representing each character of the \ufb01le. For example, with the variable-length pre\ufb01x code of Figure 16.3, we code the 3-character \ufb01le abc as0/SOH101/SOH100D\n0101100 ,w h e r e\u201c/SOH\u201d denotes concatenation.\nPre\ufb01x codes are desirable because they simplify decoding. Since no codeword\nis a pre\ufb01x of any other, the codeword that begins an encoded \ufb01le is unambiguous.We can simply identify the initial codeword, translate it back to the original char-\n3Perhaps \u201cpre\ufb01x-free codes\u201d would be a better name, but the term \u201cpre\ufb01x codes\u201d is standard in the\nliterature.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "450": {"page_number": 451, "page_information": "430 Chapter 16 Greedy Algorithms\na:45 b:13 c:12 d:16 e:9 f:558 28 1486 14100\n01 01 0101 001\ne:9 f:514\n01c:12 b:1325\n01\nd:1630\n0155\n01a:45100\n01\n(a) (b)\nFigure 16.4 Trees corresponding to the coding schemes in Figure 16.3. Each leaf is labeled with\na character and its frequency of occurrence. Each internal node is labeled with the sum of the fre-\nquencies of the leaves in its subtree. (a)The tree corresponding to the \ufb01xed-length code a= 000, ...,\nf= 101. (b)The tree corresponding to the optimal pre\ufb01x code a=0 ,b= 101, ...,f= 1100.\nacter, and repeat the decoding process on the remainder of the encoded \ufb01le. In our\nexample, the string 001011101 parses uniquely as 0/SOH0/SOH101/SOH1101 , which decodes\ntoaabe .\nThe decoding process needs a convenient representation for the pre\ufb01x code so\nthat we can easily pick off the initial codeword. A binary tree whose leaves arethe given characters provides one such representation. We interpret the binary\ncodeword for a character as the simple path from the root to that character, where 0\nmeans \u201cgo to the left child\u201d and 1means \u201cgo to the right child.\u201d Figure 16.4 shows\nthe trees for the two codes of our example. Note that these are not binary search\ntrees, since the leaves need not appear in sorted order and internal nodes do not\ncontain character keys.\nAn optimal code for a \ufb01le is always represented by a fullbinary tree, in which\nevery nonleaf node has two children (see Exercise 16.3-2). The \ufb01xed-length codein our example is not optimal since its tree, shown in Figure 16.4(a), is not a full bi-n a r yt r e e : i tc o n t a i n sc o d e w o r d sb e g i n n i n g1 0 ...,b u t none beginning 11 .... S i n c e\nwe can now restrict our attention to full binary trees, we can say that if Cis the\nalphabet from which the characters are drawn and all character frequencies are pos-itive, then the tree for an optimal pre\ufb01x code has exactly jCjleaves, one for each\nletter of the alphabet, and exactly jCj/NUL1internal nodes (see Exercise B.5-3).\nGiven a tree Tcorresponding to a pre\ufb01x code, we can easily compute the number\nof bits required to encode a \ufb01le. For each character cin the alphabet C,l e tt h e\nattribute c:freqdenote the frequency of cin the \ufb01le and let d\nT.c/denote the depth", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "451": {"page_number": 452, "page_information": "16.3 Huffman codes 431\nofc\u2019s leaf in the tree. Note that dT.c/is also the length of the codeword for\ncharacter c. The number of bits required to encode a \ufb01le is thus\nB.T/DX\nc2Cc:freq/SOHdT.c/ ; (16.4)\nwhich we de\ufb01ne as the costof the tree T.\nConstructing a Huffman code\nHuffman invented a greedy algorithm that constructs an optimal pre\ufb01x code called\naHuffman code . In line with our observations in Section 16.2, its proof of cor-\nrectness relies on the greedy-choice property and optimal substructure. Ratherthan demonstrating that these properties hold and then developing pseudocode, wepresent the pseudocode \ufb01rst. Doing so will help clarify how the algorithm makes\ngreedy choices.\nIn the pseudocode that follows, we assume that Cis a set of ncharacters and\nthat each character c2Cis an object with an attribute c:freqgiving its frequency.\nThe algorithm builds the tree Tcorresponding to the optimal code in a bottom-up\nmanner. It begins with a set of jCjleaves and performs a sequence of jCj/NUL1\n\u201cmerging\u201d operations to create the \ufb01nal tree. The algorithm uses a min-priorityqueue Q,k e y e do nt h e freqattribute, to identify the two least-frequent objects to\nmerge together. When we merge two objects, the result is a new object whosefrequency is the sum of the frequencies of the two objects that were merged.\nH\nUFFMAN .C /\n1nDjCj\n2QDC\n3foriD1ton/NUL1\n4 allocate a new node \u00b4\n5 \u00b4:leftDxDEXTRACT -MIN.Q/\n6 \u00b4:rightDyDEXTRACT -MIN.Q/\n7 \u00b4:freqDx:freqCy:freq\n8I NSERT .Q; \u00b4/\n9return EXTRACT -MIN.Q/ //return the root of the tree\nFor our example, Huffman\u2019s algorithm proceeds as shown in Figure 16.5. Since\nthe alphabet contains 6letters, the initial queue size is nD6,a n d 5merge steps\nbuild the tree. The \ufb01nal tree represents the optimal pre\ufb01x code. The codeword fora letter is the sequence of edge labels on the simple path from the root to the letter.\nLine 2 initializes the min-priority queue Qwith the characters in C.T h e for\nloop in lines 3\u20138 repeatedly extracts the two nodes xandyof lowest frequency", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "452": {"page_number": 453, "page_information": "432 Chapter 16 Greedy Algorithms\ne:9 f:514\n01c:12 b:1325\n01\nd:1630\n0155\n01a:45100\n01\ne:9 f:514\n01c:12 b:1325\n01\nd:1630\n0155\n01a:45e:9 f:514\n01c:12 b:1325\n01\nd:1630\n01a:45\ne:9 f:514\n01\nc:12 b:1325\n01d:16 a:45e:9 f:514\n01c:12 b:13 d:16 a:45 e:9 f:5 c:12 b:13 d:16 a:45 (a)\n(c)\n(e)(b)\n(d)\n(f)\nFigure 16.5 The steps of Huffman\u2019s algorithm for the frequencies given in Figure 16.3. Each part\nshows the contents of the queue sorted into increasing order by frequency. At each step, the two\ntrees with lowest frequencies are merged. Leaves are shown as rectangles containing a character\nand its frequency. Internal nodes are shown as circles containing the sum of the frequencies of their\nchildren. An edge connecting an internal node with its children is labeled 0if it is an edge to a left\nchild and 1if it is an edge to a right child. The codeword for a letter is the sequence of labels on the\nedges connecting the root to the leaf for that letter. (a)The initial set of nD6nodes, one for each\nletter. (b)\u2013(e) Intermediate stages. (f)The \ufb01nal tree.\nfrom the queue, replacing them in the queue with a new node \u00b4representing their\nmerger. The frequency of \u00b4is computed as the sum of the frequencies of xandy\nin line 7. The node \u00b4hasxas its left child and yas its right child. (This order is\narbitrary; switching the left and right child of any node yields a different code ofthe same cost.) After n/NUL1mergers, line 9 returns the one node left in the queue,\nwhich is the root of the code tree.\nAlthough the algorithm would produce the same result if we were to excise the\nvariables xandy\u2014assigning directly to \u00b4:leftand\u00b4:right in lines 5 and 6, and\nchanging line 7 to \u00b4:freqD\u00b4:left:freqC\u00b4:right:freq\u2014we shall use the node", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "453": {"page_number": 454, "page_information": "16.3 Huffman codes 433\nnames xandyin the proof of correctness. Therefore, we \ufb01nd it convenient to\nleave them in.\nTo analyze the running time of Huffman\u2019s algorithm, we assume that Qis im-\nplemented as a binary min-heap (see Chapter 6). For a set Cofncharacters, we\ncan initialize Qin line 2 in O.n/ time using the B UILD -MIN-HEAP procedure dis-\ncussed in Section 6.3. The forloop in lines 3\u20138 executes exactly n/NUL1times, and\nsince each heap operation requires time O.lgn/, the loop contributes O.n lgn/to\nthe running time. Thus, the total running time of H UFFMAN on a set of ncharac-\nters is O.n lgn/. We can reduce the running time to O.n lg lgn/by replacing the\nbinary min-heap with a van Emde Boas tree (see Chapter 20).\nCorrectness of Huffman\u2019s algorithm\nTo prove that the greedy algorithm H UFFMAN is correct, we show that the prob-\nlem of determining an optimal pre\ufb01x code exhibits the greedy-choice and optimal-substructure properties. The next lemma shows that the greedy-choice propertyholds.\nLemma 16.2\nLetCbe an alphabet in which each character c2Chas frequency c:freq.L e t\nxandybe two characters in Chaving the lowest frequencies. Then there exists\nan optimal pre\ufb01x code for Cin which the codewords for xandyhave the same\nlength and differ only in the last bit.\nProof The idea of the proof is to take the tree Trepresenting an arbitrary optimal\npre\ufb01x code and modify it to make a tree representing another optimal pre\ufb01x codesuch that the characters xandyappear as sibling leaves of maximum depth in the\nnew tree. If we can construct such a tree, then the codewords for xandywill have\nthe same length and differ only in the last bit.\nLetaandbbe two characters that are sibling leaves of maximum depth in T.\nWithout loss of generality, we assume that a:freq/DC4b:freqandx:freq/DC4y:freq.\nSince x:freq andy:freq are the two lowest leaf frequencies, in order, and a:freq\nandb:freq are two arbitrary frequencies, in order, we have x:freq/DC4a:freq and\ny:freq/DC4b:freq.\nIn the remainder of the proof, it is possible that we could have x:freqDa:freq\nory:freqDb:freq. However, if we had x:\nfreqDb:freq, then we would also have\na:freqDb:freqDx:freqDy:freq(see Exercise 16.3-1), and the lemma would\nbe trivially true. Thus, we will assume that x:freq\u00a4b:freq, which means that\nx\u00a4b.\nAs Figure 16.6 shows, we exchange the positions in Tofaandxto produce a\ntreeT0, and then we exchange the positions in T0ofbandyto produce a tree T00", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "454": {"page_number": 455, "page_information": "434 Chapter 16 Greedy Algorithms\nx\ny\nab xya\nb xya\nbT\u2032\u2032 T T\u2032\nFigure 16.6 An illustration of the key step in the proof of Lemma 16.2. In the optimal tree T,\nleaves aandbare two siblings of maximum depth. Leaves xandyare the two characters with the\nlowest frequencies; they appear in arbitrary positions in T. Assuming that x\u00a4b, swapping leaves a\nandxproduces tree T0, and then swapping leaves bandyproduces tree T00. Since each swap does\nnot increase the cost, the resulting tree T00is also an optimal tree.\nin which xandyare sibling leaves of maximum depth. (Note that if xDbbut\ny\u00a4a, then tree T00does not have xandyas sibling leaves of maximum depth.\nBecause we assume that x\u00a4b, this situation cannot occur.) By equation (16.4),\nthe difference in cost between TandT0is\nB.T //NULB.T0/\nDX\nc2Cc:freq/SOHdT.c//NULX\nc2Cc:freq/SOHdT0.c/\nDx:freq/SOHdT.x/Ca:freq/SOHdT.a//NULx:freq/SOHdT0.x//NULa:freq/SOHdT0.a/\nDx:freq/SOHdT.x/Ca:freq/SOHdT.a//NULx:freq/SOHdT.a//NULa:freq/SOHdT.x/\nD.a:freq/NULx:freq/.dT.a//NULdT.x//\n/NAK0;\nbecause both a:freq/NULx:freqanddT.a//NULdT.x/are nonnegative. More speci\ufb01-\ncally, a:freq/NULx:freqis nonnegative because xis a minimum-frequency leaf, and\ndT.a//NULdT.x/is nonnegative because ais a leaf of maximum depth in T. Similarly,\nexchanging yandbdoes not increase the cost, and so B.T0//NULB.T00/is nonnega-\ntive. Therefore, B.T00//DC4B.T / , and since Tis optimal, we have B.T //DC4B.T00/,\nwhich implies B.T00/DB.T/ . Thus, T00is an optimal tree in which xandy\nappear as sibling leaves of maximum depth, from which the lemma follows.\nLemma 16.2 implies that the process of building up an optimal tree by mergers\ncan, without loss of generality, begin with the greedy choice of merging togetherthose two characters of lowest frequency. Why is this a greedy choice? We canview the cost of a single merger as being the sum of the frequencies of the two items\nbeing merged. Exercise 16.3-4 shows that the total cost of the tree constructed\nequals the sum of the costs of its mergers. Of all possible mergers at each step,\nH\nUFFMAN chooses the one that incurs the least cost.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "455": {"page_number": 456, "page_information": "16.3 Huffman codes 435\nThe next lemma shows that the problem of constructing optimal pre\ufb01x codes has\nthe optimal-substructure property.\nLemma 16.3\nLetCbe a given alphabet with frequency c:freqde\ufb01ned for each character c2C.\nLetxandybe two characters in Cwith minimum frequency. Let C0be the\nalphabet Cwith the characters xandyremoved and a new character \u00b4added,\nso that C0DC/NULfx;yg[f\u00b4g.D e \ufb01 n e fforC0as for C, except that\n\u00b4:freqDx:freqCy:freq.L e t T0be any tree representing an optimal pre\ufb01x code\nfor the alphabet C0. Then the tree T, obtained from T0by replacing the leaf node\nfor\u00b4with an internal node having xandyas children, represents an optimal pre\ufb01x\ncode for the alphabet C.\nProof We \ufb01rst show how to express the cost B.T/ of tree Tin terms of the\ncostB.T0/of tree T0, by considering the component costs in equation (16.4).\nFor each character c2C/NULfx;yg,w eh a v et h a t dT.c/DdT0.c/, and hence\nc:freq/SOHdT.c/Dc:freq/SOHdT0.c/.S i n c e dT.x/DdT.y/DdT0.\u00b4/C1,w eh a v e\nx:freq/SOHdT.x/Cy:freq/SOHdT.y/D.x:freqCy:freq/.dT0.\u00b4/C1/\nD\u00b4:freq/SOHdT0.\u00b4/C.x:freqCy:freq/;\nfrom which we conclude that\nB.T/DB.T0/Cx:freqCy:freq\nor, equivalently,B.T\n0/DB.T //NULx:freq/NULy:freq:\nWe now prove the lemma by contradiction. Suppose that Tdoes not repre-\nsent an optimal pre\ufb01x code for C. Then there exists an optimal tree T00such that\nB.T00/<B . T/ . Without loss of generality (by Lemma 16.2), T00hasxandyas\nsiblings. Let T000be the tree T00with the common parent of xandyreplaced by a\nleaf\u00b4with frequency \u00b4:freqDx:freqCy:freq.T h e n\nB.T000/DB.T00//NULx:freq/NULy:freq\n<B . T //NULx:freq/NULy:freq\nDB.T0/;\nyielding a contradiction to the assumption that T0represents an optimal pre\ufb01x code\nforC0. Thus, Tmust represent an optimal pre\ufb01x code for the alphabet C.\nTheorem 16.4\nProcedure H UFFMAN produces an optimal pre\ufb01x code.\nProof Immediate from Lemmas 16.2 and 16.3.\n", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "456": {"page_number": 457, "page_information": "436 Chapter 16 Greedy Algorithms\nExercises\n16.3-1\nExplain why, in the proof of Lemma 16.2, if x:freqDb:freq, then we must have\na:freqDb:freqDx:freqDy:freq.\n16.3-2\nProve that a binary tree that is not full cannot correspond to an optimal pre\ufb01x code.\n16.3-3\nWhat is an optimal Huffman code for the following set of frequencies, based onthe \ufb01rst 8 Fibonacci numbers?\na:1b:1c:2d:3e:5f:8g:13h:21\nCan you generalize your answer to \ufb01nd the optimal code when the frequencies are\nthe \ufb01rst nFibonacci numbers?\n16.3-4\nProve that we can also express the total cost of a tree for a code as the sum, overall internal nodes, of the combined frequencies of the two children of the node.\n16.3-5\nProve that if we order the characters in an alphabet so that their frequencies\nare monotonically decreasing, then there exists an optimal code whose codeword\nlengths are monotonically increasing.\n16.3-6\nSuppose we have an optimal pre\ufb01x code on a set CDf0; 1; : : : ; n/NUL1gof charac-\nters and we wish to transmit this code using as few bits as possible. Show how torepresent any optimal pre\ufb01x code on Cusing only 2n/NUL1Cndlgnebits. ( Hint:\nUse2n/NUL1bits to specify the structure of the tree, as discovered by a walk of the\ntree.)\n16.3-7\nGeneralize Huffman\u2019s algorithm to ternary codewords (i.e., codewords using thesymbols 0,1,a n d 2), and prove that it yields optimal ternary codes.\n16.3-8\nSuppose that a data \ufb01le contains a sequence of 8-bit characters such that all 256characters are about equally common: the maximum character frequency is lessthan twice the minimum character frequency. Prove that Huffman coding in this\ncase is no more ef\ufb01cient than using an ordinary 8-bit \ufb01xed-length code.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "457": {"page_number": 458, "page_information": "16.4 Matroids and greedy methods 437\n16.3-9\nShow that no compression scheme can expect to compress a \ufb01le of randomly cho-sen 8-bit characters by even a single bit. ( Hint: Compare the number of possible\n\ufb01les with the number of possible encoded \ufb01les.)\n?16.4 Matroids and greedy methods\nIn this section, we sketch a beautiful theory about greedy algorithms. This theorydescribes many situations in which the greedy method yields optimal solutions. Itinvolves combinatorial structures known as \u201cmatroids.\u201d Although this theory doesnot cover all cases for which a greedy method applies (for example, it does notcover the activity-selection problem of Section 16.1 or the Huffman-coding prob-lem of Section 16.3), it does cover many cases of practical interest. Furthermore,this theory has been extended to cover many applications; see the notes at the endof this chapter for references.\nMatroids\nAmatroid is an ordered pair MD.S;/TAB/satisfying the following conditions.\n1.Sis a \ufb01nite set.\n2./TABis a nonempty family of subsets of S, called the independent subsets of S,\nsuch that if B2/TABandA/DC2B,t h e n A2/TAB. We say that /TABishereditary if it\nsatis\ufb01es this property. Note that the empty set ;is necessarily a member of /TAB.\n3. If A2/TAB,B2/TAB,a n djAj<jBj, then there exists some element x2B/NULA\nsuch that A[fxg2/TAB. We say that Msatis\ufb01es the exchange property .\nThe word \u201cmatroid\u201d is due to Hassler Whitney. He was studying matric ma-\ntroids , in which the elements of Sare the rows of a given matrix and a set of rows is\nindependent if they are linearly independent in the usual sense. As Exercise 16.4-2asks you to show, this structure de\ufb01nes a matroid.\nAs another example of matroids, consider the graphic matroid M\nGD.SG;/TABG/\nde\ufb01ned in terms of a given undirected graph GD.V; E/ as follows:\n/SIThe set SGis de\ufb01ned to be E, the set of edges of G.\n/SIIfAis a subset of E,t h e n A2/TABGif and only if Ais acyclic. That is, a set of\nedges Ais independent if and only if the subgraph GAD.V; A/ forms a forest.\nThe graphic matroid MGis closely related to the minimum-spanning-tree problem,\nwhich Chapter 23 covers in detail.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "458": {"page_number": 459, "page_information": "438 Chapter 16 Greedy Algorithms\nTheorem 16.5\nIfGD.V; E/ is an undirected graph, then MGD.SG;/TABG/is a matroid.\nProof Clearly, SGDEis a \ufb01nite set. Furthermore, /TABGis hereditary, since a\nsubset of a forest is a forest. Putting it another way, removing edges from an\nacyclic set of edges cannot create cycles.\nThus, it remains to show that MGsatis\ufb01es the exchange property. Suppose that\nGAD.V; A/ andGBD.V; B/ are forests of Gand thatjBj>jAj.T h a t i s , A\nandBare acyclic sets of edges, and Bcontains more edges than Adoes.\nWe claim that a forest FD.VF;EF/contains exactlyjVFj/NULjEFjtrees. To\nsee why, suppose that Fconsists of ttrees, where the ith tree contains /ETBivertices\nandeiedges. Then, we have\njEFjDtX\niD1ei\nDtX\niD1./ETBi/NUL1/(by Theorem B.2)\nDtX\niD1/ETBi/NULt\nDjVFj/NULt;\nwhich implies that tDjVFj/NULjEFj. Thus, forest GAcontainsjVj/NULjAjtrees, and\nforest GBcontainsjVj/NULjBjtrees.\nSince forest GBhas fewer trees than forest GAdoes, forest GBmust contain\nsome tree Twhose vertices are in two different trees in forest GA. Moreover,\nsince Tis connected, it must contain an edge .u; /ETB/ such that vertices uand/ETB\nare in different trees in forest GA. Since the edge .u; /ETB/ connects vertices in two\ndifferent trees in forest GA, we can add the edge .u; /ETB/ to forest GAwithout creating\na cycle. Therefore, MGsatis\ufb01es the exchange property, completing the proof that\nMGis a matroid.\nGiven a matroid MD.S;/TAB/, we call an element x\u2026Aanextension ofA2/TAB\nif we can add xtoAwhile preserving independence; that is, xis an extension\nofAifA[fxg2/TAB. As an example, consider a graphic matroid MG.I fAis an\nindependent set of edges, then edge eis an extension of Aif and only if eis not\ninAand the addition of etoAdoes not create a cycle.\nIfAis an independent subset in a matroid M, we say that Aismaximal if it has\nno extensions. That is, Ais maximal if it is not contained in any larger independent\nsubset of M. The following property is often useful.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "459": {"page_number": 460, "page_information": "16.4 Matroids and greedy methods 439\nTheorem 16.6\nAll maximal independent subsets in a matroid have the same size.\nProof Suppose to the contrary that Ais a maximal independent subset of M\nand there exists another larger maximal independent subset BofM. Then, the\nexchange property implies that for some x2B/NULA, we can extend Ato a larger\nindependent set A[fxg, contradicting the assumption that Ais maximal.\nAs an illustration of this theorem, consider a graphic matroid MGfor a con-\nnected, undirected graph G. Every maximal independent subset of MGmust be a\nfree tree with exactly jVj/NUL1edges that connects all the vertices of G. Such a tree\nis called a spanning tree ofG.\nWe say that a matroid MD.S;/TAB/isweighted if it is associated with a weight\nfunction wthat assigns a strictly positive weight w.x/ to each element x2S.T h e\nweight function wextends to subsets of Sby summation:\nw.A/DX\nx2Aw.x/\nfor any A/DC2S. For example, if we let w.e/ denote the weight of an edge ein a\ngraphic matroid MG,t h e n w.A/ is the total weight of the edges in edge set A.\nGreedy algorithms on a weighted matroid\nMany problems for which a greedy approach provides optimal solutions can be for-\nmulated in terms of \ufb01nding a maximum-weight independent subset in a weightedmatroid. That is, we are given a weighted matroid MD.S;/TAB/, and we wish to\n\ufb01nd an independent set A2/TABsuch that w.A/ is maximized. We call such a sub-\nset that is independent and has maximum possible weight an optimal subset of the\nmatroid. Because the weight w.x/ of any element x2Sis positive, an optimal\nsubset is always a maximal independent subset\u2014it always helps to make Aas large\nas possible.\nFor example, in the minimum-spanning-tree problem , we are given a connected\nundirected graph GD.V; E/ and a length function wsuch that w.e/ is the (posi-\ntive) length of edge e. (We use the term \u201clength\u201d here to refer to the original edge\nweights for the graph, reserving the term \u201cweight\u201d to refer to the weights in theassociated matroid.) We wish to \ufb01nd a subset of the edges that connects all ofthe vertices together and has minimum total length. To view this as a problem of\ufb01nding an optimal subset of a matroid, consider the weighted matroid M\nGwith\nweight function w0,w h e r e w0.e/Dw0/NULw.e/ andw0is larger than the maximum\nlength of any edge. In this weighted matroid, all weights are positive and an opti-mal subset is a spanning tree of minimum total length in the original graph. Morespeci\ufb01cally, each maximal independent subset Acorresponds to a spanning tree", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "460": {"page_number": 461, "page_information": "440 Chapter 16 Greedy Algorithms\nwithjVj/NUL1edges, and since\nw0.A/DX\ne2Aw0.e/\nDX\ne2A.w0/NULw.e//\nD.jVj/NUL1/w 0/NULX\ne2Aw.e/\nD.jVj/NUL1/w 0/NULw.A/\nfor any maximal independent subset A, an independent subset that maximizes the\nquantity w0.A/must minimize w.A/ . Thus, any algorithm that can \ufb01nd an optimal\nsubset Ain an arbitrary matroid can solve the minimum-spanning-tree problem.\nChapter 23 gives algorithms for the minimum-spanning-tree problem, but here\nwe give a greedy algorithm that works for any weighted matroid. The algorithmtakes as input a weighted matroid MD.S;/TAB/with an associated positive weight\nfunction w, and it returns an optimal subset A. In our pseudocode, we denote the\ncomponents of MbyM:SandM:/TABand the weight function by w. The algorithm\nis greedy because it considers in turn each element x2S, in order of monotoni-\ncally decreasing weight, and immediately adds it to the set Abeing accumulated if\nA[fxgis independent.\nG\nREEDY .M; w/\n1AD;\n2s o r t M:Sinto monotonically decreasing order by weight w\n3foreachx2M:S, taken in monotonically decreasing order by weight w.x/\n4 ifA[fxg2M:/TAB\n5 ADA[fxg\n6return A\nLine 4 checks whether adding each element xtoAwould maintain Aas an inde-\npendent set. If Awould remain independent, then line 5 adds xtoA. Otherwise, x\nis discarded. Since the empty set is independent, and since each iteration of the for\nloop maintains A\u2019s independence, the subset Ais always independent, by induc-\ntion. Therefore, G REEDY always returns an independent subset A. We shall see in\na moment that Ais a subset of maximum possible weight, so that Ais an optimal\nsubset.\nThe running time of G REEDY is easy to analyze. Let ndenotejSj. The sorting\nphase of G REEDY takes time O.n lgn/. Line 4 executes exactly ntimes, once for\neach element of S. Each execution of line 4 requires a check on whether or not\nthe set A[fxgis independent. If each such check takes time O.f .n// , the entire\nalgorithm runs in time O.n lgnCnf .n// .", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "461": {"page_number": 462, "page_information": "16.4 Matroids and greedy methods 441\nWe now prove that G REEDY returns an optimal subset.\nLemma 16.7 (Matroids exhibit the greedy-choice property)\nSuppose that MD.S;/TAB/is a weighted matroid with weight function wand that S\nis sorted into monotonically decreasing order by weight. Let xbe the \ufb01rst element\nofSsuch thatfxgis independent, if any such xexists. If xexists, then there exists\nan optimal subset AofSthat contains x.\nProof If no such xexists, then the only independent subset is the empty set and\nthe lemma is vacuously true. Otherwise, let Bbe any nonempty optimal subset.\nAssume that x\u2026B; otherwise, letting ADBgives an optimal subset of Sthat\ncontains x.\nNo element of Bhas weight greater than w.x/ . To see why, observe that y2B\nimplies thatfygis independent, since B2/TABand/TABis hereditary. Our choice of x\ntherefore ensures that w.x//NAKw.y/ for any y2B.\nConstruct the set Aas follows. Begin with ADfxg. By the choice of x, setAis\nindependent. Using the exchange property, repeatedly \ufb01nd a new element of Bthat\nwe can add to AuntiljAjDjBj, while preserving the independence of A.A tt h a t\npoint, AandBare the same except that AhasxandBhas some other element y.\nThat is, ADB/NULfyg[fxgfor some y2B,a n ds o\nw.A/Dw.B//NULw.y/Cw.x/\n/NAKw.B/ :\nBecause set Bis optimal, set A, which contains x, must also be optimal.\nWe next show that if an element is not an option initially, then it cannot be an\noption later.\nLemma 16.8\nLetMD.S;/TAB/be any matroid. If xis an element of Sthat is an extension of\nsome independent subset AofS,t h e n xis also an extension of ;.\nProof Since xis an extension of A,w eh a v et h a t A[fxgis independent. Since /TAB\nis hereditary,fxgmust be independent. Thus, xis an extension of;.\nCorollary 16.9\nLetMD.S;/TAB/be any matroid. If xis an element of Ssuch that xis not an\nextension of;,t h e n xis not an extension of any independent subset AofS.\nProof This corollary is simply the contrapositive of Lemma 16.8.\n", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "462": {"page_number": 463, "page_information": "442 Chapter 16 Greedy Algorithms\nCorollary 16.9 says that any element that cannot be used immediately can never\nbe used. Therefore, G REEDY cannot make an error by passing over any initial\nelements in Sthat are not an extension of ;, since they can never be used.\nLemma 16.10 (Matroids exhibit the optimal-substructure property)\nLetxbe the \ufb01rst element of Schosen by G REEDY for the weighted matroid\nMD.S;/TAB/. The remaining problem of \ufb01nding a maximum-weight indepen-\ndent subset containing xreduces to \ufb01nding a maximum-weight independent subset\nof the weighted matroid M0D.S0;/TAB0/,w h e r e\nS0Dfy2SWfx;yg2/TABg;\n/TAB0DfB/DC2S/NULfxgWB[fxg2/TABg;\nand the weight function for M0is the weight function for M, restricted to S0.( W e\ncallM0thecontraction ofMby the element x.)\nProof IfAis any maximum-weight independent subset of Mcontaining x,t h e n\nA0DA/NULfxgis an independent subset of M0. Conversely, any independent sub-\nsetA0ofM0yields an independent subset ADA0[fxgofM. Since we have in\nboth cases that w.A/Dw.A0/Cw.x/ , a maximum-weight solution in Mcontain-\ningxyields a maximum-weight solution in M0, and vice versa.\nTheorem 16.11 (Correctness of the greedy algorithm on matroids)\nIfMD.S;/TAB/is a weighted matroid with weight function w,t h e nG REEDY .M; w/\nreturns an optimal subset.\nProof By Corollary 16.9, any elements that G REEDY passes over initially be-\ncause they are not extensions of ;can be forgotten about, since they can never\nbe useful. Once G REEDY selects the \ufb01rst element x, Lemma 16.7 implies that\nthe algorithm does not err by adding xtoA, since there exists an optimal subset\ncontaining x. Finally, Lemma 16.10 implies that the remaining problem is one of\n\ufb01nding an optimal subset in the matroid M0that is the contraction of Mbyx.\nAfter the procedure G REEDY setsAtofxg, we can interpret all of its remaining\nsteps as acting in the matroid M0D.S0;/TAB0/, because Bis independent in M0if\nand only if B[fxgis independent in M, for all sets B2/TAB0. Thus, the subsequent\noperation of G REEDY will \ufb01nd a maximum-weight independent subset for M0,a n d\nthe overall operation of G REEDY will \ufb01nd a maximum-weight independent subset\nforM.\n", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "463": {"page_number": 464, "page_information": "16.5 A task-scheduling problem as a matroid 443\nExercises\n16.4-1\nShow that .S;/TABk/is a matroid, where Sis any \ufb01nite set and /TABkis the set of all\nsubsets of Sof size at most k,w h e r e k/DC4jSj.\n16.4-2 ?\nGiven an m/STXnmatrix Tover some \ufb01eld (such as the reals), show that .S;/TAB/is a\nmatroid, where Sis the set of columns of TandA2/TABif and only if the columns\ninAare linearly independent.\n16.4-3 ?\nShow that if .S;/TAB/is a matroid, then .S;/TAB0/is a matroid, where\n/TAB0DfA0WS/NULA0contains some maximal A2/TABg:\nThat is, the maximal independent sets of .S;/TAB0/are just the complements of the\nmaximal independent sets of .S;/TAB/.\n16.4-4 ?\nLetSbe a \ufb01nite set and let S1;S2;:::;S kbe a partition of Sinto nonempty disjoint\nsubsets. De\ufb01ne the structure .S;/TAB/by the condition that /TABDfAWjA\\Sij/DC41\nforiD1 ;2;:::;kg. Show that .S;/TAB/is a matroid. That is, the set of all sets A\nthat contain at most one member of each subset in the partition determines the\nindependent sets of a matroid.\n16.4-5\nShow how to transform the weight function of a weighted matroid problem, where\nthe desired optimal solution is a minimum-weight maximal independent subset, to\nmake it a standard weighted-matroid problem. Argue carefully that your transfor-\nmation is correct.\n?16.5 A task-scheduling problem as a matroid\nAn interesting problem that we can solve using matroids is the problem of op-timally scheduling unit-time tasks on a single processor, where each task has adeadline, along with a penalty paid if the task misses its deadline. The problemlooks complicated, but we can solve it in a surprisingly simple manner by castingit as a matroid and using a greedy algorithm.\nAunit-time task is a job, such as a program to be run on a computer, that requires\nexactly one unit of time to complete. Given a \ufb01nite set Sof unit-time tasks, a", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "464": {"page_number": 465, "page_information": "444 Chapter 16 Greedy Algorithms\nschedule forSis a permutation of Sspecifying the order in which to perform\nthese tasks. The \ufb01rst task in the schedule begins at time 0and \ufb01nishes at time 1,\nthe second task begins at time 1and \ufb01nishes at time 2, and so on.\nThe problem of scheduling unit-time tasks with deadlines and penalties for a\nsingle processor has the following inputs:\n/SIa setSDfa1;a2;:::;a ngofnunit-time tasks;\n/SIa set of ninteger deadlines d1;d2;:::;d n, such that each disatis\ufb01es 1/DC4di/DC4n\nand task aiis supposed to \ufb01nish by time di;a n d\n/SIa set of nnonnegative weights or penalties w1;w2;:::;w n, such that we incur\na penalty of wiif task aiis not \ufb01nished by time di, and we incur no penalty if\na task \ufb01nishes by its deadline.\nWe wish to \ufb01nd a schedule for Sthat minimizes the total penalty incurred for\nmissed deadlines.\nConsider a given schedule. We say that a task is latein this schedule if it \ufb01nishes\nafter its deadline. Otherwise, the task is early in the schedule. We can always trans-\nform an arbitrary schedule into early-\ufb01rst form , in which the early tasks precede\nthe late tasks. To see why, note that if some early task aifollows some late task aj,\nthen we can switch the positions of aiandaj,a n d aiwill still be early and ajwill\nstill be late.\nFurthermore, we claim that we can always transform an arbitrary schedule into\ncanonical form , in which the early tasks precede the late tasks and we schedule\nthe early tasks in order of monotonically increasing deadlines. To do so, we putthe schedule into early-\ufb01rst form. Then, as long as there exist two early tasks a\ni\nandaj\ufb01nishing at respective times kandkC1in the schedule such that dj<d i,\nwe swap the positions of aiandaj.S i n c e ajis early before the swap, kC1/DC4dj.\nTherefore, kC1<d i,a n ds o aiis still early after the swap. Because task ajis\nmoved earlier in the schedule, it remains early after the swap.\nThe search for an optimal schedule thus reduces to \ufb01nding a set Aof tasks that\nwe assign to be early in the optimal schedule. Having determined A, we can create\nthe actual schedule by listing the elements of Ain order of monotonically increas-\ning deadlines, then listing the late tasks (i.e., S/NULA) in any order, producing a\ncanonical ordering of the optimal schedule.\nWe say that a set Aof tasks is independent if there exists a schedule for these\ntasks such that no tasks are late. Clearly, the set of early tasks for a schedule forms\nan independent set of tasks. Let /TABdenote the set of all independent sets of tasks.\nConsider the problem of determining whether a given set Aof tasks is indepen-\ndent. For tD0; 1; 2; : : : ; n ,l e tNt.A/denote the number of tasks in Awhose\ndeadline is tor earlier. Note that N0.A/D0for any set A.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "465": {"page_number": 466, "page_information": "16.5 A task-scheduling problem as a matroid 445\nLemma 16.12\nFor any set of tasks A, the following statements are equivalent.\n1. The set Ais independent.\n2. For tD0; 1; 2; : : : ; n ,w eh a v e Nt.A//DC4t.\n3. If the tasks in Aare scheduled in order of monotonically increasing deadlines,\nthen no task is late.\nProof To show that (1) implies (2), we prove the contrapositive: if Nt.A/ > t for\nsome t, then there is no way to make a schedule with no late tasks for set A, because\nmore than ttasks must \ufb01nish before time t. Therefore, (1) implies (2). If (2) holds,\nthen (3) must follow: there is no way to \u201cget stuck\u201d when scheduling the tasks inorder of monotonically increasing deadlines, since (2) implies that the ith largest\ndeadline is at least i. Finally, (3) trivially implies (1).\nUsing property 2 of Lemma 16.12, we can easily compute whether or not a given\nset of tasks is independent (see Exercise 16.5-2).\nThe problem of minimizing the sum of the penalties of the late tasks is the same\nas the problem of maximizing the sum of the penalties of the early tasks. Thefollowing theorem thus ensures that we can use the greedy algorithm to \ufb01nd anindependent set Aof tasks with the maximum total penalty.\nTheorem 16.13\nIfSis a set of unit-time tasks with deadlines, and /TABis the set of all independent\nsets of tasks, then the corresponding system .S;/TAB/is a matroid.\nProof Every subset of an independent set of tasks is certainly independent. To\nprove the exchange property, suppose that BandAare independent sets of tasks\nand thatjBj>jAj.L e t kbe the largest tsuch that N\nt.B//DC4Nt.A/. (Such a value\noftexists, since N0.A/DN0.B/D0.) Since Nn.B/DjBjandNn.A/DjAj,\nbutjBj>jAj, we must have that k<n and that Nj.B/ > N j.A/for all jin\nthe range kC1/DC4j/DC4n. Therefore, Bcontains more tasks with deadline kC1\nthanAdoes. Let aibe a task in B/NULAwith deadline kC1.L e t A0DA[faig.\nWe now show that A0must be independent by using property 2 of Lemma 16.12.\nFor0/DC4t/DC4k,w eh a v e Nt.A0/DNt.A//DC4t,s i n c e Ais independent. For\nk<t/DC4n,w eh a v e Nt.A0//DC4Nt.B//DC4t,s i n c e Bis independent. Therefore, A0\nis independent, completing our proof that .S;/TAB/is a matroid.\nBy Theorem 16.11, we can use a greedy algorithm to \ufb01nd a maximum-weight\nindependent set of tasks A. We can then create an optimal schedule having the\ntasks in Aas its early tasks. This method is an ef\ufb01cient algorithm for scheduling", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "466": {"page_number": 467, "page_information": "446 Chapter 16 Greedy Algorithms\nTask\nai\n 1234567\ndi\n 4243146\nwi\n 70 60 50 40 30 20 10\nFigure 16.7 An instance of the problem of scheduling unit-time tasks with deadlines and penalties\nfor a single processor.\nunit-time tasks with deadlines and penalties for a single processor. The running\ntime is O.n2/using G REEDY , since each of the O.n/ independence checks made\nby that algorithm takes time O.n/ (see Exercise 16.5-2). Problem 16-4 gives a\nfaster implementation.\nFigure 16.7 demonstrates an example of the problem of scheduling unit-time\ntasks with deadlines and penalties for a single processor. In this example, thegreedy algorithm selects, in order, tasks a\n1,a2,a3,a n d a4, then rejects a5(because\nN4.fa1;a2;a3;a4;a5g/D5)a n d a6(because N4.fa1;a2;a3;a4;a6g/D5), and\n\ufb01nally accepts a7. The \ufb01nal optimal schedule is\nha2;a4;a1;a3;a7;a5;a6i;\nwhich has a total penalty incurred of w5Cw6D50.\nExercises\n16.5-1\nSolve the instance of the scheduling problem given in Figure 16.7, but with each\npenalty wireplaced by 80/NULwi.\n16.5-2\nShow how to use property 2 of Lemma 16.12 to determine in time O.jAj/whether\nor not a given set Aof tasks is independent.\nProblems\n16-1 Coin changing\nConsider the problem of making change for ncents using the fewest number of\ncoins. Assume that each coin\u2019s value is an integer.\na.Describe a greedy algorithm to make change consisting of quarters, dimes,\nnickels, and pennies. Prove that your algorithm yields an optimal solution.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "467": {"page_number": 468, "page_information": "Problems for Chapter 16 447\nb.Suppose that the available coins are in the denominations that are powers of c,\ni.e., the denominations are c0;c1;:::;ckfor some integers c>1 andk/NAK1.\nShow that the greedy algorithm always yields an optimal solution.\nc.Give a set of coin denominations for which the greedy algorithm does not yield\nan optimal solution. Your set should include a penny so that there is a solutionfor every value of n.\nd.Give an O.nk/ -time algorithm that makes change for any set of kdifferent coin\ndenominations, assuming that one of the coins is a penny.\n16-2 Scheduling to minimize average completion time\nSuppose you are given a set SDfa\n1;a2;:::;a ngof tasks, where task aire-\nquires piunits of processing time to complete, once it has started. You have one\ncomputer on which to run these tasks, and the computer can run only one task at atime. Let c\nibe the completion time of task ai, that is, the time at which task aicom-\npletes processing. Your goal is to minimize the average completion time, that is,to minimize .1=n/P\nn\niD1ci. For example, suppose there are two tasks, a1anda2,\nwithp1D3andp2D5, and consider the schedule in which a2runs \ufb01rst, followed\nbya1.T h e n c2D5,c1D8, and the average completion time is .5C8/=2D6:5.\nIf task a1runs \ufb01rst, however, then c1D3,c2D8, and the average completion\ntime is .3C8/=2D5:5.\na.Give an algorithm that schedules the tasks so as to minimize the average com-\npletion time. Each task must run non-preemptively, that is, once task aistarts, it\nmust run continuously for piunits of time. Prove that your algorithm minimizes\nthe average completion time, and state the running time of your algorithm.\nb.Suppose now that the tasks are not all available at once. That is, each task\ncannot start until its release time ri. Suppose also that we allow preemption ,s o\nthat a task can be suspended and restarted at a later time. For example, a task ai\nwith processing time piD6and release time riD1might start running at\ntime 1 and be preempted at time 4. It might then resume at time 10 but bepreempted at time 11, and it might \ufb01nally resume at time 13 and complete attime 15. Task a\nihas run for a total of 6 time units, but its running time has been\ndivided into three pieces. In this scenario, ai\u2019s completion time is 15.G i v e\nan algorithm that schedules the tasks so as to minimize the average completiontime in this new scenario. Prove that your algorithm minimizes the average\ncompletion time, and state the running time of your algorithm.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "468": {"page_number": 469, "page_information": "448 Chapter 16 Greedy Algorithms\n16-3 Acyclic subgraphs\na.Theincidence matrix for an undirected graph GD.V; E/ is ajVj/STXjEjma-\ntrixMsuch that M/ETBeD1if edge eis incident on vertex /ETB,a n d M/ETBeD0other-\nwise. Argue that a set of columns of Mis linearly independent over the \ufb01eld\nof integers modulo 2 if and only if the corresponding set of edges is acyclic.Then, use the result of Exercise 16.4-2 to provide an alternate proof that .E;/TAB/\nof part (a) is a matroid.\nb.Suppose that we associate a nonnegative weight w.e/ with each edge in an\nundirected graph GD.V; E/ . Give an ef\ufb01cient algorithm to \ufb01nd an acyclic\nsubset of Eof maximum total weight.\nc.LetG.V; E/ be an arbitrary directed graph, and let .E;/TAB/be de\ufb01ned so that\nA2/TABif and only if Adoes not contain any directed cycles. Give an example\nof a directed graph Gsuch that the associated system .E;/TAB/is not a matroid.\nSpecify which de\ufb01ning condition for a matroid fails to hold.\nd.Theincidence matrix for a directed graph GD.V; E/ with no self-loops is a\njVj/STXjEjmatrix Msuch that M\n/ETBeD/NUL1if edge eleaves vertex /ETB,M/ETBeD1if\nedge eenters vertex /ETB,a n d M/ETBeD0otherwise. Argue that if a set of columns\nofMis linearly independent, then the corresponding set of edges does not\ncontain a directed cycle.\ne.Exercise 16.4-2 tells us that the set of linearly independent sets of columns of\nany matrix Mforms a matroid. Explain carefully why the results of parts (d)\nand (e) are not contradictory. How can there fail to be a perfect correspon-dence between the notion of a set of edges being acyclic and the notion of theassociated set of columns of the incidence matrix being linearly independent?\n16-4 Scheduling variations\nConsider the following algorithm for the problem from Section 16.5 of schedulingunit-time tasks with deadlines and penalties. Let all ntime slots be initially empty,\nwhere time slot iis the unit-length slot of time that \ufb01nishes at time i. We consider\nthe tasks in order of monotonically decreasing penalty. When considering task a\nj,\nif there exists a time slot at or before aj\u2019s deadline djthat is still empty, assign aj\nto the latest such slot, \ufb01lling it. If there is no such slot, assign task ajto the latest\nof the as yet un\ufb01lled slots.\na.Argue that this algorithm always gives an optimal answer.\nb.Use the fast disjoint-set forest presented in Section 21.3 to implement the algo-\nrithm ef\ufb01ciently. Assume that the set of input tasks has already been sorted into", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "469": {"page_number": 470, "page_information": "Problems for Chapter 16 449\nmonotonically decreasing order by penalty. Analyze the running time of your\nimplementation.\n16-5 Off-line caching\nModern computers use a cache to store a small amount of data in a fast memory.Even though a program may access large amounts of data, by storing a small subsetof the main memory in the cache \u2014a small but faster memory\u2014overall access time\ncan greatly decrease. When a computer program executes, it makes a sequence\nhr\n1;r2;:::;r niofnmemory requests, where each request is for a particular data\nelement. For example, a program that accesses 4distinct elementsfa;b;c;dg\nmight make the sequence of requests hd; b; d; b; d; a; c;d; b; a;c; b i.L e t kbe the\nsize of the cache. When the cache contains kelements and the program requests the\n.kC1/st element, the system must decide, for this and each subsequent request,\nwhich kelements to keep in the cache. More precisely, for each request ri,t h e\ncache-management algorithm checks whether element riis already in the cache. If\nit is, then we have a cache hit ; otherwise, we have a cache miss . Upon a cache\nmiss, the system retrieves rifrom the main memory, and the cache-management\nalgorithm must decide whether to keep riin the cache. If it decides to keep riand\nthe cache already holds kelements, then it must evict one element to make room\nforri. The cache-management algorithm evicts data with the goal of minimizing\nthe number of cache misses over the entire sequence of requests.\nTypically, caching is an on-line problem. That is, we have to make decisions\nabout which data to keep in the cache without knowing the future requests. Here,\nhowever, we consider the off-line version of this problem, in which we are givenin advance the entire sequence of nrequests and the cache size k, and we wish to\nminimize the total number of cache misses.\nWe can solve this off-line problem by a greedy strategy called furthest-in-future ,\nwhich chooses to evict the item in the cache whose next access in the requestsequence comes furthest in the future.\na.Write pseudocode for a cache manager that uses the furthest-in-future strategy.\nThe input should be a sequence hr\n1;r2;:::;r niof requests and a cache size k,\nand the output should be a sequence of decisions about which data element (ifany) to evict upon each request. What is the running time of your algorithm?\nb.Show that the off-line caching problem exhibits optimal substructure.\nc.Prove that furthest-in-future produces the minimum possible number of cache\nmisses.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "470": {"page_number": 471, "page_information": "450 Chapter 16 Greedy Algorithms\nChapter notes\nMuch more material on greedy algorithms and matroids can be found in Lawler\n[224] and Papadimitriou and Steiglitz [271].\nThe greedy algorithm \ufb01rst appeared in the combinatorial optimization literature\nin a 1971 article by Edmonds [101], though the theory of matroids dates back to\na 1935 article by Whitney [355].\nOur proof of the correctness of the greedy algorithm for the activity-selection\nproblem is based on that of Gavril [131]. The task-scheduling problem is studiedin Lawler [224]; Horowitz, Sahni, and Rajasekaran [181]; and Brassard and Bratley[54].\nHuffman codes were invented in 1952 [185]; Lelewer and Hirschberg [231] sur-\nveys data-compression techniques known as of 1987.\nAn extension of matroid theory to greedoid theory was pioneered by Korte and\nLov\u00b4asz [216, 217, 218, 219], who greatly generalize the theory presented here.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "471": {"page_number": 472, "page_information": "17 Amortized Analysis\nIn anamortized analysis , we average the time required to perform a sequence of\ndata-structure operations over all the operations performed. With amortized analy-sis, we can show that the average cost of an operation is small, if we average over asequence of operations, even though a single operation within the sequence mightbe expensive. Amortized analysis differs from average-case analysis in that prob-ability is not involved; an amortized analysis guarantees the average performance\nof each operation in the worst case .\nThe \ufb01rst three sections of this chapter cover the three most common techniques\nused in amortized analysis. Section 17.1 starts with aggregate analysis, in which\nwe determine an upper bound T .n/ on the total cost of a sequence of noperations.\nThe average cost per operation is then T .n/=n . We take the average cost as the\namortized cost of each operation, so that all operations have the same amortizedcost.\nSection 17.2 covers the accounting method, in which we determine an amortized\ncost of each operation. When there is more than one type of operation, each type of\noperation may have a different amortized cost. The accounting method overchargessome operations early in the sequence, storing the overcharge as \u201cprepaid credit\u201don speci\ufb01c objects in the data structure. Later in the sequence, the credit pays foroperations that are charged less than they actually cost.\nSection 17.3 discusses the potential method, which is like the accounting method\nin that we determine the amortized cost of each operation and may overcharge op-erations early on to compensate for undercharges later. The potential method main-tains the credit as the \u201cpotential energy\u201d of the data structure as a whole instead ofassociating the credit with individual objects within the data structure.\nWe shall use two examples to examine these three methods. One is a stack\nwith the additional operation M\nULTIPOP , which pops several objects at once. The\nother is a binary counter that counts up from 0by means of the single operation\nINCREMENT .", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "472": {"page_number": 473, "page_information": "452 Chapter 17 Amortized Analysis\nWhile reading this chapter, bear in mind that the charges assigned during an\namortized analysis are for analysis purposes only. They need not\u2014and shouldnot\u2014appear in the code. If, for example, we assign a credit to an object xwhen\nusing the accounting method, we have no need to assign an appropriate amount tosome attribute, such as x:credit , in the code.\nWhen we perform an amortized analysis, we often gain insight into a particular\ndata structure, and this insight can help us optimize the design. In Section 17.4,for example, we shall use the potential method to analyze a dynamically expanding\nand contracting table.\n17.1 Aggregate analysis\nInaggregate analysis , we show that for all n, a sequence of noperations takes\nworst-case time T .n/ in total. In the worst case, the average cost, or amortized\ncost, per operation is therefore T .n/=n . Note that this amortized cost applies to\neach operation, even when there are several types of operations in the sequence.The other two methods we shall study in this chapter, the accounting method andthe potential method, may assign different amortized costs to different types of\noperations.\nStack operations\nIn our \ufb01rst example of aggregate analysis, we analyze stacks that have been aug-\nmented with a new operation. Section 10.1 presented the two fundamental stack\noperations, each of which takes O.1/ time:\nP\nUSH.S; x/ pushes object xonto stack S.\nPOP.S/pops the top of stack Sand returns the popped object. Calling P OPon an\nempty stack generates an error.\nSince each of these operations runs in O.1/ time, let us consider the cost of each\nto be 1. The total cost of a sequence of nPUSH and P OPoperations is therefore n,\nand the actual running time for noperations is therefore \u201a.n/ .\nNow we add the stack operation M ULTIPOP .S; k/ , which removes the ktop ob-\njects of stack S, popping the entire stack if the stack contains fewer than kobjects.\nOf course, we assume that kis positive; otherwise the M ULTIPOP operation leaves\nthe stack unchanged. In the following pseudocode, the operation S TACK -EMPTY\nreturns TRUE if there are no objects currently on the stack, and FALSE otherwise.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "473": {"page_number": 474, "page_information": "17.1 Aggregate analysis 453\n23\n17\n6\n3910\n47\n(a)top\n10\n47\n(b)top\n(c)\nFigure 17.1 The action of M ULTIPOP on a stack S, shown initially in (a).T h e t o p 4objects are\npopped by M ULTIPOP .S; 4/ , whose result is shown in (b). The next operation is M ULTIPOP .S; 7/ ,\nwhich empties the stack\u2014shown in (c)\u2014since there were fewer than 7objects remaining.\nMULTIPOP .S; k/\n1while not S TACK -EMPTY .S/andk>0\n2P OP.S/\n3 kDk/NUL1\nFigure 17.1 shows an example of M ULTIPOP .\nWhat is the running time of M ULTIPOP .S; k/ on a stack of sobjects? The\nactual running time is linear in the number of P OPoperations actually executed,\nand thus we can analyze M ULTIPOP in terms of the abstract costs of 1each for\nPUSH and P OP. The number of iterations of the while loop is the number min .s; k/\nof objects popped off the stack. Each iteration of the loop makes one call to P OPin\nline 2. Thus, the total cost of M ULTIPOP is min .s; k/ , and the actual running time\nis a linear function of this cost.\nLet us analyze a sequence of nPUSH,POP,a n dM ULTIPOP operations on an ini-\ntially empty stack. The worst-case cost of a M ULTIPOP operation in the sequence\nisO.n/ , since the stack size is at most n. The worst-case time of any stack opera-\ntion is therefore O.n/ , and hence a sequence of noperations costs O.n2/,s i n c ew e\nmay have O.n/ MULTIPOP operations costing O.n/ each. Although this analysis\nis correct, the O.n2/result, which we obtained by considering the worst-case cost\nof each operation individually, is not tight.\nUsing aggregate analysis, we can obtain a better upper bound that considers the\nentire sequence of noperations. In fact, although a single M ULTIPOP operation\ncan be expensive, any sequence of nPUSH,POP,a n dM ULTIPOP operations on an\ninitially empty stack can cost at most O.n/ . Why? We can pop each object from the\nstack at most once for each time we have pushed it onto the stack. Therefore, thenumber of times that P\nOPcan be called on a nonempty stack, including calls within\nMULTIPOP , is at most the number of P USH operations, which is at most n.F o ra n y\nvalue of n, any sequence of nPUSH,POP,a n dM ULTIPOP operations takes a total\nofO.n/ time. The average cost of an operation is O.n/=nDO.1/ . In aggregate", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "474": {"page_number": 475, "page_information": "454 Chapter 17 Amortized Analysis\nanalysis, we assign the amortized cost of each operation to be the average cost. In\nthis example, therefore, all three stack operations have an amortized cost of O.1/ .\nWe emphasize again that although we have just shown that the average cost, and\nhence the running time, of a stack operation is O.1/ , we did not use probabilistic\nreasoning. We actually showed a worst-case bound of O.n/ on a sequence of n\noperations. Dividing this total cost by nyielded the average cost per operation, or\nthe amortized cost.\nIncrementing a binary counter\nAs another example of aggregate analysis, consider the problem of implementing\nak-bit binary counter that counts upward from 0. We use an array A\u01520 : : k/NUL1/c141of\nbits, where A:lengthDk, as the counter. A binary number xthat is stored in the\ncounter has its lowest-order bit in A\u01520/c141 and its highest-order bit in A\u0152k/NUL1/c141,s ot h a t\nxDPk/NUL1\niD0A\u0152i/c141/SOH2i. Initially, xD0, and thus A\u0152i/c141D0foriD0; 1; : : : ; k/NUL1.T o\nadd1(modulo 2k) to the value in the counter, we use the following procedure.\nINCREMENT .A/\n1iD0\n2while i<A : length andA\u0152i/c141 ==1\n3 A\u0152i/c141D0\n4 iDiC1\n5ifi<A : length\n6 A\u0152i/c141D1\nFigure 17.2 shows what happens to a binary counter as we increment it 16times,\nstarting with the initial value 0and ending with the value 16. At the start of\neach iteration of the while loop in lines 2\u20134, we wish to add a 1into position i.\nIfA\u0152i/c141D1, then adding 1\ufb02ips the bit to 0in position iand yields a carry of 1,\nto be added into position iC1on the next iteration of the loop. Otherwise, the\nloop ends, and then, if i<k , we know that A\u0152i/c141D0, so that line 6 adds a 1into\nposition i, \ufb02ipping the 0to a1. The cost of each I NCREMENT operation is linear\nin the number of bits \ufb02ipped.\nAs with the stack example, a cursory analysis yields a bound that is correct but\nnot tight. A single execution of I NCREMENT takes time \u201a.k/ in the worst case, in\nwhich array Acontains all 1s. Thus, a sequence of nINCREMENT operations on\nan initially zero counter takes time O.nk/ in the worst case.\nWe can tighten our analysis to yield a worst-case cost of O.n/ for a sequence of n\nINCREMENT operations by observing that not all bits \ufb02ip each time I NCREMENT\nis called. As Figure 17.2 shows, A\u01520/c141 does \ufb02ip each time I NCREMENT is called.\nThe next bit up, A\u01521/c141, \ufb02ips only every other time: a sequence of nINCREMENT", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "475": {"page_number": 476, "page_information": "17.1 Aggregate analysis 455\n00000000 0\n00000001 1\n00000010 2\n00000011 3\n00000100 4\n00000101 5\n00000110 6\n00000111 7\n00001000 8\n00001001 9\n00001010 10\n00001011 11\n00001100 12\n00001101 13\n00001110 14\n00001111 15\n00010000 16A[0]A[1]A[2]A[3]A[4]A[5]A[6]A[7]Counter\nvalueTotal\ncost\n1\n3\n478\n10\n111516\n18\n192223\n25\n26310\nFigure 17.2 An8-bit binary counter as its value goes from 0to16by a sequence of 16INCREMENT\noperations. Bits that \ufb02ip to achieve the next value are shaded. The running cost for \ufb02ipping bits is\nshown at the right. Notice that the total cost is always less than twice the total number of I NCREMENT\noperations.\noperations on an initially zero counter causes A\u01521/c141 to \ufb02ipbn=2ctimes. Similarly,\nbitA\u01522/c141 \ufb02ips only every fourth time, or bn=4ctimes in a sequence of nINCREMENT\noperations. In general, for iD0; 1; : : : ; k/NUL1,b i tA\u0152i/c141 \ufb02ipsbn=2ictimes in a\nsequence of nINCREMENT operations on an initially zero counter. For i/NAKk,\nbitA\u0152i/c141 does not exist, and so it cannot \ufb02ip. The total number of \ufb02ips in the\nsequence is thus\nk/NUL1X\niD0jn\n2ik\n<n1X\niD01\n2i\nD2n ;\nby equation (A.6). The worst-case time for a sequence of nINCREMENT operations\non an initially zero counter is therefore O.n/ . The average cost of each operation,\nand therefore the amortized cost per operation, is O.n/=nDO.1/ .", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "476": {"page_number": 477, "page_information": "456 Chapter 17 Amortized Analysis\nExercises\n17.1-1\nIf the set of stack operations included a M ULTIPUSH operation, which pushes k\nitems onto the stack, would the O.1/ bound on the amortized cost of stack opera-\ntions continue to hold?\n17.1-2\nShow that if a D ECREMENT operation were included in the k-bit counter example,\nnoperations could cost as much as \u201a.nk/ time.\n17.1-3\nSuppose we perform a sequence of noperations on a data structure in which the ith\noperation costs iifiis an exact power of 2,a n d 1otherwise. Use aggregate analysis\nto determine the amortized cost per operation.\n17.2 The accounting method\nIn the accounting method of amortized analysis, we assign differing charges to\ndifferent operations, with some operations charged more or less than they actu-ally cost. We call the amount we charge an operation its amortized cost .W h e n\nan operation\u2019s amortized cost exceeds its actual cost, we assign the difference tospeci\ufb01c objects in the data structure as credit . Credit can help pay for later oper-\nations whose amortized cost is less than their actual cost. Thus, we can view theamortized cost of an operation as being split between its actual cost and credit thatis either deposited or used up. Different operations may have different amortizedcosts. This method differs from aggregate analysis, in which all operations havethe same amortized cost.\nWe must choose the amortized costs of operations carefully. If we want to show\nthat in the worst case the average cost per operation is small by analyzing with\namortized costs, we must ensure that the total amortized cost of a sequence of oper-ations provides an upper bound on the total actual cost of the sequence. Moreover,as in aggregate analysis, this relationship must hold for all sequences of opera-tions. If we denote the actual cost of the ith operation by c\niand the amortized cost\nof the ith operation byyci, we require\nnX\niD1yci/NAKnX\niD1ci (17.1)\nfor all sequences of noperations. The total credit stored in the data structure\nis the difference between the total amortized cost and the total actual cost, or", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "477": {"page_number": 478, "page_information": "17.2 The accounting method 457\nPn\niD1yci/NULPn\niD1ci. By inequality (17.1), the total credit associated with the data\nstructure must be nonnegative at all times. If we ever were to allow the total creditto become negative (the result of undercharging early operations with the promiseof repaying the account later on), then the total amortized costs incurred at thattime would be below the total actual costs incurred; for the sequence of operationsup to that time, the total amortized cost would not be an upper bound on the totalactual cost. Thus, we must take care that the total credit in the data structure neverbecomes negative.\nStack operations\nTo illustrate the accounting method of amortized analysis, let us return to the stack\nexample. Recall that the actual costs of the operations were\nP\nUSH 1,\nPOP 1,\nMULTIPOP min.k; s/ ,\nwhere kis the argument supplied to M ULTIPOP andsis the stack size when it is\ncalled. Let us assign the following amortized costs:\nPUSH 2,\nPOP 0,\nMULTIPOP 0.\nNote that the amortized cost of M ULTIPOP is a constant ( 0), whereas the actual cost\nis variable. Here, all three amortized costs are constant. In general, the amortizedcosts of the operations under consideration may differ from each other, and theymay even differ asymptotically.\nWe shall now show that we can pay for any sequence of stack operations by\ncharging the amortized costs. Suppose we use a dollar bill to represent each unitof cost. We start with an empty stack. Recall the analogy of Section 10.1 betweenthe stack data structure and a stack of plates in a cafeteria. When we push a plate\non the stack, we use 1dollar to pay the actual cost of the push and are left with a\ncredit of 1dollar (out of the 2dollars charged), which we leave on top of the plate.\nAt any point in time, every plate on the stack has a dollar of credit on it.\nThe dollar stored on the plate serves as prepayment for the cost of popping it\nfrom the stack. When we execute a P\nOPoperation, we charge the operation nothing\nand pay its actual cost using the credit stored in the stack. To pop a plate, we takethe dollar of credit off the plate and use it to pay the actual cost of the operation.Thus, by charging the P\nUSH operation a little bit more, we can charge the P OP\noperation nothing.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "478": {"page_number": 479, "page_information": "458 Chapter 17 Amortized Analysis\nMoreover, we can also charge M ULTIPOP operations nothing. To pop the \ufb01rst\nplate, we take the dollar of credit off the plate and use it to pay the actual cost of a\nPOPoperation. To pop a second plate, we again have a dollar of credit on the plate\nto pay for the P OPoperation, and so on. Thus, we have always charged enough\nup front to pay for M ULTIPOP operations. In other words, since each plate on the\nstack has 1dollar of credit on it, and the stack always has a nonnegative number of\nplates, we have ensured that the amount of credit is always nonnegative. Thus, foranysequence of nP\nUSH,POP,a n dM ULTIPOP operations, the total amortized cost\nis an upper bound on the total actual cost. Since the total amortized cost is O.n/ ,\nso is the total actual cost.\nIncrementing a binary counter\nAs another illustration of the accounting method, we analyze the I NCREMENT op-\neration on a binary counter that starts at zero. As we observed earlier, the runningtime of this operation is proportional to the number of bits \ufb02ipped, which we shalluse as our cost for this example. Let us once again use a dollar bill to representeach unit of cost (the \ufb02ipping of a bit in this example).\nFor the amortized analysis, let us charge an amortized cost of 2dollars to set a\nbit to 1. When a bit is set, we use 1dollar (out of the 2dollars charged) to pay\nfor the actual setting of the bit, and we place the other dollar on the bit as credit to\nbe used later when we \ufb02ip the bit back to 0. At any point in time, every 1in the\ncounter has a dollar of credit on it, and thus we can charge nothing to reset a bitto0; we just pay for the reset with the dollar bill on the bit.\nNow we can determine the amortized cost of I\nNCREMENT . The cost of resetting\nthe bits within the while loop is paid for by the dollars on the bits that are reset. The\nINCREMENT procedure sets at most one bit, in line 6, and therefore the amortized\ncost of an I NCREMENT operation is at most 2dollars. The number of 1si nt h e\ncounter never becomes negative, and thus the amount of credit stays nonnegativeat all times. Thus, for nI\nNCREMENT operations, the total amortized cost is O.n/ ,\nwhich bounds the total actual cost.\nExercises\n17.2-1\nSuppose we perform a sequence of stack operations on a stack whose size neverexceeds k. After every koperations, we make a copy of the entire stack for backup\npurposes. Show that the cost of nstack operations, including copying the stack,\nisO.n/ by assigning suitable amortized costs to the various stack operations.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "479": {"page_number": 480, "page_information": "17.3 The potential method 459\n17.2-2\nRedo Exercise 17.1-3 using an accounting method of analysis.\n17.2-3\nSuppose we wish not only to increment a counter but also to reset it to zero (i.e.,make all bits in it 0). Counting the time to examine or modify a bit as \u201a.1/ ,\nshow how to implement a counter as an array of bits so that any sequence of n\nI\nNCREMENT and R ESET operations takes time O.n/ on an initially zero counter.\n(Hint: Keep a pointer to the high-order 1.)\n17.3 The potential method\nInstead of representing prepaid work as credit stored with speci\ufb01c objects in the\ndata structure, the potential method of amortized analysis represents the prepaid\nwork as \u201cpotential energy,\u201d or just \u201cpotential,\u201d which can be released to pay forfuture operations. We associate the potential with the data structure as a wholerather than with speci\ufb01c objects within the data structure.\nThe potential method works as follows. We will perform noperations, starting\nwith an initial data structure D\n0. For each iD1 ;2;:::;n ,w el e t cibe the actual\ncost of the ith operation and Dibe the data structure that results after applying\ntheith operation to data structure Di/NUL1.Apotential function \u02c6maps each data\nstructure Dito a real number \u02c6.D i/, which is the potential associated with data\nstructure Di.T h e amortized costyciof the ith operation with respect to potential\nfunction \u02c6is de\ufb01ned by\nyciDciC\u02c6.D i//NUL\u02c6.D i/NUL1/: (17.2)\nThe amortized cost of each operation is therefore its actual cost plus the change in\npotential due to the operation. By equation (17.2), the total amortized cost of the n\noperations is\nnX\niD1yciDnX\niD1.ciC\u02c6.D i//NUL\u02c6.D i/NUL1//\nDnX\niD1ciC\u02c6.D n//NUL\u02c6.D 0/: (17.3)\nThe second equality follows from equation (A.9) because the \u02c6.D i/terms tele-\nscope.\nIf we can de\ufb01ne a potential function \u02c6so that \u02c6.D n//NAK\u02c6.D 0/, then the total\namortized costPn\niD1ycigives an upper bound on the total actual costPn\niD1ci.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "480": {"page_number": 481, "page_information": "460 Chapter 17 Amortized Analysis\nIn practice, we do not always know how many operations might be performed.\nTherefore, if we require that \u02c6.D i//NAK\u02c6.D 0/for all i, then we guarantee, as in\nthe accounting method, that we pay in advance. We usually just de\ufb01ne \u02c6.D 0/to\nbe0and then show that \u02c6.D i//NAK0for all i. (See Exercise 17.3-1 for an easy way\nto handle cases in which \u02c6.D 0/\u00a40.)\nIntuitively, if the potential difference \u02c6.D i//NUL\u02c6.D i/NUL1/of the ith operation is\npositive, then the amortized cost ycirepresents an overcharge to the ith operation,\nand the potential of the data structure increases. If the potential difference is neg-\native, then the amortized cost represents an undercharge to the ith operation, and\nthe decrease in the potential pays for the actual cost of the operation.\nThe amortized costs de\ufb01ned by equations (17.2) and (17.3) depend on the choice\nof the potential function \u02c6. Different potential functions may yield different amor-\ntized costs yet still be upper bounds on the actual costs. We often \ufb01nd trade-offsthat we can make in choosing a potential function; the best potential function touse depends on the desired time bounds.\nStack operations\nTo illustrate the potential method, we return once again to the example of the stack\noperations P\nUSH,POP,a n dM ULTIPOP . We de\ufb01ne the potential function \u02c6on a\nstack to be the number of objects in the stack. For the empty stack D0with which\nwe start, we have \u02c6.D 0/D0. Since the number of objects in the stack is never\nnegative, the stack Dithat results after the ith operation has nonnegative potential,\nand thus\n\u02c6.D i//NAK0\nD\u02c6.D 0/:\nThe total amortized cost of noperations with respect to \u02c6therefore represents an\nupper bound on the actual cost.\nLet us now compute the amortized costs of the various stack operations. If the ith\noperation on a stack containing sobjects is a P USH operation, then the potential\ndifference is\n\u02c6.D i//NUL\u02c6.D i/NUL1/D.sC1//NULs\nD1:\nBy equation (17.2), the amortized cost of this P USH operation is\nyciDciC\u02c6.D i//NUL\u02c6.D i/NUL1/\nD1C1\nD2:", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "481": {"page_number": 482, "page_information": "17.3 The potential method 461\nSuppose that the ith operation on the stack is M ULTIPOP .S; k/ , which causes\nk0Dmin.k; s/ objects to be popped off the stack. The actual cost of the opera-\ntion is k0, and the potential difference is\n\u02c6.D i//NUL\u02c6.D i/NUL1/D/NULk0:\nThus, the amortized cost of the M ULTIPOP operation is\nyciDciC\u02c6.D i//NUL\u02c6.D i/NUL1/\nDk0/NULk0\nD0:\nSimilarly, the amortized cost of an ordinary P OPoperation is 0.\nThe amortized cost of each of the three operations is O.1/ , and thus the total\namortized cost of a sequence of noperations is O.n/ . Since we have already argued\nthat\u02c6.D i//NAK\u02c6.D 0/, the total amortized cost of noperations is an upper bound\non the total actual cost. The worst-case cost of noperations is therefore O.n/ .\nIncrementing a binary counter\nAs another example of the potential method, we again look at incrementing a binary\ncounter. This time, we de\ufb01ne the potential of the counter after the ith INCREMENT\noperation to be bi, the number of 1s in the counter after the ith operation.\nLet us compute the amortized cost of an I NCREMENT operation. Suppose that\ntheith I NCREMENT operation resets tibits. The actual cost of the operation is\ntherefore at most tiC1, since in addition to resetting tibits, it sets at most one\nbit to 1.I fbiD0, then the ith operation resets all kbits, and so bi/NUL1DtiDk.\nIfbi>0,t h e n biDbi/NUL1/NULtiC1. In either case, bi/DC4bi/NUL1/NULtiC1,a n dt h e\npotential difference is\n\u02c6.D i//NUL\u02c6.D i/NUL1//DC4.bi/NUL1/NULtiC1//NULbi/NUL1\nD1/NULti:\nThe amortized cost is therefore\nyciDciC\u02c6.D i//NUL\u02c6.D i/NUL1/\n/DC4.tiC1/C.1/NULti/\nD2:\nIf the counter starts at zero, then \u02c6.D 0/D0.S i n c e \u02c6.D i//NAK0for all i, the total\namortized cost of a sequence of nINCREMENT operations is an upper bound on the\ntotal actual cost, and so the worst-case cost of nINCREMENT operations is O.n/ .\nThe potential method gives us an easy way to analyze the counter even when\nit does not start at zero. The counter starts with b01s, and after nINCREMENT", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "482": {"page_number": 483, "page_information": "462 Chapter 17 Amortized Analysis\noperations it has bn1s, where 0/DC4b0;bn/DC4k. (Recall that kis the number of bits\nin the counter.) We can rewrite equation (17.3) as\nnX\niD1ciDnX\niD1yci/NUL\u02c6.D n/C\u02c6.D 0/: (17.4)\nWe haveyci/DC42for all 1/DC4i/DC4n.S i n c e \u02c6.D 0/Db0and\u02c6.D n/Dbn, the total\nactual cost of nINCREMENT operations is\nnX\niD1ci/DC4nX\niD12/NULbnCb0\nD2n/NULbnCb0:\nNote in particular that since b0/DC4k, as long as kDO.n/ , the total actual cost\nisO.n/ . In other words, if we execute at least nD/DEL.k/ INCREMENT operations,\nthe total actual cost is O.n/ , no matter what initial value the counter contains.\nExercises\n17.3-1\nSuppose we have a potential function \u02c6such that \u02c6.D i//NAK\u02c6.D 0/for all i,b u t\n\u02c6.D 0/\u00a40. Show that there exists a potential function \u02c60such that \u02c60.D0/D0,\n\u02c60.Di//NAK0for all i/NAK1, and the amortized costs using \u02c60are the same as the\namortized costs using \u02c6.\n17.3-2\nRedo Exercise 17.1-3 using a potential method of analysis.\n17.3-3\nConsider an ordinary binary min-heap data structure with nelements supporting\nthe instructions I NSERT and E XTRACT -MINinO.lgn/worst-case time. Give a\npotential function \u02c6such that the amortized cost of I NSERT isO.lgn/and the\namortized cost of E XTRACT -MINisO.1/ , and show that it works.\n17.3-4\nWhat is the total cost of executing nof the stack operations P USH,POP,a n d\nMULTIPOP , assuming that the stack begins with s0objects and \ufb01nishes with sn\nobjects?\n17.3-5\nSuppose that a counter begins at a number with b1s in its binary representa-\ntion, rather than at 0. Show that the cost of performing nINCREMENT operations\nisO.n/ifnD/DEL.b/.(Do not assume that bis constant. )", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "483": {"page_number": 484, "page_information": "17.4 Dynamic tables 463\n17.3-6\nShow how to implement a queue with two ordinary stacks (Exercise 10.1-6) so thatthe amortized cost of each E\nNQUEUE and each D EQUEUE operation is O.1/ .\n17.3-7\nDesign a data structure to support the following two operations for a dynamicmultiset Sof integers, which allows duplicate values:\nI\nNSERT .S; x/ inserts xintoS.\nDELETE -LARGER -HALF.S/deletes the largestdjSj=2eelements from S.\nExplain how to implement this data structure so that any sequence of mINSERT\nand D ELETE -LARGER -HALF operations runs in O.m/ time. Your implementation\nshould also include a way to output the elements of SinO.jSj/time.\n17.4 Dynamic tables\nWe do not always know in advance how many objects some applications will store\nin a table. We might allocate space for a table, only to \ufb01nd out later that it is notenough. We must then reallocate the table with a larger size and copy all objectsstored in the original table over into the new, larger table. Similarly, if many objectshave been deleted from the table, it may be worthwhile to reallocate the table witha smaller size. In this section, we study this problem of dynamically expanding andcontracting a table. Using amortized analysis, we shall show that the amortized costof insertion and deletion is only O.1/ , even though the actual cost of an operation\nis large when it triggers an expansion or a contraction. Moreover, we shall see how\nto guarantee that the unused space in a dynamic table never exceeds a constant\nfraction of the total space.\nWe assume that the dynamic table supports the operations T\nABLE -INSERT and\nTABLE -DELETE .TABLE -INSERT inserts into the table an item that occupies a sin-\ngleslot, that is, a space for one item. Likewise, T ABLE -DELETE removes an item\nfrom the table, thereby freeing a slot. The details of the data-structuring method\nused to organize the table are unimportant; we might use a stack (Section 10.1),a heap (Chapter 6), or a hash table (Chapter 11). We might also use an array orcollection of arrays to implement object storage, as we did in Section 10.3.\nWe shall \ufb01nd it convenient to use a concept introduced in our analysis of hashing\n(Chapter 11). We de\ufb01ne the load factor \u02db.T/ of a nonempty table Tto be the\nnumber of items stored in the table divided by the size (number of slots) of thetable. We assign an empty table (one with no items) size 0, and we de\ufb01ne its load\nfactor to be 1. If the load factor of a dynamic table is bounded below by a constant,", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "484": {"page_number": 485, "page_information": "464 Chapter 17 Amortized Analysis\nthe unused space in the table is never more than a constant fraction of the total\namount of space.\nWe start by analyzing a dynamic table in which we only insert items. We then\nconsider the more general case in which we both insert and delete items.\n17.4.1 Table expansion\nLet us assume that storage for a table is allocated as an array of slots. A table \ufb01lls\nup when all slots have been used or, equivalently, when its load factor is 1.1In some\nsoftware environments, upon attempting to insert an item into a full table, the onlyalternative is to abort with an error. We shall assume, however, that our softwareenvironment, like many modern ones, provides a memory-management system thatcan allocate and free blocks of storage on request. Thus, upon inserting an item\ninto a full table, we can expand the table by allocating a new table with more slots\nthan the old table had. Because we always need the table to reside in contiguousmemory, we must allocate a new array for the larger table and then copy items fromthe old table into the new table.\nA common heuristic allocates a new table with twice as many slots as the old\none. If the only table operations are insertions, then the load factor of the table is\nalways at least 1=2, and thus the amount of wasted space never exceeds half the\ntotal space in the table.\nIn the following pseudocode, we assume that Tis an object representing the\ntable. The attribute T:table contains a pointer to the block of storage representing\nthe table, T:num contains the number of items in the table, and T:sizegives the total\nnumber of slots in the table. Initially, the table is empty: T:numDT:sizeD0.\nT\nABLE -INSERT .T; x/\n1ifT:size ==0\n2 allocate T:table with1slot\n3 T:sizeD1\n4ifT:num ==T:size\n5 allocate new-table with2/SOHT:sizeslots\n6 insert all items in T:table intonew-table\n7 free T:table\n8 T:tableDnew-table\n9 T:sizeD2/SOHT:size\n10 insert xintoT:table\n11T:numDT:numC1\n1In some situations, such as an open-address hash table, we may wish to consider a table to be full if\nits load factor equals some constant strictly less than 1.( S e eE x e r c i s e1 7 . 4 - 1 . )", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "485": {"page_number": 486, "page_information": "17.4 Dynamic tables 465\nNotice that we have two \u201cinsertion\u201d procedures here: the T ABLE -INSERT proce-\ndure itself and the elementary insertion into a table in lines 6 and 10. We can\nanalyze the running time of T ABLE -INSERT in terms of the number of elementary\ninsertions by assigning a cost of 1to each elementary insertion. We assume that\nthe actual running time of T ABLE -INSERT is linear in the time to insert individual\nitems, so that the overhead for allocating an initial table in line 2 is constant andthe overhead for allocating and freeing storage in lines 5 and 7 is dominated bythe cost of transferring items in line 6. We call the event in which lines 5\u20139 are\nexecuted an expansion .\nLet us analyze a sequence of nT\nABLE -INSERT operations on an initially empty\ntable. What is the cost ciof the ith operation? If the current table has room for the\nnew item (or if this is the \ufb01rst operation), then ciD1, since we need only perform\nthe one elementary insertion in line 10. If the current table is full, however, and anexpansion occurs, then c\niDi: the cost is 1for the elementary insertion in line 10\nplusi/NUL1for the items that we must copy from the old table to the new table in\nline 6. If we perform noperations, the worst-case cost of an operation is O.n/ ,\nwhich leads to an upper bound of O.n2/on the total running time for noperations.\nThis bound is not tight, because we rarely expand the table in the course of n\nTABLE -INSERT operations. Speci\ufb01cally, the ith operation causes an expansion\nonly when i/NUL1is an exact power of 2. The amortized cost of an operation is in\nfactO.1/ , as we can show using aggregate analysis. The cost of the ith operation\nis\nciD(\niifi/NUL1is an exact power of 2;\n1otherwise :\nThe total cost of nTABLE -INSERT operations is therefore\nnX\niD1ci/DC4nCblgncX\njD02j\n<nC2n\nD3n ;\nbecause at most noperations cost 1and the costs of the remaining operations form\na geometric series. Since the total cost of nTABLE -INSERT operations is bounded\nby3n, the amortized cost of a single operation is at most 3.\nBy using the accounting method, we can gain some feeling for why the amor-\ntized cost of a T ABLE -INSERT operation should be 3. Intuitively, each item pays\nfor3elementary insertions: inserting itself into the current table, moving itself\nwhen the table expands, and moving another item that has already been movedonce when the table expands. For example, suppose that the size of the table is m\nimmediately after an expansion. Then the table holds m=2 items, and it contains", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "486": {"page_number": 487, "page_information": "466 Chapter 17 Amortized Analysis\nno credit. We charge 3dollars for each insertion. The elementary insertion that\noccurs immediately costs 1dollar. We place another dollar as credit on the item\ninserted. We place the third dollar as credit on one of the m=2 items already in the\ntable. The table will not \ufb01ll again until we have inserted another m=2/NUL1items,\nand thus, by the time the table contains mitems and is full, we will have placed a\ndollar on each item to pay to reinsert it during the expansion.\nWe can use the potential method to analyze a sequence of nTABLE -INSERT\noperations, and we shall use it in Section 17.4.2 to design a T ABLE -DELETE op-\neration that has an O.1/ amortized cost as well. We start by de\ufb01ning a potential\nfunction \u02c6that is 0immediately after an expansion but builds to the table size by\nthe time the table is full, so that we can pay for the next expansion by the potential.The function\n\u02c6.T /D2/SOHT:num/NULT:size (17.5)\nis one possibility. Immediately after an expansion, we have T:numDT:size=2,\nand thus \u02c6.T /D0, as desired. Immediately before an expansion, we have\nT:numDT:size, and thus \u02c6.T /DT:num, as desired. The initial value of the\npotential is 0, and since the table is always at least half full, T:num/NAKT:size=2,\nwhich implies that \u02c6.T / is always nonnegative. Thus, the sum of the amortized\ncosts of nT\nABLE -INSERT operations gives an upper bound on the sum of the actual\ncosts.\nTo analyze the amortized cost of the ith T ABLE -INSERT operation, we let num i\ndenote the number of items stored in the table after the ith operation, size idenote\nthe total size of the table after the ith operation, and \u02c6idenote the potential after\ntheith operation. Initially, we have num 0D0,size 0D0,a n d \u02c60D0.\nIf the ith T ABLE -INSERT operation does not trigger an expansion, then we have\nsize iDsize i/NUL1and the amortized cost of the operation is\nyciDciC\u02c6i/NUL\u02c6i/NUL1\nD1C.2/SOHnum i/NULsize i//NUL.2/SOHnum i/NUL1/NULsize i/NUL1/\nD1C.2/SOHnum i/NULsize i//NUL.2.num i/NUL1//NULsize i/\nD3:\nIf the ith operation does trigger an expansion, then we have size iD2/SOHsize i/NUL1and\nsize i/NUL1Dnum i/NUL1Dnum i/NUL1, which implies that size iD2/SOH.num i/NUL1/. Thus,\nthe amortized cost of the operation is\nyciDciC\u02c6i/NUL\u02c6i/NUL1\nDnum iC.2/SOHnum i/NULsize i//NUL.2/SOHnum i/NUL1/NULsize i/NUL1/\nDnum iC.2/SOHnum i/NUL2/SOH.num i/NUL1///NUL.2.num i/NUL1//NUL.num i/NUL1//\nDnum iC2/NUL.num i/NUL1/\nD3:", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "487": {"page_number": 488, "page_information": "17.4 Dynamic tables 467\n\u03a6inumi sizei\n0 8 16 24 3208162432\niFigure 17.3 The effect of a sequence of nTABLE -INSERT operations on the number num iof items\nin the table, the number sizeiof slots in the table, and the potential \u02c6iD2/SOHnum i/NULsizei, each\nbeing measured after the ith operation. The thin line shows num i, the dashed line shows sizei,a n d\nthe thick line shows \u02c6i. Notice that immediately before an expansion, the potential has built up to\nthe number of items in the table, and therefore it can pay for moving all the items to the new table.\nAfterwards, the potential drops to 0, but it is immediately increased by 2upon inserting the item that\ncaused the expansion.\nFigure 17.3 plots the values of num i,size i,a n d \u02c6iagainst i. Notice how the\npotential builds to pay for expanding the table.\n17.4.2 Table expansion and contraction\nTo implement a T ABLE -DELETE operation, it is simple enough to remove the spec-\ni\ufb01ed item from the table. In order to limit the amount of wasted space, however,\nwe might wish to contract the table when the load factor becomes too small. Table\ncontraction is analogous to table expansion: when the number of items in the tabledrops too low, we allocate a new, smaller table and then copy the items from theold table into the new one. We can then free the storage for the old table by return-ing it to the memory-management system. Ideally, we would like to preserve twoproperties:\n/SIthe load factor of the dynamic table is bounded below by a positive constant,and\n/SIthe amortized cost of a table operation is bounded above by a constant.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "488": {"page_number": 489, "page_information": "468 Chapter 17 Amortized Analysis\nWe assume that we measure the cost in terms of elementary insertions and dele-\ntions.\nYou might think that we should double the table size upon inserting an item into\na full table and halve the size when a deleting an item would cause the table tobecome less than half full. This strategy would guarantee that the load factor ofthe table never drops below 1=2, but unfortunately, it can cause the amortized cost\nof an operation to be quite large. Consider the following scenario. We perform n\noperations on a table T,w h e r e nis an exact power of 2.T h e\ufb01 r s t n=2operations are\ninsertions, which by our previous analysis cost a total of \u201a.n/ . At the end of this\nsequence of insertions, T:numDT:sizeDn=2. For the second n=2 operations,\nwe perform the following sequence:\ni n s e r t ,d e l e t e ,d e l e t e ,i n s e r t ,i n s e r t ,d e l e t e ,d e l e t e ,i n s e r t ,i n s e r t ,....\nThe \ufb01rst insertion causes the table to expand to size n. The two following deletions\ncause the table to contract back to size n=2. Two further insertions cause another\nexpansion, and so forth. The cost of each expansion and contraction is \u201a.n/ ,a n d\nthere are \u201a.n/ of them. Thus, the total cost of the noperations is \u201a.n\n2/,m a k i n g\nthe amortized cost of an operation \u201a.n/ .\nThe downside of this strategy is obvious: after expanding the table, we do not\ndelete enough items to pay for a contraction. Likewise, after contracting the table,we do not insert enough items to pay for an expansion.\nWe can improve upon this strategy by allowing the load factor of the table to\ndrop below 1=2. Speci\ufb01cally, we continue to double the table size upon inserting\nan item into a full table, but we halve the table size when deleting an item causesthe table to become less than 1=4full, rather than 1=2full as before. The load\nfactor of the table is therefore bounded below by the constant 1=4.\nIntuitively, we would consider a load factor of 1=2to be ideal, and the table\u2019s\npotential would then be 0. As the load factor deviates from 1=2, the potential\nincreases so that by the time we expand or contract the table, the table has garneredsuf\ufb01cient potential to pay for copying all the items into the newly allocated table.Thus, we will need a potential function that has grown to T:num by the time that\nthe load factor has either increased to 1or decreased to 1=4. After either expanding\nor contracting the table, the load factor goes back to 1=2and the table\u2019s potential\nreduces back to 0.\nWe omit the code for T\nABLE -DELETE , since it is analogous to T ABLE -INSERT .\nFor our analysis, we shall assume that whenever the number of items in the tabledrops to 0, we free the storage for the table. That is, if T:numD0,t h e n T:sizeD0.\nWe can now use the potential method to analyze the cost of a sequence of n\nT\nABLE -INSERT and T ABLE -DELETE operations. We start by de\ufb01ning a poten-\ntial function \u02c6that is 0immediately after an expansion or contraction and builds\nas the load factor increases to 1or decreases to 1=4. Let us denote the load fac-", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "489": {"page_number": 490, "page_information": "17.4 Dynamic tables 469\nnumi\n\u03a6isizei\n0 8 16 24 32 40 4808162432\niFigure 17.4 The effect of a sequence of nTABLE -INSERT and T ABLE -DELETE operations on the\nnumber num iof items in the table, the number sizeiof slots in the table, and the potential\n\u02c6iD/SUB\n2/SOHnum i/NULsizeiif\u02dbi/NAK1=2 ;\nsizei=2/NULnum iif\u02dbi<1 = 2;\neach measured after the ith operation. The thin line shows num i, the dashed line shows sizei,a n d\nthe thick line shows \u02c6i. Notice that immediately before an expansion, the potential has built up to\nthe number of items in the table, and therefore it can pay for moving all the items to the new table.\nLikewise, immediately before a contraction, the potential has built up to the number of items in the\ntable.\ntor of a nonempty table Tby\u02db.T/DT:num=T:size. Since for an empty table,\nT:numDT:sizeD0and\u02db.T/D1,w ea l w a y sh a v e T:numD\u02db.T//SOHT:size,\nwhether the table is empty or not. We shall use as our potential function\n\u02c6.T /D(\n2/SOHT:num/NULT:size if\u02db.T//NAK1=2 ;\nT:size=2/NULT:num if\u02db.T/ < 1=2 :(17.6)\nObserve that the potential of an empty table is 0and that the potential is never\nnegative. Thus, the total amortized cost of a sequence of operations with respectto\u02c6provides an upper bound on the actual cost of the sequence.\nBefore proceeding with a precise analysis, we pause to observe some properties\nof the potential function, as illustrated in Figure 17.4. Notice that when the loadfactor is 1=2, the potential is 0. When the load factor is 1,w eh a v e T:sizeDT:num,\nwhich implies \u02c6.T /DT:num, and thus the potential can pay for an expansion if\nan item is inserted. When the load factor is 1=4,w eh a v e T:sizeD4/SOHT:num,w h i c h", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "490": {"page_number": 491, "page_information": "470 Chapter 17 Amortized Analysis\nimplies \u02c6.T /DT:num, and thus the potential can pay for a contraction if an item\nis deleted.\nTo analyze a sequence of nTABLE -INSERT and T ABLE -DELETE operations,\nwe let cidenote the actual cost of the ith operation,ycidenote its amortized cost\nwith respect to \u02c6,num idenote the number of items stored in the table after the ith\noperation, size idenote the total size of the table after the ith operation, \u02dbidenote\nthe load factor of the table after the ith operation, and \u02c6idenote the potential after\ntheith operation. Initially, num 0D0,size 0D0,\u02db0D1,a n d \u02c60D0.\nWe start with the case in which the ith operation is T ABLE -INSERT . The analy-\nsis is identical to that for table expansion in Section 17.4.1 if \u02dbi/NUL1/NAK1=2.W h e t h e r\nthe table expands or not, the amortized cost yciof the operation is at most 3.\nIf\u02dbi/NUL1<1 = 2 , the table cannot expand as a result of the operation, since the ta-\nble expands only when \u02dbi/NUL1D1.I f\u02dbi<1 = 2 as well, then the amortized cost of\ntheith operation is\nyciDciC\u02c6i/NUL\u02c6i/NUL1\nD1C.size i=2/NULnum i//NUL.size i/NUL1=2/NULnum i/NUL1/\nD1C.size i=2/NULnum i//NUL.size i=2/NUL.num i/NUL1//\nD0:\nIf\u02dbi/NUL1<1 = 2 but\u02dbi/NAK1=2,t h e n\nyciDciC\u02c6i/NUL\u02c6i/NUL1\nD1C.2/SOHnum i/NULsize i//NUL.size i/NUL1=2/NULnum i/NUL1/\nD1C.2.num i/NUL1C1//NULsize i/NUL1//NUL.size i/NUL1=2/NULnum i/NUL1/\nD3/SOHnum i/NUL1/NUL3\n2size i/NUL1C3\nD3\u02dbi/NUL1size i/NUL1/NUL3\n2size i/NUL1C3\n<3\n2size i/NUL1/NUL3\n2size i/NUL1C3\nD3:\nThus, the amortized cost of a T ABLE -INSERT operation is at most 3.\nWe now turn to the case in which the ith operation is T ABLE -DELETE .I n t h i s\ncase, num iDnum i/NUL1/NUL1.I f\u02dbi/NUL1<1 = 2 , then we must consider whether the\noperation causes the table to contract. If it does not, then size iDsize i/NUL1and the\namortized cost of the operation is\nyciDciC\u02c6i/NUL\u02c6i/NUL1\nD1C.size i=2/NULnum i//NUL.size i/NUL1=2/NULnum i/NUL1/\nD1C.size i=2/NULnum i//NUL.size i=2/NUL.num iC1//\nD2:", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "491": {"page_number": 492, "page_information": "17.4 Dynamic tables 471\nIf\u02dbi/NUL1<1 = 2 and the ith operation does trigger a contraction, then the actual cost\nof the operation is ciDnum iC1, since we delete one item and move num iitems.\nWe have size i=2Dsize i/NUL1=4Dnum i/NUL1Dnum iC1, and the amortized cost of\nthe operation is\nyciDciC\u02c6i/NUL\u02c6i/NUL1\nD.num iC1/C.size i=2/NULnum i//NUL.size i/NUL1=2/NULnum i/NUL1/\nD.num iC1/C..num iC1//NULnum i//NUL..2/SOHnum iC2//NUL.num iC1//\nD1:\nWhen the ith operation is a T ABLE -DELETE and\u02dbi/NUL1/NAK1=2, the amortized cost\nis also bounded above by a constant. We leave the analysis as Exercise 17.4-2.\nIn summary, since the amortized cost of each operation is bounded above by\na constant, the actual time for any sequence of noperations on a dynamic table\nisO.n/ .\nExercises\n17.4-1\nSuppose that we wish to implement a dynamic, open-address hash table. Why\nmight we consider the table to be full when its load factor reaches some value \u02db\nthat is strictly less than 1? Describe brie\ufb02y how to make insertion into a dynamic,\nopen-address hash table run in such a way that the expected value of the amortizedcost per insertion is O.1/ . Why is the expected value of the actual cost per insertion\nnot necessarily O.1/ for all insertions?\n17.4-2\nShow that if \u02db\ni/NUL1/NAK1=2 and the ith operation on a dynamic table is T ABLE -\nDELETE , then the amortized cost of the operation with respect to the potential\nfunction (17.6) is bounded above by a constant.\n17.4-3\nSuppose that instead of contracting a table by halving its size when its load factordrops below 1=4, we contract it by multiplying its size by 2=3when its load factor\ndrops below 1=3. Using the potential function\n\u02c6.T /Dj2/SOHT:num/NULT:sizej;\nshow that the amortized cost of a T\nABLE -DELETE that uses this strategy is bounded\nabove by a constant.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "492": {"page_number": 493, "page_information": "472 Chapter 17 Amortized Analysis\nProblems\n17-1 Bit-reversed binary counter\nChapter 30 examines an important algorithm called the fast Fourier transform,or FFT. The \ufb01rst step of the FFT algorithm performs a bit-reversal permutation on\nan input array A\u01520 : : n/NUL1/c141whose length is nD2\nkfor some nonnegative integer k.\nThis permutation swaps elements whose indices have binary representations that\nare the reverse of each other.\nWe can express each index aas ak-bit sequencehak/NUL1;ak/NUL2;:::;a 0i,w h e r e\naDPk/NUL1\niD0ai2i.W ed e \ufb01 n e\nrevk.hak/NUL1;ak/NUL2;:::;a 0i/Dha0;a1;:::;a k/NUL1iI\nthus,\nrevk.a/Dk/NUL1X\niD0ak/NULi/NUL12i:\nFor example, if nD16(or, equivalently, kD4), then rev k.3/D12,s i n c e\nthe4-bit representation of 3is0011 , which when reversed gives 1100 ,t h e 4-bit\nrepresentation of 12.\na.Given a function rev kthat runs in \u201a.k/ time, write an algorithm to perform the\nbit-reversal permutation on an array of length nD2kinO.nk/ time.\nWe can use an algorithm based on an amortized analysis to improve the running\ntime of the bit-reversal permutation. We maintain a \u201cbit-reversed counter\u201d and aprocedure B\nIT-REVERSED -INCREMENT that, when given a bit-reversed-counter\nvalue a, produces rev k.revk.a/C1/.I fkD4, for example, and the bit-reversed\ncounter starts at 0, then successive calls to B IT-REVERSED -INCREMENT produce\nthe sequence\n0000; 1000; 0100; 1100; 0010; 1010; : : : D0; 8; 4; 12; 2; 10; : : : :\nb.Assume that the words in your computer store k-bit values and that in unit time,\nyour computer can manipulate the binary values with operations such as shiftingleft or right by arbitrary amounts, bitwise-AND, bitwise-OR, etc. Describean implementation of the B\nIT-REVERSED -INCREMENT procedure that allows\nthe bit-reversal permutation on an n-element array to be performed in a total\nofO.n/ time.\nc.Suppose that you can shift a word left or right by only one bit in unit time. Is it\nstill possible to implement an O.n/ -time bit-reversal permutation?", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "493": {"page_number": 494, "page_information": "Problems for Chapter 17 473\n17-2 Making binary search dynamic\nBinary search of a sorted array takes logarithmic search time, but the time to inserta new element is linear in the size of the array. We can improve the time forinsertion by keeping several sorted arrays.\nSpeci\ufb01cally, suppose that we wish to support S\nEARCH and I NSERT on a set\nofnelements. Let kDdlg.nC1/e, and let the binary representation of n\nbehnk/NUL1;nk/NUL2;:::;n 0i.W e h a v e ksorted arrays A0;A1;:::;A k/NUL1, where for\niD0; 1; : : : ; k/NUL1, the length of array Aiis2i. Each array is either full or empty,\ndepending on whether niD1orniD0, respectively. The total number of ele-\nments held in all karrays is thereforePk/NUL1\niD0ni2iDn. Although each individual\narray is sorted, elements in different arrays bear no particular relationship to eachother.\na.Describe how to perform the S\nEARCH operation for this data structure. Analyze\nits worst-case running time.\nb.Describe how to perform the I NSERT operation. Analyze its worst-case and\namortized running times.\nc.Discuss how to implement D ELETE .\n17-3 Amortized weight-balanced trees\nConsider an ordinary binary search tree augmented by adding to each node xthe\nattribute x:sizegiving the number of keys stored in the subtree rooted at x.L e t \u02db\nbe a constant in the range 1=2/DC4\u02db<1 . We say that a given node xis\u02db-balanced\nifx:left:size/DC4\u02db/SOHx:sizeandx:right:size/DC4\u02db/SOHx:size. The tree as a whole\nis\u02db-balanced if every node in the tree is \u02db-balanced. The following amortized\napproach to maintaining weight-balanced trees was suggested by G. Varghese.\na.A1=2-balanced tree is, in a sense, as balanced as it can be. Given a node x\nin an arbitrary binary search tree, show how to rebuild the subtree rooted at x\nso that it becomes 1=2-balanced. Your algorithm should run in time \u201a.x: size/,\nand it can use O.x: size/auxiliary storage.\nb.Show that performing a search in an n-node \u02db-balanced binary search tree\ntakes O.lgn/worst-case time.\nFor the remainder of this problem, assume that the constant \u02dbis strictly greater\nthan1=2. Suppose that we implement I NSERT and D ELETE as usual for an n-node\nbinary search tree, except that after every such operation, if any node in the treeis no longer \u02db-balanced, then we \u201crebuild\u201d the subtree rooted at the highest such\nnode in the tree so that it becomes 1=2-balanced.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "494": {"page_number": 495, "page_information": "474 Chapter 17 Amortized Analysis\nWe shall analyze this rebuilding scheme using the potential method. For a node x\nin a binary search tree T,w ed e \ufb01 n e\n/c129.x/Djx:left:size/NULx:right:sizej;\nand we de\ufb01ne the potential of Tas\n\u02c6.T /DcX\nx2TW/c129.x/ /NAK2/c129.x/ ;\nwhere cis a suf\ufb01ciently large constant that depends on \u02db.\nc.Argue that any binary search tree has nonnegative potential and that a 1=2-\nbalanced tree has potential 0.\nd.Suppose that munits of potential can pay for rebuilding an m-node subtree.\nHow large must cbe in terms of \u02dbin order for it to take O.1/ amortized time\nto rebuild a subtree that is not \u02db-balanced?\ne.Show that inserting a node into or deleting a node from an n-node \u02db-balanced\ntree costs O.lgn/amortized time.\n17-4 The cost of restructuring red-black trees\nThere are four basic operations on red-black trees that perform structural modi-\n\ufb01cations : node insertions, node deletions, rotations, and color changes. We have\nseen that RB-I NSERT and RB-D ELETE use only O.1/ rotations, node insertions,\nand node deletions to maintain the red-black properties, but they may make manymore color changes.\na.Describe a legal red-black tree with nnodes such that calling RB-I\nNSERT to\nadd the .nC1/st node causes /DEL.lgn/color changes. Then describe a legal\nred-black tree with nnodes for which calling RB-D ELETE on a particular node\ncauses /DEL.lgn/color changes.\nAlthough the worst-case number of color changes per operation can be logarithmic,\nwe shall prove that any sequence of mRB-I NSERT and RB-D ELETE operations on\nan initially empty red-black tree causes O.m/ structural modi\ufb01cations in the worst\ncase. Note that we count each color change as a structural modi\ufb01cation.\nb.Some of the cases handled by the main loop of the code of both RB-I NSERT -\nFIXUP and RB-D ELETE -FIXUP areterminating : once encountered, they cause\nthe loop to terminate after a constant number of additional operations. For each\nof the cases of RB-I NSERT -FIXUP and RB-D ELETE -FIXUP , specify which are\nterminating and which are not. ( Hint: Look at Figures 13.5, 13.6, and 13.7.)", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "495": {"page_number": 496, "page_information": "Problems for Chapter 17 475\nWe shall \ufb01rst analyze the structural modi\ufb01cations when only insertions are per-\nformed. Let Tbe a red-black tree, and de\ufb01ne \u02c6.T / to be the number of red nodes\ninT. Assume that 1unit of potential can pay for the structural modi\ufb01cations per-\nformed by any of the three cases of RB-I NSERT -FIXUP .\nc.LetT0be the result of applying Case 1 of RB-I NSERT -FIXUP toT. Argue that\n\u02c6.T0/D\u02c6.T //NUL1.\nd.When we insert a node into a red-black tree using RB-I NSERT , we can break\nthe operation into three parts. List the structural modi\ufb01cations and potentialchanges resulting from lines 1\u201316 of RB-I\nNSERT , from nonterminating cases\nof RB-I NSERT -FIXUP , and from terminating cases of RB-I NSERT -FIXUP .\ne.Using part (d), argue that the amortized number of structural modi\ufb01cations per-\nformed by any call of RB-I NSERT isO.1/ .\nWe now wish to prove that there are O.m/ structural modi\ufb01cations when there are\nboth insertions and deletions. Let us de\ufb01ne, for each node x,\nw.x/D\u201e\n0ifxis red ;\n1ifxis black and has no red children ;\n0ifxis black and has one red child ;\n2ifxis black and has two red children :\nNow we rede\ufb01ne the potential of a red-black tree Tas\n\u02c6.T /DX\nx2Tw.x/ ;\nand let T0be the tree that results from applying any nonterminating case of RB-\nINSERT -FIXUP or RB-D ELETE -FIXUP toT.\nf.Show that \u02c6.T0//DC4\u02c6.T //NUL1for all nonterminating cases of RB-I NSERT -\nFIXUP . Argue that the amortized number of structural modi\ufb01cations performed\nby any call of RB-I NSERT -FIXUP isO.1/ .\ng.Show that \u02c6.T0//DC4\u02c6.T //NUL1for all nonterminating cases of RB-D ELETE -\nFIXUP . Argue that the amortized number of structural modi\ufb01cations performed\nby any call of RB-D ELETE -FIXUP isO.1/ .\nh.Complete the proof that in the worst case, any sequence of mRB-I NSERT and\nRB-D ELETE operations performs O.m/ structural modi\ufb01cations.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "496": {"page_number": 497, "page_information": "476 Chapter 17 Amortized Analysis\n17-5 Competitive analysis of self-organizing lists with move-to-front\nAself-organizing list is a linked list of nelements, in which each element has a\nunique key. When we search for an element in the list, we are given a key, and wewant to \ufb01nd an element with that key.\nA self-organizing list has two important properties:\n1. To \ufb01nd an element in the list, given its key, we must traverse the list from the\nbeginning until we encounter the element with the given key. If that element isthekth element from the start of the list, then the cost to \ufb01nd the element is k.\n2. We may reorder the list elements after any operation, according to a given rule\nwith a given cost. We may choose any heuristic we like to decide how to reorderthe list.\nAssume that we start with a given list of nelements, and we are given an access\nsequence /ESCDh/ESC\n1;/ESC2;:::;/ESC miof keys to \ufb01nd, in order. The cost of the sequence\nis the sum of the costs of the individual accesses in the sequence.\nOut of the various possible ways to reorder the list after an operation, this prob-\nlem focuses on transposing adjacent list elements\u2014switching their positions in thelist\u2014with a unit cost for each transpose operation. You will show, by means of apotential function, that a particular heuristic for reordering the list, move-to-front,entails a total cost no worse than 4times that of any other heuristic for maintaining\nthe list order\u2014even if the other heuristic knows the access sequence in advance!\nWe call this type of analysis a competitive analysis .\nFor a heuristic H and a given initial ordering of the list, denote the access cost of\nsequence /ESCbyC\nH./ESC/.L e t mbe the number of accesses in /ESC.\na.Argue that if heuristic H does not know the access sequence in advance, then\nthe worst-case cost for H on an access sequence /ESCisCH./ESC/D/DEL.mn/ .\nWith the move-to-front heuristic, immediately after searching for an element x,\nwe move xto the \ufb01rst position on the list (i.e., the front of the list).\nLet rank L.x/denote the rank of element xin list L, that is, the position of xin\nlistL. For example, if xis the fourth element in L,t h e nr a n k L.x/D4.L e t ci\ndenote the cost of access /ESCiusing the move-to-front heuristic, which includes the\ncost of \ufb01nding the element in the list and the cost of moving it to the front of thelist by a series of transpositions of adjacent list elements.\nb.Show that if /ESC\niaccesses element xin list Lusing the move-to-front heuristic,\nthenciD2/SOHrank L.x//NUL1.\nNow we compare move-to-front with any other heuristic H that processes an\naccess sequence according to the two properties above. Heuristic H may transpose", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "497": {"page_number": 498, "page_information": "Problems for Chapter 17 477\nelements in the list in any way it wants, and it might even know the entire access\nsequence in advance.\nLetLibe the list after access /ESCiusing move-to-front, and let L/ETX\nibe the list after\naccess /ESCiusing heuristic H. We denote the cost of access /ESCibycifor move-to-\nfront and by c/ETX\nifor heuristic H. Suppose that heuristic H performs t/ETX\nitranspositions\nduring access /ESCi.\nc.In part (b), you showed that ciD2/SOHrank Li/NUL1.x//NUL1. Now show that c/ETX\niD\nrank L/ETX\ni/NUL1.x/Ct/ETX\ni.\nWe de\ufb01ne an inversion in list Lias a pair of elements yand\u00b4such that y\nprecedes \u00b4inLiand\u00b4precedes yin list L/ETX\ni. Suppose that list Lihasqiinversions\nafter processing the access sequence h/ESC1;/ESC2;:::;/ESC ii. Then, we de\ufb01ne a potential\nfunction \u02c6that maps Lito a real number by \u02c6.L i/D2qi. For example, if Lihas\nthe elementshe; c; a; d; biandL/ETX\nihas the elementshc; a; b; d; ei,t h e n Lihas 5\ninversions ( .e; c/; .e; a/; .e; d/; .e; b/; .d; b/ ), and so \u02c6.L i/D10. Observe that\n\u02c6.L i//NAK0for all iand that, if move-to-front and heuristic H start with the same\nlistL0,t h e n \u02c6.L 0/D0.\nd.Argue that a transposition either increases the potential by 2or decreases the\npotential by 2.\nSuppose that access /ESCi\ufb01nds the element x. To understand how the potential\nchanges due to /ESCi, let us partition the elements other than xinto four sets, depend-\ning on where they are in the lists just before the ith access:\n/SISetAconsists of elements that precede xin both Li/NUL1andL/ETX\ni/NUL1.\n/SISetBconsists of elements that precede xinLi/NUL1and follow xinL/ETX\ni/NUL1.\n/SISetCconsists of elements that follow xinLi/NUL1and precede xinL/ETX\ni/NUL1.\n/SISetDconsists of elements that follow xin both Li/NUL1andL/ETX\ni/NUL1.\ne.Argue that rank Li/NUL1.x/DjAjCjBjC1and rank L/ETX\ni/NUL1.x/DjAjCjCjC1.\nf.Show that access /ESCicauses a change in potential of\n\u02c6.L i//NUL\u02c6.L i/NUL1//DC42.jAj/NULjBjCt/ETX\ni/;\nwhere, as before, heuristic H performs t/ETX\nitranspositions during access /ESCi.\nDe\ufb01ne the amortized cost yciof access /ESCibyyciDciC\u02c6.L i//NUL\u02c6.L i/NUL1/.\ng.Show that the amortized cost yciof access /ESCiis bounded from above by 4c/ETX\ni.\nh.Conclude that the cost CMTF./ESC/of access sequence /ESCwith move-to-front is at\nmost 4times the cost CH./ESC/of/ESCwith any other heuristic H, assuming that\nboth heuristics start with the same list.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "498": {"page_number": 499, "page_information": "478 Chapter 17 Amortized Analysis\nChapter notes\nAho, Hopcroft, and Ullman [5] used aggregate analysis to determine the running\ntime of operations on a disjoint-set forest; we shall analyze this data structure us-ing the potential method in Chapter 21. Tarjan [331] surveys the accounting andpotential methods of amortized analysis and presents several applications. He at-\ntributes the accounting method to several authors, including M. R. Brown, R. E.\nTarjan, S. Huddleston, and K. Mehlhorn. He attributes the potential method toD. D. Sleator. The term \u201camortized\u201d is due to D. D. Sleator and R. E. Tarjan.\nPotential functions are also useful for proving lower bounds for certain types of\nproblems. For each con\ufb01guration of the problem, we de\ufb01ne a potential functionthat maps the con\ufb01guration to a real number. Then we determine the potential \u02c6\ninit\nof the initial con\ufb01guration, the potential \u02c6\ufb01nalof the \ufb01nal con\ufb01guration, and the\nmaximum change in potential /c129\u02c6 maxdue to any step. The number of steps must\ntherefore be at least j\u02c6\ufb01nal/NUL\u02c6initj=j/c129\u02c6 maxj. Examples of potential functions to\nprove lower bounds in I/O complexity appear in works by Cormen, Sundquist, andWisniewski [79]; Floyd [107]; and Aggarwal and Vitter [3]. Krumme, Cybenko,and Venkataraman [221] applied potential functions to prove lower bounds on gos-\nsiping : communicating a unique item from each vertex in a graph to every other\nvertex.\nThe move-to-front heuristic from Problem 17-5 works quite well in practice.\nMoreover, if we recognize that when we \ufb01nd an element, we can splice it out of itsposition in the list and relocate it to the front of the list in constant time, we canshow that the cost of move-to-front is at most twice the cost of any other heuristicincluding, again, one that knows the entire access sequence in advance.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "499": {"page_number": 500, "page_information": "", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "500": {"page_number": 501, "page_information": "V Advanced Data Structures", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "501": {"page_number": 502, "page_information": "Introduction\nThis part returns to studying data structures that support operations on dynamic\nsets, but at a more advanced level than Part III. Two of the chapters, for example,make extensive use of the amortized analysis techniques we saw in Chapter 17.\nChapter 18 presents B-trees, which are balanced search trees speci\ufb01cally de-\nsigned to be stored on disks. Because disks operate much more slowly thanrandom-access memory, we measure the performance of B-trees not only by howmuch computing time the dynamic-set operations consume but also by how manydisk accesses they perform. For each B-tree operation, the number of disk accessesincreases with the height of the B-tree, but B-tree operations keep the height low.\nChapter 19 gives an implementation of a mergeable heap, which supports the\noperations I\nNSERT ,M INIMUM ,EXTRACT -MIN,a n dU NION .1The U NION oper-\nation unites, or merges, two heaps. Fibonacci heaps\u2014the data structure in Chap-\nter 19\u2014also support the operations D ELETE and D ECREASE -KEY. We use amor-\ntized time bounds to measure the performance of Fibonacci heaps. The opera-\ntions I NSERT ,M INIMUM ,a n dU NION take only O.1/ actual and amortized time\non Fibonacci heaps, and the operations E XTRACT -MINand D ELETE takeO.lgn/\namortized time. The most signi\ufb01cant advantage of Fibonacci heaps, however, is\nthat D ECREASE -KEYtakes only O.1/ amortized time. Because the D ECREASE -\n1As in Problem 10-2, we have de\ufb01ned a mergeable heap to support M INIMUM and E XTRACT -MIN,\nand so we can also refer to it as a mergeable min-heap . Alternatively, if it supported M AXIMUM\nand E XTRACT -MAX, it would be a mergeable max-heap . Unless we specify otherwise, mergeable\nheaps will be by default mergeable min-heaps.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "502": {"page_number": 503, "page_information": "482 Part V Advanced Data Structures\nKEYoperation takes constant amortized time, Fibonacci heaps are key components\nof some of the asymptotically fastest algorithms to date for graph problems.\nNoting that we can beat the /DEL.n lgn/lower bound for sorting when the keys\nare integers in a restricted range, Chapter 20 asks whether we can design a datastructure that supports the dynamic-set operations S\nEARCH ,INSERT ,D ELETE ,\nMINIMUM ,M AXIMUM ,SUCCESSOR ,a n dP REDECESSOR ino.lgn/time when\nthe keys are integers in a restricted range. The answer turns out to be that we can,by using a recursive data structure known as a van Emde Boas tree. If the keys are\nunique integers drawn from the set f0; 1; 2; : : : ; u/NUL1g,w h e r e uis an exact power\nof2, then van Emde Boas trees support each of the above operations in O.lg lgu/\ntime.\nFinally, Chapter 21 presents data structures for disjoint sets. We have a universe\nofnelements that are partitioned into dynamic sets. Initially, each element belongs\nto its own singleton set. The operation U\nNION unites two sets, and the query F IND-\nSETidenti\ufb01es the unique set that contains a given element at the moment. By\nrepresenting each set as a simple rooted tree, we obtain surprisingly fast operations:\na sequence of moperations runs in O.m \u02db.n// time, where \u02db.n/ is an incredibly\nslowly growing function\u2014 \u02db.n/ is at most 4in any conceivable application. The\namortized analysis that proves this time bound is as complex as the data structureis simple.\nThe topics covered in this part are by no means the only examples of \u201cadvanced\u201d\ndata structures. Other advanced data structures include the following:\n/SIDynamic trees , introduced by Sleator and Tarjan [319] and discussed by Tarjan\n[330], maintain a forest of disjoint rooted trees. Each edge in each tree hasa real-valued cost. Dynamic trees support queries to \ufb01nd parents, roots, edgecosts, and the minimum edge cost on a simple path from a node up to a root.Trees may be manipulated by cutting edges, updating all edge costs on a simplepath from a node up to a root, linking a root into another tree, and making a\nnode the root of the tree it appears in. One implementation of dynamic trees\ngives an O.lgn/amortized time bound for each operation; a more complicated\nimplementation yields O.lgn/worst-case time bounds. Dynamic trees are used\nin some of the asymptotically fastest network-\ufb02ow algorithms.\n/SISplay trees , developed by Sleator and Tarjan [320] and, again, discussed by\nTarjan [330], are a form of binary search tree on which the standard search-tree operations run in O.lgn/amortized time. One application of splay trees\nsimpli\ufb01es dynamic trees.\n/SIPersistent data structures allow queries, and sometimes updates as well, on past\nversions of a data structure. Driscoll, Sarnak, Sleator, and Tarjan [97] presenttechniques for making linked data structures persistent with only a small time", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "503": {"page_number": 504, "page_information": "Part V Advanced Data Structures 483\nand space cost. Problem 13-1 gives a simple example of a persistent dynamic\nset.\n/SIAs in Chapter 20, several data structures allow a faster implementation of dic-tionary operations (I\nNSERT ,DELETE ,a n dS EARCH ) for a restricted universe\nof keys. By taking advantage of these restrictions, they are able to achieve bet-ter worst-case asymptotic running times than comparison-based data structures.Fredman and Willard introduced fusion trees [115], which were the \ufb01rst data\nstructure to allow faster dictionary operations when the universe is restricted tointegers. They showed how to implement these operations in O.lgn=lg lgn/\ntime. Several subsequent data structures, including exponential search trees\n[16], have also given improved bounds on some or all of the dictionary opera-tions and are mentioned in the chapter notes throughout this book.\n/SIDynamic graph data structures support various queries while allowing the\nstructure of a graph to change through operations that insert or delete vertices\nor edges. Examples of the queries that they support include vertex connectivity\n[166], edge connectivity, minimum spanning trees [165], biconnectivity, and\ntransitive closure [164].\nChapter notes throughout this book mention additional data structures.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "504": {"page_number": 505, "page_information": "18 B-Trees\nB-trees are balanced search trees designed to work well on disks or other direct-\naccess secondary storage devices. B-trees are similar to red-black trees (Chap-ter 13), but they are better at minimizing disk I/O operations. Many database sys-tems use B-trees, or variants of B-trees, to store information.\nB-trees differ from red-black trees in that B-tree nodes may have many children,\nfrom a few to thousands. That is, the \u201cbranching factor\u201d of a B-tree can be quitelarge, although it usually depends on characteristics of the disk unit used. B-treesare similar to red-black trees in that every n-node B-tree has height O.lgn/.T h e\nexact height of a B-tree can be considerably less than that of a red-black tree,\nhowever, because its branching factor, and hence the base of the logarithm that\nexpresses its height, can be much larger. Therefore, we can also use B-trees to\nimplement many dynamic-set operations in time O.lgn/.\nB-trees generalize binary search trees in a natural manner. Figure 18.1 shows a\nsimple B-tree. If an internal B-tree node xcontains x:nkeys, then xhasx:nC1\nchildren. The keys in node xserve as dividing points separating the range of keys\nhandled by xintox:nC1subranges, each handled by one child of x.W h e n\nsearching for a key in a B-tree, we make an .x:nC1/-way decision based on\ncomparisons with the x:nkeys stored at node x. The structure of leaf nodes differs\nfrom that of internal nodes; we will examine these differences in Section 18.1.\nSection 18.1 gives a precise de\ufb01nition of B-trees and proves that the height of\na B-tree grows only logarithmically with the number of nodes it contains. Sec-tion 18.2 describes how to search for a key and insert a key into a B-tree, andSection 18.3 discusses deletion. Before proceeding, however, we need to ask whywe evaluate data structures designed to work on a disk differently from data struc-tures designed to work in main random-access memory.\nData structures on secondary storage\nComputer systems take advantage of various technologies that provide memory\ncapacity. The primary memory (ormain memory ) of a computer system normally", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "505": {"page_number": 506, "page_information": "Chapter 18 B-Trees 485\nBC FG JKLDH\nNP RS VW YZQTXMT:root\nFigure 18.1 A B-tree whose keys are the consonants of English. An internal node xcontaining\nx:nkeys has x:nC1children. All leaves are at the same depth in the tree. The lightly shaded nodes\nare examined in a search for the letter R.\nplatter track\narmsread/write\nheadspindle\nFigure 18.2 A typical disk drive. It comprises one or more platters (two platters are shown here)\nthat rotate around a spindle. Each platter is read and written with a head at the end of an arm. Arms\nrotate around a common pivot axis. A track is th e surface that passes beneath the read/write head\nwhen the head is stationary.\nconsists of silicon memory chips. This technology is typically more than an order\nof magnitude more expensive per bit stored than magnetic storage technology, suchas tapes or disks. Most computer systems also have secondary storage based on\nmagnetic disks; the amount of such secondary storage often exceeds the amount ofprimary memory by at least two orders of magnitude.\nFigure 18.2 shows a typical disk drive. The drive consists of one or more plat-\nters, which rotate at a constant speed around a common spindle . A magnetizable\nmaterial covers the surface of each platter. The drive reads and writes each platter\nby ahead at the end of an arm. The arms can move their heads toward or away", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "506": {"page_number": 507, "page_information": "486 Chapter 18 B-Trees\nfrom the spindle. When a given head is stationary, the surface that passes under-\nneath it is called a track . Multiple platters increase only the disk drive\u2019s capacity\nand not its performance.\nAlthough disks are cheaper and have higher capacity than main memory, they are\nmuch, much slower because they have moving mechanical parts.1The mechanical\nmotion has two components: platter rotation and arm movement. As of this writing,commodity disks rotate at speeds of 5400\u201315,000 revolutions per minute (RPM).We typically see 15,000 RPM speeds in server-grade drives, 7200 RPM speeds\nin drives for desktops, and 5400 RPM speeds in drives for laptops. Although\n7200 RPM may seem fast, one rotation takes 8.33 milliseconds, which is over 5orders of magnitude longer than the 50 nanosecond access times (more or less)commonly found for silicon memory. In other words, if we have to wait a full rota-tion for a particular item to come under the read/write head, we could access mainmemory more than 100,000 times during that span. On average we have to waitfor only half a rotation, but still, the difference in access times for silicon memorycompared with disks is enormous. Moving the arms also takes some time. As ofthis writing, average access times for commodity disks are in the range of 8 to 11milliseconds.\nIn order to amortize the time spent waiting for mechanical movements, disks\naccess not just one item but several at a time. Information is divided into a numberof equal-sized pages of bits that appear consecutively within tracks, and each disk\nread or write is of one or more entire pages. For a typical disk, a page might be 2\n11\nto214bytes in length. Once the read/write head is positioned correctly and the disk\nhas rotated to the beginning of the desired page, reading or writing a magnetic diskis entirely electronic (aside from the rotation of the disk), and the disk can quicklyread or write large amounts of data.\nOften, accessing a page of information and reading it from a disk takes longer\nthan examining all the information read. For this reason, in this chapter we shalllook separately at the two principal components of the running time:\n/SIthe number of disk accesses, and\n/SIthe CPU (computing) time.\nWe measure the number of disk accesses in terms of the number of pages of infor-\nmation that need to be read from or written to the disk. We note that disk-accesstime is not constant\u2014it depends on the distance between the current track andthe desired track and also on the initial rotational position of the disk. We shall\n1As of this writing, solid-state drives have recently come onto the consumer market. Although they\nare faster than mechanical disk drives, they cost more per gigabyte and have lower capacities than\nmechanical disk drives.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "507": {"page_number": 508, "page_information": "Chapter 18 B-Trees 487\nnonetheless use the number of pages read or written as a \ufb01rst-order approximation\nof the total time spent accessing the disk.\nIn a typical B-tree application, the amount of data handled is so large that all\nthe data do not \ufb01t into main memory at once. The B-tree algorithms copy selectedpages from disk into main memory as needed and write back onto disk the pagesthat have changed. B-tree algorithms keep only a constant number of pages inmain memory at any time; thus, the size of main memory does not limit the size ofB-trees that can be handled.\nWe model disk operations in our pseudocode as follows. Let xbe a pointer to an\nobject. If the object is currently in the computer\u2019s main memory, then we can referto the attributes of the object as usual: x:key, for example. If the object referred to\nbyxresides on disk, however, then we must perform the operation D\nISK-READ.x/\nto read object xinto main memory before we can refer to its attributes. (We as-\nsume that if xis already in main memory, then D ISK-READ.x/requires no disk\naccesses; it is a \u201cno-op.\u201d) Similarly, the operation D ISK-WRITE.x/is used to save\nany changes that have been made to the attributes of object x. That is, the typical\npattern for working with an object is as follows:\nxDa pointer to some object\nDISK-READ.x/\noperations that access and/or modify the attributes of x\nDISK-WRITE.x/ //omitted if no attributes of xwere changed\nother operations that access but do not modify attributes of x\nThe system can keep only a limited number of pages in main memory at any one\ntime. We shall assume that the system \ufb02ushes from main memory pages no longerin use; our B-tree algorithms will ignore this issue.\nSince in most systems the running time of a B-tree algorithm depends primar-\nily on the number of D\nISK-READ and D ISK-WRITE operations it performs, we\ntypically want each of these operations to read or write as much information aspossible. Thus, a B-tree node is usually as large as a whole disk page, and this sizelimits the number of children a B-tree node can have.\nFor a large B-tree stored on a disk, we often see branching factors between 50\nand2000 , depending on the size of a key relative to the size of a page. A large\nbranching factor dramatically reduces both the height of the tree and the number of\ndisk accesses required to \ufb01nd any key. Figure 18.3 shows a B-tree with a branchingfactor of 1001 and height 2that can store over one billion keys; nevertheless, since\nwe can keep the root node permanently in main memory, we can \ufb01nd any key inthis tree by making at most only two disk accesses.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "508": {"page_number": 509, "page_information": "488 Chapter 18 B-Trees\n1000\n1001\n1000\n10011000\n10011000\n1001\n1000 1000 1000\u20261 node,\n   1000 keys\n1001 nodes,\n   1,001,000 keys\n1,002,001 nodes,\n   1,002,001,000 keys \u2026T:root\nFigure 18.3 A B-tree of height 2 containing over one billion keys. Shown inside each node x\nisx:n, the number of keys in x. Each internal node and leaf contains 1000 keys. This B-tree has\n1001 nodes at depth 1 and over one million leaves at depth 2.\n18.1 De\ufb01nition of B-trees\nTo keep things simple, we assume, as we have for binary search trees and red-black\ntrees, that any \u201csatellite information\u201d associated with a key resides in the samenode as the key. In practice, one might actually store with each key just a pointer toanother disk page containing the satellite information for that key. The pseudocodein this chapter implicitly assumes that the satellite information associated with akey, or the pointer to such satellite information, travels with the key whenever the\nkey is moved from node to node. A common variant on a B-tree, known as a\nB\nC-tree , stores all the satellite information in the leaves and stores only keys and\nchild pointers in the internal nodes, thus maximizing the branching factor of the\ninternal nodes.\nAB-tree Tis a rooted tree (whose root is T:root) having the following proper-\nties:\n1. Every node xhas the following attributes:\na.x:n, the number of keys currently stored in node x,\nb. the x:nkeys themselves, x:key1;x:key2;:::;x: keyx:n, stored in nondecreas-\ning order, so that x:key1/DC4x:key2/DC4/SOH/SOH/SOH/DC4 x:keyx:n,\nc.x:leaf, a boolean value that is TRUE ifxis a leaf and FALSE ifxis an internal\nnode.\n2. Each internal node xalso contains x:nC1pointers x:c 1;x:c 2;:::;x:c x:nC1to\nits children. Leaf nodes have no children, and so their ciattributes are unde-\n\ufb01ned.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "509": {"page_number": 510, "page_information": "18.1 De\ufb01nition of B-trees 489\n3. The keys x:keyiseparate the ranges of keys stored in each subtree: if kiis any\nkey stored in the subtree with root x:c i,t h e n\nk1/DC4x:key1/DC4k2/DC4x:key2/DC4/SOH/SOH/SOH/DC4 x:keyx:n/DC4kx:nC1:\n4. All leaves have the same depth, which is the tree\u2019s height h.\n5. Nodes have lower and upper bounds on the number of keys they can contain.\nWe express these bounds in terms of a \ufb01xed integer t/NAK2called the minimum\ndegree of the B-tree:\na. Every node other than the root must have at least t/NUL1keys. Every internal\nnode other than the root thus has at least tchildren. If the tree is nonempty,\nthe root must have at least one key.\nb. Every node may contain at most 2t/NUL1keys. Therefore, an internal node\nmay have at most 2tchildren. We say that a node is fullif it contains exactly\n2t/NUL1keys.2\nThe simplest B-tree occurs when tD2. Every internal node then has either 2,\n3,o r4children, and we have a 2-3-4 tree . In practice, however, much larger values\noftyield B-trees with smaller height.\nThe height of a B-tree\nThe number of disk accesses required for most operations on a B-tree is propor-\ntional to the height of the B-tree. We now analyze the worst-case height of a B-tree.\nTheorem 18.1\nIfn/NAK1, then for any n-key B-tree Tof height hand minimum degree t/NAK2,\nh/DC4logtnC1\n2:\nProof The root of a B-tree Tcontains at least one key, and all other nodes contain\nat least t/NUL1keys. Thus, T, whose height is h, has at least 2nodes at depth 1,a t\nleast 2tnodes at depth 2, at least 2t2nodes at depth 3, and so on, until at depth h\nit has at least 2th/NUL1nodes. Figure 18.4 illustrates such a tree for hD3. Thus, the\n2Another common variant on a B-tree, known as a B/ETX-tree , requires each internal node to be at\nleast2=3full, rather than at least half full, as a B-tree requires.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "510": {"page_number": 511, "page_information": "490 Chapter 18 B-Trees\nt \u2013 1\nt \u2013 1 t \u2013 1\u2026tt \u2013 1\nt\n\u20261\nt \u2013 1\nt \u2013 1 t \u2013 1\u2026tt \u2013 1\nt \u2013 1 t \u2013 1\u2026tt \u2013 1\nt\n\u2026 t \u2013 1\nt \u2013 1 t \u2013 1\u2026tdepthnumber\nof nodes\n32 t21\n201\n2\n2tT:root\nFigure 18.4 A B-tree of height 3 containing a minimum possible number of keys. Shown inside\neach node xisx:n.\nnumber nof keys satis\ufb01es the inequality\nn/NAK1C.t/NUL1/hX\niD12ti/NUL1\nD1C2.t/NUL1//DC2th/NUL1\nt/NUL1/DC3\nD2th/NUL1:\nBy simple algebra, we get th/DC4.nC1/=2 . Taking base- tlogarithms of both sides\nproves the theorem.\nHere we see the power of B-trees, as compared with red-black trees. Although\nthe height of the tree grows as O.lgn/in both cases (recall that tis a constant), for\nB-trees the base of the logarithm can be many times larger. Thus, B-trees save afactor of about lg tover red-black trees in the number of nodes examined for most\ntree operations. Because we usually have to access the disk to examine an arbitrary\nnode in a tree, B-trees avoid a substantial number of disk accesses.\nExercises\n18.1-1\nWhy don\u2019t we allow a minimum degree of tD1?\n18.1-2\nF o rw h a tv a l u e so f tis the tree of Figure 18.1 a legal B-tree?", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "511": {"page_number": 512, "page_information": "18.2 Basic operations on B-trees 491\n18.1-3\nShow all legal B-trees of minimum degree 2that representf1; 2; 3; 4; 5g.\n18.1-4\nAs a function of the minimum degree t, what is the maximum number of keys that\ncan be stored in a B-tree of height h?\n18.1-5\nDescribe the data structure that would result if each black node in a red-black treewere to absorb its red children, incorporating their children with its own.\n18.2 Basic operations on B-trees\nIn this section, we present the details of the operations B-T REE-SEARCH ,B -\nTREE-CREATE ,a n dB - T REE-INSERT . In these procedures, we adopt two con-\nventions:\n/SIThe root of the B-tree is always in main memory, so that we never need toperform a D\nISK-READ on the root; we do have to perform a D ISK-WRITE of\nthe root, however, whenever the root node is changed.\n/SIAny nodes that are passed as parameters must already have had a D ISK-READ\noperation performed on them.\nThe procedures we present are all \u201cone-pass\u201d algorithms that proceed downward\nfrom the root of the tree, without having to back up.\nSearching a B-tree\nSearching a B-tree is much like searching a binary search tree, except that instead\nof making a binary, or \u201ctwo-way,\u201d branching decision at each node, we make amultiway branching decision according to the number of the node\u2019s children. More\nprecisely, at each internal node x,w em a k ea n .x:nC1/-way branching decision.\nB-T\nREE-SEARCH is a straightforward generalization of the T REE-SEARCH pro-\ncedure de\ufb01ned for binary search trees. B-T REE-SEARCH takes as input a pointer\nto the root node xof a subtree and a key kto be searched for in that subtree. The\ntop-level call is thus of the form B-T REE-SEARCH .T:root;k/.I fkis in the B-tree,\nB-T REE-SEARCH returns the ordered pair .y; i/ consisting of a node yand an\nindex isuch that y:keyiDk. Otherwise, the procedure returns NIL.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "512": {"page_number": 513, "page_information": "492 Chapter 18 B-Trees\nB-T REE-SEARCH .x; k/\n1iD1\n2while i/DC4x:nandk>x : keyi\n3 iDiC1\n4ifi/DC4x:nandk==x:keyi\n5 return .x; i/\n6elseif x:leaf\n7 return NIL\n8elseDISK-READ.x:c i/\n9 return B-T REE-SEARCH .x:c i;k/\nUsing a linear-search procedure, lines 1\u20133 \ufb01nd the smallest index isuch that\nk/DC4x:keyi, or else they set itox:nC1. Lines 4\u20135 check to see whether we\nhave now discovered the key, returning if we have. Otherwise, lines 6\u20139 either ter-minate the search unsuccessfully (if xis a leaf) or recurse to search the appropriate\nsubtree of x, after performing the necessary D\nISK-READ on that child.\nFigure 18.1 illustrates the operation of B-T REE-SEARCH . The procedure exam-\nines the lightly shaded nodes during a search for the key R.\nAs in the T REE-SEARCH procedure for binary search trees, the nodes encoun-\ntered during the recursion form a simple path downward from the root of the\ntree. The B-T REE-SEARCH procedure therefore accesses O.h/DO.logtn/disk\npages, where his the height of the B-tree and nis the number of keys in the B-tree.\nSince x:n<2 t ,t h ewhile loop of lines 2\u20133 takes O.t/ time within each node, and\nthe total CPU time is O.th/DO.tlogtn/.\nCreating an empty B-tree\nTo build a B-tree T,w e\ufb01 r s tu s eB - T REE-CREATE to create an empty root node\nand then call B-T REE-INSERT to add new keys. Both of these procedures use an\nauxiliary procedure A LLOCATE -NODE, which allocates one disk page to be used\nas a new node in O.1/ time. We can assume that a node created by A LLOCATE -\nNODE requires no D ISK-READ, since there is as yet no useful information stored\non the disk for that node.\nB-T REE-CREATE .T /\n1xDALLOCATE -NODE./\n2x:leafDTRUE\n3x:nD0\n4D ISK-WRITE.x/\n5T:rootDx\nB-T REE-CREATE requires O.1/ disk operations and O.1/ CPU time.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "513": {"page_number": 514, "page_information": "18.2 Basic operations on B-trees 493\nInserting a key into a B-tree\nInserting a key into a B-tree is signi\ufb01cantly more complicated than inserting a key\ninto a binary search tree. As with binary search trees, we search for the leaf positionat which to insert the new key. With a B-tree, however, we cannot simply createa new leaf node and insert it, as the resulting tree would fail to be a valid B-tree.Instead, we insert the new key into an existing leaf node. Since we cannot insert akey into a leaf node that is full, we introduce an operation that splits a full node y\n(having 2t/NUL1keys) around its median key y:key\ntinto two nodes having only t/NUL1\nkeys each. The median key moves up into y\u2019s parent to identify the dividing point\nbetween the two new trees. But if y\u2019s parent is also full, we must split it before we\ncan insert the new key, and thus we could end up splitting full nodes all the way upthe tree.\nAs with a binary search tree, we can insert a key into a B-tree in a single pass\ndown the tree from the root to a leaf. To do so, we do not wait to \ufb01nd out whether\nwe will actually need to split a full node in order to do the insertion. Instead, as we\ntravel down the tree searching for the position where the new key belongs, we spliteach full node we come to along the way (including the leaf itself). Thus wheneverwe want to split a full node y, we are assured that its parent is not full.\nSplitting a node in a B-tree\nThe procedure B-T\nREE-SPLIT-CHILD takes as input a nonfull internal node x(as-\ns u m e dt ob ei nm a i nm e m o r y )a n da ni n d e x isuch that x:c i(also assumed to be in\nmain memory) is a fullchild of x. The procedure then splits this child in two and\nadjusts xso that it has an additional child. To split a full root, we will \ufb01rst make the\nroot a child of a new empty root node, so that we can use B-T REE-SPLIT-CHILD .\nThe tree thus grows in height by one; splitting is the only means by which the tree\ngrows.\nFigure 18.5 illustrates this process. We split the full node yDx:c iabout its\nmedian key S, which moves up into y\u2019s parent node x. Those keys in ythat are\ngreater than the median key move into a new node \u00b4, which becomes a new child\nofx.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "514": {"page_number": 515, "page_information": "494 Chapter 18 B-Trees\nRSTQPU VNW\u2026\u2026\nRQP TUVNWS \u2026\u2026x x\nT1 T1 T2 T2 T3 T3 T4 T4 T5 T5 T6 T6 T7 T7 T8 T8yDx:c i yDx:c i \u00b4Dx:c iC1x:keyi/NUL1\nx:keyi/NUL1\nx:keyi\nx:keyi\nx:keyiC1\nFigure 18.5 Splitting a node with tD4. Node yDx:c isplits into two nodes, yand \u00b4,a n dt h e\nmedian key Sofymoves up into y\u2019s parent.\nB-T REE-SPLIT-CHILD .x; i /\n1 \u00b4DALLOCATE -NODE ./\n2 yDx:c i\n3 \u00b4:leafDy:leaf\n4 \u00b4:nDt/NUL1\n5for jD1tot/NUL1\n6 \u00b4:keyjDy:keyjCt\n7ifnot y:leaf\n8 for jD1tot\n9 \u00b4: c jDy:c jCt\n10 y:nDt/NUL1\n11 for jDx:nC1downto iC1\n12 x:c jC1Dx:c j\n13 x:c iC1D\u00b4\n14 for jDx:ndownto i\n15 x:keyjC1Dx:keyj\n16 x:keyiDy:keyt\n17 x:nDx:nC1\n18 D ISK-WRITE .y/\n19 D ISK-WRITE .\u00b4/\n20 D ISK-WRITE .x/\nB-T REE-SPLIT-CHILD works by straightforward \u201ccutting and pasting.\u201d Here, x\nis the node being split, and yisx\u2019sith child (set in line 2). Node yoriginally has 2t\nchildren ( 2t/NUL1keys) but is reduced to tchildren ( t/NUL1keys) by this operation.\nNode \u00b4takes the tlargest children ( t/NUL1keys) from y,a n d \u00b4becomes a new child", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "515": {"page_number": 516, "page_information": "18.2 Basic operations on B-trees 495\nofx, positioned just after yinx\u2019s table of children. The median key of ymoves\nup to become the key in xthat separates yand\u00b4.\nLines 1\u20139 create node \u00b4and give it the largest t/NUL1keys and corresponding t\nchildren of y. Line 10 adjusts the key count for y. Finally, lines 11\u201317 insert \u00b4as\na child of x, move the median key from yup to xin order to separate yfrom \u00b4,\nand adjust x\u2019s key count. Lines 18\u201320 write out all modi\ufb01ed disk pages. The\nCPU time used by B-T REE-SPLIT-CHILD is\u201a.t/ , due to the loops on lines 5\u20136\nand 8\u20139. (The other loops run for O.t/ iterations.) The procedure performs O.1/\ndisk operations.\nInserting a key into a B-tree in a single pass down the tree\nWe insert a key kinto a B-tree Tof height hin a single pass down the tree, re-\nquiring O.h/ disk accesses. The CPU time required is O.th/DO.tlogtn/.T h e\nB-T REE-INSERT procedure uses B-T REE-SPLIT-CHILD to guarantee that the re-\ncursion never descends to a full node.\nB-T REE-INSERT .T; k/\n1rDT:root\n2ifr:n==2t/NUL1\n3 sDALLOCATE -NODE./\n4 T:rootDs\n5 s:leafDFALSE\n6 s:nD0\n7 s:c1Dr\n8B - T REE-SPLIT-CHILD .s; 1/\n9B - T REE-INSERT -NONFULL .s; k/\n10elseB-T REE-INSERT -NONFULL .r; k/\nLines 3\u20139 handle the case in which the root node ris full: the root splits and a\nnew node s(having two children) becomes the root. Splitting the root is the only\nway to increase the height of a B-tree. Figure 18.6 illustrates this case. Unlike abinary search tree, a B-tree increases in height at the top instead of at the bottom.The procedure \ufb01nishes by calling B-T\nREE-INSERT -NONFULL to insert key kinto\nthe tree rooted at the nonfull root node. B-T REE-INSERT -NONFULL recurses as\nnecessary down the tree, at all times guaranteeing that the node to which it recursesis not full by calling B-T\nREE-SPLIT-CHILD as necessary.\nThe auxiliary recursive procedure B-T REE-INSERT -NONFULL inserts key kinto\nnode x, which is assumed to be nonfull when the procedure is called. The operation\nof B-T REE-INSERT and the recursive operation of B-T REE-INSERT -NONFULL\nguarantee that this assumption is true.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "516": {"page_number": 517, "page_information": "496 Chapter 18 B-Trees\nT8 T7 T6 T5 T4 T3 T2 T1 T8 T7 T6 T5 T4 T3 T2 T1FHLDAN P FDA LNPs\nH\nrrT:rootT:root\nFigure 18.6 Splitting the root with tD4. Root node rsplits in two, and a new root node sis\ncreated. The new root contains the median key of rand has the two halves of ras children. The\nB-tree grows in height by one when the root is split.\nB-T REE-INSERT -NONFULL .x; k/\n1iDx:n\n2ifx:leaf\n3 while i/NAK1andk<x : keyi\n4 x:keyiC1Dx:keyi\n5 iDi/NUL1\n6 x:keyiC1Dk\n7 x:nDx:nC1\n8D ISK-WRITE.x/\n9else while i/NAK1andk<x : keyi\n10 iDi/NUL1\n11 iDiC1\n12 D ISK-READ.x:c i/\n13 ifx:c i:n==2t/NUL1\n14 B-T REE-SPLIT-CHILD .x; i/\n15 ifk>x : keyi\n16 iDiC1\n17 B-T REE-INSERT -NONFULL .x:c i;k/\nThe B-T REE-INSERT -NONFULL procedure works as follows. Lines 3\u20138 handle\nthe case in which xis a leaf node by inserting key kintox.I fxis not a leaf\nnode, then we must insert kinto the appropriate leaf node in the subtree rooted\nat internal node x. In this case, lines 9\u201311 determine the child of xto which the\nrecursion descends. Line 13 detects whether the recursion would descend to a fullchild, in which case line 14 uses B-T\nREE-SPLIT-CHILD to split that child into two\nnonfull children, and lines 15\u201316 determine which of the two children is now the", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "517": {"page_number": 518, "page_information": "18.2 Basic operations on B-trees 497\ncorrect one to descend to. (Note that there is no need for a D ISK-READ.x:c i/after\nline 16 increments i, since the recursion will descend in this case to a child that\nwas just created by B-T REE-SPLIT-CHILD .) The net effect of lines 13\u201316 is thus\nto guarantee that the procedure never recurses to a full node. Line 17 then recursesto insert kinto the appropriate subtree. Figure 18.7 illustrates the various cases of\ninserting into a B-tree.\nFor a B-tree of height h,B - T\nREE-INSERT performs O.h/ disk accesses, since\nonly O.1/ DISK-READ and D ISK-WRITE operations occur between calls to\nB-T REE-INSERT -NONFULL . The total CPU time used is O.th/DO.tlogtn/.\nSince B-T REE-INSERT -NONFULL is tail-recursive, we can alternatively imple-\nment it as a while loop, thereby demonstrating that the number of pages that need\nto be in main memory at any time is O.1/ .\nExercises\n18.2-1\nShow the results of inserting the keys\nF;S;Q;K;C;L;H;T;V;W;M;R;N;P;A;B;X;Y;D;Z;Ein order into an empty B-tree with minimum degree 2. Draw only the con\ufb01gura-\ntions of the tree just before some node must split, and also draw the \ufb01nal con\ufb01gu-ration.\n18.2-2\nExplain under what circumstances, if any, redundant D\nISK-READ or D ISK-WRITE\noperations occur during the course of executing a call to B-T REE-INSERT .( A\nredundant D ISK-READ is a D ISK-READ for a page that is already in memory.\nA redundant D ISK-WRITE writes to disk a page of information that is identical to\nwhat is already stored there.)\n18.2-3\nExplain how to \ufb01nd the minimum key stored in a B-tree and how to \ufb01nd the prede-cessor of a given key stored in a B-tree.\n18.2-4 ?\nSuppose that we insert the keys f1 ;2;:::;nginto an empty B-tree with minimum\ndegree 2. How many nodes does the \ufb01nal B-tree have?\n18.2-5\nSince leaf nodes require no pointers to children, they could conceivably use a dif-ferent (larger) tvalue than internal nodes for the same disk page size. Show how\nto modify the procedures for creating and inserting into a B-tree to handle this\nvariation.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "518": {"page_number": 519, "page_information": "498 Chapter 18 B-Trees\nJK NO RST DECAU V YZPXMG (a)\nJK NO RST DE BAU V YZPXMG (b)\nC\nJK NO DE BAU V YZPXMG (c)\nC RSQT\nJK NO DE BAU V YZMG(d)\nC RSQ LP\nXT\nJK NO DE BAU V YZMG(e)\nC\nRSQ LP\nXT\nFQ inserted\nL inserted\nF insertedinitial tree\nB inserted\nFigure 18.7 Inserting keys into a B-tree. The minimum degree tfor this B-tree is 3, so a node can\nhold at most 5keys. Nodes that are modi\ufb01ed by the insertion process are lightly shaded. (a)The\ninitial tree for this example. (b)The result of inserting Binto the initial tree; this is a simple insertion\ninto a leaf node. (c)The result of inserting Qinto the previous tree. The node RST U V splits into\ntwo nodes containing RSandUV,t h ek e y Tmoves up to the root, and Qis inserted in the leftmost\nof the two halves (the RSnode). (d)The result of inserting Linto the previous tree. The root\nsplits right away, since it is full, and the B-tree grows in height by one. Then Lis inserted into the\nleaf containing JK.(e)The result of inserting Finto the previous tree. The node ABCDE splits\nbefore Fis inserted into the rightmost of the two halves (the DEnode).", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "519": {"page_number": 520, "page_information": "18.3 Deleting a key from a B-tree 499\n18.2-6\nSuppose that we were to implement B-T REE-SEARCH to use binary search rather\nthan linear search within each node. Show that this change makes the CPU timerequired O.lgn/, independently of how tmight be chosen as a function of n.\n18.2-7\nSuppose that disk hardware allows us to choose the size of a disk page arbitrarily,but that the time it takes to read the disk page is aCbt,w h e r e aandbare speci\ufb01ed\nconstants and tis the minimum degree for a B-tree using pages of the selected size.\nDescribe how to choose tso as to minimize (approximately) the B-tree search time.\nSuggest an optimal value of tfor the case in which aD5milliseconds and bD10\nmicroseconds.\n18.3 Deleting a key from a B-tree\nDeletion from a B-tree is analogous to insertion but a little more complicated, be-cause we can delete a key from any node\u2014not just a leaf\u2014and when we delete a\nkey from an internal node, we will have to rearrange the node\u2019s children. As in\ninsertion, we must guard against deletion producing a tree whose structure violatesthe B-tree properties. Just as we had to ensure that a node didn\u2019t get too big due toinsertion, we must ensure that a node doesn\u2019t get too small during deletion (exceptthat the root is allowed to have fewer than the minimum number t/NUL1of keys).\nJust as a simple insertion algorithm might have to back up if a node on the pathto where the key was to be inserted was full, a simple approach to deletion mighthave to back up if a node (other than the root) along the path to where the key is tobe deleted has the minimum number of keys.\nThe procedure B-T\nREE-DELETE deletes the key kfrom the subtree rooted at x.\nWe design this procedure to guarantee that whenever it calls itself recursively on anode x, the number of keys in xis at least the minimum degree t. Note that this\ncondition requires one more key than the minimum required by the usual B-tree\nconditions, so that sometimes a key may have to be moved into a child node before\nrecursion descends to that child. This strengthened condition allows us to delete a\nkey from the tree in one downward pass without having to \u201cback up\u201d (with one ex-\nception, which we\u2019ll explain). You should interpret the following speci\ufb01cation for\ndeletion from a B-tree with the understanding that if the root node xever becomes\nan internal node having no keys (this situation can occur in cases 2c and 3b on\npages 501\u2013502), then we delete x,a n d x\u2019s only child x:c\n1becomes the new root\nof the tree, decreasing the height of the tree by one and preserving the property thatthe root of the tree contains at least one key (unless the tree is empty).", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "520": {"page_number": 521, "page_information": "500 Chapter 18 B-Trees\nJK NO DE BAU V YZMG(a)\nC\nRSQ LP\nXT\nFinitial tree\nJK NO DE BAU V YZMG(b)\nC\nRSQ LP\nXTF deleted: case 1\nJK NO DE BAU V YZG(c)\nC\nRSQLP\nXTM deleted: case 2a\nJK NO DE BAU V YZ(d)\nC\nRSQLP\nXTG deleted: case 2c\nFigure 18.8 Deleting keys from a B-tree. The minimum degree for this B-tree is tD3, so a node\n(other than the root) cannot have fewer than 2 keys. Nodes that are modi\ufb01ed are lightly shaded.\n(a)The B-tree of Figure 18.7(e). (b)Deletion of F. This is case 1: simple deletion from a leaf.\n(c)Deletion of M. This is case 2a: the predecessor LofMmoves up to take M\u2019s position. (d)Dele-\ntion of G. This is case 2c: we push Gdown to make node DEGJK and then delete Gfrom this leaf\n(case 1).\nWe sketch how deletion works instead of presenting the pseudocode. Figure 18.8\nillustrates the various cases of deleting keys from a B-tree.\n1. If the key kis in node xandxis a leaf, delete the key kfrom x.\n2. If the key kis in node xandxis an internal node, do the following:", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "521": {"page_number": 522, "page_information": "18.3 Deleting a key from a B-tree 501\nJK NO E BAU V YZ(e)\nC\nRSQLPXTD deleted: case 3b\nJK NO E BAU V YZC\nRSQLP X T\nJK NO AU V YZ C RSQLP X T (f) B deleted: case 3a E(e\u2032) tree shrinks\nin height\nFigure 18.8, continued (e) Deletion of D. This is case 3b: the recursion cannot descend to\nnode CLbecause it has only 2 keys, so we push Pdown and merge it with CLandTXto form\nCLPTX ; then we delete Dfrom a leaf (case 1). (e0)After (e), we delete the root and the tree shrinks\nin height by one. (f)Deletion of B. This is case 3a: Cmoves to \ufb01ll B\u2019s position and Emoves to\n\ufb01llC\u2019s position.\na. If the child ythat precedes kin node xhas at least tkeys, then \ufb01nd the\npredecessor k0ofkin the subtree rooted at y. Recursively delete k0,a n d\nreplace kbyk0inx. (We can \ufb01nd k0and delete it in a single downward\npass.)\nb. If yhas fewer than tkeys, then, symmetrically, examine the child \u00b4that\nfollows kin node x.I f\u00b4has at least tkeys, then \ufb01nd the successor k0ofkin\nthe subtree rooted at \u00b4. Recursively delete k0, and replace kbyk0inx.( W e\ncan \ufb01nd k0and delete it in a single downward pass.)\nc. Otherwise, if both yand\u00b4have only t/NUL1keys, merge kand all of \u00b4intoy,\nso that xloses both kand the pointer to \u00b4,a n d ynow contains 2t/NUL1keys.\nThen free \u00b4and recursively delete kfrom y.\n3. If the key kis not present in internal node x, determine the root x:c iof the\nappropriate subtree that must contain k,i fkis in the tree at all. If x:c ihas\nonlyt/NUL1keys, execute step 3a or 3b as necessary to guarantee that we descend\nto a node containing at least tkeys. Then \ufb01nish by recursing on the appropriate\nchild of x.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "522": {"page_number": 523, "page_information": "502 Chapter 18 B-Trees\na. Ifx:c ihas only t/NUL1keys but has an immediate sibling with at least tkeys,\ngivex:c ian extra key by moving a key from xdown into x:c i,m o v i n ga\nkey from x:c i\u2019s immediate left or right sibling up into x, and moving the\nappropriate child pointer from the sibling into x:c i.\nb. Ifx:c iand both of x:c i\u2019s immediate siblings have t/NUL1keys, merge x:c i\nwith one sibling, which involves moving a key from xdown into the new\nmerged node to become the median key for that node.\nSince most of the keys in a B-tree are in the leaves, we may expect that in\npractice, deletion operations are most often used to delete keys from leaves. The\nB-T REE-DELETE procedure then acts in one downward pass through the tree,\nwithout having to back up. When deleting a key in an internal node, however,the procedure makes a downward pass through the tree but may have to return tothe node from which the key was deleted to replace the key with its predecessor orsuccessor (cases 2a and 2b).\nAlthough this procedure seems complicated, it involves only O.h/ disk oper-\nations for a B-tree of height h, since only O.1/ calls to D\nISK-READ and D ISK-\nWRITE are made between recursive invocations of the procedure. The CPU time\nrequired is O.th/DO.tlogtn/.\nExercises\n18.3-1\nShow the results of deleting C,P,a n d V, in order, from the tree of Figure 18.8(f).\n18.3-2\nWrite pseudocode for B-T REE-DELETE .\nProblems\n18-1 Stacks on secondary storage\nConsider implementing a stack in a computer that has a relatively small amountof fast primary memory and a relatively large amount of slower disk storage. Theoperations P\nUSH and P OPwork on single-word values. The stack we wish to\nsupport can grow to be much larger than can \ufb01t in memory, and thus most of it\nmust be stored on disk.\nA simple, but inef\ufb01cient, stack implementation keeps the entire stack on disk.\nWe maintain in memory a stack pointer, which is the disk address of the top elementon the stack. If the pointer has value p, the top element is the .pmodm/th word\non pagebp=mcof the disk, where mis the number of words per page.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "523": {"page_number": 524, "page_information": "Problems for Chapter 18 503\nTo implement the P USH operation, we increment the stack pointer, read the ap-\npropriate page into memory from disk, copy the element to be pushed to the ap-propriate word on the page, and write the page back to disk. A P\nOPoperation is\nsimilar. We decrement the stack pointer, read in the appropriate page from disk,and return the top of the stack. We need not write back the page, since it was notmodi\ufb01ed.\nBecause disk operations are relatively expensive, we count two costs for any\nimplementation: the total number of disk accesses and the total CPU time. Any\ndisk access to a page of mwords incurs charges of one disk access and \u201a.m/ CPU\ntime.\na.Asymptotically, what is the worst-case number of disk accesses for nstack\noperations using this simple implementation? What is the CPU time for nstack\noperations? (Express your answer in terms of mandnfor this and subsequent\nparts.)\nNow consider a stack implementation in which we keep one page of the stack in\nmemory. (We also maintain a small amount of memory to keep track of which pageis currently in memory.) We can perform a stack operation only if the relevant diskpage resides in memory. If necessary, we can write the page currently in memoryto the disk and read in the new page from the disk to memory. If the relevant diskpage is already in memory, then no disk accesses are required.\nb.What is the worst-case number of disk accesses required for nP\nUSH opera-\ntions? What is the CPU time?\nc.What is the worst-case number of disk accesses required for nstack operations?\nWhat is the CPU time?\nSuppose that we now implement the stack by keeping two pages in memory (in\naddition to a small number of words for bookkeeping).\nd.Describe how to manage the stack pages so that the amortized number of disk\naccesses for any stack operation is O.1=m/ and the amortized CPU time for\nany stack operation is O.1/ .\n18-2 Joining and splitting 2-3-4 trees\nThejoin operation takes two dynamic sets S0andS00a n da ne l e m e n t xsuch that\nfor any x02S0andx002S00,w eh a v e x0:key<x : key<x00:key. It returns a set\nSDS0[fxg[S00.T h esplit operation is like an \u201cinverse\u201d join: given a dynamic\nsetSand an element x2S, it creates a set S0that consists of all elements in\nS/NULfxgwhose keys are less than x:keyand a set S00that consists of all elements\ninS/NULfxgwhose keys are greater than x:key. In this problem, we investigate", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "524": {"page_number": 525, "page_information": "504 Chapter 18 B-Trees\nhow to implement these operations on 2-3-4 trees. We assume for convenience that\nelements consist only of keys and that all key values are distinct.\na.Show how to maintain, for every node xof a 2-3-4 tree, the height of the subtree\nrooted at xas an attribute x:height . Make sure that your implementation does\nnot affect the asymptotic running times of searching, insertion, and deletion.\nb.Show how to implement the join operation. Given two 2-3-4 trees T0andT00\nand a key k, the join operation should run in O.1Cjh0/NULh00j/time, where h0\nandh00are the heights of T0andT00, respectively.\nc.Consider the simple path pfrom the root of a 2-3-4 tree Tto a given key k,\nthe set S0of keys in Tthat are less than k, and the set S00of keys in Tthat are\ngreater than k. Show that pbreaks S0into a set of treesfT0\n0;T0\n1;:::;T0\nmgand a\nset of keysfk0\n1;k0\n2;:::;k0\nmg, where, for iD1 ;2;:::;m ,w eh a v e y<k0\ni<\u00b4\nfor any keys y2T0\ni/NUL1and\u00b42T0\ni. What is the relationship between the heights\nofT0\ni/NUL1andT0\ni? Describe how pbreaks S00into sets of trees and keys.\nd.Show how to implement the split operation on T. Use the join operation to\nassemble the keys in S0into a single 2-3-4 tree T0and the keys in S00into a\nsingle 2-3-4 tree T00. The running time of the split operation should be O.lgn/,\nwhere nis the number of keys in T.(Hint: The costs for joining should tele-\nscope.)\nChapter notes\nKnuth [211], Aho, Hopcroft, and Ullman [5], and Sedgewick [306] give furtherdiscussions of balanced-tree schemes and B-trees. Comer [74] provides a compre-hensive survey of B-trees. Guibas and Sedgewick [155] discuss the relationshipsamong various kinds of balanced-tree schemes, including red-black trees and 2-3-4trees.\nIn 1970, J. E. Hopcroft invented 2-3 trees, a precursor to B-trees and 2-3-4\ntrees, in which every internal node has either two or three children. Bayer andMcCreight [35] introduced B-trees in 1972; they did not explain their choice ofname.\nBender, Demaine, and Farach-Colton [40] studied how to make B-trees perform\nwell in the presence of memory-hierarchy effects. Their cache-oblivious algo-\nrithms work ef\ufb01ciently without explicitly knowing the data transfer sizes within\nthe memory hierarchy.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "525": {"page_number": 526, "page_information": "19 Fibonacci Heaps\nThe Fibonacci heap data structure serves a dual purpose. First, it supports a set of\noperations that constitutes what is known as a \u201cmergeable heap.\u201d Second, severalFibonacci-heap operations run in constant amortized time, which makes this datastructure well suited for applications that invoke these operations frequently.\nMergeable heaps\nAmergeable heap is any data structure that supports the following \ufb01ve operations,\nin which each element has a key:\nM\nAKE-HEAP./creates and returns a new heap containing no elements.\nINSERT .H; x/ inserts element x, whose keyhas already been \ufb01lled in, into heap H.\nMINIMUM .H/ returns a pointer to the element in heap Hwhose key is minimum.\nEXTRACT -MIN.H/ deletes the element from heap Hwhose key is minimum, re-\nturning a pointer to the element.\nUNION .H1;H2/creates and returns a new heap that contains all the elements of\nheaps H1andH2. Heaps H1andH2are \u201cdestroyed\u201d by this operation.\nIn addition to the mergeable-heap operations above, Fibonacci heaps also support\nthe following two operations:\nDECREASE -KEY. H;x;k/ assigns to element xwithin heap Hthe new key\nvalue k, which we assume to be no greater than its current key value.1\nDELETE .H; x/ deletes element xfrom heap H.\n1As mentioned in the introduction to Part V, our default mergeable heaps are mergeable min-\nheaps, and so the operations M INIMUM ,EXTRACT -MIN,a n dD ECREASE -KEYapply. Alterna-\ntively, we could de\ufb01ne a mergeable max-heap with the operations M AXIMUM ,EXTRACT -MAX,\nand I NCREASE -KEY.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "526": {"page_number": 527, "page_information": "506 Chapter 19 Fibonacci Heaps\nBinary heap Fibonacci heap\nProcedure (worst-case) (amortized)\nMAKE-HEAP \u201a.1/ \u201a.1/\nINSERT \u201a.lgn/ \u201a.1/\nMINIMUM \u201a.1/ \u201a.1/\nEXTRACT -MIN \u201a.lgn/ O. lgn/\nUNION \u201a.n/ \u201a.1/\nDECREASE -KEY \u201a.lgn/ \u201a.1/\nDELETE \u201a.lgn/ O. lgn/\nFigure 19.1 Running times for operations on two implementations of mergeable heaps. The num-\nber of items in the heap(s) at the time of an operation is denoted by n.\nAs the table in Figure 19.1 shows, if we don\u2019t need the U NION operation, ordi-\nnary binary heaps, as used in heapsort (Chapter 6), work fairly well. Operationsother than U\nNION run in worst-case time O.lgn/on a binary heap. If we need\nto support the U NION operation, however, binary heaps perform poorly. By con-\ncatenating the two arrays that hold the binary heaps to be merged and then running\nBUILD -MIN-HEAP (see Section 6.3), the U NION operation takes \u201a.n/ time in the\nworst case.\nFibonacci heaps, on the other hand, have better asymptotic time bounds than\nbinary heaps for the I NSERT ,UNION ,a n dD ECREASE -KEYoperations, and they\nhave the same asymptotic running times for the remaining operations. Note, how-ever, that the running times for Fibonacci heaps in Figure 19.1 are amortized timebounds, not worst-case per-operation time bounds. The U\nNION operation takes\nonly constant amortized time in a Fibonacci heap, which is signi\ufb01cantly betterthan the linear worst-case time required in a binary heap (assuming, of course, thatan amortized time bound suf\ufb01ces).\nFibonacci heaps in theory and practice\nFrom a theoretical standpoint, Fibonacci heaps are especially desirable when the\nnumber of E\nXTRACT -MINand D ELETE operations is small relative to the number\nof other operations performed. This situation arises in many applications. For\nexample, some algorithms for graph problems may call D ECREASE -KEYonce per\nedge. For dense graphs, which have many edges, the \u201a.1/ amortized time of each\ncall of D ECREASE -KEYadds up to a big improvement over the \u201a.lgn/worst-case\ntime of binary heaps. Fast algorithms for problems such as computing minimum\nspanning trees (Chapter 23) and \ufb01nding single-source shortest paths (Chapter 24)\nmake essential use of Fibonacci heaps.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "527": {"page_number": 528, "page_information": "19.1 Structure of Fibonacci heaps 507\nFrom a practical point of view, however, the constant factors and program-\nming complexity of Fibonacci heaps make them less desirable than ordinary binary(ork-ary) heaps for most applications, except for certain applications that manage\nlarge amounts of data. Thus, Fibonacci heaps are predominantly of theoretical in-terest. If a much simpler data structure with the same amortized time bounds asFibonacci heaps were developed, it would be of practical use as well.\nBoth binary heaps and Fibonacci heaps are inef\ufb01cient in how they support the\noperation S\nEARCH ; it can take a while to \ufb01nd an element with a given key. For this\nreason, operations such as D ECREASE -KEYand D ELETE that refer to a given ele-\nment require a pointer to that element as part of their input. As in our discussion ofpriority queues in Section 6.5, when we use a mergeable heap in an application, weoften store a handle to the corresponding application object in each mergeable-heapelement, as well as a handle to the corresponding mergeable-heap element in eachapplication object. The exact nature of these handles depends on the applicationand its implementation.\nLike several other data structures that we have seen, Fibonacci heaps are based\non rooted trees. We represent each element by a node within a tree, and each\nnode has a keyattribute. For the remainder of this chapter, we shall use the term\n\u201cnode\u201d instead of \u201celement.\u201d We shall also ignore issues of allocating nodes priorto insertion and freeing nodes following deletion, assuming instead that the codecalling the heap procedures deals with these details.\nSection 19.1 de\ufb01nes Fibonacci heaps, discusses how we represent them, and\npresents the potential function used for their amortized analysis. Section 19.2shows how to implement the mergeable-heap operations and achieve the amortizedtime bounds shown in Figure 19.1. The remaining two operations, D\nECREASE -\nKEYand D ELETE , form the focus of Section 19.3. Finally, Section 19.4 \ufb01nishes a\nkey part of the analysis and also explains the curious name of the data structure.\n19.1 Structure of Fibonacci heaps\nAFibonacci heap is a collection of rooted trees that are min-heap ordered .T h a t\nis, each tree obeys the min-heap property : the key of a node is greater than or equal\nto the key of its parent. Figure 19.2(a) shows an example of a Fibonacci heap.\nAs Figure 19.2(b) shows, each node xcontains a pointer x:pto its parent and\na pointer x:child to any one of its children. The children of xare linked together\nin a circular, doubly linked list, which we call the child list ofx. Each child yin\na child list has pointers y:leftandy:right that point to y\u2019s left and right siblings,\nrespectively. If node yis an only child, then y:leftDy:rightDy. Siblings may\nappear in a child list in any order.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "528": {"page_number": 529, "page_information": "508 Chapter 19 Fibonacci Heaps\n17\n30 26 46\n3524\n18 52 383\n39 4123 7\n17\n30 26 46\n3524\n18 52 383\n39 4123 7(a)\n(b)H:minH:min\nFigure 19.2 (a) A Fibonacci heap consisting of \ufb01ve min-heap-ordered trees and 14 nodes. The\ndashed line indicates the root list. The minimum node of the heap is the node containing the key 3.\nBlack nodes are marked. The potential of this particular Fibonacci heap is 5C2/SOH3D11.(b)Am o r e\ncomplete representation showing pointers p(up arrows), child (down arrows), and leftandright\n(sideways arrows). The remaining \ufb01gures in this chapter omit these details, since all the information\nshown here can be determined from what appears in part (a).\nCircular, doubly linked lists (see Section 10.2) have two advantages for use in\nFibonacci heaps. First, we can insert a node into any location or remove a node\nfrom anywhere in a circular, doubly linked list in O.1/ time. Second, given two\nsuch lists, we can concatenate them (or \u201csplice\u201d them together) into one circular,doubly linked list in O.1/ time. In the descriptions of Fibonacci heap operations,\nwe shall refer to these operations informally, letting you \ufb01ll in the details of theirimplementations if you wish.\nEach node has two other attributes. We store the number of children in the child\nlist of node xinx:degree . The boolean-valued attribute x:mark indicates whether\nnode xhas lost a child since the last time xwas made the child of another node.\nNewly created nodes are unmarked, and a node xbecomes unmarked whenever it\nis made the child of another node. Until we look at the D\nECREASE -KEYoperation\nin Section 19.3, we will just set all mark attributes to FALSE .\nWe access a given Fibonacci heap Hby a pointer H:minto the root of a tree\ncontaining the minimum key; we call this node the minimum node of the Fibonacci", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "529": {"page_number": 530, "page_information": "19.1 Structure of Fibonacci heaps 509\nheap. If more than one root has a key with the minimum value, then any such root\nmay serve as the minimum node. When a Fibonacci heap His empty, H:min\nisNIL.\nThe roots of all the trees in a Fibonacci heap are linked together using their\nleftandright pointers into a circular, doubly linked list called the root list of the\nFibonacci heap. The pointer H:minthus points to the node in the root list whose\nkey is minimum. Trees may appear in any order within a root list.\nWe rely on one other attribute for a Fibonacci heap H:H:n, the number of\nnodes currently in H.\nPotential function\nAs mentioned, we shall use the potential method of Section 17.3 to analyze the\nperformance of Fibonacci heap operations. For a given Fibonacci heap H,w e\nindicate by t.H/ the number of trees in the root list of Hand by m.H/ the number\nof marked nodes in H. We then de\ufb01ne the potential \u02c6.H/ of Fibonacci heap H\nby\n\u02c6.H/Dt.H/C2m . H/: (19.1)\n(We will gain some intuition for this potential function in Section 19.3.) For exam-\nple, the potential of the Fibonacci heap shown in Figure 19.2 is 5C2/SOH3D11.T h e\npotential of a set of Fibonacci heaps is the sum of the potentials of its constituentFibonacci heaps. We shall assume that a unit of potential can pay for a constantamount of work, where the constant is suf\ufb01ciently large to cover the cost of any ofthe speci\ufb01c constant-time pieces of work that we might encounter.\nWe assume that a Fibonacci heap application begins with no heaps. The initial\npotential, therefore, is 0, and by equation (19.1), the potential is nonnegative at\nall subsequent times. From equation (17.3), an upper bound on the total amortizedcost provides an upper bound on the total actual cost for the sequence of operations.\nMaximum degree\nThe amortized analyses we shall perform in the remaining sections of this chapter\nassume that we know an upper bound D.n/ on the maximum degree of any node\nin an n-node Fibonacci heap. We won\u2019t prove it, but when only the mergeable-\nheap operations are supported, D.n//DC4blgnc. (Problem 19-2(d) asks you to prove\nthis property.) In Sections 19.3 and 19.4, we shall show that when we support\nD\nECREASE -KEYand D ELETE as well, D.n/DO.lgn/.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "530": {"page_number": 531, "page_information": "510 Chapter 19 Fibonacci Heaps\n19.2 Mergeable-heap operations\nThe mergeable-heap operations on Fibonacci heaps delay work as long as possible.\nThe various operations have performance trade-offs. For example, we insert a nodeby adding it to the root list, which takes just constant time. If we were to startwith an empty Fibonacci heap and then insert knodes, the Fibonacci heap would\nconsist of just a root list of knodes. The trade-off is that if we then perform\nan E\nXTRACT -MINoperation on Fibonacci heap H, after removing the node that\nH:minpoints to, we would have to look through each of the remaining k/NUL1nodes\nin the root list to \ufb01nd the new minimum node. As long as we have to go throughthe entire root list during the E\nXTRACT -MINoperation, we also consolidate nodes\ninto min-heap-ordered trees to reduce the size of the root list. We shall see that, nomatter what the root list looks like before a E\nXTRACT -MINoperation, afterward\neach node in the root list has a degree that is unique within the root list, which leadsto a root list of size at most D.n/C1.\nCreating a new Fibonacci heap\nTo make an empty Fibonacci heap, the M\nAKE-FIB-HEAP procedure allocates and\nreturns the Fibonacci heap object H,w h e r e H:nD0andH:minDNIL;t h e r e\nare no trees in H. Because t.H/D0andm.H/D0, the potential of the empty\nFibonacci heap is \u02c6.H/D0. The amortized cost of M AKE-FIB-HEAP is thus\nequal to its O.1/ actual cost.\nInserting a node\nThe following procedure inserts node xinto Fibonacci heap H, assuming that the\nnode has already been allocated and that x:keyhas already been \ufb01lled in.\nFIB-HEAP-INSERT .H; x/\n1x:degreeD0\n2x:pDNIL\n3x:childDNIL\n4x:markDFALSE\n5ifH:min ==NIL\n6 create a root list for Hcontaining just x\n7 H:minDx\n8elseinsert xintoH\u2019s root list\n9 ifx:key<H : min:key\n10 H:minDx\n11 nD nC1 H: H:", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "531": {"page_number": 532, "page_information": "19.2 Mergeable-heap operations 511\n(a) (b)17\n3024 23\n26\n3546721\n18 52 38\n39 413 17\n3024 23\n26\n35467\n18 52 38\n39 413H:min H:min\nFigure 19.3 Inserting a node into a Fibonacci heap. (a)A Fibonacci heap H.(b)Fibonacci heap H\nafter inserting the node with key 21. The node becomes its own min-heap-ordered tree and is then\nadded to the root list, becoming the left sibling of the root.\nLines 1\u20134 initialize some of the structural attributes of node x. Line 5 tests to see\nwhether Fibonacci heap His empty. If it is, then lines 6\u20137 make xbe the only\nnode in H\u2019s root list and set H:minto point to x. Otherwise, lines 8\u201310 insert x\nintoH\u2019s root list and update H:minif necessary. Finally, line 11 increments H:n\nto re\ufb02ect the addition of the new node. Figure 19.3 shows a node with key 21\ninserted into the Fibonacci heap of Figure 19.2.\nTo determine the amortized cost of F IB-HEAP-INSERT ,l e tHbe the input Fi-\nbonacci heap and H0be the resulting Fibonacci heap. Then, t.H0/Dt.H/C1\nandm.H0/Dm.H/ , and the increase in potential is\n..t.H/C1/C2 m.H///NUL.t.H/C2 m.H//D1:\nSince the actual cost is O.1/ , the amortized cost is O.1/C1DO.1/ .\nFinding the minimum node\nThe minimum node of a Fibonacci heap His given by the pointer H:min,s ow e\ncan \ufb01nd the minimum node in O.1/ actual time. Because the potential of Hdoes\nnot change, the amortized cost of this operation is equal to its O.1/ actual cost.\nUniting two Fibonacci heaps\nThe following procedure unites Fibonacci heaps H1andH2, destroying H1andH2\nin the process. It simply concatenates the root lists of H1andH2and then deter-\nmines the new minimum node. Afterward, the objects representing H1andH2will\nnever be used again.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "532": {"page_number": 533, "page_information": "512 Chapter 19 Fibonacci Heaps\nFIB-HEAP-UNION .H1;H2/\n1HDMAKE-FIB-HEAP./\n2H:minDH1:min\n3 concatenate the root list of H2with the root list of H\n4if.H1:min ==NIL/or.H2:min\u00a4NILandH2:min:key<H 1:min:key/\n5 H:minDH2:min\n6H:nDH1:nCH2:n\n7return H\nLines 1\u20133 concatenate the root lists of H1andH2into a new root list H.L i n e s\n2, 4, and 5 set the minimum node of H, and line 6 sets H:nto the total number\nof nodes. Line 7 returns the resulting Fibonacci heap H.A s i n t h e F IB-HEAP-\nINSERT procedure, all roots remain roots.\nThe change in potential is\n\u02c6.H//NUL.\u02c6.H 1/C\u02c6.H 2//\nD.t.H/C2 m.H///NUL..t.H 1/C2m . H 1//C.t.H 2/C2m . H 2///\nD0;\nbecause t.H/Dt.H 1/Ct.H 2/andm.H/Dm.H 1/Cm.H 2/. The amortized\ncost of F IB-HEAP-UNION is therefore equal to its O.1/ actual cost.\nExtracting the minimum node\nThe process of extracting the minimum node is the most complicated of the oper-\nations presented in this section. It is also where the delayed work of consolidatingtrees in the root list \ufb01nally occurs. The following pseudocode extracts the mini-mum node. The code assumes for convenience that when a node is removed froma linked list, pointers remaining in the list are updated, but pointers in the extracted\nnode are left unchanged. It also calls the auxiliary procedure C\nONSOLIDATE ,\nwhich we shall see shortly.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "533": {"page_number": 534, "page_information": "19.2 Mergeable-heap operations 513\nFIB-HEAP-EXTRACT -MIN.H/\n1\u00b4DH:min\n2if\u00b4\u00a4NIL\n3 foreach child xof\u00b4\n4a d d xto the root list of H\n5 x:pDNIL\n6 remove \u00b4from the root list of H\n7 if\u00b4==\u00b4:right\n8 H:minDNIL\n9 elseH:minD\u00b4:right\n10 C ONSOLIDATE .H/\n11 H:nDH:n/NUL1\n12return \u00b4\nAs Figure 19.4 illustrates, F IB-HEAP-EXTRACT -MINworks by \ufb01rst making a root\nout of each of the minimum node\u2019s children and removing the minimum node fromthe root list. It then consolidates the root list by linking roots of equal degree untilat most one root remains of each degree.\nWe start in line 1 by saving a pointer \u00b4to the minimum node; the procedure\nreturns this pointer at the end. If \u00b4is\nNIL, then Fibonacci heap His already empty\nand we are done. Otherwise, we delete node \u00b4from Hby making all of \u00b4\u2019s chil-\ndren roots of Hin lines 3\u20135 (putting them into the root list) and removing \u00b4from\nthe root list in line 6. If \u00b4is its own right sibling after line 6, then \u00b4was the\nonly node on the root list and it had no children, so all that remains is to make\nthe Fibonacci heap empty in line 8 before returning \u00b4. Otherwise, we set the\npointer H:mininto the root list to point to a root other than \u00b4(in this case, \u00b4\u2019s\nright sibling), which is not necessarily going to be the new minimum node when\nFIB-HEAP-EXTRACT -MINis done. Figure 19.4(b) shows the Fibonacci heap of\nFigure 19.4(a) after executing line 9.\nThe next step, in which we reduce the number of trees in the Fibonacci heap, is\nconsolidating the root list of H, which the call C ONSOLIDATE .H/ accomplishes.\nConsolidating the root list consists of repeatedly executing the following steps untilevery root in the root list has a distinct degree value:\n1. Find two roots xandyin the root list with the same degree. Without loss of\ngenerality, let x:key/DC4y:key.\n2.Link ytox: remove yfrom the root list, and make ya child of xby calling the\nF\nIB-HEAP-LINKprocedure. This procedure increments the attribute x:degree\nand clears the mark on y.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "534": {"page_number": 535, "page_information": "514 Chapter 19 Fibonacci Heaps\nA0123\nA0123\nA0123\nA0123A0123A0123\n(c) (d)\n(e)\n17\n3024 23\n26\n3546717\n3024 23\n26\n3546721\n18 52 38\n39 41(a) 3 (b)\n(f)\n(g) 2118 52 38\n39 41(h)17\n3024 23\n26\n354672118 52 38\n39 41\n17\n3024 23\n26\n354672118 52 38\n39 4117\n3024 23\n26\n354672118 52 38\n39 41\n17\n3024 23\n26\n354672118 52 38\n39 4117\n3024\n23 26\n354672118 52 38\n39 41\n17\n3024\n23 26\n35467 2118 52 38\n39 41w,x w,x\nw,x w,x\nw,x w,xH:min H:min\nFigure 19.4 The action of F IB-HEAP-EXTRACT -MIN.(a)A Fibonacci heap H.(b)The situa-\ntion after removing the minimum node \u00b4from the root list and adding its children to the root list.\n(c)\u2013(e) The array Aand the trees after each of the \ufb01rst three iterations of the forloop of lines 4\u201314 of\nthe procedure C ONSOLIDATE . The procedure processes the root list by starting at the node pointed\nto by H:minand following right pointers. Each part shows the values of wandxat the end of an\niteration. (f)\u2013(h) The next iteration of the forloop, with the values of wandxs h o w na tt h ee n do f\neach iteration of the while loop of lines 7\u201313. Part (f) shows the situation after the \ufb01rst time through\nthewhile loop. The node with key 23has been linked to the node with key 7,w h i c h xnow points to.\nIn part (g), the node with key 17has been linked to the node with key 7,w h i c h xstill points to. In\npart (h), the node with key 24has been linked to the node with key 7. Since no node was previously\npointed to by A\u01523/c141, at the end of the forloop iteration, A\u01523/c141 is set to point to the root of the resulting\ntree.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "535": {"page_number": 536, "page_information": "19.2 Mergeable-heap operations 515\nA0123\nA0123A0123\nA0123\n17\n3024 23\n26\n35467 21 18 52 38\n39 41(i)\n17\n3024 23\n26\n35467 21 18 52 38\n39 41(j)\n17\n3024 23\n26\n35467 38\n41(k)\n2118\n5239 17\n3024 23\n26\n35467 38\n41(l)\n2118\n5239\n17\n3024 23\n26\n35467 38\n41(m)\n2118\n5239w,x w,x\nx w,x\nw\nH:min\nFigure 19.4, continued (i)\u2013(l) The situation after each of the next four iterations of the forloop.\n(m)Fibonacci heap Hafter reconstructing the root list from the array Aand determining the new\nH:minpointer.\nThe procedure C ONSOLIDATE uses an auxiliary array A\u01520 : : D.H: n//c141to keep\ntrack of roots according to their degrees. If A\u0152i/c141Dy,t h e n yis currently a root\nwithy:degreeDi. Of course, in order to allocate the array we have to know how\nto calculate the upper bound D.H: n/on the maximum degree, but we will see how\nto do so in Section 19.4.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "536": {"page_number": 537, "page_information": "516 Chapter 19 Fibonacci Heaps\nCONSOLIDATE .H/\n1l e t A\u01520 : : D.H: n//c141b ean e wa r r a y\n2foriD0toD.H: n/\n3 A\u0152i/c141DNIL\n4foreach node win the root list of H\n5 xDw\n6 dDx:degree\n7 while A\u0152d/c141\u00a4NIL\n8 yDA\u0152d/c141 //another node with the same degree as x\n9 ifx:key>y : key\n10 exchange xwithy\n11 F IB-HEAP-LINK. H;y;x/\n12 A\u0152d/c141DNIL\n13 dDdC1\n14 A\u0152d/c141Dx\n15H:minDNIL\n16foriD0toD.H: n/\n17 ifA\u0152i/c141\u00a4NIL\n18 ifH:min ==NIL\n19 create a root list for Hcontaining just A\u0152i/c141\n20 H:minDA\u0152i/c141\n21 elseinsert A\u0152i/c141 intoH\u2019s root list\n22 ifA\u0152i/c141: key<H : min:key\n23 H:minDA\u0152i/c141\nFIB-HEAP-LINK. H;y;x/\n1 remove yfrom the root list of H\n2m a k e ya child of x, incrementing x:degree\n3y:markDFALSE\nIn detail, the C ONSOLIDATE procedure works as follows. Lines 1\u20133 allocate\nand initialize the array Aby making each entry NIL.T h e forloop of lines 4\u201314\nprocesses each root win the root list. As we link roots together, wmay be linked\nto some other node and no longer be a root. Nevertheless, wis always in a tree\nrooted at some node x, which may or may not be witself. Because we want at\nmost one root with each degree, we look in the array Ato see whether it contains\na root ywith the same degree as x. If it does, then we link the roots xandybut\nguaranteeing that xremains a root after linking. That is, we link ytoxafter \ufb01rst\nexchanging the pointers to the two roots if y\u2019s key is smaller than x\u2019s key. After\nwe link ytox, the degree of xhas increased by 1, and so we continue this process,\nlinking xand another root whose degree equals x\u2019s new degree, until no other root", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "537": {"page_number": 538, "page_information": "19.2 Mergeable-heap operations 517\nthat we have processed has the same degree as x. We then set the appropriate entry\nofAto point to x, so that as we process roots later on, we have recorded that xis\nthe unique root of its degree that we have already processed. When this forloop\nterminates, at most one root of each degree will remain, and the array Awill point\nto each remaining root.\nThewhile loop of lines 7\u201313 repeatedly links the root xof the tree containing\nnode wto another tree whose root has the same degree as x, until no other root has\nthe same degree. This while loop maintains the following invariant:\nAt the start of each iteration of the while loop, dDx:degree .\nWe use this loop invariant as follows:\nInitialization: Line 6 ensures that the loop invariant holds the \ufb01rst time we enter\nthe loop.\nMaintenance: In each iteration of the while loop, A\u0152d/c141 points to some root y.\nBecause dDx:degreeDy:degree , we want to link xandy. Whichever of\nxandyhas the smaller key becomes the parent of the other as a result of the\nlink operation, and so lines 9\u201310 exchange the pointers to xandyif necessary.\nNext, we link ytoxby the call F IB-HEAP-LINK. H;y;x/ in line 11. This\ncall increments x:degree but leaves y:degree asd. Node yis no longer a root,\nand so line 12 removes the pointer to it in array A. Because the call of F IB-\nHEAP-LINK increments the value of x:degree , line 13 restores the invariant\nthatdDx:degree .\nTermination: We repeat the while loop until A\u0152d/c141DNIL, in which case there is\nno other root with the same degree as x.\nAfter the while loop terminates, we set A\u0152d/c141 toxin line 14 and perform the next\niteration of the forloop.\nFigures 19.4(c)\u2013(e) show the array Aand the resulting trees after the \ufb01rst three\niterations of the forloop of lines 4\u201314. In the next iteration of the forloop, three\nlinks occur; their results are shown in Figures 19.4(f)\u2013(h). Figures 19.4(i)\u2013(l) showthe result of the next four iterations of the forloop.\nAll that remains is to clean up. Once the forloop of lines 4\u201314 completes,\nline 15 empties the root list, and lines 16\u201323 reconstruct it from the array A.T h e\nresulting Fibonacci heap appears in Figure 19.4(m). After consolidating the rootlist, F\nIB-HEAP-EXTRACT -MIN\ufb01nishes up by decrementing H:nin line 11 and\nreturning a pointer to the deleted node \u00b4in line 12.\nWe are now ready to show that the amortized cost of extracting the minimum\nnode of an n-node Fibonacci heap is O.D.n// .L e t Hdenote the Fibonacci heap\njust prior to the F IB-HEAP-EXTRACT -MINoperation.\nWe start by accounting for the actual cost of extracting the minimum node.\nAnO.D.n// contribution comes from F IB-HEAP-EXTRACT -MINprocessing at", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "538": {"page_number": 539, "page_information": "518 Chapter 19 Fibonacci Heaps\nmost D.n/ children of the minimum node and from the work in lines 2\u20133 and\n16\u201323 of C ONSOLIDATE . It remains to analyze the contribution from the forloop\nof lines 4\u201314 in C ONSOLIDATE , for which we use an aggregate analysis. The size\nof the root list upon calling C ONSOLIDATE is at most D.n/Ct.H//NUL1, since it\nconsists of the original t.H/ root-list nodes, minus the extracted root node, plus\nthe children of the extracted node, which number at most D.n/ . Within a given\niteration of the forloop of lines 4\u201314, the number of iterations of the while loop of\nlines 7\u201313 depends on the root list. But we know that every time through the while\nloop, one of the roots is linked to another, and thus the total number of iterations\nof the while loop over all iterations of the forloop is at most the number of roots\nin the root list. Hence, the total amount of work performed in the forloop is at\nmost proportional to D.n/Ct.H/ . Thus, the total actual work in extracting the\nminimum node is O.D.n/Ct.H// .\nThe potential before extracting the minimum node is t.H/C2m . H/ ,a n dt h e\npotential afterward is at most .D.n/C1/C2m . H/ , since at most D.n/C1roots\nremain and no nodes become marked during the operation. The amortized cost is\nthus at most\nO.D.n/Ct.H//C..D.n/C1/C2 m.H///NUL.t.H/C2 m.H//\nDO.D.n//CO.t.H///NULt.H/\nDO.D.n// ;\nsince we can scale up the units of potential to dominate the constant hidden\ninO.t.H// . Intuitively, the cost of performing each link is paid for by the re-\nduction in potential due to the link\u2019s reducing the number of roots by one. We shallsee in Section 19.4 that D.n/DO.lgn/, so that the amortized cost of extracting\nthe minimum node is O.lgn/.\nExercises\n19.2-1\nShow the Fibonacci heap that results from calling F\nIB-HEAP-EXTRACT -MINon\nthe Fibonacci heap shown in Figure 19.4(m).\n19.3 Decreasing a key and deleting a node\nIn this section, we show how to decrease the key of a node in a Fibonacci heapinO.1/ amortized time and how to delete any node from an n-node Fibonacci\nheap in O.D.n// amortized time. In Section 19.4, we will show that the maxi-", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "539": {"page_number": 540, "page_information": "19.3 Decreasing a key and deleting a node 519\nmum degree D.n/ isO.lgn/, which will imply that F IB-HEAP-EXTRACT -MIN\nand F IB-HEAP-DELETE run in O.lgn/amortized time.\nDecreasing a key\nIn the following pseudocode for the operation F IB-HEAP-DECREASE -KEY,w e\nassume as before that removing a node from a linked list does not change any ofthe structural attributes in the removed node.\nF\nIB-HEAP-DECREASE -KEY. H;x;k/\n1ifk>x : key\n2 error \u201cnew key is greater than current key\u201d\n3x:keyDk\n4yDx:p\n5ify\u00a4NILandx:key<y : key\n6C UT. H;x;y/\n7C ASCADING -CUT.H; y/\n8ifx:key<H : min:key\n9 H:minDx\nCUT. H;x;y/\n1 remove xfrom the child list of y, decrementing y:degree\n2a d d xto the root list of H\n3x:pDNIL\n4x:markDFALSE\nCASCADING -CUT.H; y/\n1\u00b4Dy:p\n2if\u00b4\u00a4NIL\n3 ify:mark ==FALSE\n4 y:markDTRUE\n5 elseCUT. H;y;\u00b4 /\n6C ASCADING -CUT.H; \u00b4/\nThe F IB-HEAP-DECREASE -KEYprocedure works as follows. Lines 1\u20133 ensure\nthat the new key is no greater than the current key of xand then assign the new key\ntox.I fxis a root or if x:key/NAKy:key,w h e r e yisx\u2019s parent, then no structural\nchanges need occur, since min-heap order has not been violated. Lines 4\u20135 test forthis condition.\nIf min-heap order has been violated, many changes may occur. We start by\ncutting xin line 6. The C\nUTprocedure \u201ccuts\u201d the link between xand its parent y,\nmaking xa root.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "540": {"page_number": 541, "page_information": "520 Chapter 19 Fibonacci Heaps\nWe use the mark attributes to obtain the desired time bounds. They record a little\npiece of the history of each node. Suppose that the following events have happenedto node x:\n1. at some time, xw a sar o o t ,\n2. then xwas linked to (made the child of) another node,\n3. then two children of xwere removed by cuts.\nAs soon as the second child has been lost, we cut xfrom its parent, making it a new\nroot. The attribute x:mark is\nTRUE if steps 1 and 2 have occurred and one child\nofxhas been cut. The C UTprocedure, therefore, clears x:mark in line 4, since it\nperforms step 1. (We can now see why line 3 of F IB-HEAP-LINK clears y:mark :\nnode yis being linked to another node, and so step 2 is being performed. The next\ntime a child of yis cut, y:mark will be set to TRUE .)\nWe are not yet done, because xmight be the second child cut from its parent y\nsince the time that ywas linked to another node. Therefore, line 7 of F IB-HEAP-\nDECREASE -KEYattempts to perform a cascading-cut operation on y.I fyis a\nroot, then the test in line 2 of C ASCADING -CUTcauses the procedure to just return.\nIfyis unmarked, the procedure marks it in line 4, since its \ufb01rst child has just been\ncut, and returns. If yis marked, however, it has just lost its second child; yis cut\nin line 5, and C ASCADING -CUTcalls itself recursively in line 6 on y\u2019s parent \u00b4.\nThe C ASCADING -CUTprocedure recurses its way up the tree until it \ufb01nds either a\nroot or an unmarked node.\nOnce all the cascading cuts have occurred, lines 8\u20139 of F IB-HEAP-DECREASE -\nKEY\ufb01nish up by updating H:minif necessary. The only node whose key changed\nwas the node xwhose key decreased. Thus, the new minimum node is either the\noriginal minimum node or node x.\nFigure 19.5 shows the execution of two calls of F IB-HEAP-DECREASE -KEY,\nstarting with the Fibonacci heap shown in Figure 19.5(a). The \ufb01rst call, shownin Figure 19.5(b), involves no cascading cuts. The second call, shown in Fig-ures 19.5(c)\u2013(e), invokes two cascading cuts.\nWe shall now show that the amortized cost of F\nIB-HEAP-DECREASE -KEYis\nonlyO.1/ . We start by determining its actual cost. The F IB-HEAP-DECREASE -\nKEYprocedure takes O.1/ time, plus the time to perform the cascading cuts. Sup-\npose that a given invocation of F IB-HEAP-DECREASE -KEYresults in ccalls of\nCASCADING -CUT(the call made from line 7 of F IB-HEAP-DECREASE -KEYfol-\nlowed by c/NUL1recursive calls of C ASCADING -CUT). Each call of C ASCADING -\nCUTtakes O.1/ time exclusive of recursive calls. Thus, the actual cost of F IB-\nHEAP-DECREASE -KEY, including all recursive calls, is O.c/ .\nWe next compute the change in potential. Let Hdenote the Fibonacci heap just\nprior to the F IB-HEAP-DECREASE -KEYoperation. The call to C UTin line 6 of", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "541": {"page_number": 542, "page_information": "19.3 Decreasing a key and deleting a node 521\n17\n3024 23\n26\n3515 7\n2118\n5238\n39 41(b)\n17\n3024 23\n265 15 7\n2118\n5238\n39 41(c)\n17\n3024 23265 15 7\n2118\n5238\n39 41(d)\n17\n3024\n23265 15 7\n2118\n5238\n39 41(e)17\n3024 23\n26\n35467\n2118\n5238\n39 41(a)H:min\nH:minH:min H:minH:min\nFigure 19.5 Two calls of F IB-HEAP-DECREASE -KEY.(a)The initial Fibonacci heap. (b)The\nnode with key 46has its key decreased to 15. The node becomes a root, and its parent (with key 24),\nwhich had previously been unmarked, becomes marked. (c)\u2013(e) The node with key 35has its key\ndecreased to 5. In part (c), the node, now with key 5, becomes a root. Its parent, with key 26,\nis marked, so a cascading cut occurs. The node with key 26is cut from its parent and made an\nunmarked root in (d). Another cascading cut occurs, since the node with key 24is marked as well.\nThis node is cut from its parent and made an unmarked root in part (e). The cascading cuts stop\nat this point, since the node with key 7is a root. (Even if this node were not a root, the cascading\ncuts would stop, since it is unmarked.) Part (e) shows the result of the F IB-HEAP-DECREASE -KEY\noperation, with H:minpointing to the new minimum node.\nFIB-HEAP-DECREASE -KEYcreates a new tree rooted at node xand clears x\u2019s\nmark bit (which may have already been FALSE ). Each call of C ASCADING -CUT,\nexcept for the last one, cuts a marked node and clears the mark bit. Afterward, theFibonacci heap contains t.H/Cctrees (the original t.H/ trees, c/NUL1trees produced\nby cascading cuts, and the tree rooted at x) and at most m.H//NULcC2marked nodes\n(c/NUL1were unmarked by cascading cuts and the last call of C\nASCADING -CUTmay\nhave marked a node). The change in potential is therefore at most\n..t.H/Cc/C2.m.H//NULcC2///NUL.t.H/C2 m.H//D4/NULc:", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "542": {"page_number": 543, "page_information": "522 Chapter 19 Fibonacci Heaps\nThus, the amortized cost of F IB-HEAP-DECREASE -KEYis at most\nO.c/C4/NULcDO.1/ ;\nsince we can scale up the units of potential to dominate the constant hidden in O.c/ .\nYou can now see why we de\ufb01ned the potential function to include a term that is\ntwice the number of marked nodes. When a marked node yis cut by a cascading\ncut, its mark bit is cleared, which reduces the potential by 2. One unit of potential\npays for the cut and the clearing of the mark bit, and the other unit compensates\nfor the unit increase in potential due to node ybecoming a root.\nDeleting a node\nThe following pseudocode deletes a node from an n-node Fibonacci heap in\nO.D.n// amortized time. We assume that there is no key value of /NUL1 currently\nin the Fibonacci heap.\nFIB-HEAP-DELETE .H; x/\n1F IB-HEAP-DECREASE -KEY.H; x;/NUL1/\n2F IB-HEAP-EXTRACT -MIN.H/\nFIB-HEAP-DELETE makes xbecome the minimum node in the Fibonacci heap by\ngiving it a uniquely small key of /NUL1.T h eF IB-HEAP-EXTRACT -MINprocedure\nthen removes node xfrom the Fibonacci heap. The amortized time of F IB-HEAP-\nDELETE is the sum of the O.1/ amortized time of F IB-HEAP-DECREASE -KEY\nand the O.D.n// amortized time of F IB-HEAP-EXTRACT -MIN. Since we shall see\nin Section 19.4 that D.n/DO.lgn/, the amortized time of F IB-HEAP-DELETE\nisO.lgn/.\nExercises\n19.3-1\nSuppose that a root xin a Fibonacci heap is marked. Explain how xcame to be\na marked root. Argue that it doesn\u2019t matter to the analysis that xis marked, even\nthough it is not a root that was \ufb01rst linked to another node and then lost one child.\n19.3-2\nJustify the O.1/ amortized time of F IB-HEAP-DECREASE -KEYas an average cost\nper operation by using aggregate analysis.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "543": {"page_number": 544, "page_information": "19.4 Bounding the maximum degree 523\n19.4 Bounding the maximum degree\nTo prove that the amortized time of F IB-HEAP-EXTRACT -MINand F IB-HEAP-\nDELETE isO.lgn/, we must show that the upper bound D.n/ on the degree of\nany node of an n-node Fibonacci heap is O.lgn/. In particular, we shall show that\nD.n//DC4/EOT\nlog/RSn\u02d8\n,w h e r e /RSis the golden ratio, de\ufb01ned in equation (3.24) as\n/RSD.1Cp\n5/=2D1:61803 : : : :\nThe key to the analysis is as follows. For each node xwithin a Fibonacci heap,\nde\ufb01ne size .x/to be the number of nodes, including xitself, in the subtree rooted\natx. (Note that xneed not be in the root list\u2014it can be any node at all.) We shall\nshow that size .x/is exponential in x:degree . Bear in mind that x:degree is always\nmaintained as an accurate count of the degree of x.\nLemma 19.1\nLetxbe any node in a Fibonacci heap, and suppose that x:degreeDk.L e t\ny1;y2;:::;y kdenote the children of xin the order in which they were linked to x,\nfrom the earliest to the latest. Then, y1:degree/NAK0andyi:degree/NAKi/NUL2for\niD2;3 ;:::;k .\nProof Obviously, y1:degree/NAK0.\nFori/NAK2, we note that when yiwas linked to x,a l lo f y1;y2;:::;y i/NUL1were\nchildren of x, and so we must have had x:degree/NAKi/NUL1. Because node yiis\nlinked to x(by C ONSOLIDATE ) only if x:degreeDyi:degree ,w em u s th a v ea l s o\nhadyi:degree/NAKi/NUL1at that time. Since then, node yihas lost at most one\nchild, since it would have been cut from x(by C ASCADING -CUT) if it had lost\ntwo children. We conclude that yi:degree/NAKi/NUL2.\nWe \ufb01nally come to the part of the analysis that explains the name \u201cFibonacci\nheaps.\u201d Recall from Section 3.2 that for kD0; 1; 2; : : : ,t h ekth Fibonacci number\nis de\ufb01ned by the recurrence\nFkD/c128\n0 ifkD0;\n1 ifkD1;\nFk/NUL1CFk/NUL2ifk/NAK2:\nThe following lemma gives another way to express Fk.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "544": {"page_number": 545, "page_information": "524 Chapter 19 Fibonacci Heaps\nLemma 19.2\nFor all integers k/NAK0,\nFkC2D1CkX\niD0Fi:\nProof The proof is by induction on k.W h e n kD0,\n1C0X\niD0FiD1CF0\nD1C0\nDF2:\nWe now assume the inductive hypothesis that FkC1D1CPk/NUL1\niD0Fi,a n dw e\nhave\nFkC2DFkCFkC1\nDFkC \n1Ck/NUL1X\niD0Fi!\nD1CkX\niD0Fi:\nLemma 19.3\nFor all integers k/NAK0,t h e.kC2/nd Fibonacci number satis\ufb01es FkC2/NAK/RSk.\nProof The proof is by induction on k. The base cases are for kD0andkD1.\nWhen kD0we have F2D1D/RS0,a n dw h e n kD1we have F3D2>\n1:619 > /RS1. The inductive step is for k/NAK2, and we assume that FiC2>/RSifor\niD0; 1; : : : ; k/NUL1. Recall that /RSis the positive root of equation (3.23), x2DxC1.\nThus, we have\nFkC2DFkC1CFk\n/NAK/RSk/NUL1C/RSk/NUL2(by the inductive hypothesis)\nD/RSk/NUL2./RSC1/\nD/RSk/NUL2/SOH/RS2(by equation (3.23))\nD/RSk:\nThe following lemma and its corollary complete the analysis.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "545": {"page_number": 546, "page_information": "19.4 Bounding the maximum degree 525\nLemma 19.4\nLetxbe any node in a Fibonacci heap, and let kDx:degree .T h e n s i z e .x//NAK\nFkC2/NAK/RSk,w h e r e /RSD.1Cp\n5/=2 .\nProof Letskdenote the minimum possible size of any node of degree kin any\nFibonacci heap. Trivially, s0D1ands1D2. The number skis at most size .x/\nand, because adding children to a node cannot decrease the node\u2019s size, the valueofs\nkincreases monotonically with k. Consider some node \u00b4, in any Fibonacci\nheap, such that \u00b4:degreeDkand size .\u00b4/Dsk. Because sk/DC4size.x/,w e\ncompute a lower bound on size .x/by computing a lower bound on sk.A s i n\nLemma 19.1, let y1;y2;:::;y kdenote the children of \u00b4in the order in which they\nwere linked to \u00b4. To bound sk, we count one for \u00b4itself and one for the \ufb01rst child y1\n(for which size .y1//NAK1), giving\nsize.x//NAKsk\n/NAK2CkX\niD2syi:degree\n/NAK2CkX\niD2si/NUL2;\nwhere the last line follows from Lemma 19.1 (so that yi:degree/NAKi/NUL2)a n dt h e\nmonotonicity of sk(so that syi:degree/NAKsi/NUL2).\nWe now show by induction on kthatsk/NAKFkC2for all nonnegative integers k.\nThe bases, for kD0andkD1, are trivial. For the inductive step, we assume that\nk/NAK2and that si/NAKFiC2foriD0; 1; : : : ; k/NUL1.W eh a v e\nsk/NAK2CkX\niD2si/NUL2\n/NAK2CkX\niD2Fi\nD1CkX\niD0Fi\nDFkC2 (by Lemma 19.2)\n/NAK/RSk(by Lemma 19.3) .\nThus, we have shown that size .x//NAKsk/NAKFkC2/NAK/RSk.\n", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "546": {"page_number": 547, "page_information": "526 Chapter 19 Fibonacci Heaps\nCorollary 19.5\nThe maximum degree D.n/ of any node in an n-node Fibonacci heap is O.lgn/.\nProof Letxbe any node in an n-node Fibonacci heap, and let kDx:degree .\nBy Lemma 19.4, we have n/NAKsize.x//NAK/RSk. Taking base- /RSlogarithms gives\nusk/DC4log/RSn. (In fact, because kis an integer, k/DC4/EOT\nlog/RSn\u02d8\n.) The maximum\ndegree D.n/ of any node is thus O.lgn/.\nExercises\n19.4-1\nProfessor Pinocchio claims that the height of an n-node Fibonacci heap is O.lgn/.\nShow that the professor is mistaken by exhibiting, for any positive integer n,a\nsequence of Fibonacci-heap operations that creates a Fibonacci heap consisting ofjust one tree that is a linear chain of nnodes.\n19.4-2\nSuppose we generalize the cascading-cut rule to cut a node xfrom its parent as\nsoon as it loses its kth child, for some integer constant k. (The rule in Section 19.3\nuseskD2.) For what values of kisD.n/DO.lgn/?\nProblems\n19-1 Alternative implementation of deletion\nProfessor Pisano has proposed the following variant of the F IB-HEAP-DELETE\nprocedure, claiming that it runs faster when the node being deleted is not the nodepointed to by H:min.\nP\nISANO -DELETE .H; x/\n1ifx==H:min\n2F IB-HEAP-EXTRACT -MIN.H/\n3elseyDx:p\n4 ify\u00a4NIL\n5C UT. H;x;y/\n6C ASCADING -CUT.H; y/\n7a d d x\u2019s child list to the root list of H\n8 remove xfrom the root list of H", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "547": {"page_number": 548, "page_information": "Problems for Chapter 19 527\na.The professor\u2019s claim that this procedure runs faster is based partly on the as-\nsumption that line 7 can be performed in O.1/ actual time. What is wrong with\nthis assumption?\nb.Give a good upper bound on the actual time of P ISANO -DELETE when xis\nnotH:min. Your bound should be in terms of x:degree and the number cof\ncalls to the C ASCADING -CUTprocedure.\nc.Suppose that we call P ISANO -DELETE .H; x/ ,a n dl e t H0be the Fibonacci heap\nthat results. Assuming that node xis not a root, bound the potential of H0in\nterms of x:degree ,c,t.H/ ,a n d m.H/ .\nd.Conclude that the amortized time for P ISANO -DELETE is asymptotically no\nbetter than for F IB-HEAP-DELETE ,e v e nw h e n x\u00a4H:min.\n19-2 Binomial trees and binomial heaps\nThebinomial tree Bkis an ordered tree (see Section B.5.2) de\ufb01ned recursively.\nAs shown in Figure 19.6(a), the binomial tree B0consists of a single node. The\nbinomial tree Bkconsists of two binomial trees Bk/NUL1that are linked together so\nthat the root of one is the leftmost child of the root of the other. Figure 19.6(b)shows the binomial trees B\n0through B4.\na.Show that for the binomial tree Bk,\n1. there are 2knodes,\n2. the height of the tree is k,\n3. there are exactly/NULk\ni/SOH\nnodes at depth iforiD0; 1; : : : ; k ,a n d\n4. the root has degree k, which is greater than that of any other node; moreover,\nas Figure 19.6(c) shows, if we number the children of the root from left toright by k/NUL1; k/NUL2;:::;0 , then child iis the root of a subtree B\ni.\nAbinomial heap His a set of binomial trees that satis\ufb01es the following proper-\nties:\n1. Each node has a key(like a Fibonacci heap).\n2. Each binomial tree in Hobeys the min-heap property.\n3. For any nonnegative integer k, there is at most one binomial tree in Hwhose\nroot has degree k.\nb.Suppose that a binomial heap Hhas a total of nnodes. Discuss the relationship\nbetween the binomial trees that Hcontains and the binary representation of n.\nConclude that Hconsists of at mostblgncC1binomial trees.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "548": {"page_number": 549, "page_information": "528 Chapter 19 Fibonacci Heaps\nB4\nBk\u20131Bk\u20132\nBkB2B1B0B3 B2 B1 B0BkBk\u20131Bk\u20131\nB0(a)\ndepth\n0\n1\n2\n3\n4(b)\n(c)\nFigure 19.6 (a) The recursive de\ufb01nition of the binomial tree Bk. Triangles represent rooted sub-\ntrees. (b)The binomial trees B0through B4. Node depths in B4are shown. (c)Another way of\nlooking at the binomial tree Bk.\nSuppose that we represent a binomial heap as follows. The left-child, right-\nsibling scheme of Section 10.4 represents each binomial tree within a binomialheap. Each node contains its key; pointers to its parent, to its leftmost child, andto the sibling immediately to its right (these pointers are\nNILwhen appropriate);\nand its degree (as in Fibonacci heaps, how many children it has). The roots form asingly linked root list, ordered by the degrees of the roots (from low to high), and\nwe access the binomial heap by a pointer to the \ufb01rst node on the root list.\nc.Complete the description of how to represent a binomial heap (i.e., name the\nattributes, describe when attributes have the value\nNIL, and de\ufb01ne how the root\nlist is organized), and show how to implement the same seven operations onbinomial heaps as this chapter implemented on Fibonacci heaps. Each opera-tion should run in O.lgn/worst-case time, where nis the number of nodes in", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "549": {"page_number": 550, "page_information": "Problems for Chapter 19 529\nthe binomial heap (or in the case of the U NION operation, in the two binomial\nheaps that are being united). The M AKE-HEAP operation should take constant\ntime.\nd.Suppose that we were to implement only the mergeable-heap operations on a\nFibonacci heap (i.e., we do not implement the D ECREASE -KEYor D ELETE op-\nerations). How would the trees in a Fibonacci heap resemble those in a binomialheap? How would they differ? Show that the maximum degree in an n-node\nFibonacci heap would be at most blgnc.\ne.Professor McGee has devised a new data structure based on Fibonacci heaps.\nA McGee heap has the same structure as a Fibonacci heap and supports justthe mergeable-heap operations. The implementations of the operations are thesame as for Fibonacci heaps, except that insertion and union consolidate theroot list as their last step. What are the worst-case running times of operationson McGee heaps?\n19-3 More Fibonacci-heap operations\nWe wish to augment a Fibonacci heap Hto support two new operations without\nchanging the amortized running time of any other Fibonacci-heap operations.\na.The operation F\nIB-HEAP-CHANGE -KEY. H;x;k/ changes the key of node x\nto the value k. Give an ef\ufb01cient implementation of F IB-HEAP-CHANGE -KEY,\nand analyze the amortized running time of your implementation for the cases\nin which kis greater than, less than, or equal to x:key.\nb.Give an ef\ufb01cient implementation of F IB-HEAP-PRUNE .H; r/ , which deletes\nqDmin.r; H: n/nodes from H. You may choose any qnodes to delete. Ana-\nlyze the amortized running time of your implementation. ( Hint: You may need\nto modify the data structure and potential function.)\n19-4 2-3-4 heaps\nChapter 18 introduced the 2-3-4 tree, in which every internal node (other than pos-sibly the root) has two, three, or four children and all leaves have the same depth. Inthis problem, we shall implement 2-3-4 heaps , which support the mergeable-heap\noperations.\nThe 2-3-4 heaps differ from 2-3-4 trees in the following ways. In 2-3-4 heaps,\nonly leaves store keys, and each leaf xstores exactly one key in the attribute x:key.\nThe keys in the leaves may appear in any order. Each internal node xcontains\nav a l u e x:small that is equal to the smallest key stored in any leaf in the subtree\nrooted at x. The root rcontains an attribute r:height that gives the height of the", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "550": {"page_number": 551, "page_information": "530 Chapter 19 Fibonacci Heaps\ntree. Finally, 2-3-4 heaps are designed to be kept in main memory, so that disk\nreads and writes are not needed.\nImplement the following 2-3-4 heap operations. In parts (a)\u2013(e), each operation\nshould run in O.lgn/time on a 2-3-4 heap with nelements. The U NION operation\nin part (f) should run in O.lgn/time, where nis the number of elements in the two\ninput heaps.\na.MINIMUM , which returns a pointer to the leaf with the smallest key.\nb.DECREASE -KEY, which decreases the key of a given leaf xto a given value\nk/DC4x:key.\nc.INSERT , which inserts leaf xwith key k.\nd.DELETE , which deletes a given leaf x.\ne.EXTRACT -MIN, which extracts the leaf with the smallest key.\nf.UNION , which unites two 2-3-4 heaps, returning a single 2-3-4 heap and de-\nstroying the input heaps.\nChapter notes\nFredman and Tarjan [114] introduced Fibonacci heaps. Their paper also describesthe application of Fibonacci heaps to the problems of single-source shortest paths,all-pairs shortest paths, weighted bipartite matching, and the minimum-spanning-tree problem.\nSubsequently, Driscoll, Gabow, Shrairman, and Tarjan [96] developed \u201crelaxed\nheaps\u201d as an alternative to Fibonacci heaps. They devised two varieties of re-laxed heaps. One gives the same amortized time bounds as Fibonacci heaps. Theother allows D\nECREASE -KEYto run in O.1/ worst-case (not amortized) time and\nEXTRACT -MINand D ELETE to run in O.lgn/worst-case time. Relaxed heaps\nalso have some advantages over Fibonacci heaps in parallel algorithms.\nSee also the chapter notes for Chapter 6 for other data structures that support fast\nDECREASE -KEYoperations when the sequence of values returned by E XTRACT -\nMINcalls are monotonically increasing over time and the data are integers in a\nspeci\ufb01c range.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "551": {"page_number": 552, "page_information": "20 van Emde Boas Trees\nIn previous chapters, we saw data structures that support the operations of a priority\nqueue\u2014binary heaps in Chapter 6, red-black trees in Chapter 13,1and Fibonacci\nheaps in Chapter 19. In each of these data structures, at least one important op-eration took O.lgn/time, either worst case or amortized. In fact, because each\nof these data structures bases its decisions on comparing keys, the /DEL.n lgn/lower\nbound for sorting in Section 8.1 tells us that at least one operation will have totake/DEL.lgn/time. Why? If we could perform both the I\nNSERT and E XTRACT -MIN\noperations in o.lgn/time, then we could sort nkeys in o.nlgn/time by \ufb01rst per-\nforming nINSERT operations, followed by nEXTRACT -MINoperations.\nWe saw in Chapter 8, however, that sometimes we can exploit additional infor-\nmation about the keys to sort in o.nlgn/time. In particular, with counting sort\nwe can sort nkeys, each an integer in the range 0tok, in time \u201a.nCk/,w h i c h\nis\u201a.n/ when kDO.n/ .\nSince we can circumvent the /DEL.n lgn/lower bound for sorting when the keys are\nintegers in a bounded range, you might wonder whether we can perform each of the\npriority-queue operations in o.lgn/time in a similar scenario. In this chapter, we\nshall see that we can: van Emde Boas trees support the priority-queue operations,and a few others, each in O.lg lgn/worst-case time. The hitch is that the keys\nmust be integers in the range 0ton/NUL1, with no duplicates allowed.\nSpeci\ufb01cally, van Emde Boas trees support each of the dynamic set operations\nlisted on page 230\u2014S\nEARCH ,INSERT ,DELETE ,M INIMUM ,M AXIMUM ,SUC-\nCESSOR ,a n dP REDECESSOR \u2014in O.lg lgn/time. In this chapter, we will omit\ndiscussion of satellite data and focus only on storing keys. Because we concentrateon keys and disallow duplicate keys to be stored, instead of describing the S\nEARCH\n1Chapter 13 does not explicitly discuss how to implement E XTRACT -MINand D ECREASE -KEY,b u t\nwe can easily build these operations for any data structure that supports M INIMUM ,DELETE ,a n d\nINSERT .", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "552": {"page_number": 553, "page_information": "532 Chapter 20 van Emde Boas Trees\noperation, we will implement the simpler operation M EMBER .S; x/ , which returns\na boolean indicating whether the value xis currently in dynamic set S.\nSo far, we have used the parameter nfor two distinct purposes: the number of\nelements in the dynamic set, and the range of the possible values. To avoid anyfurther confusion, from here on we will use nto denote the number of elements\ncurrently in the set and uas the range of possible values, so that each van Emde\nBoas tree operation runs in O.lg lgu/time. We call the set f0; 1; 2; : : : ; u/NUL1g\ntheuniverse of values that can be stored and utheuniverse size . We assume\nthroughout this chapter that uis an exact power of 2, i.e., uD2\nkfor some integer\nk/NAK1.\nSection 20.1 starts us out by examining some simple approaches that will get\nus going in the right direction. We enhance these approaches in Section 20.2,introducing proto van Emde Boas structures, which are recursive but do not achieveour goal of O.lg lgu/-time operations. Section 20.3 modi\ufb01es proto van Emde Boas\nstructures to develop van Emde Boas trees, and it shows how to implement eachoperation in O.lg lgu/time.\n20.1 Preliminary approaches\nIn this section, we shall examine various approaches for storing a dynamic set.\nAlthough none will achieve the O.lg lgu/time bounds that we desire, we will gain\ninsights that will help us understand van Emde Boas trees when we see them laterin this chapter.\nDirect addressing\nDirect addressing, as we saw in Section 11.1, provides the simplest approach to\nstoring a dynamic set. Since in this chapter we are concerned only with storingkeys, we can simplify the direct-addressing approach to store the dynamic set as abit vector, as discussed in Exercise 11.1-2. To store a dynamic set of values fromthe universef0; 1; 2; : : : ; u/NUL1g, we maintain an array A\u01520 : : u/NUL1/c141ofubits. The\nentry A\u0152x/c141 holds a 1if the value xis in the dynamic set, and it holds a 0otherwise.\nAlthough we can perform each of the I\nNSERT ,DELETE ,a n dM EMBER operations\ninO.1/ time with a bit vector, the remaining operations\u2014M INIMUM ,M AXIMUM ,\nSUCCESSOR ,a n dP REDECESSOR \u2014each take \u201a.u/ time in the worst case because", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "553": {"page_number": 554, "page_information": "20.1 Preliminary approaches 533\n0\n00\n11\n21\n31\n41\n50\n61\n70\n80\n90\n100\n110\n120\n131\n141\n150 1 1 1 0 0 0 11 1 0 11 11\nA\nFigure 20.1 A binary tree of bits superimposed on top of a bit vector representing the set\nf2; 3; 4; 5; 7; 14; 15gwhen uD16. Each internal node contains a 1if and only if some leaf in\nits subtree contains a 1. The arrows show the path followed to determine the predecessor of 14in the\nset.\nwe might have to scan through \u201a.u/ elements.2For example, if a set contains only\nthe values 0andu/NUL1, then to \ufb01nd the successor of 0, we would have to scan\nentries 1through u/NUL2before \ufb01nding a 1inA\u0152u/NUL1/c141.\nSuperimposing a binary tree structure\nWe can short-cut long scans in the bit vector by superimposing a binary tree of bits\non top of it. Figure 20.1 shows an example. The entries of the bit vector form theleaves of the binary tree, and each internal node contains a 1if and only if any leaf\nin its subtree contains a 1. In other words, the bit stored in an internal node is the\nlogical-or of its two children.\nThe operations that took \u201a.u/ worst-case time with an unadorned bit vector now\nuse the tree structure:\n/SITo \ufb01nd the minimum value in the set, start at the root and head down toward\nthe leaves, always taking the leftmost node containing a 1.\n/SITo \ufb01nd the maximum value in the set, start at the root and head down toward\nthe leaves, always taking the rightmost node containing a 1.\n2We assume throughout this chapter that M INIMUM and M AXIMUM return NILif the dynamic set\nis empty and that S UCCESSOR and P REDECESSOR return NILif the element they are given has no\nsuccessor or predecessor, respectively.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "554": {"page_number": 555, "page_information": "534 Chapter 20 van Emde Boas Trees\n/SITo \ufb01nd the successor of x, start at the leaf indexed by x, and head up toward the\nroot until we enter a node from the left and this node has a 1in its right child \u00b4.\nThen head down through node \u00b4, always taking the leftmost node containing\na1(i.e., \ufb01nd the minimum value in the subtree rooted at the right child \u00b4).\n/SITo \ufb01nd the predecessor of x, start at the leaf indexed by x, and head up toward\nthe root until we enter a node from the right and this node has a 1in its left\nchild \u00b4. Then head down through node \u00b4, always taking the rightmost node\ncontaining a 1(i.e., \ufb01nd the maximum value in the subtree rooted at the left\nchild \u00b4).\nFigure 20.1 shows the path taken to \ufb01nd the predecessor, 7,o ft h ev a l u e 14.\nWe also augment the I NSERT and D ELETE operations appropriately. When in-\nserting a value, we store a 1in each node on the simple path from the appropriate\nleaf up to the root. When deleting a value, we go from the appropriate leaf up tothe root, recomputing the bit in each internal node on the path as the logical-or ofits two children.\nSince the height of the tree is lg uand each of the above operations makes at\nmost one pass up the tree and at most one pass down, each operation takes O.lgu/\ntime in the worst case.\nThis approach is only marginally better than just using a red-black tree. We can\nstill perform the M\nEMBER operation in O.1/ time, whereas searching a red-black\ntree takes O.lgn/time. Then again, if the number nof elements stored is much\nsmaller than the size uof the universe, a red-black tree would be faster for all the\nother operations.\nSuperimposing a tree of constant height\nWhat happens if we superimpose a tree with greater degree? Let us assume that\nthe size of the universe is uD22kfor some integer k,s ot h a tp\nuis an integer.\nInstead of superimposing a binary tree on top of the bit vector, we superimpose atree of degreep\nu. Figure 20.2(a) shows such a tree for the same bit vector as in\nFigure 20.1. The height of the resulting tree is always 2.\nAs before, each internal node stores the logical-or of the bits within its sub-\ntree, so that thep\nuinternal nodes at depth 1summarize each group ofp\nuval-\nues. As Figure 20.2(b) demonstrates, we can think of these nodes as an arraysummary \u01520 : :p\nu/NUL1/c141,w h e r e summary \u0152i/c141contains a 1if and only if the subar-\nrayA\u0152ip\nu::. iC1/p\nu/NUL1/c141contains a 1. We call thisp\nu-bit subarray of A\ntheithcluster .F o r a g i v e n v a l u e o f x, the bit A\u0152x/c141 appears in cluster num-\nberbx=p\nuc.N o w I NSERT becomes an O.1/ -time operation: to insert x, set\nbothA\u0152x/c141 andsummary \u0152bx=p\nuc/c141to1. We can use the summary array to perform", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "555": {"page_number": 556, "page_information": "20.1 Preliminary approaches 535\n0\n00\n11\n21\n31\n41\n50\n61\n70\n80\n90\n100\n110\n120\n131\n141\n1511\n1 0 1\n(a)0\n00\n11\n21\n31\n41\n50\n61\n70\n80\n90\n100\n110\n120\n131\n141\n15\n(b)10\n11\n02\n13\nA Asummary\np\nubitsp\nubits\nFigure 20.2 (a) A tree of degreep\nusuperimposed on top of the same bit vector as in Figure 20.1.\nEach internal node stores the logical-or of the bits in its subtree. (b)A view of the same structure,\nbut with the internal nodes at depth 1treated as an array summary \u01520 : :p\nu/NUL1/c141,w h e r e summary \u0152i/c141is\nthe logical-or of the subarray A\u0152ip\nu::. iC1/p\nu/NUL1/c141.\neach of the operations M INIMUM ,MAXIMUM ,SUCCESSOR ,PREDECESSOR ,a n d\nDELETE inO.p\nu/time:\n/SITo \ufb01nd the minimum (maximum) value, \ufb01nd the leftmost (rightmost) entry in\nsummary that contains a 1, say summary \u0152i/c141, and then do a linear search within\ntheith cluster for the leftmost (rightmost) 1.\n/SITo \ufb01nd the successor (predecessor) of x, \ufb01rst search to the right (left) within its\ncluster. If we \ufb01nd a 1, that position gives the result. Otherwise, let iDbx=p\nuc\nand search to the right (left) within the summary array from index i.T h e \ufb01 r s t\nposition that holds a 1gives the index of a cluster. Search within that cluster\nfor the leftmost (rightmost) 1. That position holds the successor (predecessor).\n/SITo delete the value x,l e tiDbx=p\nuc/c141.S e t A\u0152x/c141 to0and then set summary \u0152i/c141\nto the logical-or of the bits in the ith cluster.\nIn each of the above operations, we search through at most two clusters ofp\nubits\nplus the summary array, and so each operation takes O.p\nu/time.\nAt \ufb01rst glance, it seems as though we have made negative progress. Superimpos-\ning a binary tree gave us O.lgu/-time operations, which are asymptotically faster\nthanO.p\nu/time. Using a tree of degreep\nuwill turn out to be a key idea of van\nEmde Boas trees, however. We continue down this path in the next section.\nExercises\n20.1-1\nModify the data structures in this section to support duplicate keys.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "556": {"page_number": 557, "page_information": "536 Chapter 20 van Emde Boas Trees\n20.1-2\nModify the data structures in this section to support keys that have associated satel-lite data.\n20.1-3\nObserve that, using the structures in this section, the way we \ufb01nd the successor andpredecessor of a value xdoes not depend on whether xis in the set at the time.\nShow how to \ufb01nd the successor of xin a binary search tree when xis not stored in\nthe tree.\n20.1-4\nSuppose that instead of superimposing a tree of degreep\nu,w ew e r et os u p e r i m -\npose a tree of degree u1=k,w h e r e k>1 is a constant. What would be the height of\nsuch a tree, and how long would each of the operations take?\n20.2 A recursive structure\nIn this section, we modify the idea of superimposing a tree of degreep\nuon top of\na bit vector. In the previous section, we used a summary structure of sizep\nu, with\neach entry pointing to another stucture of sizep\nu. Now, we make the structure\nrecursive, shrinking the universe size by the square root at each level of recursion.Starting with a universe of size u, we make structures holdingp\nuDu1=2items,\nwhich themselves hold structures of u1=4items, which hold structures of u1=8items,\nand so on, down to a base size of 2.\nFor simplicity, in this section, we assume that uD22kfor some integer k,s o\nthatu; u1=2;u1=4;:::are integers. This restriction would be quite severe in practice,\nallowing only values of uin the sequence 2; 4; 16; 256; 65536; : : : . We shall see in\nthe next section how to relax this assumption and assume only that uD2kfor\nsome integer k. Since the structure we examine in this section is only a precursor\nto the true van Emde Boas tree structure, we tolerate this restriction in favor of\naiding our understanding.\nRecalling that our goal is to achieve running times of O.lg lgu/for the oper-\nations, let\u2019s think about how we might obtain such running times. At the end of\nSection 4.3, we saw that by changing variables, we could show that the recurrence\nT .n/D2T/NUL/EOTp\nn\u02d8/SOH\nClgn (20.1)\nhas the solution T .n/DO.lgnlg lgn/. Let\u2019s consider a similar, but simpler,\nrecurrence:\nT. u /DT.p\nu/CO.1/ : (20.2)", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "557": {"page_number": 558, "page_information": "20.2 A recursive structure 537\nIf we use the same technique, changing variables, we can show that recur-\nrence (20.2) has the solution T. u /DO.lg lgu/.L e t mDlgu,s ot h a t uD2m\nand we have\nT. 2m/DT. 2m=2/CO.1/ :\nNow we rename S.m/DT. 2m/, giving the new recurrence\nS.m/DS.m=2/CO.1/ :\nBy case 2 of the master method, this recurrence has the solution S.m/DO.lgm/.\nWe change back from S.m/ toT. u / ,g i v i n g T. u /DT. 2m/DS.m/DO.lgm/D\nO.lg lgu/.\nRecurrence (20.2) will guide our search for a data structure. We will design a\nrecursive data structure that shrinks by a factor ofp\nuin each level of its recursion.\nWhen an operation traverses this data structure, it will spend a constant amount oftime at each level before recursing to the level below. Recurrence (20.2) will thencharacterize the running time of the operation.\nHere is another way to think of how the term lg lg uends up in the solution to\nrecurrence (20.2). As we look at the universe size in each level of the recursive datastructure, we see the sequence u; u\n1=2;u1=4;u1=8;:::. If we consider how many bits\nwe need to store the universe size at each level, we need lg uat the top level, and\neach level needs half the bits of the previous level. In general, if we start with b\nbits and halve the number of bits at each level, then after lg blevels, we get down\nto just one bit. Since bDlgu, we see that after lg lg ulevels, we have a universe\nsize of 2.\nLooking back at the data structure in Figure 20.2, a given value xresides in\ncluster numberbx=p\nuc.I f w e v i e w xas a lg u-bit binary integer, that cluster\nnumber,bx=p\nuc, is given by the most signi\ufb01cant .lgu/=2 bits of x. Within its\ncluster, xappears in position xmodp\nu, which is given by the least signi\ufb01cant\n.lgu/=2 bits of x. We will need to index in this way, and so let us de\ufb01ne some\nfunctions that will help us do so:\nhigh.x/D/EOT\nx=p\nu\u02d8\n;\nlow.x/Dxmodp\nu;\nindex .x; y/Dxp\nuCy:\nThe function high .x/gives the most signi\ufb01cant .lgu/=2 bits of x, producing the\nnumber of x\u2019s cluster. The function low .x/gives the least signi\ufb01cant .lgu/=2 bits\nofxand provides x\u2019s position within its cluster. The function index .x; y/ builds an\nelement number from xandy, treating xas the most signi\ufb01cant .lgu/=2 bits of the\nelement number and yas the least signi\ufb01cant .lgu/=2 bits. We have the identity\nxDindex .high.x/;low.x//.T h e v a l u e o f uused by each of these functions will", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "558": {"page_number": 559, "page_information": "538 Chapter 20 van Emde Boas Trees\n\u2026 0123p\nu/NUL1 proto -/ETBEB.u/\nu summary cluster\nproto -/ETBEB.p\nu/structurep\nuproto -/ETBEB.p\nu/structures\nFigure 20.3 The information in a proto -/ETBEB.u/structure when u/NAK4. The structure contains the\nuniverse size u, a pointer summary to aproto -/ETBEB.p\nu/structure, and an array cluster \u01520 : :p\nu/NUL1/c141\nofp\nupointers to proto -/ETBEB.p\nu/structures.\nalways be the universe size of the data structure in which we call the function,\nwhich changes as we descend into the recursive structure.\n20.2.1 Proto van Emde Boas structures\nTaking our cue from recurrence (20.2), let us design a recursive data structure to\nsupport the operations. Although this data structure will fail to achieve our goal ofO.lg lgu/time for some operations, it serves as a basis for the van Emde Boas tree\nstructure that we will see in Section 20.3.\nFor the universef0; 1; 2; : : : ; u/NUL1g,w ed e \ufb01 n ea proto van Emde Boas struc-\nture,o rproto-vEB structure , which we denote as proto -/ETBEB.u/, recursively as\nfollows. Each proto -/ETBEB.u/structure contains an attribute ugiving its universe\nsize. In addition, it contains the following:\n/SIIfuD2, then it is the base size, and it contains an array A\u01520 : : 1/c141 of two bits.\n/SIOtherwise, uD22kfor some integer k/NAK1,s ot h a t u/NAK4. In addition\nto the universe size u, the data structure proto -/ETBEB.u/contains the following\nattributes, illustrated in Figure 20.3:\n/SIa pointer named summary to aproto -/ETBEB.p\nu/structure and\n/SIan array cluster \u01520 : :p\nu/NUL1/c141ofp\nupointers, each to a proto -/ETBEB.p\nu/struc-\nture.\nThe element x,w h e r e 0/DC4x<u , is recursively stored in the cluster numbered\nhigh.x/as element low .x/within that cluster.\nIn the two-level structure of the previous section, each node stores a summary\narray of sizep\nu, in which each entry contains a bit. From the index of each\nentry, we can compute the starting index of the subarray of sizep\nuthat the bit\nsummarizes. In the proto-vEB structure, we use explicit pointers rather than index", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "559": {"page_number": 560, "page_information": "20.2 A recursive structure 539\n0123\ncluster u16 summaryproto-vEB (16)\n01cluster\nu\n4summaryproto-vEB (4)\n0\n1Aproto-vEB (2)\n1\n101cluster\nu\n4summaryproto-vEB (4)\n01cluster\nu\n4summaryproto-vEB (4)\n01cluster\nu\n4summaryproto-vEB (4)\n01cluster\nu\n4summaryproto-vEB (4)elements 0,1 elements 2,3 clusters 0,1 clusters 2,3 elements 4,5 elements 6,7\nelements 8,9 elements 10,11 elements 12,13 elements 14,15u\n2\n0\n1Aproto-vEB (2)\n1\n1u\n2\n0\n1Aproto-vEB (2)\n0\n0u\n2\n0\n1Aproto-vEB (2)\n0\n1u\n2\n0\n1Aproto-vEB (2)\n0\n0u\n2\n0\n1Aproto-vEB (2)\n0\n0u\n2\n0\n1Aproto-vEB (2)\n0\n0u\n20\n1Aproto-vEB (2)\n0\n1u\n2\n0\n1Aproto-vEB (2)\n1\n1u\n2\n0\n1Aproto-vEB (2)\n1\n1u\n2\n0\n1Aproto-vEB (2)\n1\n1u\n2\n0\n1Aproto-vEB (2)\n0\n0u\n2\n0\n1Aproto-vEB (2)\n0\n1u\n2\n0\n1Aproto-vEB (2)\n0\n1u\n2\n0\n1Aproto-vEB (2)\n1\n1u\n2\nFigure 20.4 Aproto -/ETBEB.16/ structure representing the set f2; 3; 4; 5; 7; 14; 15g. It points to four\nproto -/ETBEB.4/structures in cluster \u01520 : : 3/c141 , and to a summary structure, which is also a proto -/ETBEB.4/.\nEach proto -/ETBEB.4/structure points to two proto -/ETBEB.2/structures in cluster \u01520 : : 1/c141 ,a n dt oa\nproto -/ETBEB.2/summary. Each proto -/ETBEB.2/structure contains just an array A\u01520 : : 1/c141 of two bits.\nTheproto -/ETBEB.2/structures above \u201celements i,j\u201d store bits iandjof the actual dynamic set, and\ntheproto -/ETBEB.2/structures above \u201cclusters i,j\u201d store the summary bits for clusters iandjin the\ntop-level proto -/ETBEB.16/ structure. For clarity, heavy shading indicates the top level of a proto-vEB\nstructure that stores summary information for its parent structure; such a proto-vEB structure is\notherwise identical to any other proto-vEB structure with the same universe size.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "560": {"page_number": 561, "page_information": "540 Chapter 20 van Emde Boas Trees\ncalculations. The array summary contains the summary bits stored recursively in a\nproto-vEB structure, and the array cluster containsp\nupointers.\nFigure 20.4 shows a fully expanded proto -/ETBEB.16/ structure representing the\nsetf2; 3; 4; 5; 7; 14; 15g.I ft h ev a l u e iis in the proto-vEB structure pointed to by\nsummary , then the ith cluster contains some value in the set being represented.\nAs in the tree of constant height, cluster \u0152i/c141represents the values ip\nuthrough\n.iC1/p\nu/NUL1, which form the ith cluster.\nAt the base level, the elements of the actual dynamic sets are stored in some\nof the proto -/ETBEB.2/structures, and the remaining proto -/ETBEB.2/structures store\nsummary bits. Beneath each of the non-summary base structures, the \ufb01gure in-dicates which bits it stores. For example, the proto -/ETBEB.2/structure labeled\n\u201celements 6,7\u201d stores bit 6(0, since element 6is not in the set) in its A\u01520/c141 and\nbit7(1, since element 7is in the set) in its A\u01521/c141.\nLike the clusters, each summary is just a dynamic set with universe sizep\nu,\nand so we represent each summary as a proto -/ETBEB.p\nu/structure. The four sum-\nmary bits for the main proto -/ETBEB.16/ structure are in the leftmost proto -/ETBEB.4/\nstructure, and they ultimately appear in two proto -/ETBEB.2/structures. For exam-\nple, the proto -/ETBEB.2/structure labeled \u201cclusters 2,3\u201d has A\u01520/c141D0, indicating that\ncluster 2of the proto -/ETBEB.16/ structure (containing elements 8; 9; 10; 11 )i sa l l 0,\nandA\u01521/c141D1, telling us that cluster 3(containing elements 12; 13; 14; 15 ) has at\nleast one 1. Each proto -/ETBEB.4/structure points to its own summary, which is itself\nstored as a proto -/ETBEB.2/structure. For example, look at the proto -/ETBEB.2/struc-\nture just to the left of the one labeled \u201celements 0,1.\u201d Because its A\u01520/c141 is0, it tells\nus that the \u201celements 0,1\u201d structure is all 0, and because its A\u01521/c141 is1, we know that\nthe \u201celements 2,3\u201d structure contains at least one 1.\n20.2.2 Operations on a proto van Emde Boas structure\nWe shall now describe how to perform operations on a proto-vEB structure.\nWe \ufb01rst examine the query operations\u2014M EMBER ,M INIMUM ,M AXIMUM ,a n d\nSUCCESSOR \u2014which do not change the proto-vEB structure. We then discuss\nINSERT and D ELETE .W e l e a v e M AXIMUM and P REDECESSOR , which are sym-\nmetric to M INIMUM and S UCCESSOR , respectively, as Exercise 20.2-1.\nEach of the M EMBER ,SUCCESSOR ,PREDECESSOR ,INSERT ,a n dD ELETE op-\nerations takes a parameter x, along with a proto-vEB structure V. Each of these\noperations assumes that 0/DC4x<V : u.\nDetermining whether a value is in the set\nTo perform M EMBER .x/, we need to \ufb01nd the bit corresponding to xwithin the\nappropriate proto -/ETBEB.2/structure. We can do so in O.lg lgu/time, bypassing", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "561": {"page_number": 562, "page_information": "20.2 A recursive structure 541\nthesummary structures altogether. The following procedure takes a proto -/ETBEB\nstructure Vand a value x, and it returns a bit indicating whether xis in the dynamic\nset held by V.\nPROTO -VEB-M EMBER .V; x/\n1ifV:u==2\n2 return V:A\u0152x/c141\n3else return PROTO -VEB-M EMBER .V:cluster \u0152high.x//c141; low.x//\nThe P ROTO -VEB-M EMBER procedure works as follows. Line 1 tests whether\nwe are in a base case, where Vis aproto -/ETBEB.2/structure. Line 2 handles the\nbase case, simply returning the appropriate bit of array A. Line 3 deals with the\nrecursive case, \u201cdrilling down\u201d into the appropriate smaller proto-vEB structure.The value high .x/says which proto -/ETBEB.p\nu/structure we visit, and low .x/de-\ntermines which element within that proto -/ETBEB.p\nu/structure we are querying.\nLet\u2019s see what happens when we call P ROTO -VEB-M EMBER .V; 6/ on the\nproto -/ETBEB.16/ structure in Figure 20.4. Since high .6/D1when uD16,w e\nrecurse into the proto -/ETBEB.4/structure in the upper right, and we ask about ele-\nment low .6/D2of that structure. In this recursive call, uD4, and so we recurse\nagain. With uD4,w eh a v eh i g h .2/D1and low .2/D0, and so we ask about\nelement 0of the proto -/ETBEB.2/structure in the upper right. This recursive call turns\nout to be a base case, and so it returns A\u01520/c141D0back up through the chain of re-\ncursive calls. Thus, we get the result that P ROTO -VEB-M EMBER .V; 6/ returns 0,\nindicating that 6is not in the set.\nTo determine the running time of P ROTO -VEB-M EMBER ,l e t T. u / denote\nits running time on a proto -/ETBEB.u/structure. Each recursive call takes con-\nstant time, not including the time taken by the recursive calls that it makes.When P\nROTO -VEB-M EMBER makes a recursive call, it makes a call on a\nproto -/ETBEB.p\nu/structure. Thus, we can characterize the running time by the recur-\nrence T. u /DT.p\nu/CO.1/ , which we have already seen as recurrence (20.2).\nIts solution is T. u /DO.lg lgu/, and so we conclude that P ROTO -VEB-M EMBER\nruns in time O.lg lgu/.\nFinding the minimum element\nNow we examine how to perform the M INIMUM operation. The procedure\nPROTO -VEB-M INIMUM .V /returns the minimum element in the proto-vEB struc-\ntureV,o r NILifVrepresents an empty set.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "562": {"page_number": 563, "page_information": "542 Chapter 20 van Emde Boas Trees\nPROTO -VEB-M INIMUM .V /\n1ifV:u==2\n2 ifV:A\u01520/c141==1\n3 return 0\n4 elseif V:A\u01521/c141==1\n5 return 1\n6 else return NIL\n7elsemin-clusterDPROTO -VEB-M INIMUM .V:summary /\n8 ifmin-cluster ==NIL\n9 return NIL\n10 elseoffsetDPROTO -VEB-M INIMUM .V:cluster \u0152min-cluster /c141/\n11 return index .min-cluster ;offset /\nThis procedure works as follows. Line 1 tests for the base case, which lines 2\u20136\nhandle by brute force. Lines 7\u201311 handle the recursive case. First, line 7 \ufb01nds thenumber of the \ufb01rst cluster that contains an element of the set. It does so by recur-sively calling P\nROTO -VEB-M INIMUM onV:summary ,w h i c hi sa proto -/ETBEB.p\nu/\nstructure. Line 7 assigns this cluster number to the variable min-cluster . If the set\nis empty, then the recursive call returned NIL, and line 9 returns NIL. Otherwise,\nthe minimum element of the set is somewhere in cluster number min-cluster .T h e\nrecursive call in line 10 \ufb01nds the offset within the cluster of the minimum element\nin this cluster. Finally, line 11 constructs the value of the minimum element from\nthe cluster number and offset, and it returns this value.\nAlthough querying the summary information allows us to quickly \ufb01nd the clus-\nter containing the minimum element, because this procedure makes two recursive\ncalls on proto -/ETBEB.p\nu/structures, it does not run in O.lg lgu/time in the worst\ncase. Letting T. u / denote the worst-case time for P ROTO -VEB-M INIMUM on a\nproto -/ETBEB.u/structure, we have the recurrence\nT. u /D2T .p\nu/CO.1/ : (20.3)\nAgain, we use a change of variables to solve this recurrence, letting mDlgu,\nwhich gives\nT. 2m/D2T .2m=2/CO.1/ :\nRenaming S.m/DT. 2m/gives\nS.m/D2S.m=2/CO.1/ ;\nwhich, by case 1 of the master method, has the solution S.m/D\u201a.m/ . By chang-\ning back from S.m/ toT. u / ,w eh a v et h a t T. u /DT. 2m/DS.m/D\u201a.m/D\n\u201a.lgu/. Thus, we see that because of the second recursive call, P ROTO -VEB-\nMINIMUM runs in \u201a.lgu/time rather than the desired O.lg lgu/time.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "563": {"page_number": 564, "page_information": "20.2 A recursive structure 543\nFinding the successor\nThe S UCCESSOR operation is even worse. In the worst case, it makes two recursive\ncalls, along with a call to P ROTO -VEB-M INIMUM . The procedure P ROTO -VEB-\nSUCCESSOR .V; x/ returns the smallest element in the proto-vEB structure Vthat\nis greater than x,o r NILif no element in Vis greater than x. It does not require x\nto be a member of the set, but it does assume that 0/DC4x<V : u.\nPROTO -VEB-S UCCESSOR .V; x/\n1ifV:u==2\n2 ifx==0andV:A\u01521/c141==1\n3 return 1\n4 else return NIL\n5elseoffsetDPROTO -VEB-S UCCESSOR .V:cluster \u0152high.x//c141; low.x//\n6 ifoffset\u00a4NIL\n7 return index .high.x/;offset /\n8 elsesucc-clusterDPROTO -VEB-S UCCESSOR .V:summary ;high.x//\n9 ifsucc-cluster ==NIL\n10 return NIL\n11 elseoffsetDPROTO -VEB-M INIMUM .V:cluster \u0152succ-cluster /c141/\n12 return index .succ-cluster ;offset /\nThe P ROTO -VEB-S UCCESSOR procedure works as follows. As usual, line 1\ntests for the base case, which lines 2\u20134 handle by brute force: the only way that x\ncan have a successor within a proto -/ETBEB.2/structure is when xD0andA\u01521/c141\nis1. Lines 5\u201312 handle the recursive case. Line 5 searches for a successor to x\nwithin x\u2019s cluster, assigning the result to offset . Line 6 determines whether xhas\na successor within its cluster; if it does, then line 7 computes and returns the value\nof this successor. Otherwise, we have to search in other clusters. Line 8 assigns tosucc-cluster the number of the next nonempty cluster, using the summary informa-\ntion to \ufb01nd it. Line 9 tests whether succ-cluster is\nNIL, with line 10 returning NIL\nif all succeeding clusters are empty. If succ-cluster is non- NIL, line 11 assigns\nthe \ufb01rst element within that cluster to offset , and line 12 computes and returns the\nminimum element in that cluster.\nIn the worst case, P ROTO -VEB-S UCCESSOR calls itself recursively twice on\nproto -/ETBEB.p\nu/structures, and it makes one call to P ROTO -VEB-M INIMUM on\naproto -/ETBEB.p\nu/structure. Thus, the recurrence for the worst-case running\ntimeT. u / of P ROTO -VEB-S UCCESSOR is\nT. u /D2T .p\nu/C\u201a.lgp\nu/\nD2T .p\nu/C\u201a.lgu/ :", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "564": {"page_number": 565, "page_information": "544 Chapter 20 van Emde Boas Trees\nWe can employ the same technique that we used for recurrence (20.1) to show\nthat this recurrence has the solution T. u /D\u201a.lgulg lgu/. Thus, P ROTO -VEB-\nSUCCESSOR is asymptotically slower than P ROTO -VEB-M INIMUM .\nInserting an element\nTo insert an element, we need to insert it into the appropriate cluster and also set\nthe summary bit for that cluster to 1. The procedure P ROTO -VEB-I NSERT .V; x/\ninserts the value xinto the proto-vEB structure V.\nPROTO -VEB-I NSERT .V; x/\n1ifV:u==2\n2 V:A\u0152x/c141D1\n3elsePROTO -VEB-I NSERT .V:cluster \u0152high.x//c141; low.x//\n4P ROTO -VEB-I NSERT .V:summary ;high.x//\nIn the base case, line 2 sets the appropriate bit in the array Ato1. In the recursive\ncase, the recursive call in line 3 inserts xinto the appropriate cluster, and line 4\nsets the summary bit for that cluster to 1.\nBecause P ROTO -VEB-I NSERT makes two recursive calls in the worst case, re-\ncurrence (20.3) characterizes its running time. Hence, P ROTO -VEB-I NSERT runs\nin\u201a.lgu/time.\nDeleting an element\nThe D ELETE operation is more complicated than insertion. Whereas we can always\nset a summary bit to 1when inserting, we cannot always reset the same summary\nbit to 0when deleting. We need to determine whether any bit in the appropriate\ncluster is 1. As we have de\ufb01ned proto-vEB structures, we would have to examine\nallp\nubits within a cluster to determine whether any of them are 1. Alternatively,\nwe could add an attribute nto the proto-vEB structure, counting how many el-\nements it has. We leave implementation of P ROTO -VEB-D ELETE as Exercises\n20.2-2 and 20.2-3.\nClearly, we need to modify the proto-vEB structure to get each operation down\nto making at most one recursive call. We will see in the next section how to do so.\nExercises\n20.2-1\nWrite pseudocode for the procedures P ROTO -VEB-M AXIMUM and P ROTO -VEB-\nPREDECESSOR .", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "565": {"page_number": 566, "page_information": "20.3 The van Emde Boas tree 545\n20.2-2\nWrite pseudocode for P ROTO -VEB-D ELETE . It should update the appropriate\nsummary bit by scanning the related bits within the cluster. What is the worst-case running time of your procedure?\n20.2-3\nAdd the attribute nto each proto-vEB structure, giving the number of elements\ncurrently in the set it represents, and write pseudocode for P\nROTO -VEB-D ELETE\nthat uses the attribute nto decide when to reset summary bits to 0. What is the\nworst-case running time of your procedure? What other procedures need to change\nbecause of the new attribute? Do these changes affect their running times?\n20.2-4\nModify the proto-vEB structure to support duplicate keys.\n20.2-5\nModify the proto-vEB structure to support keys that have associated satellite data.\n20.2-6\nWrite pseudocode for a procedure that creates a proto -/ETBEB.u/structure.\n20.2-7\nArgue that if line 9 of P ROTO -VEB-M INIMUM is executed, then the proto-vEB\nstructure is empty.\n20.2-8\nSuppose that we designed a proto-vEB structure in which each cluster array had\nonlyu1=4elements. What would the running times of each operation be?\n20.3 The van Emde Boas tree\nThe proto-vEB structure of the previous section is close to what we need to achieve\nO.lg lgu/running times. It falls short because we have to recurse too many times\nin most of the operations. In this section, we shall design a data structure thatis similar to the proto-vEB structure but stores a little more information, therebyremoving the need for some of the recursion.\nIn Section 20.2, we observed that the assumption that we made about the uni-\nverse size\u2014that uD2\n2kfor some integer k\u2014is unduly restrictive, con\ufb01ning the\npossible values of uan overly sparse set. From this point on, therefore, we will\nallow the universe size uto be any exact power of 2,a n dw h e np\nuis not an inte-", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "566": {"page_number": 567, "page_information": "546 Chapter 20 van Emde Boas Trees\n\u2026 0123\"p\nu/NUL1/ETBEB.u/ u min max\nsummary cluster\n/ETBEB.\"p\nu/\n\"p\nu/ETBEB.#p\nu/trees\nFigure 20.5 The information in a /ETBEB.u/tree when u>2 . The structure contains the uni-\nverse size u,e l e m e n t s min and max, a pointer summary to a /ETBEB.\"p\nu/tree, and an array\ncluster \u01520 : :\"p\nu/NUL1/c141of\"p\nupointers to /ETBEB.#p\nu/trees.\nger\u2014that is, if uis an odd power of 2(uD22kC1for some integer k/NAK0)\u2014then\nwe will divide the lg ubits of a number into the most signi\ufb01cant d.lgu/=2ebits and\nthe least signi\ufb01cant b.lgu/=2cbits. For convenience, we denote 2d.lgu/=2 e(the \u201cup-\nper square root\u201d of u)b y\"p\nuand2b.lgu/=2 c(the \u201clower square root\u201d of u)b y#p\nu,\nso that uD\"p\nu/SOH#p\nuand, when uis an even power of 2(uD22kfor some\ninteger k),\"p\nuD#p\nuDp\nu. Because we now allow uto be an odd power of 2,\nwe must rede\ufb01ne our helpful functions from Section 20.2:\nhigh.x/D/EOT\nx=#p\nu\u02d8\n;\nlow.x/Dxmod#p\nu;\nindex .x; y/Dx#p\nuCy:\n20.3.1 van Emde Boas trees\nThevan Emde Boas tree ,o rvEB tree , modi\ufb01es the proto-vEB structure. We\ndenote a vEB tree with a universe size of uas/ETBEB.u/and, unless uequals the\nbase size of 2, the attribute summary points to a /ETBEB.\"p\nu/tree and the array\ncluster \u01520 : :\"p\nu/NUL1/c141points to\"p\nu/ETBEB.#p\nu/trees. As Figure 20.5 illustrates, a\nvEB tree contains two attributes not found in a proto-vEB structure:\n/SIminstores the minimum element in the vEB tree, and\n/SImax stores the maximum element in the vEB tree.\nFurthermore, the element stored in min does not appear in any of the recur-\nsive/ETBEB.#p\nu/trees that the cluster array points to. The elements stored in a\n/ETBEB.u/treeV, therefore, are V:min plus all the elements recursively stored in\nthe/ETBEB.#p\nu/trees pointed to by V:cluster \u01520 : :\"p\nu/NUL1/c141. Note that when a vEB\ntree contains two or more elements, we treat minandmax differently: the element", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "567": {"page_number": 568, "page_information": "20.3 The van Emde Boas tree 547\nstored in mindoes not appear in any of the clusters, but the element stored in max\ndoes.\nSince the base size is 2,a/ETBEB.2/tree does not need the array Athat the cor-\nresponding proto -/ETBEB.2/structure has. Instead, we can determine its elements\nfrom its minandmax attributes. In a vEB tree with no elements, regardless of its\nuniverse size u, both minandmax areNIL.\nFigure 20.6 shows a /ETBEB.16/ treeVholding the setf2; 3; 4; 5; 7; 14; 15g.B e -\ncause the smallest element is 2,V:minequals 2, and even though high .2/D0,t h e\nelement 2does not appear in the /ETBEB.4/tree pointed to by V:cluster \u01520/c141: notice\nthatV:cluster \u01520/c141:minequals 3,a n ds o 2is not in this vEB tree. Similarly, since\nV:cluster \u01520/c141:minequals 3,a n d 2and3are the only elements in V:cluster \u01520/c141,t h e\n/ETBEB.2/clusters within V:cluster \u01520/c141are empty.\nThe minandmax attributes will turn out to be key to reducing the number of\nrecursive calls within the operations on vEB trees. These attributes will help us infour ways:\n1. The M\nINIMUM and M AXIMUM operations do not even need to recurse, for they\ncan just return the values of minormax.\n2. The S UCCESSOR operation can avoid making a recursive call to determine\nwhether the successor of a value xlies within high .x/. That is because x\u2019s\nsuccessor lies within its cluster if and only if xis strictly less than the max\nattribute of its cluster. A symmetric argument holds for P REDECESSOR and\nmin.\n3. We can tell whether a vEB tree has no elements, exactly one element, or at least\ntwo elements in constant time from its minandmax values. This ability will\nhelp in the I NSERT and D ELETE operations. If minandmax are both NIL,t h e n\nthe vEB tree has no elements. If minandmax are non- NILbut are equal to each\nother, then the vEB tree has exactly one element. Otherwise, both minandmax\nare non- NILbut are unequal, and the vEB tree has two or more elements.\n4. If we know that a vEB tree is empty, we can insert an element into it by updating\nonly its minandmax attributes. Hence, we can insert into an empty vEB tree in\nconstant time. Similarly, if we know that a vEB tree has only one element, wecan delete that element in constant time by updating only minandmax. These\nproperties will allow us to cut short the chain of recursive calls.\nEven if the universe size uis an odd power of 2, the difference in the sizes\nof the summary vEB tree and the clusters will not turn out to affect the asymptoticrunning times of the vEB-tree operations. The recursive procedures that implementthe vEB-tree operations will all have running times characterized by the recurrence\nT. u //DC4T.\n\"p\nu/CO.1/ : (20.4)", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "568": {"page_number": 569, "page_information": "548 Chapter 20 van Emde Boas Trees\n0123\nclusteru16\nsummaryvEB(16) min 2max 15\n01\nclusteru4\nsummaryvEB(4) min 0max 3\nu2\nmin 0\nmax 1vEB(2)\nu2\nmin 1\nmax 1vEB(2)\nu2\nmin 1\nmax 1vEB(2)01\ncluster summary\nu2\nmin\nmaxvEB(2)\nu2\nmin\nmaxvEB(2)\nu2\nmin\nmaxvEB(2)01\ncluster summary\nu2\nmin 0\nmax 1vEB(2)\nu2\nmin 1\nmax 1vEB(2)\nu2\nmin 1\nmax 1vEB(2)\n01\ncluster summary\nu2\nmin\nmaxvEB(2)\nu2\nmin\nmaxvEB(2)\nu2\nmin\nmaxvEB(2)01\ncluster summary\nu2\nmin 1\nmax 1vEB(2)\nu2\nmin\nmaxvEB(2)\nu2\nmin 1\nmax 1vEB(2)u4 vEB(4) min 3max 3 u4 vEB(4) min 0max 3\nu4 vEB(4) min max u4 vEB(4) min 2max 3\nFigure 20.6 A/ETBEB.16/ tree corresponding to the proto-vEB tree in Figure 20.4. It stores the set\nf2; 3; 4; 5; 7; 14; 15g. Slashes indicate NILvalues. The value stored in the minattribute of a vEB tree\ndoes not appear in any of its clusters. Heavy shading serves the same purpose here as in Figure 20.4.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "569": {"page_number": 570, "page_information": "20.3 The van Emde Boas tree 549\nThis recurrence looks similar to recurrence (20.2), and we will solve it in a similar\nfashion. Letting mDlgu, we rewrite it as\nT. 2m//DC4T. 2dm=2e/CO.1/ :\nNoting thatdm=2e/DC42m=3 for all m/NAK2,w eh a v e\nT. 2m//DC4T. 22m=3/CO.1/ :\nLetting S.m/DT. 2m/, we rewrite this last recurrence as\nS.m//DC4S.2m=3/CO.1/ ;\nwhich, by case 2 of the master method, has the solution S.m/DO.lgm/. (In\nterms of the asymptotic solution, the fraction 2=3 does not make any difference\ncompared with the fraction 1=2, because when we apply the master method, we\n\ufb01nd that log3=21Dlog21D0:) Thus, we have T. u /DT. 2m/DS.m/D\nO.lgm/DO.lg lgu/.\nBefore using a van Emde Boas tree, we must know the universe size u,s ot h a t\nwe can create a van Emde Boas tree of the appropriate size that initially represents\nan empty set. As Problem 20-1 asks you to show, the total space requirement ofa van Emde Boas tree is O.u/ , and it is straightforward to create an empty tree\ninO.u/ time. In contrast, we can create an empty red-black tree in constant time.\nTherefore, we might not want to use a van Emde Boas tree when we perform onlya small number of operations, since the time to create the data structure wouldexceed the time saved in the individual operations. This drawback is usually notsigni\ufb01cant, since we typically use a simple data structure, such as an array or linkedlist, to represent a set with only a few elements.\n20.3.2 Operations on a van Emde Boas tree\nWe are now ready to see how to perform operations on a van Emde Boas tree. As\nwe did for the proto van Emde Boas structure, we will consider the querying oper-ations \ufb01rst, and then I\nNSERT and D ELETE . Due to the slight asymmetry between\nthe minimum and maximum elements in a vEB tree\u2014when a vEB tree containsat least two elements, the minumum element does not appear within a cluster butthe maximum element does\u2014we will provide pseudocode for all \ufb01ve querying op-erations. As in the operations on proto van Emde Boas structures, the operationshere that take parameters Vandx,w h e r e Vis a van Emde Boas tree and xis an\nelement, assume that 0/DC4x<V : u.\nFinding the minimum and maximum elements\nBecause we store the minimum and maximum in the attributes minandmax,t w o\nof the operations are one-liners, taking constant time:", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "570": {"page_number": 571, "page_information": "550 Chapter 20 van Emde Boas Trees\nVEB-T REE-MINIMUM .V /\n1return V:min\nVEB-T REE-MAXIMUM .V /\n1return V:max\nDetermining whether a value is in the set\nThe procedure VEB-T REE-MEMBER .V; x/ has a recursive case like that of\nPROTO -VEB-M EMBER , but the base case is a little different. We also check di-\nrectly whether xequals the minimum or maximum element. Since a vEB tree\ndoesn\u2019t store bits as a proto-vEB structure does, we design VEB-T REE-MEMBER\nto return TRUE orFALSE rather than 1or0.\nVEB-T REE-MEMBER .V; x/\n1ifx==V:minorx==V:max\n2 return TRUE\n3elseif V:u==2\n4 return FALSE\n5else return VEB-T REE-MEMBER .V:cluster \u0152high.x//c141; low.x//\nLine 1 checks to see whether xequals either the minimum or maximum element.\nIf it does, line 2 returns TRUE . Otherwise, line 3 tests for the base case. Since\na/ETBEB.2/tree has no elements other than those in minandmax, if it is the base\ncase, line 4 returns FALSE . The other possibility\u2014it is not a base case and xequals\nneither minnormax\u2014is handled by the recursive call in line 5.\nRecurrence (20.4) characterizes the running time of the VEB-T REE-MEMBER\nprocedure, and so this procedure takes O.lg lgu/time.\nFinding the successor and predecessor\nNext we see how to implement the S UCCESSOR operation. Recall that the pro-\ncedure P ROTO -VEB-S UCCESSOR .V; x/ could make two recursive calls: one to\ndetermine whether x\u2019s successor resides in the same cluster as xand, if it does\nnot, one to \ufb01nd the cluster containing x\u2019s successor. Because we can access the\nmaximum value in a vEB tree quickly, we can avoid making two recursive calls,and instead make one recursive call on either a cluster or on the summary, but noton both.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "571": {"page_number": 572, "page_information": "20.3 The van Emde Boas tree 551\nVEB-T REE-SUCCESSOR .V; x/\n1ifV:u==2\n2 ifx==0andV:max ==1\n3 return 1\n4 else return NIL\n5elseif V:min\u00a4NILandx<V : min\n6 return V:min\n7elsemax-lowDVEB-T REE-MAXIMUM .V:cluster \u0152high.x//c141/\n8 ifmax-low\u00a4NILand low .x/ < max-low\n9 offsetDVEB-T REE-SUCCESSOR .V:cluster \u0152high.x//c141; low.x//\n10 return index .high.x/;offset /\n11 elsesucc-clusterDVEB-T REE-SUCCESSOR .V:summary ;high.x//\n12 ifsucc-cluster ==NIL\n13 return NIL\n14 elseoffsetDVEB-T REE-MINIMUM .V:cluster \u0152succ-cluster /c141/\n15 return index .succ-cluster ;offset /\nThis procedure has six return statements and several cases. We start with the\nbase case in lines 2\u20134, which returns 1in line 3 if we are trying to \ufb01nd the successor\nof0and1is in the 2-element set; otherwise, the base case returns NILin line 4.\nIf we are not in the base case, we next check in line 5 whether xis strictly less\nthan the minimum element. If so, then we simply return the minimum element inline 6.\nIf we get to line 7, then we know that we are not in a base case and that xis\ngreater than or equal to the minimum value in the vEB tree V. Line 7 assigns to\nmax-lowthe maximum element in x\u2019s cluster. If x\u2019s cluster contains some element\nthat is greater than x, then we know that x\u2019s successor lies somewhere within x\u2019s\ncluster. Line 8 tests for this condition. If x\u2019s successor is within x\u2019s cluster, then\nline 9 determines where in the cluster it is, and line 10 returns the successor in the\nsame way as line 7 of P\nROTO -VEB-S UCCESSOR .\nWe get to line 11 if xis greater than or equal to the greatest element in its\ncluster. In this case, lines 11\u201315 \ufb01nd x\u2019s successor in the same way as lines 8\u201312\nof P ROTO -VEB-S UCCESSOR .\nIt is easy to see how recurrence (20.4) characterizes the running time of VEB-\nTREE-SUCCESSOR . Depending on the result of the test in line 7, the procedure\ncalls itself recursively in either line 9 (on a vEB tree with universe size#p\nu)o r\nline 11 (on a vEB tree with universe size\"p\nu). In either case, the one recursive\ncall is on a vEB tree with universe size at most\"p\nu. The remainder of the proce-\ndure, including the calls to VEB-T REE-MINIMUM and VEB-T REE-MAXIMUM ,\ntakes O.1/ time. Hence, VEB-T REE-SUCCESSOR runs in O.lg lgu/worst-case\ntime.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "572": {"page_number": 573, "page_information": "552 Chapter 20 van Emde Boas Trees\nThe VEB-T REE-PREDECESSOR procedure is symmetric to the VEB-T REE-\nSUCCESSOR procedure, but with one additional case:\nVEB-T REE-PREDECESSOR .V; x/\n1ifV:u==2\n2 ifx==1andV:min ==0\n3 return 0\n4 else return NIL\n5elseif V:max\u00a4NILandx>V : max\n6 return V:max\n7elsemin-lowDVEB-T REE-MINIMUM .V:cluster \u0152high.x//c141/\n8 ifmin-low\u00a4NILand low .x/ > min-low\n9 offsetDVEB-T REE-PREDECESSOR .V:cluster \u0152high.x//c141; low.x//\n10 return index .high.x/;offset /\n11 elsepred-clusterDVEB-T REE-PREDECESSOR .V:summary ;high.x//\n12 ifpred-cluster ==NIL\n13 ifV:min\u00a4NILandx>V : min\n14 return V:min\n15 else return NIL\n16 elseoffsetDVEB-T REE-MAXIMUM .V:cluster \u0152pred-cluster /c141/\n17 return index .pred-cluster ;offset /\nLines 13\u201314 form the additional case. This case occurs when x\u2019s predecessor,\nif it exists, does not reside in x\u2019s cluster. In VEB-T REE-SUCCESSOR ,w ew e r e\nassured that if x\u2019s successor resides outside of x\u2019s cluster, then it must reside in\na higher-numbered cluster. But if x\u2019s predecessor is the minimum value in vEB\ntreeV, then the successor resides in no cluster at all. Line 13 checks for this\ncondition, and line 14 returns the minimum value as appropriate.\nThis extra case does not affect the asymptotic running time of VEB-T REE-\nPREDECESSOR when compared with VEB-T REE-SUCCESSOR ,a n d s o VEB-\nTREE-PREDECESSOR runs in O.lg lgu/worst-case time.\nInserting an element\nNow we examine how to insert an element into a vEB tree. Recall that P ROTO -\nVEB-I NSERT made two recursive calls: one to insert the element and one to insert\nthe element\u2019s cluster number into the summary. The VEB-T REE-INSERT proce-\ndure will make only one recursive call. How can we get away with just one? When\nwe insert an element, either the cluster that it goes into already has another elementor it does not. If the cluster already has another element, then the cluster number\nis already in the summary, and so we do not need to make that recursive call. If", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "573": {"page_number": 574, "page_information": "20.3 The van Emde Boas tree 553\nthe cluster does not already have another element, then the element being inserted\nbecomes the only element in the cluster, and we do not need to recurse to insert anelement into an empty vEB tree:\nVEB-E MPTY -TREE-INSERT .V; x/\n1V:minDx\n2V:maxDx\nWith this procedure in hand, here is the pseudocode for VEB-T REE-INSERT .V; x/ ,\nwhich assumes that xis not already an element in the set represented by vEB\ntreeV:\nVEB-T REE-INSERT .V; x/\n1ifV:min ==NIL\n2 VEB-E MPTY -TREE-INSERT .V; x/\n3else if x<V : min\n4 exchange xwithV:min\n5 ifV:u>2\n6 ifVEB-T REE-MINIMUM .V:cluster \u0152high.x//c141/ ==NIL\n7 VEB-T REE-INSERT .V:summary ;high.x//\n8 VEB-E MPTY -TREE-INSERT .V:cluster \u0152high.x//c141; low.x//\n9 else VEB-T REE-INSERT .V:cluster \u0152high.x//c141; low.x//\n10 ifx>V : max\n11 V:maxDx\nThis procedure works as follows. Line 1 tests whether Vis an empty vEB tree\nand, if it is, then line 2 handles this easy case. Lines 3\u201311 assume that Vis not\nempty, and therefore some element will be inserted into one of V\u2019s clusters. But\nthat element might not necessarily be the element xpassed to VEB-T REE-INSERT .\nIfx< min, as tested in line 3, then xneeds to become the new min. We don\u2019t\nwant to lose the original min, however, and so we need to insert it into one of V\u2019s\nclusters. In this case, line 4 exchanges xwith min, so that we insert the original\nmininto one of V\u2019s clusters.\nWe execute lines 6\u20139 only if Vis not a base-case vEB tree. Line 6 determines\nwhether the cluster that xwill go into is currently empty. If so, then line 7 in-\nserts x\u2019s cluster number into the summary and line 8 handles the easy case of\ninserting xinto an empty cluster. If x\u2019s cluster is not currently empty, then line 9\ninserts xinto its cluster. In this case, we do not need to update the summary,\nsince x\u2019s cluster number is already a member of the summary.\nFinally, lines 10\u201311 take care of updating max ifx> max. Note that if Vis a\nbase-case vEB tree that is not empty, then lines 3\u20134 and 10\u201311 update minandmax\nproperly.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "574": {"page_number": 575, "page_information": "554 Chapter 20 van Emde Boas Trees\nOnce again, we can easily see how recurrence (20.4) characterizes the running\ntime. Depending on the result of the test in line 6, either the recursive call in line 7(run on a vEB tree with universe size\n\"p\nu) or the recursive call in line 9 (run on\na vEB with universe size#p\nu) executes. In either case, the one recursive call is\non a vEB tree with universe size at most\"p\nu. Because the remainder of VEB-\nTREE-INSERT takes O.1/ time, recurrence (20.4) applies, and so the running time\nisO.lg lgu/.\nDeleting an element\nFinally, we look at how to delete an element from a vEB tree. The procedure\nVEB-T REE-DELETE .V; x/ assumes that xis currently an element in the set repre-\nsented by the vEB tree V.\nVEB-T REE-DELETE .V; x/\n1ifV:min ==V:max\n2 V:minDNIL\n3 V:maxDNIL\n4elseif V:u==2\n5 ifx==0\n6 V:minD1\n7 elseV:minD0\n8 V:maxDV:min\n9else if x==V:min\n10 \ufb01rst-clusterDVEB-T REE-MINIMUM .V:summary /\n11 xDindex .\ufb01rst-cluster ;\nVEB-T REE-MINIMUM .V:cluster \u0152\ufb01rst-cluster /c141//\n12 V:minDx\n13 VEB-T REE-DELETE .V:cluster \u0152high.x//c141; low.x//\n14 ifVEB-T REE-MINIMUM .V:cluster \u0152high.x//c141/ ==NIL\n15 VEB-T REE-DELETE .V:summary ;high.x//\n16 ifx==V:max\n17 summary -maxDVEB-T REE-MAXIMUM .V:summary /\n18 ifsummary -max ==NIL\n19 V:maxDV:min\n20 elseV:maxDindex .summary -max;\nVEB-T REE-MAXIMUM .V:cluster \u0152summary -max/c141//\n21 elseif x==V:max\n22 V:maxDindex .high.x/;\nVEB-T REE-MAXIMUM .V:cluster \u0152high.x//c141//", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "575": {"page_number": 576, "page_information": "20.3 The van Emde Boas tree 555\nThe VEB-T REE-DELETE procedure works as follows. If the vEB tree Vcon-\ntains only one element, then it\u2019s just as easy to delete it as it was to insert an elementinto an empty vEB tree: just set minandmax to\nNIL. Lines 1\u20133 handle this case.\nOtherwise, Vhas at least two elements. Line 4 tests whether Vis a base-case vEB\ntree and, if so, lines 5\u20138 set minandmax to the one remaining element.\nLines 9\u201322 assume that Vhas two or more elements and that u/NAK4.I n t h i s\ncase, we will have to delete an element from a cluster. The element we delete froma cluster might not be x, however, because if xequals min, then once we have\ndeleted x, some other element within one of V\u2019s clusters becomes the new min,\nand we have to delete that other element from its cluster. If the test in line 9 revealsthat we are in this case, then line 10 sets \ufb01rst-cluster to the number of the cluster\nthat contains the lowest element other than min, and line 11 sets xto the value of\nthe lowest element in that cluster. This element becomes the new minin line 12\nand, because we set xto its value, it is the element that will be deleted from its\ncluster.\nWhen we reach line 13, we know that we need to delete element xfrom its\ncluster, whether xwas the value originally passed to\nVEB-T REE-DELETE orx\nis the element becoming the new minimum. Line 13 deletes xfrom its cluster.\nThat cluster might now become empty, which line 14 tests, and if it does, thenwe need to remove x\u2019s cluster number from the summary, which line 15 handles.\nAfter updating the summary, we might need to update max. Line 16 checks to see\nwhether we are deleting the maximum element in Vand, if we are, then line 17 sets\nsummary -max to the number of the highest-numbered nonempty cluster. (The call\nVEB-T REE-MAXIMUM .V:summary /works because we have already recursively\ncalled VEB-T REE-DELETE onV:summary , and therefore V:summary :max has al-\nready been updated as necessary.) If all of V\u2019s clusters are empty, then the only\nremaining element in Vismin; line 18 checks for this case, and line 19 updates\nmax appropriately. Otherwise, line 20 sets max to the maximum element in the\nhighest-numbered cluster. (If this cluster is where the element has been deleted,we again rely on the recursive call in line 13 having already corrected that cluster\u2019smax attribute.)\nFinally, we have to handle the case in which x\u2019s cluster did not become empty\ndue to xbeing deleted. Although we do not have to update the summary in this\ncase, we might have to update max. Line 21 tests for this case, and if we have to\nupdate max, line 22 does so (again relying on the recursive call to have corrected\nmax in the cluster).\nNow we show that\nVEB-T REE-DELETE runs in O.lg lgu/time in the worst\ncase. At \ufb01rst glance, you might think that recurrence (20.4) does not always apply,because a single call of\nVEB-T REE-DELETE can make two recursive calls: one\non line 13 and one on line 15. Although the procedure can make both recursivecalls, let\u2019s think about what happens when it does. In order for the recursive call on", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "576": {"page_number": 577, "page_information": "556 Chapter 20 van Emde Boas Trees\nline 15 to occur, the test on line 14 must show that x\u2019s cluster is empty. The only\nway that x\u2019s cluster can be empty is if xwas the only element in its cluster when\nwe made the recursive call on line 13. But if xwas the only element in its cluster,\nthen that recursive call took O.1/ time, because it executed only lines 1\u20133. Thus,\nwe have two mutually exclusive possibilities:\n/SIThe recursive call on line 13 took constant time.\n/SIThe recursive call on line 15 did not occur.\nIn either case, recurrence (20.4) characterizes the running time of VEB-T REE-\nDELETE , and hence its worst-case running time is O.lg lgu/.\nExercises\n20.3-1\nModify vEB trees to support duplicate keys.\n20.3-2\nModify vEB trees to support keys that have associated satellite data.\n20.3-3\nWrite pseudocode for a procedure that creates an empty van Emde Boas tree.\n20.3-4\nWhat happens if you call VEB-T REE-INSERT with an element that is already in\nthe vEB tree? What happens if you call VEB-T REE-DELETE with an element that\nis not in the vEB tree? Explain why the procedures exhibit the behavior that theydo. Show how to modify vEB trees and their operations so that we can check in\nconstant time whether an element is present.\n20.3-5\nSuppose that instead of\n\"p\nuclusters, each with universe size#p\nu, we constructed\nvEB trees to have u1=kclusters, each with universe size u1/NUL1=k,w h e r e k>1 is a\nconstant. If we were to modify the operations appropriately, what would be theirrunning times? For the purpose of analysis, assume that u\n1=kandu1/NUL1=kare always\nintegers.\n20.3-6\nCreating a vEB tree with universe size urequires O.u/ time. Suppose we wish to\nexplicitly account for that time. What is the smallest number of operations nfor\nwhich the amortized time of each operation in a vEB tree is O.lg lgu/?", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "577": {"page_number": 578, "page_information": "Problems for Chapter 20 557\nProblems\n20-1 Space requirements for van Emde Boas trees\nThis problem explores the space requirements for van Emde Boas trees and sug-gests a way to modify the data structure to make its space requirement depend onthe number nof elements actually stored in the tree, rather than on the universe\nsizeu. For simplicity, assume thatp\nuis always an integer.\na.Explain why the following recurrence characterizes the space requirement P.u/\nof a van Emde Boas tree with universe size u:\nP.u/D.p\nuC1/P.p\nu/C\u201a.p\nu/ : (20.5)\nb.Prove that recurrence (20.5) has the solution P.u/DO.u/ .\nIn order to reduce the space requirements, let us de\ufb01ne a reduced-space van Emde\nBoas tree ,o rRS-vEB tree , as a vEB tree Vbut with the following changes:\n/SIThe attribute V:cluster , rather than being stored as a simple array of pointers to\nvEB trees with universe sizep\nu, is a hash table (see Chapter 11) stored as a dy-\nnamic table (see Section 17.4). Corresponding to the array version of V:cluster ,\nthe hash table stores pointers to RS-vEB trees with universe sizep\nu.T o \ufb01 n d\ntheith cluster, we look up the key iin the hash table, so that we can \ufb01nd the\nith cluster by a single search in the hash table.\n/SIThe hash table stores only pointers to nonempty clusters. A search in the hash\ntable for an empty cluster returns NIL, indicating that the cluster is empty.\n/SIThe attribute V:summary isNILif all clusters are empty. Otherwise, V:summary\npoints to an RS-vEB tree with universe sizep\nu.\nBecause the hash table is implemented with a dynamic table, the space it requires\nis proportional to the number of nonempty clusters.\nWhen we need to insert an element into an empty RS-vEB tree, we create the RS-\nvEB tree by calling the following procedure, where the parameter uis the universe\nsize of the RS-vEB tree:\nCREATE -NEW-RS- VEB-T REE.u/\n1 allocate a new vEB tree V\n2V:uDu\n3V:minDNIL\n4V:maxDNIL\n5V:summaryDNIL\n6 create V:cluster as an empty dynamic hash table\n7return V", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "578": {"page_number": 579, "page_information": "558 Chapter 20 van Emde Boas Trees\nc.Modify the VEB-T REE-INSERT procedure to produce pseudocode for the pro-\ncedure RS- VEB-T REE-INSERT .V; x/ , which inserts xinto the RS-vEB tree V,\ncalling C REATE -NEW-RS- VEB-T REE as appropriate.\nd.Modify the VEB-T REE-SUCCESSOR procedure to produce pseudocode for\nthe procedure RS- VEB-T REE-SUCCESSOR .V; x/ , which returns the successor\nofxin RS-vEB tree V,o r NILifxhas no successor in V.\ne.Prove that, under the assumption of simple uniform hashing, your RS- VEB-\nTREE-INSERT and RS- VEB-T REE-SUCCESSOR procedures run in O.lg lgu/\nexpected time.\nf.Assuming that elements are never deleted from a vEB tree, prove that the space\nrequirement for the RS-vEB tree structure is O.n/ ,w h e r e nis the number of\nelements actually stored in the RS-vEB tree.\ng.RS-vEB trees have another advantage over vEB trees: they require less time to\ncreate. How long does it take to create an empty RS-vEB tree?\n20-2 y-fast tries\nThis problem investigates D. Willard\u2019s \u201c y-fast tries\u201d which, like van Emde Boas\ntrees, perform each of the operations M EMBER ,M INIMUM ,M AXIMUM ,PRE-\nDECESSOR ,a n dS UCCESSOR on elements drawn from a universe with size uin\nO.lg lgu/worst-case time. The I NSERT and D ELETE operations take O.lg lgu/\namortized time. Like reduced-space van Emde Boas trees (see Problem 20-1), y-\nfast tries use only O.n/ space to store nelements. The design of y-fast tries relies\non perfect hashing (see Section 11.5).\nAs a preliminary structure, suppose that we create a perfect hash table containing\nnot only every element in the dynamic set, but every pre\ufb01x of the binary represen-tation of every element in the set. For example, if uD16,s ot h a tl g uD4,a n d\nxD13is in the set, then because the binary representation of 13is1101 ,t h e\nperfect hash table would contain the strings 1,11,110,a n d 1101 . In addition to\nthe hash table, we create a doubly linked list of the elements currently in the set, inincreasing order.\na.How much space does this structure require?\nb.Show how to perform the M\nINIMUM and M AXIMUM operations in O.1/ time;\nthe M EMBER ,PREDECESSOR ,a n dS UCCESSOR operations in O.lg lgu/time;\nand the I NSERT and D ELETE operations in O.lgu/time.\nTo reduce the space requirement to O.n/ , we make the following changes to the\ndata structure:", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "579": {"page_number": 580, "page_information": "Notes for Chapter 20 559\n/SIWe cluster the nelements into n=lgugroups of size lg u. (Assume for now\nthat lg udivides n.) The \ufb01rst group consists of the lg usmallest elements in the\nset, the second group consists of the next lg usmallest elements, and so on.\n/SIWe designate a \u201crepresentative\u201d value for each group. The representative of\ntheith group is at least as large as the largest element in the ith group, and it is\nsmaller than every element of the .iC1/st group. (The representative of the last\ngroup can be the maximum possible element u/NUL1.) Note that a representative\nmight be a value not currently in the set.\n/SIWe store the lg uelements of each group in a balanced binary search tree, such\nas a red-black tree. Each representative points to the balanced binary searchtree for its group, and each balanced binary search tree points to its group\u2019srepresentative.\n/SIThe perfect hash table stores only the representatives, which are also stored ina doubly linked list in increasing order.\nWe call this structure a y-fast trie .\nc.Show that a y-fast trie requires only O.n/ space to store nelements.\nd.Show how to perform the M\nINIMUM and M AXIMUM operations in O.lg lgu/\ntime with a y-fast trie.\ne.Show how to perform the M EMBER operation in O.lg lgu/time.\nf.Show how to perform the P REDECESSOR and S UCCESSOR operations in\nO.lg lgu/time.\ng.Explain why the I NSERT and D ELETE operations take /DEL.lg lgu/time.\nh.Show how to relax the requirement that each group in a y-fast trie has exactly\nlguelements to allow I NSERT and D ELETE to run in O.lg lgu/amortized time\nwithout affecting the asymptotic running times of the other operations.\nChapter notes\nThe data structure in this chapter is named after P. van Emde Boas, who describedan early form of the idea in 1975 [339]. Later papers by van Emde Boas [340]and van Emde Boas, Kaas, and Zijlstra [341] re\ufb01ned the idea and the exposition.Mehlhorn and N\u00a8 aher [252] subsequently extended the ideas to apply to universe", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "580": {"page_number": 581, "page_information": "560 Chapter 20 van Emde Boas Trees\nsizes that are prime. Mehlhorn\u2019s book [249] contains a slightly different treatment\nof van Emde Boas trees than the one in this chapter.\nUsing the ideas behind van Emde Boas trees, Dementiev et al. [83] developed\na nonrecursive, three-level search tree that ran faster than van Emde Boas trees intheir own experiments.\nWang and Lin [347] designed a hardware-pipelined version of van Emde Boas\ntrees, which achieves constant amortized time per operation and uses O.lg lgu/\nstages in the pipeline.\nA lower bound by P\u02c7 atras\u00b8cu and Thorup [273, 274] for \ufb01nding the predecessor\nshows that van Emde Boas trees are optimal for this operation, even if randomiza-tion is allowed.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "581": {"page_number": 582, "page_information": "21 Data Structures for Disjoint Sets\nSome applications involve grouping ndistinct elements into a collection of disjoint\nsets. These applications often need to perform two operations in particular: \ufb01ndingthe unique set that contains a given element and uniting two sets. This chapterexplores methods for maintaining a data structure that supports these operations.\nSection 21.1 describes the operations supported by a disjoint-set data structure\nand presents a simple application. In Section 21.2, we look at a simple linked-listimplementation for disjoint sets. Section 21.3 presents a more ef\ufb01cient represen-tation using rooted trees. The running time using the tree representation is theo-retically superlinear, but for all practical purposes it is linear. Section 21.4 de\ufb01nesand discusses a very quickly growing function and its very slowly growing inverse,which appears in the running time of operations on the tree-based implementation,and then, by a complex amortized analysis, proves an upper bound on the runningtime that is just barely superlinear.\n21.1 Disjoint-set operations\nAdisjoint-set data structure maintains a collection SDfS1;S2;:::;S kgof dis-\njoint dynamic sets. We identify each set by a representative , which is some mem-\nber of the set. In some applications, it doesn\u2019t matter which member is used as therepresentative; we care only that if we ask for the representative of a dynamic settwice without modifying the set between the requests, we get the same answer bothtimes. Other applications may require a prespeci\ufb01ed rule for choosing the repre-sentative, such as choosing the smallest member in the set (assuming, of course,that the elements can be ordered).\nAs in the other dynamic-set implementations we have studied, we represent each\nelement of a set by an object. Letting xdenote an object, we wish to support the\nfollowing operations:", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "582": {"page_number": 583, "page_information": "562 Chapter 21 Data Structures for Disjoint Sets\nMAKE-SET.x/creates a new set whose only member (and thus representative)\nisx. Since the sets are disjoint, we require that xnot already be in some other\nset.\nUNION .x; y/ unites the dynamic sets that contain xandy, say SxandSy,i n t oa\nnew set that is the union of these two sets. We assume that the two sets are dis-joint prior to the operation. The representative of the resulting set is any memberofS\nx[Sy, although many implementations of U NION speci\ufb01cally choose the\nrepresentative of either SxorSyas the new representative. Since we require\nthe sets in the collection to be disjoint, conceptually we destroy sets SxandSy,\nremoving them from the collection S. In practice, we often absorb the elements\nof one of the sets into the other set.\nFIND-SET.x/returns a pointer to the representative of the (unique) set contain-\ningx.\nThroughout this chapter, we shall analyze the running times of disjoint-set data\nstructures in terms of two parameters: n, the number of M AKE-SEToperations,\nandm, the total number of M AKE-SET,UNION ,a n dF IND-SEToperations. Since\nthe sets are disjoint, each U NION operation reduces the number of sets by one.\nAfter n/NUL1UNION operations, therefore, only one set remains. The number of\nUNION operations is thus at most n/NUL1. Note also that since the M AKE-SET\noperations are included in the total number of operations m,w eh a v e m/NAKn.W e\nassume that the nMAKE-SEToperations are the \ufb01rst noperations performed.\nAn application of disjoint-set data structures\nOne of the many applications of disjoint-set data structures arises in determin-\ning the connected components of an undirected graph (see Section B.4). Fig-ure 21.1(a), for example, shows a graph with four connected components.\nThe procedure C\nONNECTED -COMPONENTS that follows uses the disjoint-set\noperations to compute the connected components of a graph. Once C ONNECTED -\nCOMPONENTS has preprocessed the graph, the procedure S AME -COMPONENT\nanswers queries about whether two vertices are in the same connected component.1\n(In pseudocode, we denote the set of vertices of a graph GbyG:Vand the set of\nedges by G:E.)\n1When the edges of the graph are static\u2014not changing over time\u2014we can compute the connected\ncomponents faster by using depth-\ufb01rst search (Exercise 22.3-12). Sometimes, however, the edges\nare added dynamically and we need to maintain the connected components as each edge is added. In\nthis case, the implementation given here can be more ef\ufb01cient than running a new depth-\ufb01rst search\nfor each new edge.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "583": {"page_number": 584, "page_information": "21.1 Disjoint-set operations 563\nab\ncdef\ngh\nij\nEdge processed\ninitial sets\n(b,d)\n(e,g)\n(a,c)\n(h,i)\n(a,b)\n(e,f)\n(b,c){a,b,c,d}{a,b,c,d}{a,c}{a,c}{a}{a}{a}\n{a,b,c,d}{b,d}{b,d}{b,d}{b,d}{b}\n{c}{c}{c}{d}\n{e, f,g}{e, f,g}{e,g}{e,g}{e,g}{e,g}{e}{e}{ f}\n{f}\n{f}\n{f}\n{f}\n{f}{g}\n{g}\n{h,i}{h,i}{h,i}{h,i}{h}{h}{h}{h}{ i}\n{i}\n{i}\n{i}{j}\n{j}\n{j}\n{j}\n{j}\n{j}\n{j}\n{j}Collection of disjoint sets(a)\n(b)\nFigure 21.1 (a) A graph with four connected components: fa; b; c; dg,fe;f;gg,fh; ig,a n dfjg.\n(b)The collection of disjoint sets after processing each edge.\nCONNECTED -COMPONENTS .G/\n1foreach vertex /ETB2G:V\n2M AKE-SET./ETB/\n3foreach edge .u; /ETB/2G:E\n4 ifFIND-SET.u/\u00a4FIND-SET./ETB/\n5U NION .u; /ETB/\nSAME -COMPONENT .u; /ETB/\n1ifFIND-SET.u/==FIND-SET./ETB/\n2 return TRUE\n3else return FALSE\nThe procedure C ONNECTED -COMPONENTS initially places each vertex /ETBin its\nown set. Then, for each edge .u; /ETB/ , it unites the sets containing uand/ETB.B y\nExercise 21.1-2, after processing all the edges, two vertices are in the same con-nected component if and only if the corresponding objects are in the same set.Thus, C\nONNECTED -COMPONENTS computes sets in such a way that the proce-\ndure S AME -COMPONENT can determine whether two vertices are in the same con-", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "584": {"page_number": 585, "page_information": "564 Chapter 21 Data Structures for Disjoint Sets\nnected component. Figure 21.1(b) illustrates how C ONNECTED -COMPONENTS\ncomputes the disjoint sets.\nIn an actual implementation of this connected-components algorithm, the repre-\nsentations of the graph and the disjoint-set data structure would need to referenceeach other. That is, an object representing a vertex would contain a pointer tothe corresponding disjoint-set object, and vice versa. These programming detailsdepend on the implementation language, and we do not address them further here.\nExercises\n21.1-1\nSuppose that C\nONNECTED -COMPONENTS is run on the undirected graph GD\n.V; E/ ,w h e r e VDfa;b;c;d;e;f;g;h;i;j;k gand the edges of Eare pro-\ncessed in the order .d; i/; .f; k/; .g; i/; .b; g/; .a; h/; .i; j /; .d; k/; .b; j /; .d; f /;\n.g; j /; .a; e/ . List the vertices in each connected component after each iteration of\nlines 3\u20135.\n21.1-2\nShow that after all edges are processed by C ONNECTED -COMPONENTS ,t w ov e r -\ntices are in the same connected component if and only if they are in the same set.\n21.1-3\nDuring the execution of C ONNECTED -COMPONENTS on an undirected graph GD\n.V; E/ withkconnected components, how many times is F IND-SETcalled? How\nmany times is U NION called? Express your answers in terms of jVj,jEj,a n d k.\n21.2 Linked-list representation of disjoint sets\nFigure 21.2(a) shows a simple way to implement a disjoint-set data structure: each\nset is represented by its own linked list. The object for each set has attributes head ,\npointing to the \ufb01rst object in the list, and tail, pointing to the last object. Each\nobject in the list contains a set member, a pointer to the next object in the list, anda pointer back to the set object. Within each linked list, the objects may appear inany order. The representative is the set member in the \ufb01rst object in the list.\nWith this linked-list representation, both M\nAKE-SETand F IND-SETare easy,\nrequiring O.1/ time. To carry out M AKE-SET.x/, we create a new linked list\nwhose only object is x.F o rF IND-SET.x/, we just follow the pointer from xback\nto its set object and then return the member in the object that head points to. For\nexample, in Figure 21.2(a), the call F IND-SET.g/would return f.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "585": {"page_number": 586, "page_information": "21.2 Linked-list representation of disjoint sets 565\nfgd cheb(a)\n(b)\nhead\ntailS1che\nhead\ntailS2b fgd\nhead\ntailS1\nFigure 21.2 (a) Linked-list representations of two sets. Set S1contains members d,f,a n d g, with\nrepresentative f,a n ds e t S2contains members b,c,e,a n d h, with representative c. Each object in\nthe list contains a set member, a pointer to the next object in the list, and a pointer back to the set\nobject. Each set object has pointers head andtailto the \ufb01rst and last objects, respectively. (b)The\nresult of U NION .g; e/ , which appends the linked list containing eto the linked list containing g.T h e\nrepresentative of the resulting set is f. The set object for e\u2019s list, S2, is destroyed.\nA simple implementation of union\nThe simplest implementation of the U NION operation using the linked-list set rep-\nresentation takes signi\ufb01cantly more time than M AKE-SETor F IND-SET.A s F i g -\nure 21.2(b) shows, we perform U NION .x; y/ by appending y\u2019s list onto the end\nofx\u2019s list. The representative of x\u2019s list becomes the representative of the resulting\nset. We use the tailpointer for x\u2019s list to quickly \ufb01nd where to append y\u2019s list. Be-\ncause all members of y\u2019s list join x\u2019s list, we can destroy the set object for y\u2019s list.\nUnfortunately, we must update the pointer to the set object for each object origi-nally on y\u2019s list, which takes time linear in the length of y\u2019s list. In Figure 21.2, for\nexample, the operation U\nNION .g; e/ causes pointers to be updated in the objects\nforb,c,e,a n d h.\nIn fact, we can easily construct a sequence of moperations on nobjects that\nrequires \u201a.n2/time. Suppose that we have objects x1;x2;:::;x n. We execute\nthe sequence of nMAKE-SEToperations followed by n/NUL1UNION operations\nshown in Figure 21.3, so that mD2n/NUL1. We spend \u201a.n/ time performing the n\nMAKE-SEToperations. Because the ith U NION operation updates iobjects, the\ntotal number of objects updated by all n/NUL1UNION operations is", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "586": {"page_number": 587, "page_information": "566 Chapter 21 Data Structures for Disjoint Sets\nOperation Number of objects updated\nMAKE-SET.x1/ 1\nMAKE-SET.x2/ 1\n::::::\nMAKE-SET.xn/ 1\nUNION .x2;x1/ 1\nUNION .x3;x2/ 2\nUNION .x4;x3/ 3\n::::::\nUNION .xn;xn/NUL1/n/NUL1\nFigure 21.3 A sequence of 2n/NUL1operations on nobjects that takes \u201a.n2/time, or \u201a.n/ time\nper operation on average, using the linked-list set r epresentation and the simple implementation of\nUNION .\nn/NUL1X\niD1iD\u201a.n2/:\nThe total number of operations is 2n/NUL1, and so each operation on average requires\n\u201a.n/ time. That is, the amortized time of an operation is \u201a.n/ .\nA weighted-union heuristic\nIn the worst case, the above implementation of the U NION procedure requires an\naverage of \u201a.n/ time per call because we may be appending a longer list onto\na shorter list; we must update the pointer to the set object for each member ofthe longer list. Suppose instead that each list also includes the length of the list(which we can easily maintain) and that we always append the shorter list onto thelonger, breaking ties arbitrarily. With this simple weighted-union heuristic ,as i n -\ngle U\nNION operation can still take /DEL.n/ t i m ei fb o t hs e t sh a v e /DEL.n/ members. As\nthe following theorem shows, however, a sequence of mMAKE-SET,UNION ,a n d\nFIND-SEToperations, nof which are M AKE-SEToperations, takes O.mCnlgn/\ntime.\nTheorem 21.1\nUsing the linked-list representation of disjoint sets and the weighted-union heuris-tic, a sequence of mM\nAKE-SET,UNION ,a n dF IND-SEToperations, nof which\nare M AKE-SEToperations, takes O.mCnlgn/time.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "587": {"page_number": 588, "page_information": "21.2 Linked-list representation of disjoint sets 567\nProof Because each U NION operation unites two disjoint sets, we perform at\nmost n/NUL1UNION operations over all. We now bound the total time taken by these\nUNION operations. We start by determining, for each object, an upper bound on the\nnumber of times the object\u2019s pointer back to its set object is updated. Consider aparticular object x. We know that each time x\u2019s pointer was updated, xmust have\nstarted in the smaller set. The \ufb01rst time x\u2019s pointer was updated, therefore, the\nresulting set must have had at least 2members. Similarly, the next time x\u2019s pointer\nwas updated, the resulting set must have had at least 4members. Continuing on,\nwe observe that for any k/DC4n, after x\u2019s pointer has been updated dlgketimes,\nthe resulting set must have at least kmembers. Since the largest set has at most n\nmembers, each object\u2019s pointer is updated at most dlgnetimes over all the U\nNION\noperations. Thus the total time spent updating object pointers over all U NION\noperations is O.n lgn/. We must also account for updating the tailpointers and\nthe list lengths, which take only \u201a.1/ time per U NION operation. The total time\nspent in all U NION operations is thus O.n lgn/.\nThe time for the entire sequence of moperations follows easily. Each M AKE-\nSETand F IND-SEToperation takes O.1/ time, and there are O.m/ of them. The\ntotal time for the entire sequence is thus O.mCnlgn/.\nExercises\n21.2-1\nWrite pseudocode for M AKE-SET,FIND-SET,a n dU NION using the linked-list\nrepresentation and the weighted-union heuristic. Make sure to specify the attributesthat you assume for set objects and list objects.\n21.2-2\nShow the data structure that results and the answers returned by the F\nIND-SET\noperations in the following program. Use the linked-list representation with theweighted-union heuristic.\n1foriD1to16\n2M\nAKE-SET.xi/\n3foriD1to15by2\n4U NION .xi;xiC1/\n5foriD1to13by4\n6U NION .xi;xiC2/\n7U NION .x1;x5/\n8U NION .x11;x13/\n9U NION .x1;x10/\n10 F IND-SET.x2/\n11 F IND-SET.x9/", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "588": {"page_number": 589, "page_information": "568 Chapter 21 Data Structures for Disjoint Sets\nAssume that if the sets containing xiandxjhave the same size, then the operation\nUNION .xi;xj/appends xj\u2019s list onto xi\u2019s list.\n21.2-3\nAdapt the aggregate proof of Theorem 21.1 to obtain amortized time boundsofO.1/ for M\nAKE-SETand F IND-SETandO.lgn/for U NION using the linked-\nlist representation and the weighted-union heuristic.\n21.2-4\nGive a tight asymptotic bound on the running time of the sequence of operations in\nFigure 21.3 assuming the linked-list representation and the weighted-union heuris-\ntic.\n21.2-5\nProfessor Gompers suspects that it might be possible to keep just one pointer ineach set object, rather than two ( head andtail), while keeping the number of point-\ners in each list element at two. Show that the professor\u2019s suspicion is well foundedby describing how to represent each set by a linked list such that each operationhas the same running time as the operations described in this section. Describealso how the operations work. Your scheme should allow for the weighted-unionheuristic, with the same effect as described in this section. ( Hint: Use the tail of a\nlinked list as its set\u2019s representative.)\n21.2-6\nSuggest a simple change to the U\nNION procedure for the linked-list representation\nthat removes the need to keep the tailpointer to the last object in each list. Whether\nor not the weighted-union heuristic is used, your change should not change the\nasymptotic running time of the U NION procedure. ( Hint: Rather than appending\none list to another, splice them together.)\n21.3 Disjoint-set forests\nIn a faster implementation of disjoint sets, we represent sets by rooted trees, witheach node containing one member and each tree representing one set. In a disjoint-\nset forest , illustrated in Figure 21.4(a), each member points only to its parent. The\nroot of each tree contains the representative and is its own parent. As we shall\nsee, although the straightforward algorithms that use this representation are nofaster than ones that use the linked-list representation, by introducing two heuris-tics\u2014\u201cunion by rank\u201d and \u201cpath compression\u201d\u2014we can achieve an asymptoticallyoptimal disjoint-set data structure.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "589": {"page_number": 590, "page_information": "21.3 Disjoint-set forests 569\nc\nhebf\ndg\n(a)f\nc\nhebdg\n(b)\nFigure 21.4 A disjoint-set forest. (a)Two trees representing the two sets of Figure 21.2. The\ntree on the left represents the set fb;c; e;hg,w i t h cas the representative, and the tree on the right\nrepresents the setfd;f;gg, with fas the representative. (b)The result of U NION .e; g/ .\nWe perform the three disjoint-set operations as follows. A M AKE-SEToperation\nsimply creates a tree with just one node. We perform a F IND-SEToperation by\nfollowing parent pointers until we \ufb01nd the root of the tree. The nodes visited onthis simple path toward the root constitute the \ufb01nd path .A U\nNION operation,\nshown in Figure 21.4(b), causes the root of one tree to point to the root of the other.\nHeuristics to improve the running time\nSo far, we have not improved on the linked-list implementation. A sequence of\nn/NUL1UNION operations may create a tree that is just a linear chain of nnodes. By\nusing two heuristics, however, we can achieve a running time that is almost linearin the total number of operations m.\nThe \ufb01rst heuristic, union by rank , is similar to the weighted-union heuristic we\nused with the linked-list representation. The obvious approach would be to make\nthe root of the tree with fewer nodes point to the root of the tree with more nodes.\nRather than explicitly keeping track of the size of the subtree rooted at each node,we shall use an approach that eases the analysis. For each node, we maintain a\nrank , which is an upper bound on the height of the node. In union by rank, we\nmake the root with smaller rank point to the root with larger rank during a U\nNION\noperation.\nThe second heuristic, path compression , is also quite simple and highly effec-\ntive. As shown in Figure 21.5, we use it during F IND-SEToperations to make each\nnode on the \ufb01nd path point directly to the root. Path compression does not changeany ranks.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "590": {"page_number": 591, "page_information": "570 Chapter 21 Data Structures for Disjoint Sets\nabcde\nf\nabcdef\n(a) (b)\nFigure 21.5 Path compression during the operation F IND-SET. Arrows and self-loops at roots are\nomitted. (a)A tree representing a set prior to executing F IND-SET.a/. Triangles represent subtrees\nwhose roots are the nodes shown. Each node has a pointer to its parent. (b)The same set after\nexecuting F IND-SET.a/. Each node on the \ufb01nd path now points directly to the root.\nPseudocode for disjoint-set forests\nTo implement a disjoint-set forest with the union-by-rank heuristic, we must keep\ntrack of ranks. With each node x, we maintain the integer value x:rank,w h i c hi s\nan upper bound on the height of x(the number of edges in the longest simple path\nbetween xand a descendant leaf). When M AKE-SETcreates a singleton set, the\nsingle node in the corresponding tree has an initial rank of 0. Each F IND-SEToper-\nation leaves all ranks unchanged. The U NION operation has two cases, depending\non whether the roots of the trees have equal rank. If the roots have unequal rank,\nwe make the root with higher rank the parent of the root with lower rank, but theranks themselves remain unchanged. If, instead, the roots have equal ranks, wearbitrarily choose one of the roots as the parent and increment its rank.\nLet us put this method into pseudocode. We designate the parent of node x\nbyx:p.T h eL\nINKprocedure, a subroutine called by U NION , takes pointers to two\nroots as inputs.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "591": {"page_number": 592, "page_information": "21.3 Disjoint-set forests 571\nMAKE-SET.x/\n1x:pDx\n2x:rankD0\nUNION .x; y/\n1L INK.FIND-SET.x/;FIND-SET.y//\nLINK.x; y/\n1ifx:rank >y : rank\n2 y:pDx\n3elsex:pDy\n4 ifx:rank ==y:rank\n5 y:rankDy:rankC1\nThe F IND-SETprocedure with path compression is quite simple:\nFIND-SET.x/\n1ifx\u00a4x:p\n2 x:pDFIND-SET.x:p/\n3return x:p\nThe F IND-SETprocedure is a two-pass method : as it recurses, it makes one pass\nup the \ufb01nd path to \ufb01nd the root, and as the recursion unwinds, it makes a secondpass back down the \ufb01nd path to update each node to point directly to the root. Eachcall of F\nIND-SET.x/returns x:pin line 3. If xis the root, then F IND-SETskips\nline 2 and instead returns x:p,w h i c hi s x; this is the case in which the recursion\nbottoms out. Otherwise, line 2 executes, and the recursive call with parameter x:p\nreturns a pointer to the root. Line 2 updates node xto point directly to the root,\nand line 3 returns this pointer.\nEffect of the heuristics on the running time\nSeparately, either union by rank or path compression improves the running time of\nthe operations on disjoint-set forests, and the improvement is even greater whenwe use the two heuristics together. Alone, union by rank yields a running timeofO.m lgn/(see Exercise 21.4-4), and this bound is tight (see Exercise 21.3-3).\nAlthough we shall not prove it here, for a sequence of nM\nAKE-SETopera-\ntions (and hence at most n/NUL1UNION operations) and fFIND-SETopera-\ntions, the path-compression heuristic alone gives a worst-case running time of\n\u201a.nCf/SOH.1Clog2Cf=nn//.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "592": {"page_number": 593, "page_information": "572 Chapter 21 Data Structures for Disjoint Sets\nWhen we use both union by rank and path compression, the worst-case running\ntime is O.m \u02db.n// ,w h e r e \u02db.n/ is avery slowly growing function, which we de-\n\ufb01ne in Section 21.4. In any conceivable application of a disjoint-set data structure,\u02db.n//DC44; thus, we can view the running time as linear in min all practical situa-\ntions. Strictly speaking, however, it is superlinear. In Section 21.4, we prove thisupper bound.\nExercises\n21.3-1\nRedo Exercise 21.2-2 using a disjoint-set forest with union by rank and path com-pression.\n21.3-2\nWrite a nonrecursive version of F\nIND-SETwith path compression.\n21.3-3\nGive a sequence of mMAKE-SET,UNION ,a n dF IND-SEToperations, nof which\nare M AKE-SEToperations, that takes /DEL.m lgn/time when we use union by rank\nonly.\n21.3-4\nSuppose that we wish to add the operation P RINT -SET.x/, which is given a node x\nand prints all the members of x\u2019s set, in any order. Show how we can add just\na single attribute to each node in a disjoint-set forest so that P RINT -SET.x/takes\ntime linear in the number of members of x\u2019s set and the asymptotic running times\nof the other operations are unchanged. Assume that we can print each member of\nthe set in O.1/ time.\n21.3-5 ?\nShow that any sequence of mMAKE-SET,FIND-SET,a n dL INKoperations, where\nall the L INKoperations appear before any of the F IND-SEToperations, takes only\nO.m/ time if we use both path compression and union by rank. What happens in\nthe same situation if we use only the path-compression heuristic?", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "593": {"page_number": 594, "page_information": "21.4 Analysis of union by rank with path compression 573\n?21.4 Analysis of union by rank with path compression\nAs noted in Section 21.3, the combined union-by-rank and path-compression heu-\nristic runs in time O.m \u02db.n// formdisjoint-set operations on nelements. In this\nsection, we shall examine the function \u02dbto see just how slowly it grows. Then we\nprove this running time using the potential method of amortized analysis.\nA very quickly growing function and its very slowly growing inverse\nFor integers k/NAK0andj/NAK1, we de\ufb01ne the function Ak.j /as\nAk.j /D(\njC1 ifkD0;\nA.jC1/\nk/NUL1.j / ifk/NAK1;\nwhere the expression A.jC1/\nk/NUL1.j /uses the functional-iteration notation given in Sec-\ntion 3.2. Speci\ufb01cally, A.0/\nk/NUL1.j /DjandA.i/\nk/NUL1.j /DAk/NUL1.A.i/NUL1/\nk/NUL1.j // fori/NAK1.\nWe will refer to the parameter kas the level of the function A.\nThe function Ak.j /strictly increases with both jandk. To see just how quickly\nthis function grows, we \ufb01rst obtain closed-form expressions for A1.j /andA2.j /.\nLemma 21.2\nFor any integer j/NAK1,w eh a v e A1.j /D2jC1.\nProof We \ufb01rst use induction on ito show that A.i/\n0.j /DjCi. For the base case,\nwe have A.0/\n0.j /DjDjC0. For the inductive step, assume that A.i/NUL1/\n0.j /D\njC.i/NUL1/.T h e n A.i/\n0.j /DA0.A.i/NUL1/\n0.j //D.jC.i/NUL1//C1DjCi. Finally,\nwe note that A1.j /DA.jC1/\n0.j /DjC.jC1/D2jC1.\nLemma 21.3\nFor any integer j/NAK1,w eh a v e A2.j /D2jC1.jC1//NUL1.\nProof We \ufb01rst use induction on ito show that A.i/\n1.j /D2i.jC1//NUL1.F o r\nthe base case, we have A.0/\n1.j /DjD20.jC1//NUL1. For the inductive step,\nassume that A.i/NUL1/\n1.j /D2i/NUL1.jC1//NUL1.T h e n A.i/\n1.j /DA1.A.i/NUL1/\n1.j //D\nA1.2i/NUL1.jC1//NUL1/D2/SOH.2i/NUL1.jC1//NUL1/C1D2i.jC1//NUL2C1D2i.jC1//NUL1.\nFinally, we note that A2.j /DA.jC1/\n1.j /D2jC1.jC1//NUL1.\nNow we can see how quickly Ak.j /grows by simply examining Ak.1/for levels\nkD0; 1; 2; 3; 4 . From the de\ufb01nition of A0.k/and the above lemmas, we have\nA0.1/D1C1D2,A1.1/D2/SOH1C1D3,a n d A2.1/D21C1/SOH.1C1//NUL1D7.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "594": {"page_number": 595, "page_information": "574 Chapter 21 Data Structures for Disjoint Sets\nWe also have\nA3.1/DA.2/\n2.1/\nDA2.A2.1//\nDA2.7/\nD28/SOH8/NUL1\nD211/NUL1\nD2047\nandA\n4.1/DA.2/\n3.1/\nDA3.A3.1//\nDA3.2047/\nDA.2048/\n2.2047/\n/GSA2.2047/\nD22048/SOH2048/NUL1\n>22048\nD.24/512\nD16512\n/GS1080;\nwhich is the estimated number of atoms in the observable universe. (The symbol\n\u201c/GS\u201d denotes the \u201cmuch-greater-than\u201d relation.)\nWe de\ufb01ne the inverse of the function Ak.n/, for integer n/NAK0,b y\n\u02db.n/DminfkWAk.1//NAKng:\nIn words, \u02db.n/ is the lowest level kfor which Ak.1/is at least n. From the above\nvalues of Ak.1/, we see that\n\u02db.n/D\u02da\n0for0/DC4n/DC42;\n1fornD3;\n2for4/DC4n/DC47;\n3for8/DC4n/DC42047 ;\n4for2048/DC4n/DC4A4.1/ :\nIt is only for values of nso large that the term \u201castronomical\u201d understates them\n(greater than A4.1/, a huge number) that \u02db.n/ > 4 ,a n ds o \u02db.n//DC44for all\npractical purposes.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "595": {"page_number": 596, "page_information": "21.4 Analysis of union by rank with path compression 575\nProperties of ranks\nIn the remainder of this section, we prove an O.m\u02db.n// bound on the running time\nof the disjoint-set operations with union by rank and path compression. In order toprove this bound, we \ufb01rst prove some simple properties of ranks.\nLemma 21.4\nFor all nodes x,w eh a v e x:rank/DC4x:p:rank, with strict inequality if x\u00a4x:p.\nThe value of x:rank is initially 0 and increases through time until x\u00a4x:p; from\nthen on, x:rank does not change. The value of x:p:rank monotonically increases\nover time.\nProof The proof is a straightforward induction on the number of operations, us-\ning the implementations of M\nAKE-SET,U NION ,a n dF IND-SETthat appear in\nSection 21.3. We leave it as Exercise 21.4-1.\nCorollary 21.5As we follow the simple path from any node toward a root, the node ranks strictlyincrease.\nLemma 21.6Every node has rank at most n/NUL1.\nProof Each node\u2019s rank starts at 0, and it increases only upon L\nINKoperations.\nBecause there are at most n/NUL1UNION operations, there are also at most n/NUL1\nLINK operations. Because each L INK operation either leaves all ranks alone or\nincreases some node\u2019s rank by 1, all ranks are at most n/NUL1.\nLemma 21.6 provides a weak bound on ranks. In fact, every node has rank at\nmostblgnc(see Exercise 21.4-2). The looser bound of Lemma 21.6 will suf\ufb01ce\nfor our purposes, however.\nProving the time bound\nWe shall use the potential method of amortized analysis (see Section 17.3) to prove\ntheO.m \u02db.n// time bound. In performing the amortized analysis, we will \ufb01nd it\nconvenient to assume that we invoke the L INK operation rather than the U NION\noperation. That is, since the parameters of the L INKprocedure are pointers to two\nroots, we act as though we perform the appropriate F IND-SEToperations sepa-\nrately. The following lemma shows that even if we count the extra F IND-SETop-\nerations induced by U NION calls, the asymptotic running time remains unchanged.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "596": {"page_number": 597, "page_information": "576 Chapter 21 Data Structures for Disjoint Sets\nLemma 21.7\nSuppose we convert a sequence S0ofm0MAKE-SET,UNION ,a n dF IND-SETop-\nerations into a sequence SofmMAKE-SET,LINK,a n dF IND-SEToperations by\nturning each U NION into two F IND-SEToperations followed by a L INK. Then, if\nsequence Sruns in O.m \u02db.n// time, sequence S0runs in O.m0\u02db.n// time.\nProof Since each U NION operation in sequence S0is converted into three opera-\ntions in S,w eh a v e m0/DC4m/DC43m0.S i n c e mDO.m0/,a nO.m \u02db.n// time bound\nfor the converted sequence Simplies an O.m0\u02db.n// time bound for the original\nsequence S0.\nIn the remainder of this section, we shall assume that the initial sequence of m0\nMAKE-SET,UNION ,a n dF IND-SEToperations has been converted to a sequence\nofmMAKE-SET,LINK,a n dF IND-SEToperations. We now prove an O.m \u02db.n//\ntime bound for the converted sequence and appeal to Lemma 21.7 to prove theO.m\n0\u02db.n// running time of the original sequence of m0operations.\nPotential function\nThe potential function we use assigns a potential /RSq.x/to each node xin the\ndisjoint-set forest after qoperations. We sum the node potentials for the poten-\ntial of the entire forest: \u02c6qDP\nx/RSq.x/,w h e r e \u02c6qdenotes the potential of the\nforest after qoperations. The forest is empty prior to the \ufb01rst operation, and we\narbitrarily set \u02c60D0. No potential \u02c6qwill ever be negative.\nThe value of /RSq.x/depends on whether xis a tree root after the qth operation.\nIf it is, or if x:rankD0,t h e n /RSq.x/D\u02db.n//SOHx:rank.\nNow suppose that after the qth operation, xis not a root and that x:rank/NAK1.\nWe need to de\ufb01ne two auxiliary functions on xbefore we can de\ufb01ne /RSq.x/. First\nwe de\ufb01ne\nlevel.x/DmaxfkWx:p:rank/NAKAk.x:rank/g:\nThat is, level .x/is the greatest level kfor which Ak, applied to x\u2019s rank, is no\ngreater than x\u2019s parent\u2019s rank.\nWe claim that\n0/DC4level.x/ < \u02db.n/ ; (21.1)\nwhich we see as follows. We havex:p:rank/NAKx:rankC1(by Lemma 21.4)\nDA\n0.x:rank/(by de\ufb01nition of A0.j /),\nwhich implies that level .x//NAK0, and we have", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "597": {"page_number": 598, "page_information": "21.4 Analysis of union by rank with path compression 577\nA\u02db.n/.x:rank//NAKA\u02db.n/.1/ (because Ak.j /is strictly increasing)\n/NAKn (by the de\ufb01nition of \u02db.n/ )\n>x : p:rank (by Lemma 21.6) ,\nwhich implies that level .x/ < \u02db.n/ . Note that because x:p:rank monotonically\nincreases over time, so does level .x/.\nThe second auxiliary function applies when x:rank/NAK1:\niter.x/Dmax\u02da\niWx:p:rank/NAKA.i/\nlevel.x/.x:rank//TAB\n:\nThat is, iter .x/is the largest number of times we can iteratively apply Alevel.x/,\napplied initially to x\u2019s rank, before we get a value greater than x\u2019s parent\u2019s rank.\nWe claim that when x:rank/NAK1,w eh a v e\n1/DC4iter.x//DC4x:rank; (21.2)\nwhich we see as follows. We havex:p:rank/NAKA\nlevel.x/.x:rank/(by de\ufb01nition of level .x/)\nDA.1/\nlevel.x/.x:rank/(by de\ufb01nition of functional iteration) ,\nwhich implies that iter .x//NAK1, and we have\nA.x:rankC1/\nlevel.x/.x:rank/DAlevel.x/C1.x:rank/(by de\ufb01nition of Ak.j /)\n>x : p:rank (by de\ufb01nition of level .x/),\nwhich implies that iter .x//DC4x:rank. Note that because x:p:rank monotonically\nincreases over time, in order for iter .x/to decrease, level .x/must increase. As long\nas level .x/remains unchanged, iter .x/must either increase or remain unchanged.\nWith these auxiliary functions in place, we are ready to de\ufb01ne the potential of\nnode xafterqoperations:\n/RSq.x/D(\n\u02db.n//SOHx:rank ifxis a root or x:rankD0;\n.\u02db.n//NULlevel.x///SOHx:rank/NULiter.x/ifxis not a root and x:rank/NAK1:\nWe next investigate some useful properties of node potentials.\nLemma 21.8\nFor every node x, and for all operation counts q,w eh a v e\n0/DC4/RSq.x//DC4\u02db.n//SOHx:rank:", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "598": {"page_number": 599, "page_information": "578 Chapter 21 Data Structures for Disjoint Sets\nProof Ifxis a root or x:rankD0,t h e n /RSq.x/D\u02db.n//SOHx:rank by de\ufb01nition. Now\nsuppose that xis not a root and that x:rank/NAK1. We obtain a lower bound on /RSq.x/\nby maximizing level .x/and iter .x/. By the bound (21.1), level .x//DC4\u02db.n//NUL1,a n d\nby the bound (21.2), iter .x//DC4x:rank. Thus,\n/RSq.x/D.\u02db.n//NULlevel.x///SOHx:rank/NULiter.x/\n/NAK.\u02db.n//NUL.\u02db.n//NUL1///SOHx:rank/NULx:rank\nDx:rank/NULx:rank\nD0:\nSimilarly, we obtain an upper bound on /RSq.x/by minimizing level .x/and iter .x/.\nBy the bound (21.1), level .x//NAK0, and by the bound (21.2), iter .x//NAK1. Thus,\n/RSq.x//DC4.\u02db.n//NUL0//SOHx:rank/NUL1\nD\u02db.n//SOHx:rank/NUL1\n< \u02db.n//SOHx:rank:\nCorollary 21.9\nIf node xis not a root and x:rank >0,t h e n /RSq.x/ < \u02db.n//SOHx:rank.\nPotential changes and amortized costs of operations\nWe are now ready to examine how the disjoint-set operations affect node potentials.\nWith an understanding of the change in potential due to each operation, we candetermine each operation\u2019s amortized cost.\nLemma 21.10\nLetxbe a node that is not a root, and suppose that the qth operation is either a\nL\nINKor F IND-SET. Then after the qth operation, /RSq.x//DC4/RSq/NUL1.x/. Moreover, if\nx:rank/NAK1and either level .x/or iter .x/changes due to the qth operation, then\n/RSq.x//DC4/RSq/NUL1.x//NUL1.T h a ti s , x\u2019s potential cannot increase, and if it has positive\nrank and either level .x/or iter .x/changes, then x\u2019s potential drops by at least 1.\nProof Because xis not a root, the qth operation does not change x:rank,a n d\nbecause ndoes not change after the initial nMAKE-SEToperations, \u02db.n/ remains\nunchanged as well. Hence, these components of the formula for x\u2019s potential re-\nmain the same after the qth operation. If x:rankD0,t h e n /RSq.x/D/RSq/NUL1.x/D0.\nNow assume that x:rank/NAK1.\nRecall that level .x/monotonically increases over time. If the qth operation\nleaves level .x/unchanged, then iter .x/either increases or remains unchanged.\nIf both level .x/and iter .x/are unchanged, then /RSq.x/D/RSq/NUL1.x/.I f l e v e l .x/", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "599": {"page_number": 600, "page_information": "21.4 Analysis of union by rank with path compression 579\nis unchanged and iter .x/ increases, then it increases by at least 1,a n ds o\n/RSq.x//DC4/RSq/NUL1.x//NUL1.\nFinally, if the qth operation increases level .x/, it increases by at least 1,s ot h a t\nthe value of the term .\u02db.n//NULlevel.x///SOHx:rank drops by at least x:rank.B e -\ncause level .x/increased, the value of iter .x/might drop, but according to the\nbound (21.2), the drop is by at most x:rank/NUL1. Thus, the increase in poten-\ntial due to the change in iter .x/is less than the decrease in potential due to the\nchange in level .x/, and we conclude that /RSq.x//DC4/RSq/NUL1.x//NUL1.\nOur \ufb01nal three lemmas show that the amortized cost of each M AKE-SET,LINK,\nand F IND-SEToperation is O.\u02db.n// . Recall from equation (17.2) that the amor-\ntized cost of each operation is its actual cost plus the increase in potential due tothe operation.\nLemma 21.11\nThe amortized cost of each M\nAKE-SEToperation is O.1/ .\nProof Suppose that the qth operation is M AKE-SET.x/. This operation creates\nnode xwith rank 0,s ot h a t /RSq.x/D0. No other ranks or potentials change, and\nso\u02c6qD\u02c6q/NUL1. Noting that the actual cost of the M AKE-SEToperation is O.1/\ncompletes the proof.\nLemma 21.12The amortized cost of each L\nINKoperation is O.\u02db.n// .\nProof Suppose that the qth operation is L INK.x; y/ . The actual cost of the L INK\noperation is O.1/ . Without loss of generality, suppose that the L INKmakes ythe\nparent of x.\nTo determine the change in potential due to the L INK, we note that the only\nnodes whose potentials may change are x,y, and the children of yjust prior to the\noperation. We shall show that the only node whose potential can increase due tothe L\nINKisy, and that its increase is at most \u02db.n/ :\n/SIBy Lemma 21.10, any node that is y\u2019s child just before the L INKcannot have\nits potential increase due to the L INK.\n/SIFrom the de\ufb01nition of /RSq.x/, we see that, since xwas a root just before the qth\noperation, /RSq/NUL1.x/D\u02db.n//SOHx:rank.I fx:rankD0,t h e n /RSq.x/D/RSq/NUL1.x/D0.\nOtherwise,\n/RSq.x/ < \u02db.n//SOHx:rank (by Corollary 21.9)\nD/RSq/NUL1.x/ ;\nand so x\u2019s potential decreases.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "600": {"page_number": 601, "page_information": "580 Chapter 21 Data Structures for Disjoint Sets\n/SIBecause yis a root prior to the L INK,/RSq/NUL1.y/D\u02db.n//SOHy:rank.T h e L INK\noperation leaves yas a root, and it either leaves y\u2019s rank alone or it increases y\u2019s\nrank by 1. Therefore, either /RSq.y/D/RSq/NUL1.y/or/RSq.y/D/RSq/NUL1.y/C\u02db.n/ .\nThe increase in potential due to the L INKoperation, therefore, is at most \u02db.n/ .\nThe amortized cost of the L INKoperation is O.1/C\u02db.n/DO.\u02db.n// .\nLemma 21.13\nThe amortized cost of each F IND-SEToperation is O.\u02db.n// .\nProof Suppose that the qth operation is a F IND-SETand that the \ufb01nd path con-\ntains snodes. The actual cost of the F IND-SEToperation is O.s/ .W e s h a l l\nshow that no node\u2019s potential increases due to the F IND-SETand that at least\nmax.0; s/NUL.\u02db.n/C2//nodes on the \ufb01nd path have their potential decrease by\nat least 1.\nTo see that no node\u2019s potential increases, we \ufb01rst appeal to Lemma 21.10 for all\nnodes other than the root. If xis the root, then its potential is \u02db.n//SOHx:rank,w h i c h\ndoes not change.\nNow we show that at least max .0; s/NUL.\u02db.n/C2//nodes have their potential\ndecrease by at least 1.L e t xbe a node on the \ufb01nd path such that x:rank >0\nandxis followed somewhere on the \ufb01nd path by another node ythat is not a root,\nwhere level .y/Dlevel.x/just before the F IND-SEToperation. (Node yneed not\nimmediately follow xon the \ufb01nd path.) All but at most \u02db.n/C2nodes on the \ufb01nd\npath satisfy these constraints on x. Those that do not satisfy them are the \ufb01rst node\non the \ufb01nd path (if it has rank 0), the last node on the path (i.e., the root), and the\nlast node won the path for which level .w/Dk, for each kD0; 1; 2; : : : ; \u02db.n//NUL1.\nLet us \ufb01x such a node x, and we shall show that x\u2019s potential decreases by at\nleast1.L e t kDlevel.x/Dlevel.y/. Just prior to the path compression caused by\nthe F IND-SET,w eh a v e\nx:p:rank/NAKA.iter.x//\nk.x:rank/(by de\ufb01nition of iter .x/),\ny:p:rank/NAKAk.y:rank/ (by de\ufb01nition of level .y/),\ny:rank/NAKx:p:rank (by Corollary 21.5 and because\nyfollows xon the \ufb01nd path) .\nPutting these inequalities together and letting ibe the value of iter .x/before path\ncompression, we have\ny:p:rank/NAKAk.y:rank/\n/NAKAk.x:p:rank/ (because Ak.j /is strictly increasing)\n/NAKAk.A.iter.x//\nk.x:rank//\nDA.iC1/\nk.x:rank/:", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "601": {"page_number": 602, "page_information": "21.4 Analysis of union by rank with path compression 581\nBecause path compression will make xandyhave the same parent, we know\nthat after path compression, x:p:rankDy:p:rank and that the path compression\ndoes not decrease y:p:rank.S i n c e x:rank does not change, after path compression\nwe have that x:p:rank/NAKA.iC1/\nk.x:rank/. Thus, path compression will cause ei-\nther iter .x/to increase (to at least iC1)o rl e v e l .x/to increase (which occurs if\niter.x/increases to at least x:rankC1). In either case, by Lemma 21.10, we have\n/RSq.x//DC4/RSq/NUL1.x//NUL1. Hence, x\u2019s potential decreases by at least 1.\nThe amortized cost of the F IND-SEToperation is the actual cost plus the change\nin potential. The actual cost is O.s/ , and we have shown that the total potential\ndecreases by at least max .0; s/NUL.\u02db.n/C2//. The amortized cost, therefore, is at\nmost O.s//NUL.s/NUL.\u02db.n/C2//DO.s//NULsCO.\u02db.n//DO.\u02db.n// , since we can\nscale up the units of potential to dominate the constant hidden in O.s/ .\nPutting the preceding lemmas together yields the following theorem.\nTheorem 21.14\nA sequence of mMAKE-SET,UNION ,a n dF IND-SEToperations, nof which are\nMAKE-SEToperations, can be performed on a disjoint-set forest with union by\nrank and path compression in worst-case time O.m \u02db.n// .\nProof Immediate from Lemmas 21.7, 21.11, 21.12, and 21.13.\nExercises\n21.4-1\nProve Lemma 21.4.\n21.4-2\nProve that every node has rank at most blgnc.\n21.4-3\nIn light of Exercise 21.4-2, how many bits are necessary to store x:rank for each\nnode x?\n21.4-4\nUsing Exercise 21.4-2, give a simple proof that operations on a disjoint-set forestwith union by rank but without path compression run in O.m lgn/time.\n21.4-5\nProfessor Dante reasons that because node ranks increase strictly along a simplepath to the root, node levels must monotonically increase along the path. In other", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "602": {"page_number": 603, "page_information": "582 Chapter 21 Data Structures for Disjoint Sets\nwords, if x:rank >0 andx:pis not a root, then level .x//DC4level.x:p/.I s t h e\nprofessor correct?\n21.4-6 ?\nConsider the function \u02db0.n/DminfkWAk.1//NAKlg.nC1/g. Show that \u02db0.n//DC43\nfor all practical values of nand, using Exercise 21.4-2, show how to modify the\npotential-function argument to prove that we can perform a sequence of mMAKE-\nSET,UNION ,a n dF IND-SEToperations, nof which are M AKE-SEToperations, on\na disjoint-set forest with union by rank and path compression in worst-case time\nO.m \u02db0.n//.\nProblems\n21-1 Off-line minimum\nTheoff-line minimum problem asks us to maintain a dynamic set Tof elements\nfrom the domainf1 ;2;:::;ngunder the operations I NSERT and E XTRACT -MIN.\nWe are given a sequence SofnINSERT andmEXTRACT -MINcalls, where each\nkey inf1 ;2;:::;ngis inserted exactly once. We wish to determine which key\nis returned by each E XTRACT -MINcall. Speci\ufb01cally, we wish to \ufb01ll in an array\nextracted \u0152 1::m /c141 , where for iD1 ;2;:::;m ,extracted \u0152i/c141is the key returned by\ntheith E XTRACT -MINcall. The problem is \u201coff-line\u201d in the sense that we are\nallowed to process the entire sequence Sbefore determining any of the returned\nkeys.\na.In the following instance of the off-line minimum problem, each operation\nINSERT .i/is represented by the value of iand each E XTRACT -MINis rep-\nresented by the letter E:\n4;8; E;3 ;E;9 ;2;6 ; E;E;E;1 ;7 ; E;5:\nFill in the correct values in the extracted array.\nTo develop an algorithm for this problem, we break the sequence Sinto homoge-\nneous subsequences. That is, we represent Sby\nI1;E;I2;E;I3;:::; Im;E;ImC1;\nwhere each E represents a single E XTRACT -MINcall and each I jrepresents a (pos-\nsibly empty) sequence of I NSERT calls. For each subsequence I j, we initially place\nthe keys inserted by these operations into a set Kj, which is empty if I jis empty.\nWe then do the following:", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "603": {"page_number": 604, "page_information": "Problems for Chapter 21 583\nOFF-LINE-MINIMUM .m; n/\n1foriD1ton\n2 determine jsuch that i2Kj\n3 ifj\u00a4mC1\n4 extracted \u0152j /c141Di\n5l e t lbe the smallest value greater than j\nfor which set Klexists\n6 KlDKj[Kl, destroying Kj\n7return extracted\nb.Argue that the array extracted returned by O FF-LINE-MINIMUM is correct.\nc.Describe how to implement O FF-LINE-MINIMUM ef\ufb01ciently with a disjoint-\nset data structure. Give a tight bound on the worst-case running time of yourimplementation.\n21-2 Depth determination\nIn the depth-determination problem , we maintain a forest FDfT\nigof rooted\ntrees under three operations:\nMAKE-TREE./ETB/creates a tree whose only node is /ETB.\nFIND-DEPTH ./ETB/returns the depth of node /ETBwithin its tree.\nGRAFT .r; /ETB/ makes node r, which is assumed to be the root of a tree, become the\nchild of node /ETB, which is assumed to be in a different tree than rbut may or may\nnot itself be a root.\na.Suppose that we use a tree representation similar to a disjoint-set forest: /ETB:p\nis the parent of node /ETB, except that /ETB:pD/ETBif/ETBis a root. Suppose further\nthat we implement G RAFT .r; /ETB/ by setting r:pD/ETBand F IND-DEPTH ./ETB/by\nfollowing the \ufb01nd path up to the root, returning a count of all nodes other than /ETB\nencountered. Show that the worst-case running time of a sequence of mMAKE-\nTREE,FIND-DEPTH ,a n dG RAFT operations is \u201a.m2/.\nBy using the union-by-rank and path-compression heuristics, we can reduce the\nworst-case running time. We use the disjoint-set forest SDfSig, where each\nsetSi(which is itself a tree) corresponds to a tree Tiin the forest F. The tree\nstructure within a set Si, however, does not necessarily correspond to that of Ti.I n\nfact, the implementation of Sidoes not record the exact parent-child relationships\nbut nevertheless allows us to determine any node\u2019s depth in Ti.\nThe key idea is to maintain in each node /ETBa \u201cpseudodistance\u201d /ETB:d,w h i c hi s\nde\ufb01ned so that the sum of the pseudodistances along the simple path from /ETBto the", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "604": {"page_number": 605, "page_information": "584 Chapter 21 Data Structures for Disjoint Sets\nroot of its set Siequals the depth of /ETBinTi. That is, if the simple path from /ETBto its\nroot in Siis/ETB0;/ETB1;:::;/ETB k,w h e r e /ETB0D/ETBand/ETBkisSi\u2019s root, then the depth of /ETB\ninTiisPk\njD0/ETBj:d.\nb.Give an implementation of M AKE-TREE.\nc.Show how to modify F IND-SETto implement F IND-DEPTH . Your implemen-\ntation should perform path compression, and its running time should be linearin the length of the \ufb01nd path. Make sure that your implementation updates\npseudodistances correctly.\nd.Show how to implement G\nRAFT .r; /ETB/ , which combines the sets containing r\nand/ETB, by modifying the U NION and L INK procedures. Make sure that your\nimplementation updates pseudodistances correctly. Note that the root of a set Si\nis not necessarily the root of the corresponding tree Ti.\ne.Give a tight bound on the worst-case running time of a sequence of mMAKE-\nTREE,FIND-DEPTH ,a n dG RAFT operations, nof which are M AKE-TREE op-\nerations.\n21-3 Tarjan\u2019s off-line least-common-ancestors algorithm\nTheleast common ancestor of two nodes uand/ETBin a rooted tree Tis the node w\nthat is an ancestor of both uand/ETBand that has the greatest depth in T.I n t h e\noff-line least-common-ancestors problem , we are given a rooted tree Tand an\narbitrary set PDffu; /ETBggof unordered pairs of nodes in T, and we wish to deter-\nmine the least common ancestor of each pair in P.\nTo solve the off-line least-common-ancestors problem, the following procedure\nperforms a tree walk of Twith the initial call LCA .T:root/. We assume that each\nnode is colored WHITE prior to the walk.\nLCA .u/\n1M AKE-SET.u/\n2F IND-SET.u/:ancestorDu\n3foreach child /ETBofuinT\n4L C A ./ETB/\n5U NION .u; /ETB/\n6F IND-SET.u/:ancestorDu\n7u:colorDBLACK\n8foreach node /ETBsuch thatfu; /ETBg2P\n9 if/ETB:color ==BLACK\n10 print \u201cThe least common ancestor of\u201d\nu\u201cand\u201d /ETB\u201cis\u201d F IND-SET./ETB/:ancestor", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "605": {"page_number": 606, "page_information": "Notes for Chapter 21 585\na.Argue that line 10 executes exactly once for each pair fu; /ETBg2P.\nb.Argue that at the time of the call LCA .u/, the number of sets in the disjoint-set\ndata structure equals the depth of uinT.\nc.Prove that LCA correctly prints the least common ancestor of uand/ETBfor each\npairfu; /ETBg2P.\nd.Analyze the running time of LCA, assuming that we use the implementation of\nthe disjoint-set data structure in Section 21.3.\nChapter notes\nMany of the important results for disjoint-set data structures are due at least in partto R. E. Tarjan. Using aggregate analysis, Tarjan [328, 330] gave the \ufb01rst tightupper bound in terms of the very slowly growing inverse y\u02db.m;n/ of Ackermann\u2019s\nfunction. (The function A\nk.j /g i v e ni nS e c t i o n2 1 . 4i ss i m i l a rt oA c k e r m a n n \u2019 s\nfunction, and the function \u02db.n/ is similar to the inverse. Both \u02db.n/ andy\u02db.m;n/\nare at most 4for all conceivable values of mandn.) An O.m lg/ETXn/upper bound\nwas proven earlier by Hopcroft and Ullman [5, 179]. The treatment in Section 21.4is adapted from a later analysis by Tarjan [332], which is in turn based on an anal-\nysis by Kozen [220]. Harfst and Reingold [161] give a potential-based version of\nTarjan\u2019s earlier bound.\nTarjan and van Leeuwen [333] discuss variants on the path-compression heuris-\ntic, including \u201cone-pass methods,\u201d which sometimes offer better constant factorsin their performance than do two-pass methods. As with Tarjan\u2019s earlier analysesof the basic path-compression heuristic, the analyses by Tarjan and van Leeuwenare aggregate. Harfst and Reingold [161] later showed how to make a small changeto the potential function to adapt their path-compression analysis to these one-passvariants. Gabow and Tarjan [121] show that in certain applications, the disjoint-setoperations can be made to run in O.m/ time.\nTarjan [329] showed that a lower bound of /DEL.my\u02db.m; n// time is required for\noperations on any disjoint-set data structure satisfying certain technical conditions.This lower bound was later generalized by Fredman and Saks [113], who showedthat in the worst case, /DEL.my\u02db.m; n// . lgn/-bit words of memory must be accessed.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "606": {"page_number": 607, "page_information": "VI Graph Algorithms", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "607": {"page_number": 608, "page_information": "Introduction\nGraph problems pervade computer science, and algorithms for working with them\nare fundamental to the \ufb01eld. Hundreds of interesting computational problems are\ncouched in terms of graphs. In this part, we touch on a few of the more signi\ufb01cantones.\nChapter 22 shows how we can represent a graph in a computer and then discusses\nalgorithms based on searching a graph using either breadth-\ufb01rst search or depth-\ufb01rst search. The chapter gives two applications of depth-\ufb01rst search: topologicallysorting a directed acyclic graph and decomposing a directed graph into its stronglyconnected components.\nChapter 23 describes how to compute a minimum-weight spanning tree of a\ngraph: the least-weight way of connecting all of the vertices together when each\nedge has an associated weight. The algorithms for computing minimum spanningtrees serve as good examples of greedy algorithms (see Chapter 16).\nChapters 24 and 25 consider how to compute shortest paths between vertices\nwhen each edge has an associated length or \u201cweight.\u201d Chapter 24 shows how to\n\ufb01nd shortest paths from a given source vertex to all other vertices, and Chapter 25\nexamines methods to compute shortest paths between every pair of vertices.\nFinally, Chapter 26 shows how to compute a maximum \ufb02ow of material in a \ufb02ow\nnetwork, which is a directed graph having a speci\ufb01ed source vertex of material, aspeci\ufb01ed sink vertex, and speci\ufb01ed capacities for the amount of material that cantraverse each directed edge. This general problem arises in many forms, and agood algorithm for computing maximum \ufb02ows can help solve a variety of relatedproblems ef\ufb01ciently.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "608": {"page_number": 609, "page_information": "588 Part VI Graph Algorithms\nWhen we characterize the running time of a graph algorithm on a given graph\nGD.V; E/ , we usually measure the size of the input in terms of the number of\nverticesjVjand the number of edges jEjof the graph. That is, we describe the\nsize of the input with two parameters, not just one. We adopt a common notationalconvention for these parameters. Inside asymptotic notation (such as O-notation\nor\u201a-notation), and only inside such notation, the symbol VdenotesjVjand\nthe symbol EdenotesjEj. For example, we might say, \u201cthe algorithm runs in\ntimeO.VE/ ,\u201d meaning that the algorithm runs in time O.jVjjEj/. This conven-\ntion makes the running-time formulas easier to read, without risk of ambiguity.\nAnother convention we adopt appears in pseudocode. We denote the vertex set\nof a graph GbyG:Vand its edge set by G:E. That is, the pseudocode views vertex\nand edge sets as attributes of a graph.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "609": {"page_number": 610, "page_information": "22 Elementary Graph Algorithms\nThis chapter presents methods for representing a graph and for searching a graph.\nSearching a graph means systematically following the edges of the graph so as tovisit the vertices of the graph. A graph-searching algorithm can discover muchabout the structure of a graph. Many algorithms begin by searching their inputgraph to obtain this structural information. Several other graph algorithms elabo-rate on basic graph searching. Techniques for searching a graph lie at the heart ofthe \ufb01eld of graph algorithms.\nSection 22.1 discusses the two most common computational representations of\ngraphs: as adjacency lists and as adjacency matrices. Section 22.2 presents a sim-\nple graph-searching algorithm called breadth-\ufb01rst search and shows how to cre-\nate a breadth-\ufb01rst tree. Section 22.3 presents depth-\ufb01rst search and proves some\nstandard results about the order in which depth-\ufb01rst search visits vertices. Sec-tion 22.4 provides our \ufb01rst real application of depth-\ufb01rst search: topologically sort-ing a directed acyclic graph. A second application of depth-\ufb01rst search, \ufb01nding the\nstrongly connected components of a directed graph, is the topic of Section 22.5.\n22.1 Representations of graphs\nWe can choose between two standard ways to represent a graph GD.V; E/ :\nas a collection of adjacency lists or as an adjacency matrix. Either way appliesto both directed and undirected graphs. Because the adjacency-list representationprovides a compact way to represent sparse graphs\u2014those for which jEjis much\nless thanjVj\n2\u2014it is usually the method of choice. Most of the graph algorithms\npresented in this book assume that an input graph is represented in adjacency-\nlist form. We may prefer an adjacency-matrix representation, however, when the\ngraph is dense \u2014jEjis close tojVj2\u2014or when we need to be able to tell quickly\nif there is an edge connecting two given vertices. For example, two of the all-pairs", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "610": {"page_number": 611, "page_information": "590 Chapter 22 Elementary Graph Algorithms\n12\n3\n4 51\n234525\n1\n2\n2\n4 1 25 344 5 31001\n01111010110110100100112345\n12345\n(a) (b) (c)\nFigure 22.1 Two representations of an undirected graph. (a)An undirected graph Gwith 5 vertices\na n d7e d g e s . (b)An adjacency-list representation of G.(c)The adjacency-matrix representation\nofG.\n12\n5 41\n234524\n5\n6\n2\n4\n65101000010001100000100000012345\n12345\n(a) (b) (c)\n3\n6 66\n600000100100\nFigure 22.2 Two representations of a directed graph. (a)A directed graph Gwith 6 vertices and 8\nedges. (b)An adjacency-list representation of G.(c)The adjacency-matrix representation of G.\nshortest-paths algorithms presented in Chapter 25 assume that their input graphs\nare represented by adjacency matrices.\nTheadjacency-list representation of a graph GD.V; E/ consists of an ar-\nrayAdjofjVjlists, one for each vertex in V. For each u2V, the adjacency list\nAdj\u0152u/c141contains all the vertices /ETBsuch that there is an edge .u; /ETB/2E.T h a t i s ,\nAdj\u0152u/c141consists of all the vertices adjacent to uinG. (Alternatively, it may contain\npointers to these vertices.) Since the adjacency lists represent the edges of a graph,in pseudocode we treat the array Adjas an attribute of the graph, just as we treat\nthe edge set E. In pseudocode, therefore, we will see notation such as G:Adj\u0152u/c141.\nFigure 22.1(b) is an adjacency-list representation of the undirected graph in Fig-ure 22.1(a). Similarly, Figure 22.2(b) is an adjacency-list representation of thedirected graph in Figure 22.2(a).\nIfGis a directed graph, the sum of the lengths of all the adjacency lists is jEj,\nsince an edge of the form .u; /ETB/ is represented by having /ETBappear in Adj\u0152u/c141.I fGis", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "611": {"page_number": 612, "page_information": "22.1 Representations of graphs 591\nan undirected graph, the sum of the lengths of all the adjacency lists is 2jEj,s i n c e\nif.u; /ETB/ is an undirected edge, then uappears in /ETB\u2019s adjacency list and vice versa.\nFor both directed and undirected graphs, the adjacency-list representation has thedesirable property that the amount of memory it requires is \u201a.VCE/.\nWe can readily adapt adjacency lists to represent weighted graphs , that is, graphs\nfor which each edge has an associated weight , typically given by a weight function\nwWE! R. For example, let GD.V; E/ be a weighted graph with weight\nfunction w. We simply store the weight w.u;/ETB/ of the edge .u; /ETB/2Ewith\nvertex /ETBinu\u2019s adjacency list. The adjacency-list representation is quite robust in\nthat we can modify it to support many other graph variants.\nA potential disadvantage of the adjacency-list representation is that it provides\nno quicker way to determine whether a given edge .u; /ETB/ is present in the graph\nthan to search for /ETBin the adjacency list Adj\u0152u/c141. An adjacency-matrix representa-\ntion of the graph remedies this disadvantage, but at the cost of using asymptoticallymore memory. (See Exercise 22.1-8 for suggestions of variations on adjacency liststhat permit faster edge lookup.)\nFor the adjacency-matrix representation of a graph GD.V; E/ , we assume\nthat the vertices are numbered 1 ;2;:::;jVjin some arbitrary manner. Then the\nadjacency-matrix representation of a graph Gconsists of ajVj/STXjVjmatrix\nAD.a\nij/such that\naijD(\n1if.i; j /2E;\n0otherwise :\nFigures 22.1(c) and 22.2(c) are the adjacency matrices of the undirected and di-\nrected graphs in Figures 22.1(a) and 22.2(a), respectively. The adjacency matrix ofa graph requires \u201a.V\n2/memory, independent of the number of edges in the graph.\nObserve the symmetry along the main diagonal of the adjacency matrix in Fig-\nure 22.1(c). Since in an undirected graph, .u; /ETB/ and./ETB; u/ represent the same\nedge, the adjacency matrix Aof an undirected graph is its own transpose: ADAT.\nIn some applications, it pays to store only the entries on and above the diagonal ofthe adjacency matrix, thereby cutting the memory needed to store the graph almostin half.\nLike the adjacency-list representation of a graph, an adjacency matrix can repre-\nsent a weighted graph. For example, if GD.V; E/ is a weighted graph with edge-\nweight function w, we can simply store the weight w.u;/ETB/ of the edge .u; /ETB/2E\nas the entry in row uand column /ETBof the adjacency matrix. If an edge does not\nexist, we can store a\nNILvalue as its corresponding matrix entry, though for many\nproblems it is convenient to use a value such as 0or1.\nAlthough the adjacency-list representation is asymptotically at least as space-\nef\ufb01cient as the adjacency-matrix representation, adjacency matrices are simpler,and so we may prefer them when graphs are reasonably small. Moreover, adja-", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "612": {"page_number": 613, "page_information": "592 Chapter 22 Elementary Graph Algorithms\ncency matrices carry a further advantage for unweighted graphs: they require only\none bit per entry.\nRepresenting attributes\nMost algorithms that operate on graphs need to maintain attributes for vertices\nand/or edges. We indicate these attributes using our usual notation, such as /ETB:d\nfor an attribute dof a vertex /ETB. When we indicate edges as pairs of vertices, we\nuse the same style of notation. For example, if edges have an attribute f,t h e nw e\ndenote this attribute for edge .u; /ETB/ by.u; /ETB/: f. For the purpose of presenting and\nunderstanding algorithms, our attribute notation suf\ufb01ces.\nImplementing vertex and edge attributes in real programs can be another story\nentirely. There is no one best way to store and access vertex and edge attributes.\nFor a given situation, your decision will likely depend on the programming lan-\nguage you are using, the algorithm you are implementing, and how the rest of yourprogram uses the graph. If you represent a graph using adjacency lists, one designrepresents vertex attributes in additional arrays, such as an array d\u01521::jVj/c141that\nparallels the Adjarray. If the vertices adjacent to uare in Adj\u0152u/c141, then what we call\nthe attribute u:dwould actually be stored in the array entry d\u0152u/c141. Many other ways\nof implementing attributes are possible. For example, in an object-oriented pro-\ngramming language, vertex attributes might be represented as instance variables\nwithin a subclass of a Vertex class.\nExercises\n22.1-1\nGiven an adjacency-list representation of a directed graph, how long does it taketo compute the out-degree of every vertex? How long does it take to compute thein-degrees?\n22.1-2\nGive an adjacency-list representation for a complete binary tree on 7vertices. Give\nan equivalent adjacency-matrix representation. Assume that vertices are numberedfrom 1to7as in a binary heap.\n22.1-3\nThetranspose of a directed graph GD.V; E/ is the graph G\nTD.V; ET/,w h e r e\nETDf./ETB; u/2V/STXVW.u; /ETB/2Eg. Thus, GTisGwith all its edges reversed.\nDescribe ef\ufb01cient algorithms for computing GTfrom G, for both the adjacency-\nlist and adjacency-matrix representations of G. Analyze the running times of your\nalgorithms.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "613": {"page_number": 614, "page_information": "22.1 Representations of graphs 593\n22.1-4\nGiven an adjacency-list representation of a multigraph GD.V; E/ , describe an\nO.VCE/-time algorithm to compute the adjacency-list representation of the\n\u201cequivalent\u201d undirected graph G0D.V; E0/,w h e r e E0consists of the edges in E\nwith all multiple edges between two vertices replaced by a single edge and with allself-loops removed.\n22.1-5\nThesquare of a directed graph GD.V; E/ is the graph G\n2D.V; E2/such that\n.u; /ETB/2E2if and only Gcontains a path with at most two edges between uand/ETB.\nDescribe ef\ufb01cient algorithms for computing G2from Gfor both the adjacency-\nlist and adjacency-matrix representations of G. Analyze the running times of your\nalgorithms.\n22.1-6\nMost graph algorithms that take an adjacency-matrix representation as input re-quire time /DEL.V\n2/, but there are some exceptions. Show how to determine whether\na directed graph Gcontains a universal sink \u2014a vertex with in-degree jVj/NUL1and\nout-degree 0\u2014in time O.V / , given an adjacency matrix for G.\n22.1-7\nTheincidence matrix of a directed graph GD.V; E/ with no self-loops is a\njVj/STXjEjmatrix BD.bij/such that\nbijD/c128\n/NUL1if edge jleaves vertex i;\n1 if edge jenters vertex i;\n0 otherwise :\nDescribe what the entries of the matrix product BBTrepresent, where BTis the\ntranspose of B.\n22.1-8\nSuppose that instead of a linked list, each array entry Adj\u0152u/c141is a hash table contain-\ning the vertices /ETBfor which .u; /ETB/2E. If all edge lookups are equally likely, what\nis the expected time to determine whether an edge is in the graph? What disadvan-tages does this scheme have? Suggest an alternate data structure for each edge listthat solves these problems. Does your alternative have disadvantages compared tothe hash table?", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "614": {"page_number": 615, "page_information": "594 Chapter 22 Elementary Graph Algorithms\n22.2 Breadth-\ufb01rst search\nBreadth-\ufb01rst search is one of the simplest algorithms for searching a graph and\nthe archetype for many important graph algorithms. Prim\u2019s minimum-spanning-tree algorithm (Section 23.2) and Dijkstra\u2019s single-source shortest-paths algorithm(Section 24.3) use ideas similar to those in breadth-\ufb01rst search.\nGiven a graph GD.V; E/ and a distinguished source vertex s, breadth-\ufb01rst\nsearch systematically explores the edges of Gto \u201cdiscover\u201d every vertex that is\nreachable from s. It computes the distance (smallest number of edges) from s\nto each reachable vertex. It also produces a \u201cbreadth-\ufb01rst tree\u201d with root sthat\ncontains all reachable vertices. For any vertex /ETBreachable from s, the simple path\nin the breadth-\ufb01rst tree from sto/ETBcorresponds to a \u201cshortest path\u201d from sto/ETB\ninG, that is, a path containing the smallest number of edges. The algorithm works\non both directed and undirected graphs.\nBreadth-\ufb01rst search is so named because it expands the frontier between discov-\nered and undiscovered vertices uniformly across the breadth of the frontier. Thatis, the algorithm discovers all vertices at distance kfrom sbefore discovering any\nvertices at distance kC1.\nTo keep track of progress, breadth-\ufb01rst search colors each vertex white, gray, or\nblack. All vertices start out white and may later become gray and then black. A\nvertex is discovered the \ufb01rst time it is encountered during the search, at which time\nit becomes nonwhite. Gray and black vertices, therefore, have been discovered, but\nbreadth-\ufb01rst search distinguishes between them to ensure that the search proceedsin a breadth-\ufb01rst manner.\n1If.u; /ETB/2Eand vertex uis black, then vertex /ETB\nis either gray or black; that is, all vertices adjacent to black vertices have beendiscovered. Gray vertices may have some adjacent white vertices; they representthe frontier between discovered and undiscovered vertices.\nBreadth-\ufb01rst search constructs a breadth-\ufb01rst tree, initially containing only its\nroot, which is the source vertex s. Whenever the search discovers a white vertex /ETB\nin the course of scanning the adjacency list of an already discovered vertex u,t h e\nvertex /ETBand the edge .u; /ETB/ are added to the tree. We say that uis thepredecessor\norparent of/ETBin the breadth-\ufb01rst tree. Since a vertex is discovered at most once, it\nhas at most one parent. Ancestor and descendant relationships in the breadth-\ufb01rsttree are de\ufb01ned relative to the root sas usual: if uis on the simple path in the tree\nfrom the root sto vertex /ETB,t h e n uis an ancestor of /ETBand/ETBis a descendant of u.\n1We distinguish between gray and black vertices to help us understand how breadth-\ufb01rst search op-\nerates. In fact, as Exercise 22.2-3 shows, we would get the same result even if we did not distinguish\nbetween gray and black vertices.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "615": {"page_number": 616, "page_information": "22.2 Breadth-\ufb01rst search 595\nThe breadth-\ufb01rst-search procedure BFS below assumes that the input graph\nGD.V; E/ is represented using adjacency lists. It attaches several additional\nattributes to each vertex in the graph. We store the color of each vertex u2V\nin the attribute u:color and the predecessor of uin the attribute u:/EM.I fuhas no\npredecessor (for example, if uDsoruhas not been discovered), then u:/EMDNIL.\nThe attribute u:dholds the distance from the source sto vertex ucomputed by the\nalgorithm. The algorithm also uses a \ufb01rst-in, \ufb01rst-out queue Q(see Section 10.1)\nto manage the set of gray vertices.\nBFS.G; s/\n1foreach vertex u2G:V/NULfsg\n2 u:colorDWHITE\n3 u:dD1\n4 u:/EMDNIL\n5s:colorDGRAY\n6s:dD0\n7s:/EMDNIL\n8QD;\n9E NQUEUE .Q; s/\n10while Q\u00a4;\n11 uDDEQUEUE .Q/\n12 foreach/ETB2G:Adj\u0152u/c141\n13 if/ETB:color ==WHITE\n14 /ETB:colorDGRAY\n15 /ETB:dDu:dC1\n16 /ETB:/EMDu\n17 E NQUEUE .Q; /ETB/\n18 u:colorDBLACK\nFigure 22.3 illustrates the progress of BFS on a sample graph.\nThe procedure BFS works as follows. With the exception of the source vertex s,\nlines 1\u20134 paint every vertex white, set u:dto be in\ufb01nity for each vertex u, and set\nthe parent of every vertex to be NIL. Line 5 paints sgray, since we consider it to be\ndiscovered as the procedure begins. Line 6 initializes s:dto0,a n dl i n e7s e t st h e\npredecessor of the source to be NIL. Lines 8\u20139 initialize Qto the queue containing\njust the vertex s.\nThewhile loop of lines 10\u201318 iterates as long as there remain gray vertices,\nwhich are discovered vertices that have not yet had their adjacency lists fully ex-\namined. This while loop maintains the following invariant:\nAt the test in line 10, the queue Qconsists of the set of gray vertices.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "616": {"page_number": 617, "page_information": "596 Chapter 22 Elementary Graph Algorithms\nrstu\nvwxy0 \u221e\u221e \u221e\n\u221e \u221e \u221e \u221es\n0Q (a)tu\nvwxy0 1 \u221e\u221e\n\u221e \u221e \u221e 1w\n1Q (b) r\n1\ntu\nvwxy0 12 \u221e\n\u221e 2 \u221e 1Q (c) r\n1tu\nvwxy0 1 \u221e\n\u221eQ (d)\n(e) (f)\n(g) (h)\nQ (i)rs\nrs rs\nt\n2x\n22\n2 1 2t\n2x\n2v\n2\ntu\nvwxy0 1\n\u221eQrs\n2\n2 1 2x\n2v\n2u\n33tu\nvwxy0 1\n3Qrs\n2\n2 1 2v\n2u\n33\ny\n3\ntu\nvwxy0 1\n3Qrs\n2\n2 1u\n33\ny\n3 2tu\nvwxy0 1\n3Qrs\n2\n2 13\ny\n3 2\ntu\nvwxy0 1rs\n2\n2 13\n2 3;\nFigure 22.3 The operation of BFS on an undirected graph. Tree edges are shown shaded as they\nare produced by BFS. The value of u:dappears within each vertex u. The queue Qis shown at the\nbeginning of each iteration of the while loop of lines 10\u201318. Vertex distances appear below vertices\nin the queue.\nAlthough we won\u2019t use this loop invariant to prove correctness, it is easy to see\nthat it holds prior to the \ufb01rst iteration and that each iteration of the loop maintainsthe invariant. Prior to the \ufb01rst iteration, the only gray vertex, and the only vertexinQ, is the source vertex s. Line 11 determines the gray vertex uat the head of\nthe queue Qand removes it from Q.T h e forloop of lines 12\u201317 considers each\nvertex /ETBin the adjacency list of u.I f/ETBis white, then it has not yet been discovered,\nand the procedure discovers it by executing lines 14\u201317. The procedure paintsvertex /ETBgray, sets its distance /ETB:dtou:dC1, records uas its parent /ETB:/EM, and places\nit at the tail of the queue Q. Once the procedure has examined all the vertices on u\u2019s", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "617": {"page_number": 618, "page_information": "22.2 Breadth-\ufb01rst search 597\nadjacency list, it blackens uin line 18. The loop invariant is maintained because\nwhenever a vertex is painted gray (in line 14) it is also enqueued (in line 17), andwhenever a vertex is dequeued (in line 11) it is also painted black (in line 18).\nThe results of breadth-\ufb01rst search may depend upon the order in which the neigh-\nbors of a given vertex are visited in line 12: the breadth-\ufb01rst tree may vary, but thedistances dcomputed by the algorithm will not. (See Exercise 22.2-5.)\nAnalysis\nBefore proving the various properties of breadth-\ufb01rst search, we take on the some-\nwhat easier job of analyzing its running time on an input graph GD.V; E/ .W e\nuse aggregate analysis, as we saw in Section 17.1. After initialization, breadth-\ufb01rstsearch never whitens a vertex, and thus the test in line 13 ensures that each vertex\nis enqueued at most once, and hence dequeued at most once. The operations of\nenqueuing and dequeuing take O.1/ time, and so the total time devoted to queue\noperations is O.V / . Because the procedure scans the adjacency list of each vertex\nonly when the vertex is dequeued, it scans each adjacency list at most once. Sincethe sum of the lengths of all the adjacency lists is \u201a.E/ , the total time spent in\nscanning adjacency lists is O.E/ . The overhead for initialization is O.V / ,a n d\nthus the total running time of the BFS procedure is O.VCE/. Thus, breadth-\ufb01rst\nsearch runs in time linear in the size of the adjacency-list representation of G.\nShortest paths\nAt the beginning of this section, we claimed that breadth-\ufb01rst search \ufb01nds the dis-\ntance to each reachable vertex in a graph GD.V; E/ from a given source vertex\ns2V.D e \ufb01 n et h e shortest-path distance \u0131.s; /ETB/ from sto/ETBas the minimum num-\nber of edges in any path from vertex sto vertex /ETB; if there is no path from sto/ETB,\nthen\u0131.s; /ETB/D1 . We call a path of length \u0131.s; /ETB/ from sto/ETBashortest path\n2\nfrom sto/ETB. Before showing that breadth-\ufb01rst search correctly computes shortest-\npath distances, we investigate an important property of shortest-path distances.\n2In Chapters 24 and 25, we shall generalize our study of shortest paths to weighted graphs, in which\nevery edge has a real-valued weight and the weight of a path is the sum of the weights of its con-\nstituent edges. The graphs considered in the present chapter are unweighted or, equivalently, all\nedges have unit weight.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "618": {"page_number": 619, "page_information": "598 Chapter 22 Elementary Graph Algorithms\nLemma 22.1\nLetGD.V; E/ be a directed or undirected graph, and let s2Vbe an arbitrary\nvertex. Then, for any edge .u; /ETB/2E,\n\u0131.s; /ETB//DC4\u0131.s; u/C1:\nProof Ifuis reachable from s,t h e ns oi s /ETB. In this case, the shortest path from s\nto/ETBcannot be longer than the shortest path from stoufollowed by the edge .u; /ETB/ ,\nand thus the inequality holds. If uis not reachable from s,t h e n \u0131.s; u/D1 ,a n d\nthe inequality holds.\nWe want to show that BFS properly computes /ETB:dD\u0131.s; /ETB/ for each ver-\ntex/ETB2V. We \ufb01rst show that /ETB:dbounds \u0131.s; /ETB/ from above.\nLemma 22.2\nLetGD.V; E/ be a directed or undirected graph, and suppose that BFS is run\nonGfrom a given source vertex s2V. Then upon termination, for each ver-\ntex/ETB2V,t h ev a l u e /ETB:dcomputed by BFS satis\ufb01es /ETB:d/NAK\u0131.s; /ETB/ .\nProof We use induction on the number of E NQUEUE operations. Our inductive\nhypothesis is that /ETB:d/NAK\u0131.s; /ETB/ for all /ETB2V.\nThe basis of the induction is the situation immediately after enqueuing sin line 9\nof BFS. The inductive hypothesis holds here, because s:dD0D\u0131.s; s/ and\n/ETB:dD1/NAK \u0131.s; /ETB/ for all /ETB2V/NULfsg.\nFor the inductive step, consider a white vertex /ETBthat is discovered during the\nsearch from a vertex u. The inductive hypothesis implies that u:d/NAK\u0131.s; u/ .F r o m\nthe assignment performed by line 15 and from Lemma 22.1, we obtain\n/ETB:dDu:dC1\n/NAK\u0131.s; u/C1\n/NAK\u0131.s; /ETB/ :\nVertex /ETBis then enqueued, and it is never enqueued again because it is also grayed\nand the then clause of lines 14\u201317 is executed only for white vertices. Thus, the\nvalue of /ETB:dnever changes again, and the inductive hypothesis is maintained.\nTo prove that /ETB:dD\u0131.s; /ETB/ , we must \ufb01rst show more precisely how the queue Q\noperates during the course of BFS. The next lemma shows that at all times, thequeue holds at most two distinct dvalues.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "619": {"page_number": 620, "page_information": "22.2 Breadth-\ufb01rst search 599\nLemma 22.3\nSuppose that during the execution of BFS on a graph GD.V; E/ , the queue Q\ncontains the vertices h/ETB1;/ETB2;:::;/ETB ri,w h e r e /ETB1is the head of Qand/ETBris the tail.\nThen, /ETBr:d/DC4/ETB1:dC1and/ETBi:d/DC4/ETBiC1:dforiD1 ;2;:::;r/NUL1.\nProof The proof is by induction on the number of queue operations. Initially,\nwhen the queue contains only s, the lemma certainly holds.\nFor the inductive step, we must prove that the lemma holds after both dequeuing\nand enqueuing a vertex. If the head /ETB1of the queue is dequeued, /ETB2becomes the\nnew head. (If the queue becomes empty, then the lemma holds vacuously.) By theinductive hypothesis, /ETB\n1:d/DC4/ETB2:d. But then we have /ETBr:d/DC4/ETB1:dC1/DC4/ETB2:dC1,\nand the remaining inequalities are unaffected. Thus, the lemma follows with /ETB2as\nthe head.\nIn order to understand what happens upon enqueuing a vertex, we need to ex-\namine the code more closely. When we enqueue a vertex /ETBin line 17 of BFS, it\nbecomes /ETBrC1. At that time, we have already removed vertex u, whose adjacency\nlist is currently being scanned, from the queue Q, and by the inductive hypothesis,\nthe new head /ETB1has/ETB1:d/NAKu:d. Thus, /ETBrC1:dD/ETB:dDu:dC1/DC4/ETB1:dC1.F r o m\nthe inductive hypothesis, we also have /ETBr:d/DC4u:dC1,a n ds o /ETBr:d/DC4u:dC1D\n/ETB:dD/ETBrC1:d, and the remaining inequalities are unaffected. Thus, the lemma\nfollows when /ETBis enqueued.\nThe following corollary shows that the dvalues at the time that vertices are\nenqueued are monotonically increasing over time.\nCorollary 22.4\nSuppose that vertices /ETBiand/ETBjare enqueued during the execution of BFS, and\nthat/ETBiis enqueued before /ETBj.T h e n /ETBi:d/DC4/ETBj:dat the time that /ETBjis enqueued.\nProof Immediate from Lemma 22.3 and the property that each vertex receives a\n\ufb01nite dvalue at most once during the course of BFS.\nWe can now prove that breadth-\ufb01rst search correctly \ufb01nds shortest-path dis-\ntances.\nTheorem 22.5 (Correctness of breadth-\ufb01rst search)\nLetGD.V; E/ be a directed or undirected graph, and suppose that BFS is run\nonGfrom a given source vertex s2V. Then, during its execution, BFS discovers\nevery vertex /ETB2Vthat is reachable from the source s, and upon termination,\n/ETB:dD\u0131.s; /ETB/ for all /ETB2V. Moreover, for any vertex /ETB\u00a4sthat is reachable", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "620": {"page_number": 621, "page_information": "600 Chapter 22 Elementary Graph Algorithms\nfrom s, one of the shortest paths from sto/ETBis a shortest path from sto/ETB:/EM\nfollowed by the edge ./ETB:/EM; /ETB/ .\nProof Assume, for the purpose of contradiction, that some vertex receives a d\nvalue not equal to its shortest-path distance. Let /ETBbe the vertex with min-\nimum \u0131.s; /ETB/ that receives such an incorrect dvalue; clearly /ETB\u00a4s.B y\nLemma 22.2, /ETB:d/NAK\u0131.s; /ETB/ , and thus we have that /ETB:d>\u0131 . s ;/ETB / . Vertex /ETBmust be\nreachable from s, for if it is not, then \u0131.s; /ETB/D1/NAK /ETB:d.L e t ube the vertex im-\nmediately preceding /ETBon a shortest path from sto/ETB,s ot h a t \u0131.s; /ETB/D\u0131.s; u/C1.\nBecause \u0131.s; u/ < \u0131.s; /ETB/ , and because of how we chose /ETB,w eh a v e u:dD\u0131.s; u/ .\nPutting these properties together, we have\n/ETB:d>\u0131 . s ;/ETB /D\u0131.s; u/C1Du:dC1: (22.1)\nNow consider the time when BFS chooses to dequeue vertex ufrom Qin\nline 11. At this time, vertex /ETBis either white, gray, or black. We shall show\nthat in each of these cases, we derive a contradiction to inequality (22.1). If /ETBis\nwhite, then line 15 sets /ETB:dDu:dC1, contradicting inequality (22.1). If /ETBis\nblack, then it was already removed from the queue and, by Corollary 22.4, we have/ETB:d/DC4u:d, again contradicting inequality (22.1). If /ETBis gray, then it was painted\ngray upon dequeuing some vertex w, which was removed from Qearlier than u\nand for which /ETB:dDw:dC1. By Corollary 22.4, however, w:d/DC4u:d,a n ds ow e\nhave /ETB:dDw:dC1/DC4u:dC1, once again contradicting inequality (22.1).\nThus we conclude that /ETB:dD\u0131.s; /ETB/ for all /ETB2V. All vertices /ETBreachable\nfrom smust be discovered, for otherwise they would have 1D /ETB:d>\u0131 . s ;/ETB / .T o\nconclude the proof of the theorem, observe that if /ETB:/EMDu,t h e n /ETB:dDu:dC1.\nThus, we can obtain a shortest path from sto/ETBby taking a shortest path from s\nto/ETB:/EMand then traversing the edge ./ETB:/EM; /ETB/ .\nBreadth-\ufb01rst trees\nThe procedure BFS builds a breadth-\ufb01rst tree as it searches the graph, as Fig-\nure 22.3 illustrates. The tree corresponds to the /EMattributes. More formally, for\nag r a p h GD.V; E/ with source s,w ed e \ufb01 n et h e predecessor subgraph ofGas\nG/EMD.V/EM;E/EM/,w h e r e\nV/EMDf/ETB2VW/ETB:/EM\u00a4NILg[fsg\nand\nE/EMDf./ETB:/EM; /ETB/W/ETB2V/EM/NULfsgg:\nThe predecessor subgraph G/EMis abreadth-\ufb01rst tree ifV/EMconsists of the vertices\nreachable from sand, for all /ETB2V/EM, the subgraph G/EMcontains a unique simple", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "621": {"page_number": 622, "page_information": "22.2 Breadth-\ufb01rst search 601\npath from sto/ETBthat is also a shortest path from sto/ETBinG. A breadth-\ufb01rst tree\nis in fact a tree, since it is connected and jE/EMjDjV/EMj/NUL1(see Theorem B.2). We\ncall the edges in E/EMtree edges .\nThe following lemma shows that the predecessor subgraph produced by the BFS\nprocedure is a breadth-\ufb01rst tree.\nLemma 22.6\nWhen applied to a directed or undirected graph GD.V; E/ , procedure BFS con-\nstructs /EMso that the predecessor subgraph G/EMD.V/EM;E/EM/is a breadth-\ufb01rst tree.\nProof Line 16 of BFS sets /ETB:/EMDuif and only if .u; /ETB/2Eand\u0131.s; /ETB/ <1\u2014\nthat is, if /ETBis reachable from s\u2014and thus V/EMconsists of the vertices in Vreachable\nfrom s.S i n c e G/EMforms a tree, by Theorem B.2, it contains a unique simple path\nfrom sto each vertex in V/EM. By applying Theorem 22.5 inductively, we conclude\nthat every such path is a shortest path in G.\nThe following procedure prints out the vertices on a shortest path from sto/ETB,\nassuming that BFS has already computed a breadth-\ufb01rst tree:\nPRINT -PATH. G ;s ;/ETB/\n1if/ETB==s\n2 print s\n3elseif /ETB:/EM ==NIL\n4 print \u201cno path from\u201d s\u201cto\u201d/ETB\u201cexists\u201d\n5elsePRINT -PATH. G ;s ;/ETB:/EM/\n6 print /ETB\nThis procedure runs in time linear in the number of vertices in the path printed,\nsince each recursive call is for a path one vertex shorter.\nExercises\n22.2-1\nShow the dand/EMvalues that result from running breadth-\ufb01rst search on the di-\nrected graph of Figure 22.2(a), using vertex 3as the source.\n22.2-2\nShow the dand/EMvalues that result from running breadth-\ufb01rst search on the undi-\nrected graph of Figure 22.3, using vertex uas the source.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "622": {"page_number": 623, "page_information": "602 Chapter 22 Elementary Graph Algorithms\n22.2-3\nShow that using a single bit to store each vertex color suf\ufb01ces by arguing that the\nBFS procedure would produce the same result if lines 5 and 14 were removed.\n22.2-4\nWhat is the running time of BFS if we represent its input graph by an adjacencymatrix and modify the algorithm to handle this form of input?\n22.2-5\nArgue that in a breadth-\ufb01rst search, the value u:dassigned to a vertex uis inde-\npendent of the order in which the vertices appear in each adjacency list. Using\nFigure 22.3 as an example, show that the breadth-\ufb01rst tree computed by BFS candepend on the ordering within adjacency lists.\n22.2-6\nGive an example of a directed graph GD.V; E/ , a source vertex s2V,a n da\nset of tree edges E\n/EM/DC2Esuch that for each vertex /ETB2V, the unique simple path\nin the graph .V; E /EM/from sto/ETBis a shortest path in G, yet the set of edges E/EM\ncannot be produced by running BFS on G, no matter how the vertices are ordered\nin each adjacency list.\n22.2-7\nThere are two types of professional wrestlers: \u201cbabyfaces\u201d (\u201cgood guys\u201d) and\u201cheels\u201d (\u201cbad guys\u201d). Between any pair of professional wrestlers, there may ormay not be a rivalry. Suppose we have nprofessional wrestlers and we have a list\nofrpairs of wrestlers for which there are rivalries. Give an O.nCr/-time algo-\nrithm that determines whether it is possible to designate some of the wrestlers as\nbabyfaces and the remainder as heels such that each rivalry is between a babyface\nand a heel. If it is possible to perform such a designation, your algorithm shouldproduce it.\n22.2-8 ?\nThediameter of a tree TD.V; E/ is de\ufb01ned as max\nu;/ETB2V\u0131.u;/ETB/ ,t h a ti s ,t h e\nlargest of all shortest-path distances in the tree. Give an ef\ufb01cient algorithm tocompute the diameter of a tree, and analyze the running time of your algorithm.\n22.2-9\nLetGD.V; E/ be a connected, undirected graph. Give an O.VCE/-time algo-\nrithm to compute a path in Gthat traverses each edge in Eexactly once in each\ndirection. Describe how you can \ufb01nd your way out of a maze if you are given alarge supply of pennies.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "623": {"page_number": 624, "page_information": "22.3 Depth-\ufb01rst search 603\n22.3 Depth-\ufb01rst search\nThe strategy followed by depth-\ufb01rst search is, as its name implies, to search\n\u201cdeeper\u201d in the graph whenever possible. Depth-\ufb01rst search explores edges outof the most recently discovered vertex /ETBthat still has unexplored edges leaving it.\nOnce all of /ETB\u2019s edges have been explored, the search \u201cbacktracks\u201d to explore edges\nleaving the vertex from which /ETBwas discovered. This process continues until we\nhave discovered all the vertices that are reachable from the original source vertex.If any undiscovered vertices remain, then depth-\ufb01rst search selects one of them asa new source, and it repeats the search from that source. The algorithm repeats thisentire process until it has discovered every vertex.\n3\nAs in breadth-\ufb01rst search, whenever depth-\ufb01rst search discovers a vertex /ETBdur-\ning a scan of the adjacency list of an already discovered vertex u, it records this\nevent by setting /ETB\u2019s predecessor attribute /ETB:/EM tou. Unlike breadth-\ufb01rst search,\nwhose predecessor subgraph forms a tree, the predecessor subgraph produced bya depth-\ufb01rst search may be composed of several trees, because the search mayrepeat from multiple sources. Therefore, we de\ufb01ne the predecessor subgraph of\na depth-\ufb01rst search slightly differently from that of a breadth-\ufb01rst search: we letG\n/EMD.V; E /EM/,w h e r e\nE/EMDf./ETB:/EM; /ETB/W/ETB2Vand/ETB:/EM\u00a4NILg:\nThe predecessor subgraph of a depth-\ufb01rst search forms a depth-\ufb01rst forest com-\nprising several depth-\ufb01rst trees . The edges in E/EMaretree edges .\nAs in breadth-\ufb01rst search, depth-\ufb01rst search colors vertices during the search to\nindicate their state. Each vertex is initially white, is grayed when it is discovered\nin the search, and is blackened when it is \ufb01nished , that is, when its adjacency list\nhas been examined completely. This technique guarantees that each vertex ends upin exactly one depth-\ufb01rst tree, so that these trees are disjoint.\nBesides creating a depth-\ufb01rst forest, depth-\ufb01rst search also timestamps each ver-\ntex. Each vertex /ETBhas two timestamps: the \ufb01rst timestamp /ETB:drecords when /ETB\nis \ufb01rst discovered (and grayed), and the second timestamp /ETB:frecords when the\nsearch \ufb01nishes examining /ETB\u2019s adjacency list (and blackens /ETB). These timestamps\n3It may seem arbitrary that breadth-\ufb01rst search is limited to only one source whereas depth-\ufb01rst\nsearch may search from multiple sources. Although conceptually, breadth-\ufb01rst search could proceed\nfrom multiple sources and depth-\ufb01rst search could be limited to one source, our approach re\ufb02ects how\nthe results of these searches are typically used. Breadth-\ufb01rst search usually serves to \ufb01nd shortest-\npath distances (and the associated predecessor subgr aph) from a given source. Depth-\ufb01rst search is\noften a subroutine in another algorithm, as we shall see later in this chapter.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "624": {"page_number": 625, "page_information": "604 Chapter 22 Elementary Graph Algorithms\nprovide important information about the structure of the graph and are generally\nhelpful in reasoning about the behavior of depth-\ufb01rst search.\nThe procedure DFS below records when it discovers vertex uin the attribute u:d\nand when it \ufb01nishes vertex uin the attribute u:f. These timestamps are integers\nbetween 1and2jVj, since there is one discovery event and one \ufb01nishing event for\neach of thejVjvertices. For every vertex u,\nu:d<u : f: (22.2)\nVertex uisWHITE before time u:d,GRAY between time u:dand time u:f,a n d\nBLACK thereafter.\nThe following pseudocode is the basic depth-\ufb01rst-search algorithm. The input\ngraph Gmay be undirected or directed. The variable time is a global variable that\nwe use for timestamping.\nDFS.G/\n1foreach vertex u2G:V\n2 u:colorDWHITE\n3 u:/EMDNIL\n4timeD0\n5foreach vertex u2G:V\n6 ifu:color ==WHITE\n7 DFS-V ISIT.G; u/\nDFS-V ISIT.G; u/\n1timeDtimeC1 //white vertex uhas just been discovered\n2u:dDtime\n3u:colorDGRAY\n4foreach/ETB2G:Adj\u0152u/c141 //explore edge .u; /ETB/\n5 if/ETB:color ==WHITE\n6 /ETB:/EMDu\n7 DFS-V ISIT.G; /ETB/\n8u:colorDBLACK //blacken u;i ti s\ufb01 n i s h e d\n9timeDtimeC1\n10u:fDtime\nFigure 22.4 illustrates the progress of DFS on the graph shown in Figure 22.2.\nProcedure DFS works as follows. Lines 1\u20133 paint all vertices white and ini-\ntialize their /EMattributes to NIL. Line 4 resets the global time counter. Lines 5\u20137\ncheck each vertex in Vin turn and, when a white vertex is found, visit it using\nDFS-V ISIT. Every time DFS-V ISIT.G; u/ is called in line 7, vertex ubecomes", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "625": {"page_number": 626, "page_information": "22.3 Depth-\ufb01rst search 605\nuvw\nxyz1/ 1/ 2/ 1/ 2/\n3/1/ 2/\n3/ 4/\n1/ 2/\n3/ 4/B1/ 2/\n3/B\n4/51/ 2/\nB\n4/5 3/61/\nB\n4/5 3/62/7\n1/\nB\n4/5 3/62/7\nF B\n4/5 3/62/7\nF1/8\nB\n4/5 3/62/7\nF1/8 9/\nB\n4/5 3/62/7\nF1/8 9/\nC\nB\n4/5 3/62/7\nF1/8 9/\nC B\n4/5 3/62/7\nF1/8 9/\nC\nBB\n4/5 3/62/7\nF1/8 9/\nC\nB\n10/11B\n4/5 3/62/7\nF1/8\nC\nB\n10/119/12uvw\nxyzuvw\nxyzuvw\nxyz\nuvw\nxyzuvw\nxyzuvw\nxyzuvw\nxyz\nuvw\nxyzuvw\nxyzuvw\nxyzuvw\nxyz\nuvw\nxyzuvw\nxyzuvw\nxyzuvw\nxyz\n(m) (n) (o) (p)(i) (j) (k) (l)(e) (f) (g) (h)(a) (b) (c) (d)\n10/ 10/\nFigure 22.4 The progress of the depth-\ufb01rst-search algorithm DFS on a directed graph. As edges\nare explored by the algorithm, they are shown as either shaded (if they are tree edges) or dashed\n(otherwise). Nontree edges are labeled B, C, or F according to whether they are back, cross, or\nforward edges. Timestamps within vertices i ndicate discovery ti me/\ufb01nishing times.\nthe root of a new tree in the depth-\ufb01rst forest. When DFS returns, every vertex u\nhas been assigned a discovery time u:dand a\ufb01nishing time u:f.\nIn each call DFS-V ISIT.G; u/ , vertex uis initially white. Line 1 increments\nthe global variable time, line 2 records the new value of time as the discovery\ntimeu:d, and line 3 paints ugray. Lines 4\u20137 examine each vertex /ETBadjacent to u\nand recursively visit /ETBif it is white. As each vertex /ETB2Adj\u0152u/c141is considered in\nline 4, we say that edge .u; /ETB/ isexplored by the depth-\ufb01rst search. Finally, after\nevery edge leaving uhas been explored, lines 8\u201310 paint ublack, increment time,\nand record the \ufb01nishing time in u:f.\nNote that the results of depth-\ufb01rst search may depend upon the order in which\nline 5 of DFS examines the vertices and upon the order in which line 4 of DFS-\nVISIT visits the neighbors of a vertex. These different visitation orders tend not", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "626": {"page_number": 627, "page_information": "606 Chapter 22 Elementary Graph Algorithms\nto cause problems in practice, as we can usually use anydepth-\ufb01rst search result\neffectively, with essentially equivalent results.\nWhat is the running time of DFS? The loops on lines 1\u20133 and lines 5\u20137 of DFS\ntake time \u201a.V / , exclusive of the time to execute the calls to DFS-V ISIT. A sw ed i d\nfor breadth-\ufb01rst search, we use aggregate analysis. The procedure DFS-V ISIT is\ncalled exactly once for each vertex /ETB2V, since the vertex uon which DFS-V ISIT\nis invoked must be white and the \ufb01rst thing DFS-V ISIT does is paint vertex ugray.\nDuring an execution of DFS-V ISIT.G; /ETB/ , the loop on lines 4\u20137 executes jAdj\u0152/ETB/c141j\ntimes. SinceX\n/ETB2VjAdj\u0152/ETB/c141jD\u201a.E/ ;\nthe total cost of executing lines 4\u20137 of DFS-V ISIT is\u201a.E/ . The running time of\nDFS is therefore \u201a.VCE/.\nProperties of depth-\ufb01rst search\nDepth-\ufb01rst search yields valuable information about the structure of a graph. Per-\nhaps the most basic property of depth-\ufb01rst search is that the predecessor sub-graph G\n/EMdoes indeed form a forest of trees, since the structure of the depth-\n\ufb01rst trees exactly mirrors the structure of recursive calls of DFS-V ISIT.T h a t i s ,\nuD/ETB:/EM if and only if DFS-V ISIT.G; /ETB/ was called during a search of u\u2019s ad-\njacency list. Additionally, vertex /ETBis a descendant of vertex uin the depth-\ufb01rst\nforest if and only if /ETBis discovered during the time in which uis gray.\nAnother important property of depth-\ufb01rst search is that discovery and \ufb01nishing\ntimes have parenthesis structure . If we represent the discovery of vertex uwith\na left parenthesis \u201c .u\u201d and represent its \ufb01nishing by a right parenthesis \u201c u/\u201d, then\nthe history of discoveries and \ufb01nishings makes a well-formed expression in thesense that the parentheses are properly nested. For example, the depth-\ufb01rst searchof Figure 22.5(a) corresponds to the parenthesization shown in Figure 22.5(b). Thefollowing theorem provides another way to characterize the parenthesis structure.\nTheorem 22.7 (Parenthesis theorem)\nIn any depth-\ufb01rst search of a (directed or undirected) graph GD.V; E/ ,f o ra n y\ntwo vertices uand/ETB, exactly one of the following three conditions holds:\n/SIthe intervals \u0152u:d;u :f/c141and\u0152/ETB:d;/ETB:f/c141are entirely disjoint, and neither unor/ETB\nis a descendant of the other in the depth-\ufb01rst forest,\n/SIthe interval \u0152u:d;u :f/c141is contained entirely within the interval \u0152/ETB:d;/ETB:f/c141,a n d u\nis a descendant of /ETBin a depth-\ufb01rst tree, or\n/SIthe interval \u0152/ETB:d;/ETB:f/c141is contained entirely within the interval \u0152u:d;u :f/c141,a n d /ETB\nis a descendant of uin a depth-\ufb01rst tree.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "627": {"page_number": 628, "page_information": "22.3 Depth-\ufb01rst search 607\n3/6 2/9 1/10 11/16\n14/15 12/13 7/8 4/5yzst\nu v w xB\nCF\nCC\nCB\n123456789 1 0 1 1 1 2 1 3 1 4 1 5 1 6s t\nz\nyw\nxvu\ns\nz\nyw\nxt\nvuC\nF\nB\nCCB\nC(a)\n(b)\n(c)(s(z(y(xx)y)(ww )z)s)(t(vv)(uu)t)\nFigure 22.5 Properties of depth-\ufb01rst search. (a)The result of a depth-\ufb01rst search of a directed\ngraph. Vertices are timestamped and edge types are indicated as in Figure 22.4. (b)Intervals for\nthe discovery time and \ufb01nishing time of each vertex correspond to the parenthesization shown. Each\nrectangle spans the interval given by the discovery and \ufb01nishing times of the corresponding vertex.\nOnly tree edges are shown. If two intervals overlap, then one is nested within the other, and the\nvertex corresponding to the smaller interval is a descendant of the vertex corresponding to the larger.\n(c)The graph of part (a) redrawn with all tree and forward edges going down within a depth-\ufb01rst tree\nand all back edges going up from a descendant to an ancestor.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "628": {"page_number": 629, "page_information": "608 Chapter 22 Elementary Graph Algorithms\nProof We begin with the case in which u:d</ETB : d. We consider two subcases,\naccording to whether /ETB:d<u : for not. The \ufb01rst subcase occurs when /ETB:d<u : f,\nso/ETBwas discovered while uwas still gray, which implies that /ETBis a descendant\nofu. Moreover, since /ETBwas discovered more recently than u, all of its outgo-\ning edges are explored, and /ETBis \ufb01nished, before the search returns to and \ufb01n-\nishes u. In this case, therefore, the interval \u0152/ETB:d;/ETB:f/c141is entirely contained within\nthe interval \u0152u:d;u :f/c141. In the other subcase, u:f</ETB : d, and by inequality (22.2),\nu:d<u : f</ETB : d</ETB : f; thus the intervals \u0152u:d;u :f/c141and\u0152/ETB:d;/ETB:f/c141are disjoint.\nBecause the intervals are disjoint, neither vertex was discovered while the other\nwas gray, and so neither vertex is a descendant of the other.\nThe case in which /ETB:d<u : dis similar, with the roles of uand/ETBreversed in the\nabove argument.\nCorollary 22.8 (Nesting of descendants\u2019 intervals)Vertex /ETBis a proper descendant of vertex uin the depth-\ufb01rst forest for a (directed\nor undirected) graph Gif and only if u:d</ETB : d</ETB : f<u : f.\nProof Immediate from Theorem 22.7.\nThe next theorem gives another important characterization of when one vertex\nis a descendant of another in the depth-\ufb01rst forest.\nTheorem 22.9 (White-path theorem)\nIn a depth-\ufb01rst forest of a (directed or undirected) graph GD.V; E/ , vertex /ETBis\na descendant of vertex uif and only if at the time u:dthat the search discovers u,\nthere is a path from uto/ETBconsisting entirely of white vertices.\nProof):I f/ETBDu, then the path from uto/ETBcontains just vertex u, which is still\nwhite when we set the value of u:d. Now, suppose that /ETBis a proper descendant\nofuin the depth-\ufb01rst forest. By Corollary 22.8, u:d</ETB : d,a n ds o /ETBis white at\ntime u:d.S i n c e /ETBcan be any descendant of u, all vertices on the unique simple\npath from uto/ETBin the depth-\ufb01rst forest are white at time u:d.\n(: Suppose that there is a path of white vertices from uto/ETBat time u:d,b u t/ETB\ndoes not become a descendant of uin the depth-\ufb01rst tree. Without loss of general-\nity, assume that every vertex other than /ETBalong the path becomes a descendant of u.\n(Otherwise, let /ETBbe the closest vertex to ualong the path that doesn\u2019t become a de-\nscendant of u.) Let wbe the predecessor of /ETBin the path, so that wis a descendant\nofu(wandumay in fact be the same vertex). By Corollary 22.8, w:f/DC4u:f.B e -\ncause /ETBmust be discovered after uis discovered, but before wis \ufb01nished, we have\nu:d</ETB : d<w : f/DC4u:f. Theorem 22.7 then implies that the interval \u0152/ETB:d;/ETB:f/c141", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "629": {"page_number": 630, "page_information": "22.3 Depth-\ufb01rst search 609\nis contained entirely within the interval \u0152u:d;u :f/c141. By Corollary 22.8, /ETBmust after\nall be a descendant of u.\nClassi\ufb01cation of edges\nAnother interesting property of depth-\ufb01rst search is that the search can be used\nto classify the edges of the input graph GD.V; E/ . The type of each edge can\nprovide important information about a graph. For example, in the next section, weshall see that a directed graph is acyclic if and only if a depth-\ufb01rst search yields no\u201cback\u201d edges (Lemma 22.11).\nWe can de\ufb01ne four edge types in terms of the depth-\ufb01rst forest G\n/EMproduced by\na depth-\ufb01rst search on G:\n1.Tree edges are edges in the depth-\ufb01rst forest G/EM. Edge .u; /ETB/ is a tree edge if /ETB\nwas \ufb01rst discovered by exploring edge .u; /ETB/ .\n2.Back edges are those edges .u; /ETB/ connecting a vertex uto an ancestor /ETBin a\ndepth-\ufb01rst tree. We consider self-loops, which may occur in directed graphs, to\nbe back edges.\n3.Forward edges are those nontree edges .u; /ETB/ connecting a vertex uto a de-\nscendant /ETBin a depth-\ufb01rst tree.\n4.Cross edges are all other edges. They can go between vertices in the same\ndepth-\ufb01rst tree, as long as one vertex is not an ancestor of the other, or they cango between vertices in different depth-\ufb01rst trees.\nIn Figures 22.4 and 22.5, edge labels indicate edge types. Figure 22.5(c) also shows\nhow to redraw the graph of Figure 22.5(a) so that all tree and forward edges headdownward in a depth-\ufb01rst tree and all back edges go up. We can redraw any graphin this fashion.\nThe DFS algorithm has enough information to classify some edges as it encoun-\nters them. The key idea is that when we \ufb01rst explore an edge .u; /ETB/ ,t h ec o l o ro f\nvertex /ETBtells us something about the edge:\n1.\nWHITE indicates a tree edge,\n2.GRAY indicates a back edge, and\n3.BLACK indicates a forward or cross edge.\nThe \ufb01rst case is immediate from the speci\ufb01cation of the algorithm. For the sec-\nond case, observe that the gray vertices always form a linear chain of descendantscorresponding to the stack of active DFS-V\nISIT invocations; the number of gray\nvertices is one more than the depth in the depth-\ufb01rst forest of the vertex most re-cently discovered. Exploration always proceeds from the deepest gray vertex, so", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "630": {"page_number": 631, "page_information": "610 Chapter 22 Elementary Graph Algorithms\nan edge that reaches another gray vertex has reached an ancestor. The third case\nhandles the remaining possibility; Exercise 22.3-5 asks you to show that such anedge .u; /ETB/ is a forward edge if u:d</ETB : dand a cross edge if u:d>/ETB : d.\nAn undirected graph may entail some ambiguity in how we classify edges,\nsince .u; /ETB/ and./ETB; u/ are really the same edge. In such a case, we classify the\nedge as the \ufb01rst type in the classi\ufb01cation list that applies. Equivalently (see Ex-\nercise 22.3-6), we classify the edge according to whichever of .u; /ETB/ or./ETB; u/ the\nsearch encounters \ufb01rst.\nWe now show that forward and cross edges never occur in a depth-\ufb01rst search of\nan undirected graph.\nTheorem 22.10\nIn a depth-\ufb01rst search of an undirected graph G, every edge of Gis either a tree\nedge or a back edge.\nProof Let.u; /ETB/ be an arbitrary edge of G, and suppose without loss of generality\nthatu:d</ETB : d. Then the search must discover and \ufb01nish /ETBbefore it \ufb01nishes u\n(while uis gray), since /ETBis on u\u2019s adjacency list. If the \ufb01rst time that the search\nexplores edge .u; /ETB/ , it is in the direction from uto/ETB,t h e n /ETBis undiscovered\n(white) until that time, for otherwise the search would have explored this edge\nalready in the direction from /ETBtou. Thus, .u; /ETB/ becomes a tree edge. If the\nsearch explores .u; /ETB/ \ufb01rst in the direction from /ETBtou,t h e n .u; /ETB/ is a back edge,\nsince uis still gray at the time the edge is \ufb01rst explored.\nWe shall see several applications of these theorems in the following sections.\nExercises\n22.3-1\nMake a 3-by-3chart with row and column labels WHITE ,GRAY ,a n d BLACK .I n\neach cell .i; j / , indicate whether, at any point during a depth-\ufb01rst search of a di-\nrected graph, there can be an edge from a vertex of color ito a vertex of color j.\nFor each possible edge, indicate what edge types it can be. Make a second suchchart for depth-\ufb01rst search of an undirected graph.\n22.3-2\nShow how depth-\ufb01rst search works on the graph of Figure 22.6. Assume that theforloop of lines 5\u20137 of the DFS procedure considers the vertices in alphabetical\norder, and assume that each adjacency list is ordered alphabetically. Show thediscovery and \ufb01nishing times for each vertex, and show the classi\ufb01cation of eachedge.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "631": {"page_number": 632, "page_information": "22.3 Depth-\ufb01rst search 611\nqr\nstu\nvw xy\nz\nFigure 22.6 A directed graph for use in Exercises 22.3-2 and 22.5-2.\n22.3-3\nShow the parenthesis structure of the depth-\ufb01rst search of Figure 22.4.\n22.3-4\nShow that using a single bit to store each vertex color suf\ufb01ces by arguing thatthe DFS procedure would produce the same result if line 3 of DFS-V\nISIT was\nremoved.\n22.3-5\nShow that edge .u; /ETB/ is\na.a tree edge or forward edge if and only if u:d</ETB : d</ETB : f<u : f,\nb.a back edge if and only if /ETB:d/DC4u:d<u : f/DC4/ETB:f,a n d\nc.a cross edge if and only if /ETB:d</ETB : f<u : d<u : f.\n22.3-6\nShow that in an undirected graph, classifying an edge .u; /ETB/ as a tree edge or a back\nedge according to whether .u; /ETB/ or./ETB; u/ is encountered \ufb01rst during the depth-\ufb01rst\nsearch is equivalent to classifying it according to the ordering of the four types in\nthe classi\ufb01cation scheme.\n22.3-7\nRewrite the procedure DFS, using a stack to eliminate recursion.\n22.3-8\nGive a counterexample to the conjecture that if a directed graph Gcontains a path\nfrom uto/ETB,a n di f u:d</ETB : din a depth-\ufb01rst search of G,t h e n /ETBis a descendant\nofuin the depth-\ufb01rst forest produced.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "632": {"page_number": 633, "page_information": "612 Chapter 22 Elementary Graph Algorithms\n22.3-9\nGive a counterexample to the conjecture that if a directed graph Gcontains a path\nfrom uto/ETB, then any depth-\ufb01rst search must result in /ETB:d/DC4u:f.\n22.3-10\nModify the pseudocode for depth-\ufb01rst search so that it prints out every edge in thedirected graph G, together with its type. Show what modi\ufb01cations, if any, you need\nto make if Gis undirected.\n22.3-11\nExplain how a vertex uof a directed graph can end up in a depth-\ufb01rst tree contain-\ning only u, even though uhas both incoming and outgoing edges in G.\n22.3-12\nShow that we can use a depth-\ufb01rst search of an undirected graph Gto identify the\nconnected components of G, and that the depth-\ufb01rst forest contains as many trees\nasGhas connected components. More precisely, show how to modify depth-\ufb01rst\nsearch so that it assigns to each vertex /ETBan integer label /ETB:ccbetween 1andk,\nwhere kis the number of connected components of G, such that u:ccD/ETB:ccif\nand only if uand/ETBare in the same connected component.\n22.3-13 ?\nA directed graph GD.V; E/ issingly connected ifu;/ETBimplies that Gcontains\nat most one simple path from uto/ETBfor all vertices u; /ETB2V. Give an ef\ufb01cient\nalgorithm to determine whether or not a directed graph is singly connected.\n22.4 Topological sort\nThis section shows how we can use depth-\ufb01rst search to perform a topological sortof a directed acyclic graph, or a \u201cdag\u201d as it is sometimes called. A topological sort\nof a dag GD.V; E/ is a linear ordering of all its vertices such that if Gcontains an\nedge .u; /ETB/ ,t h e n uappears before /ETBin the ordering. (If the graph contains a cycle,\nthen no linear ordering is possible.) We can view a topological sort of a graph asan ordering of its vertices along a horizontal line so that all directed edges go fromleft to right. Topological sorting is thus different from the usual kind of \u201csorting\u201d\nstudied in Part II.\nMany applications use directed acyclic graphs to indicate precedences among\nevents. Figure 22.7 gives an example that arises when Professor Bumstead gets\ndressed in the morning. The professor must don certain garments before others\n(e.g., socks before shoes). Other items may be put on in any order (e.g., socks and", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "633": {"page_number": 634, "page_information": "22.4 Topological sort 613\n11/16\n12/15\n6/71/8\n2/5\n3/417/18\n13/149/10\n17/18 11/16 12/15 13/14 9/10 1/8 6/7 2/5 3/4(a)\n(b)undershorts\npants\nbeltshirt\ntie\njacketsocks\nshoeswatch\nsocks undershorts pants shoes watch shirt belt tie jacket\nFigure 22.7 (a) Professor Bumstead topologically sorts his clothing when getting dressed. Each\ndirected edge .u; /ETB/ means that garment umust be put on before garment /ETB. The discovery and\n\ufb01nishing times from a depth-\ufb01rst search are shown next to each vertex. (b)T h es a m eg r a p hs h o w n\ntopologically sorted, with its vertices arranged from left to right in order of decreasing \ufb01nishing time.\nAll directed edges go from left to right.\npants). A directed edge .u; /ETB/ in the dag of Figure 22.7(a) indicates that garment u\nmust be donned before garment /ETB. A topological sort of this dag therefore gives an\norder for getting dressed. Figure 22.7(b) shows the topologically sorted dag as anordering of vertices along a horizontal line such that all directed edges go from leftto right.\nThe following simple algorithm topologically sorts a dag:\nT\nOPOLOGICAL -SORT.G/\n1 call DFS .G/to compute \ufb01nishing times /ETB:ffor each vertex /ETB\n2 as each vertex is \ufb01nished, insert it onto the front of a linked list3return the linked list of vertices\nFigure 22.7(b) shows how the topologically sorted vertices appear in reverse order\nof their \ufb01nishing times.\nWe can perform a topological sort in time \u201a.VCE/, since depth-\ufb01rst search\ntakes \u201a.VCE/time and it takes O.1/ time to insert each of the jVjvertices onto\nthe front of the linked list.\nWe prove the correctness of this algorithm using the following key lemma char-\nacterizing directed acyclic graphs.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "634": {"page_number": 635, "page_information": "614 Chapter 22 Elementary Graph Algorithms\nLemma 22.11\nA directed graph Gis acyclic if and only if a depth-\ufb01rst search of Gyields no back\nedges.\nProof): Suppose that a depth-\ufb01rst search produces a back edge .u; /ETB/ .T h e n\nvertex /ETBis an ancestor of vertex uin the depth-\ufb01rst forest. Thus, Gcontains a path\nfrom /ETBtou, and the back edge .u; /ETB/ completes a cycle.\n(: Suppose that Gcontains a cycle c. We show that a depth-\ufb01rst search of G\nyields a back edge. Let /ETBbe the \ufb01rst vertex to be discovered in c,a n dl e t .u; /ETB/ be\nthe preceding edge in c. At time /ETB:d, the vertices of cform a path of white vertices\nfrom /ETBtou. By the white-path theorem, vertex ubecomes a descendant of /ETBin the\ndepth-\ufb01rst forest. Therefore, .u; /ETB/ is a back edge.\nTheorem 22.12\nTOPOLOGICAL -SORT produces a topological sort of the directed acyclic graph\nprovided as its input.\nProof Suppose that DFS is run on a given dag GD.V; E/ to determine \ufb01n-\nishing times for its vertices. It suf\ufb01ces to show that for any pair of distinct ver-tices u; /ETB2V,i fGcontains an edge from uto/ETB,t h e n /ETB:f<u : f. Consider any\nedge .u; /ETB/ explored by DFS .G/. When this edge is explored, /ETBcannot be gray,\nsince then /ETBwould be an ancestor of uand.u; /ETB/ would be a back edge, contra-\ndicting Lemma 22.11. Therefore, /ETBmust be either white or black. If /ETBis white,\nit becomes a descendant of u,a n ds o /ETB:f<u : f.I f/ETBis black, it has already been\n\ufb01nished, so that /ETB:fhas already been set. Because we are still exploring from u,w e\nhave yet to assign a timestamp to u:f, and so once we do, we will have /ETB:f<u : f\nas well. Thus, for any edge .u; /ETB/ in the dag, we have /ETB:f<u : f, proving the\ntheorem.\nExercises\n22.4-1\nShow the ordering of vertices produced by T OPOLOGICAL -SORT when it is run on\nthe dag of Figure 22.8, under the assumption of Exercise 22.3-2.\n22.4-2\nGive a linear-time algorithm that takes as input a directed acyclic graph GD\n.V; E/ and two vertices sandt, and returns the number of simple paths from s\ntotinG. For example, the directed acyclic graph of Figure 22.8 contains exactly\nfour simple paths from vertex pto vertex /ETB:po/ETB,pory/ETB ,posry/ETB ,a n d psry/ETB .\n(Your algorithm needs only to count the simple paths, not list them.)", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "635": {"page_number": 636, "page_information": "22.5 Strongly connected components 615\nz y xw v u ts r qp o n m\nFigure 22.8 A dag for topological sorting.\n22.4-3\nGive an algorithm that determines whether or not a given undirected graph GD\n.V; E/ contains a cycle. Your algorithm should run in O.V / time, independent\nofjEj.\n22.4-4\nProve or disprove: If a directed graph Gcontains cycles, then T OPOLOGICAL -\nSORT.G/ produces a vertex ordering that minimizes the number of \u201cbad\u201d edges\nthat are inconsistent with the ordering produced.\n22.4-5\nAnother way to perform topological sorting on a directed acyclic graph GD\n.V; E/ is to repeatedly \ufb01nd a vertex of in-degree 0, output it, and remove it and\nall of its outgoing edges from the graph. Explain how to implement this idea so\nthat it runs in time O.VCE/. What happens to this algorithm if Ghas cycles?\n22.5 Strongly connected components\nWe now consider a classic application of depth-\ufb01rst search: decomposing a di-\nrected graph into its strongly connected components. This section shows how to doso using two depth-\ufb01rst searches. Many algorithms that work with directed graphs\nbegin with such a decomposition. After decomposing the graph into strongly con-\nnected components, such algorithms run separately on each one and then combinethe solutions according to the structure of connections among components.\nRecall from Appendix B that a strongly connected component of a directed\ngraph GD.V; E/ is a maximal set of vertices C/DC2Vsuch that for every pair\nof vertices uand/ETBinC, we have both u;/ETBand/ETB;u; that is, vertices uand/ETB\nare reachable from each other. Figure 22.9 shows an example.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "636": {"page_number": 637, "page_information": "616 Chapter 22 Elementary Graph Algorithms\n13/14 11/16\n12/15 3/41/10\n2/78/9\n5/6abcd\nef g h\nabcd\nef g h\nabecd\nfg h(c)(b)(a)\nFigure 22.9 (a) A directed graph G. Each shaded region is a strongly connected component of G.\nEach vertex is labeled with its discovery and \ufb01nishing times in a depth-\ufb01rst search, and tree edges\nare shaded. (b)The graph GT, the transpose of G, with the depth-\ufb01rst forest computed in line 3\nof S TRONGLY -CONNECTED -COMPONENTS shown and tree edges shaded. Each strongly connected\ncomponent corresponds to one depth-\ufb01rst tree. Vertices b,c,g,a n d h, which are heavily shaded, are\nthe roots of the depth-\ufb01rst trees produced by the depth-\ufb01rst search of GT.(c)The acyclic component\ngraph GSCCobtained by contracting all edges within each strongly connected component of Gso\nthat only a single vertex remains in each component.\nOur algorithm for \ufb01nding strongly connected components of a graph GD\n.V; E/ uses the transpose of G, which we de\ufb01ned in Exercise 22.1-3 to be the\ngraph GTD.V; ET/,w h e r e ETDf.u; /ETB/W./ETB; u/2Eg.T h a t i s , ETconsists of\nthe edges of Gwith their directions reversed. Given an adjacency-list representa-\ntion of G, the time to create GTisO.VCE/. It is interesting to observe that G\nandGThave exactly the same strongly connected components: uand/ETBare reach-\nable from each other in Gif and only if they are reachable from each other in GT.\nFigure 22.9(b) shows the transpose of the graph in Figure 22.9(a), with the stronglyconnected components shaded.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "637": {"page_number": 638, "page_information": "22.5 Strongly connected components 617\nThe following linear-time (i.e., \u201a.VCE/-time) algorithm computes the strongly\nconnected components of a directed graph GD.V; E/ using two depth-\ufb01rst\nsearches, one on Gand one on GT.\nSTRONGLY -CONNECTED -COMPONENTS .G/\n1 call DFS .G/to compute \ufb01nishing times u:ffor each vertex u\n2 compute GT\n3 call DFS .GT/, but in the main loop of DFS, consider the vertices\nin order of decreasing u:f(as computed in line 1)\n4 output the vertices of each tree in the depth-\ufb01rst forest formed in line 3 as a\nseparate strongly connected component\nThe idea behind this algorithm comes from a key property of the component\ngraph GSCCD.VSCC;ESCC/, which we de\ufb01ne as follows. Suppose that G\nhas strongly connected components C1;C2;:::;C k. The vertex set VSCCis\nf/ETB1;/ETB2;:::;/ETB kg, and it contains a vertex /ETBifor each strongly connected compo-\nnentCiofG. There is an edge ./ETBi;/ETBj/2ESCCifGcontains a directed edge .x; y/\nfor some x2Ciand some y2Cj. Looked at another way, by contracting all\nedges whose incident vertices are within the same strongly connected componentofG, the resulting graph is G\nSCC. Figure 22.9(c) shows the component graph of\nthe graph in Figure 22.9(a).\nThe key property is that the component graph is a dag, which the following\nlemma implies.\nLemma 22.13\nLetCandC0be distinct strongly connected components in directed graph GD\n.V; E/ ,l e tu; /ETB2C,l e tu0;/ETB02C0, and suppose that Gcontains a path u;u0.\nThen Gcannot also contain a path /ETB0;/ETB.\nProof IfGcontains a path /ETB0;/ETB, then it contains paths u;u0;/ETB0and\n/ETB0;/ETB;u. Thus, uand/ETB0are reachable from each other, thereby contradicting\nthe assumption that CandC0are distinct strongly connected components.\nWe shall see that by considering vertices in the second depth-\ufb01rst search in de-\ncreasing order of the \ufb01nishing times that were computed in the \ufb01rst depth-\ufb01rstsearch, we are, in essence, visiting the vertices of the component graph (each ofwhich corresponds to a strongly connected component of G) in topologically sorted\norder.\nBecause the S\nTRONGLY -CONNECTED -COMPONENTS procedure performs two\ndepth-\ufb01rst searches, there is the potential for ambiguity when we discuss u:d\noru:f. In this section, these values always refer to the discovery and \ufb01nishing\ntimes as computed by the \ufb01rst call of DFS, in line 1.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "638": {"page_number": 639, "page_information": "618 Chapter 22 Elementary Graph Algorithms\nWe extend the notation for discovery and \ufb01nishing times to sets of vertices.\nIfU/DC2V, then we de\ufb01ne d.U/Dmin u2Ufu:dgandf. U/Dmax u2Ufu:fg.\nThat is, d.U/ andf. U/ are the earliest discovery time and latest \ufb01nishing time,\nrespectively, of any vertex in U.\nThe following lemma and its corollary give a key property relating strongly con-\nnected components and \ufb01nishing times in the \ufb01rst depth-\ufb01rst search.\nLemma 22.14\nLetCandC0be distinct strongly connected components in directed graph GD\n.V; E/ . Suppose that there is an edge .u; /ETB/2E,w h e r e u2Cand/ETB2C0.T h e n\nf. C/>f. C0/.\nProof We consider two cases, depending on which strongly connected compo-\nnent, CorC0, had the \ufb01rst discovered vertex during the depth-\ufb01rst search.\nIfd.C/ < d.C0/,l e txbe the \ufb01rst vertex discovered in C. At time x:d,a l lv e r -\ntices in CandC0are white. At that time, Gcontains a path from xto each vertex\ninCconsisting only of white vertices. Because .u; /ETB/2E, for any vertex w2C0,\nthere is also a path in Gat time x:dfrom xtowconsisting only of white vertices:\nx;u!/ETB;w. By the white-path theorem, all vertices in CandC0become\ndescendants of xin the depth-\ufb01rst tree. By Corollary 22.8, xhas the latest \ufb01nishing\ntime of any of its descendants, and so x:fDf. C/>f. C0/.\nIf instead we have d.C/ > d.C0/,l e tybe the \ufb01rst vertex discovered in C0.\nAt time y:d, all vertices in C0are white and Gcontains a path from yto each\nvertex in C0consisting only of white vertices. By the white-path theorem, all ver-\ntices in C0become descendants of yin the depth-\ufb01rst tree, and by Corollary 22.8,\ny:fDf. C0/. At time y:d, all vertices in Care white. Since there is an edge .u; /ETB/\nfrom CtoC0, Lemma 22.13 implies that there cannot be a path from C0toC.\nHence, no vertex in Cis reachable from y. At time y:f, therefore, all vertices in C\nare still white. Thus, for any vertex w2C,w eh a v e w:f>y : f, which implies\nthatf. C/>f. C0/.\nThe following corollary tells us that each edge in GTthat goes between different\nstrongly connected components goes from a component with an earlier \ufb01nishing\ntime (in the \ufb01rst depth-\ufb01rst search) to a component with a later \ufb01nishing time.\nCorollary 22.15\nLetCandC0be distinct strongly connected components in directed graph GD\n.V; E/ . Suppose that there is an edge .u; /ETB/2ET,w h e r e u2Cand/ETB2C0.T h e n\nf. C/<f. C0/.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "639": {"page_number": 640, "page_information": "22.5 Strongly connected components 619\nProof Since .u; /ETB/2ET,w eh a v e ./ETB; u/2E. Because the strongly con-\nnected components of GandGTare the same, Lemma 22.14 implies that\nf. C/<f. C0/.\nCorollary 22.15 provides the key to understanding why the strongly connected\ncomponents algorithm works. Let us examine what happens when we perform thesecond depth-\ufb01rst search, which is on G\nT. We start with the strongly connected\ncomponent Cwhose \ufb01nishing time f. C/ is maximum. The search starts from\nsome vertex x2C, and it visits all vertices in C. By Corollary 22.15, GTcontains\nno edges from Cto any other strongly connected component, and so the search\nfrom xwill not visit vertices in any other component. Thus, the tree rooted at x\ncontains exactly the vertices of C. Having completed visiting all vertices in C,\nthe search in line 3 selects as a root a vertex from some other strongly connected\ncomponent C0whose \ufb01nishing time f. C0/is maximum over all components other\nthanC. Again, the search will visit all vertices in C0, but by Corollary 22.15,\nthe only edges in GTfrom C0to any other component must be to C,w h i c hw e\nhave already visited. In general, when the depth-\ufb01rst search of GTin line 3 visits\nany strongly connected component, any edges out of that component must be tocomponents that the search already visited. Each depth-\ufb01rst tree, therefore, will beexactly one strongly connected component. The following theorem formalizes thisargument.\nTheorem 22.16\nThe S\nTRONGLY -CONNECTED -COMPONENTS procedure correctly computes the\nstrongly connected components of the directed graph Gprovided as its input.\nProof We argue by induction on the number of depth-\ufb01rst trees found in the\ndepth-\ufb01rst search of GTin line 3 that the vertices of each tree form a strongly\nconnected component. The inductive hypothesis is that the \ufb01rst ktrees produced\nin line 3 are strongly connected components. The basis for the induction, whenkD0, is trivial.\nIn the inductive step, we assume that each of the \ufb01rst kdepth-\ufb01rst trees produced\nin line 3 is a strongly connected component, and we consider the .kC1/st tree\nproduced. Let the root of this tree be vertex u,a n dl e t ube in strongly connected\ncomponent C. Because of how we choose roots in the depth-\ufb01rst search in line 3,\nu:fDf. C/ > f. C\n0/for any strongly connected component C0other than C\nthat has yet to be visited. By the inductive hypothesis, at the time that the searchvisits u, all other vertices of Care white. By the white-path theorem, therefore, all\nother vertices of Care descendants of uin its depth-\ufb01rst tree. Moreover, by the\ninductive hypothesis and by Corollary 22.15, any edges in G\nTthat leave Cmust be\nto strongly connected components that have already been visited. Thus, no vertex", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "640": {"page_number": 641, "page_information": "620 Chapter 22 Elementary Graph Algorithms\nin any strongly connected component other than Cwill be a descendant of uduring\nthe depth-\ufb01rst search of GT. Thus, the vertices of the depth-\ufb01rst tree in GTthat is\nrooted at uform exactly one strongly connected component, which completes the\ninductive step and the proof.\nHere is another way to look at how the second depth-\ufb01rst search operates. Con-\nsider the component graph .GT/SCCofGT. If we map each strongly connected\ncomponent visited in the second depth-\ufb01rst search to a vertex of .GT/SCC, the sec-\nond depth-\ufb01rst search visits vertices of .GT/SCCin the reverse of a topologically\nsorted order. If we reverse the edges of .GT/SCC, we get the graph ..GT/SCC/T.\nBecause ..GT/SCC/TDGSCC(see Exercise 22.5-4), the second depth-\ufb01rst search\nvisits the vertices of GSCCin topologically sorted order.\nExercises\n22.5-1\nHow can the number of strongly connected components of a graph change if a newedge is added?\n22.5-2\nShow how the procedure S\nTRONGLY -CONNECTED -COMPONENTS works on the\ngraph of Figure 22.6. Speci\ufb01cally, show the \ufb01nishing times computed in line 1 andthe forest produced in line 3. Assume that the loop of lines 5\u20137 of DFS considersvertices in alphabetical order and that the adjacency lists are in alphabetical order.\n22.5-3\nProfessor Bacon claims that the algorithm for strongly connected components\nwould be simpler if it used the original (instead of the transpose) graph in the\nsecond depth-\ufb01rst search and scanned the vertices in order of increasing \ufb01nishing\ntimes. Does this simpler algorithm always produce correct results?\n22.5-4\nProve that for any directed graph G,w eh a v e ..G\nT/SCC/TDGSCC.T h a t i s , t h e\ntranspose of the component graph of GTis the same as the component graph of G.\n22.5-5\nGive an O.VCE/-time algorithm to compute the component graph of a directed\ngraph GD.V; E/ . Make sure that there is at most one edge between two vertices\nin the component graph your algorithm produces.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "641": {"page_number": 642, "page_information": "Problems for Chapter 22 621\n22.5-6\nGiven a directed graph GD.V; E/ , explain how to create another graph G0D\n.V; E0/such that (a) G0has the same strongly connected components as G,( b )G0\nhas the same component graph as G,a n d( c ) E0is as small as possible. Describe a\nfast algorithm to compute G0.\n22.5-7\nA directed graph GD.V; E/ issemiconnected if, for all pairs of vertices u; /ETB2V,\nwe have u;/ETBor/ETB;u. Give an ef\ufb01cient algorithm to determine whether\nor not Gis semiconnected. Prove that your algorithm is correct, and analyze its\nrunning time.\nProblems\n22-1 Classifying edges by breadth-\ufb01rst searchA depth-\ufb01rst forest classi\ufb01es the edges of a graph into tree, back, forward, andcross edges. A breadth-\ufb01rst tree can also be used to classify the edges reachable\nfrom the source of the search into the same four categories.\na.Prove that in a breadth-\ufb01rst search of an undirected graph, the following prop-\nerties hold:\n1. There are no back edges and no forward edges.\n2. For each tree edge .u; /ETB/ ,w eh a v e /ETB:dDu:dC1.\n3. For each cross edge .u; /ETB/ ,w eh a v e /ETB:dDu:dor/ETB:dDu:dC1.\nb.Prove that in a breadth-\ufb01rst search of a directed graph, the following properties\nhold:\n1. There are no forward edges.\n2. For each tree edge .u; /ETB/ ,w eh a v e /ETB:dDu:dC1.\n3. For each cross edge .u; /ETB/ ,w eh a v e /ETB:d/DC4u:dC1.\n4. For each back edge .u; /ETB/ ,w eh a v e 0/DC4/ETB:d/DC4u:d.\n22-2 Articulation points, bridges, and biconnected components\nLetGD.V; E/ be a connected, undirected graph. An articulation point ofGis\na vertex whose removal disconnects G.Abridge ofGis an edge whose removal\ndisconnects G.Abiconnected component ofGis a maximal set of edges such\nthat any two edges in the set lie on a common simple cycle. Figure 22.10 illustrates", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "642": {"page_number": 643, "page_information": "622 Chapter 22 Elementary Graph Algorithms\n12\n34\n56\nFigure 22.10 The articulation points, bridges, and biconnected components of a connected, undi-\nrected graph for use in Problem 22-2. The articulation points are the heavily shaded vertices, the\nbridges are the heavily shaded edges, and the biconnected components are the edges in the shaded\nregions, with a bccnumbering shown.\nthese de\ufb01nitions. We can determine articulation points, bridges, and biconnected\ncomponents using depth-\ufb01rst search. Let G/EMD.V; E /EM/be a depth-\ufb01rst tree of G.\na.Prove that the root of G/EMis an articulation point of Gif and only if it has at\nleast two children in G/EM.\nb.Let/ETBbe a nonroot vertex of G/EM. Prove that /ETBis an articulation point of Gif and\nonly if /ETBh a sac h i l d ssuch that there is no back edge from sor any descendant\nofsto a proper ancestor of /ETB.\nc.Let\n/ETB:lowDmin(\n/ETB:d;\nw:dW.u; w/ is a back edge for some descendant uof/ETB:\nShow how to compute /ETB:lowfor all vertices /ETB2VinO.E/ time.\nd.Show how to compute all articulation points in O.E/ time.\ne.Prove that an edge of Gis a bridge if and only if it does not lie on any simple\ncycle of G.\nf.Show how to compute all the bridges of GinO.E/ time.\ng.Prove that the biconnected components of Gpartition the nonbridge edges of G.\nh.Give an O.E/ -time algorithm to label each edge eofGwith a positive in-\nteger e:bccsuch that e:bccDe0:bccif and only if eande0are in the same\nbiconnected component.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "643": {"page_number": 644, "page_information": "Notes for Chapter 22 623\n22-3 Euler tour\nAnEuler tour of a strongly connected, directed graph GD.V; E/ is a cycle that\ntraverses each edge of Gexactly once, although it may visit a vertex more than\nonce.\na.Show that Ghas an Euler tour if and only if in-degree ./ETB/Dout-degree ./ETB/for\neach vertex /ETB2V.\nb.Describe an O.E/ -time algorithm to \ufb01nd an Euler tour of Gif one exists. ( Hint:\nMerge edge-disjoint cycles.)\n22-4 Reachability\nLetGD.V; E/ be a directed graph in which each vertex u2Vis labeled with\na unique integer L.u/ from the setf1 ;2;:::;jVjg. For each vertex u2V,l e t\nR.u/Df/ETB2VWu;/ETBgbe the set of vertices that are reachable from u.D e \ufb01 n e\nmin.u/to be the vertex in R.u/ whose label is minimum, i.e., min .u/is the vertex /ETB\nsuch that L./ETB/DminfL.w/Ww2R.u/g.G i v ea n O.VCE/-time algorithm that\ncomputes min .u/for all vertices u2V.\nChapter notes\nEven [103] and Tarjan [330] are excellent references for graph algorithms.\nBreadth-\ufb01rst search was discovered by Moore [260] in the context of \ufb01nding\npaths through mazes. Lee [226] independently discovered the same algorithm in\nthe context of routing wires on circuit boards.\nHopcroft and Tarjan [178] advocated the use of the adjacency-list representation\nover the adjacency-matrix representation for sparse graphs and were the \ufb01rst torecognize the algorithmic importance of depth-\ufb01rst search. Depth-\ufb01rst search hasbeen widely used since the late 1950s, especially in arti\ufb01cial intelligence programs.\nTarjan [327] gave a linear-time algorithm for \ufb01nding strongly connected compo-\nnents. The algorithm for strongly connected components in Section 22.5 is adaptedfrom Aho, Hopcroft, and Ullman [6], who credit it to S. R. Kosaraju (unpublished)and M. Sharir [314]. Gabow [119] also developed an algorithm for strongly con-nected components that is based on contracting cycles and uses two stacks to makeit run in linear time. Knuth [209] was the \ufb01rst to give a linear-time algorithm fortopological sorting.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "644": {"page_number": 645, "page_information": "23 Minimum Spanning Trees\nElectronic circuit designs often need to make the pins of several components elec-\ntrically equivalent by wiring them together. To interconnect a set of npins, we can\nuse an arrangement of n/NUL1wires, each connecting two pins. Of all such arrange-\nments, the one that uses the least amount of wire is usually the most desirable.\nWe can model this wiring problem with a connected, undirected graph GD\n.V; E/ ,w h e r e Vis the set of pins, Eis the set of possible interconnections between\npairs of pins, and for each edge .u; /ETB/2E,w eh a v eaw e i g h t w.u;/ETB/ specifying\nthe cost (amount of wire needed) to connect uand/ETB. W et h e nw i s ht o\ufb01 n da n\nacyclic subset T/DC2Ethat connects all of the vertices and whose total weight\nw.T/DX\n.u;/ETB/ 2Tw.u;/ETB/\nis minimized. Since Tis acyclic and connects all of the vertices, it must form a tree,\nwhich we call a spanning tree since it \u201cspans\u201d the graph G. We call the problem of\ndetermining the tree Ttheminimum-spanning-tree problem .1Figure 23.1 shows\nan example of a connected graph and a minimum spanning tree.\nIn this chapter, we shall examine two algorithms for solving the minimum-\nspanning-tree problem: Kruskal\u2019s algorithm and Prim\u2019s algorithm. We can easilymake each of them run in time O.E lgV/using ordinary binary heaps. By using\nFibonacci heaps, Prim\u2019s algorithm runs in time O.ECVlgV/, which improves\nover the binary-heap implementation if jVjis much smaller than jEj.\nThe two algorithms are greedy algorithms, as described in Chapter 16. Each\nstep of a greedy algorithm must make one of several possible choices. The greedystrategy advocates making the choice that is the best at the moment. Such a strat-egy does not generally guarantee that it will always \ufb01nd globally optimal solutions\n1The phrase \u201cminimum spanning tree\u201d is a shortened form of the phrase \u201cminimum-weight spanning\ntree.\u201d We are not, for example, minimizing the number of edges in T, since all spanning trees have\nexactlyjVj/NUL1edges by Theorem B.2.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "645": {"page_number": 646, "page_information": "23.1 Growing a minimum spanning tree 625\nb\na\nhc\ngid\nfe4\n81187\n9\n1014 4\n2 12\n76\nFigure 23.1 A minimum spanning tree for a connected graph. The weights on edges are shown,\nand the edges in a minimum spanning tree are shaded. The total weight of the tree shown is 37.T h i s\nminimum spanning tree is not unique: removing the edge .b; c/ and replacing it with the edge .a; h/\nyields another spanning tree with weight 37.\nto problems. For the minimum-spanning-tree problem, however, we can prove that\ncertain greedy strategies do yield a spanning tree with minimum weight. Althoughyou can read this chapter independently of Chapter 16, the greedy methods pre-sented here are a classic application of the theoretical notions introduced there.\nSection 23.1 introduces a \u201cgeneric\u201d minimum-spanning-tree method that grows\na spanning tree by adding one edge at a time. Section 23.2 gives two algorithmsthat implement the generic method. The \ufb01rst algorithm, due to Kruskal, is similarto the connected-components algorithm from Section 21.1. The second, due toPrim, resembles Dijkstra\u2019s shortest-paths algorithm (Section 24.3).\nBecause a tree is a type of graph, in order to be precise we must de\ufb01ne a tree in\nterms of not just its edges, but its vertices as well. Although this chapter focuses\non trees in terms of their edges, we shall operate with the understanding that the\nvertices of a tree Tare those that some edge of Tis incident on.\n23.1 Growing a minimum spanning tree\nAssume that we have a connected, undirected graph GD.V; E/ with a weight\nfunction wWE! R, and we wish to \ufb01nd a minimum spanning tree for G.T h e\ntwo algorithms we consider in this chapter use a greedy approach to the problem,although they differ in how they apply this approach.\nThis greedy strategy is captured by the following generic method, which grows\nthe minimum spanning tree one edge at a time. The generic method manages a set\nof edges A, maintaining the following loop invariant:\nPrior to each iteration, Ais a subset of some minimum spanning tree.\nAt each step, we determine an edge .u; /ETB/ that we can add to Awithout violating\nthis invariant, in the sense that A[f.u; /ETB/gis also a subset of a minimum spanning", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "646": {"page_number": 647, "page_information": "626 Chapter 23 Minimum Spanning Trees\ntree. We call such an edge a safe edge forA, since we can add it safely to Awhile\nmaintaining the invariant.\nGENERIC -MST .G; w/\n1AD;\n2while Adoes not form a spanning tree\n3 \ufb01nd an edge .u; /ETB/ that is safe for A\n4 ADA[f.u; /ETB/g\n5return A\nWe use the loop invariant as follows:\nInitialization: After line 1, the set Atrivially satis\ufb01es the loop invariant.\nMaintenance: The loop in lines 2\u20134 maintains the invariant by adding only safe\nedges.\nTermination: All edges added to Aare in a minimum spanning tree, and so the\nsetAreturned in line 5 must be a minimum spanning tree.\nThe tricky part is, of course, \ufb01nding a safe edge in line 3. One must exist, since\nwhen line 3 is executed, the invariant dictates that there is a spanning tree Tsuch\nthatA/DC2T. Within the while loop body, Amust be a proper subset of T,a n d\ntherefore there must be an edge .u; /ETB/2Tsuch that .u; /ETB/62Aand.u; /ETB/ is safe\nforA.\nIn the remainder of this section, we provide a rule (Theorem 23.1) for recogniz-\ning safe edges. The next section describes two algorithms that use this rule to \ufb01ndsafe edges ef\ufb01ciently.\nWe \ufb01rst need some de\ufb01nitions. A cut.S; V/NULS/of an undirected graph GD\n.V; E/ is a partition of V. Figure 23.2 illustrates this notion. We say that an edge\n.u; /ETB/2Ecrosses the cut .S; V/NULS/if one of its endpoints is in Sand the other\nis inV/NULS. We say that a cut respects a setA\nof edges if no edge in Acrosses the\ncut. An edge is a light edge crossing a cut if its weight is the minimum of any edge\ncrossing the cut. Note that there can be more than one light edge crossing a cut inthe case of ties. More generally, we say that an edge is a light edge satisfying a\ngiven property if its weight is the minimum of any edge satisfying the property.\nOur rule for recognizing safe edges is given by the following theorem.\nTheorem 23.1\nLetGD.V; E/ be a connected, undirected graph with a real-valued weight func-\ntionwde\ufb01ned on E.L e t Abe a subset of Ethat is included in some minimum\nspanning tree for G,l e t.S; V/NULS/be any cut of Gthat respects A,a n dl e t .u; /ETB/\nbe a light edge crossing .S; V/NULS/. Then, edge .u; /ETB/ is safe for A.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "647": {"page_number": 648, "page_information": "23.1 Growing a minimum spanning tree 627\nb\na\nhc\ngid\nfe4\n81187\n9\n10144\n2 12\n76a\nb\nd\neh\ni\ng\nc\nf8\n11\n8\n7\n14\n10467\n4\n921\n2\nS\n(a) (b)V \u2013 SS\nV \u2013 SS\nV \u2013 S\nFigure 23.2 Two ways of viewing a cut .S; V/NULS/of the graph from Figure 23.1. (a)Black\nvertices are in the set S, and white vertices are in V/NULS. The edges crossing the cut are those\nconnecting white vertices with black vertices. The edge .d; c/ is the unique light edge crossing the\ncut. A subset Aof the edges is shaded; note that the cut .S; V/NULS/respects A, since no edge of A\ncrosses the cut. (b)The same graph with the vertices in the set Son the left and the vertices in the\nsetV/NULSon the right. An edge crosses the cut if it connects a vertex on the left with a vertex on the\nright.\nProof LetTbe a minimum spanning tree that includes A, and assume that T\ndoes not contain the light edge .u; /ETB/ , since if it does, we are done. We shall\nconstruct another minimum spanning tree T0that includes A[f.u; /ETB/gby using a\ncut-and-paste technique, thereby showing that .u; /ETB/ is a safe edge for A.\nThe edge .u; /ETB/ forms a cycle with the edges on the simple path pfrom u\nto/ETBinT, as Figure 23.3 illustrates. Since uand/ETBare on opposite sides of the\ncut.S; V/NULS/, at least one edge in Tlies on the simple path pand also crosses\nthe cut. Let .x; y/ be any such edge. The edge .x; y/ is not in A, because the cut\nrespects A.S i n c e .x; y/ is on the unique simple path from uto/ETBinT,r e m o v -\ning.x; y/ breaks Tinto two components. Adding .u; /ETB/ reconnects them to form\na new spanning tree T0DT/NULf.x; y/g[f.u; /ETB/g.\nWe next show that T0is a minimum spanning tree. Since .u; /ETB/ is a light edge\ncrossing .S; V/NULS/and.x; y/ also crosses this cut, w.u;/ETB//DC4w.x;y/ . Therefore,\nw.T0/Dw.T//NULw.x;y/Cw.u;/ETB/\n/DC4w.T/ :", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "648": {"page_number": 649, "page_information": "628 Chapter 23 Minimum Spanning Trees\ny\nvux\np\nFigure 23.3 The proof of Theorem 23.1. Black vertices are in S, and white vertices are in V/NULS.\nThe edges in the minimum spanning tree Tare shown, but the edges in the graph Gare not. The\nedges in Aare shaded, and .u; /ETB/ is a light edge crossing the cut .S; V/NULS/. The edge .x; y/ is\nan edge on the unique simple path pfrom uto/ETBinT. To form a minimum spanning tree T0that\ncontains .u; /ETB/ , remove the edge .x; y/ from Tand add the edge .u; /ETB/ .\nButTis a minimum spanning tree, so that w.T//DC4w.T0/; thus, T0must be a\nminimum spanning tree also.\nIt remains to show that .u; /ETB/ is actually a safe edge for A.W e h a v e A/DC2T0,\nsince A/DC2Tand.x; y/62A; thus, A[f.u; /ETB/g/DC2T0. Consequently, since T0is a\nminimum spanning tree, .u; /ETB/ is safe for A.\nTheorem 23.1 gives us a better understanding of the workings of the G ENERIC -\nMST method on a connected graph GD.V; E/ . As the method proceeds, the\nsetAis always acyclic; otherwise, a minimum spanning tree including Awould\ncontain a cycle, which is a contradiction. At any point in the execution, the graphG\nAD.V; A/ is a forest, and each of the connected components of GAis a tree.\n(Some of the trees may contain just one vertex, as is the case, for example, whenthe method begins: Ais empty and the forest contains jVjtrees, one for each\nvertex.) Moreover, any safe edge .u; /ETB/ forAconnects distinct components of G\nA,\nsince A[f.u; /ETB/gmust be acyclic.\nThewhile loop in lines 2\u20134 of G ENERIC -MST executesjVj/NUL1times because\nit \ufb01nds one of thejVj/NUL1edges of a minimum spanning tree in each iteration.\nInitially, when AD;,t h e r ea r ejVjtrees in GA, and each iteration reduces that\nnumber by 1. When the forest contains only a single tree, the method terminates.\nThe two algorithms in Section 23.2 use the following corollary to Theorem 23.1.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "649": {"page_number": 650, "page_information": "23.1 Growing a minimum spanning tree 629\nCorollary 23.2\nLetGD.V; E/ be a connected, undirected graph with a real-valued weight func-\ntionwde\ufb01ned on E.L e t Abe a subset of Ethat is included in some minimum\nspanning tree for G,a n dl e t CD.VC;EC/be a connected component (tree) in the\nforest GAD.V; A/ .I f.u; /ETB/ is a light edge connecting Cto some other component\ninGA,t h e n .u; /ETB/ is safe for A.\nProof The cut .VC;V/NULVC/respects A,a n d .u; /ETB/ is a light edge for this cut.\nTherefore, .u; /ETB/ is safe for A.\nExercises\n23.1-1\nLet.u; /ETB/ be a minimum-weight edge in a connected graph G. Show that .u; /ETB/\nbelongs to some minimum spanning tree of G.\n23.1-2\nProfessor Sabatier conjectures the following converse of Theorem 23.1. Let GD\n.V; E/ be a connected, undirected graph with a real-valued weight function wde-\n\ufb01ned on E.L e t Abe a subset of Ethat is included in some minimum spanning\ntree for G,l e t.S; V/NULS/be any cut of Gthat respects A,a n dl e t .u; /ETB/ be a safe\nedge for Acrossing .S; V/NULS/. Then, .u; /ETB/ is a light edge for the cut. Show that\nthe professor\u2019s conjecture is incorrect by giving a counterexample.\n23.1-3\nShow that if an edge .u; /ETB/ is contained in some minimum spanning tree, then it is\na light edge crossing some cut of the graph.\n23.1-4\nGive a simple example of a connected graph such that the set of edges f.u; /ETB/W\nthere exists a cut .S; V/NULS/such that .u; /ETB/ is a light edge crossing .S; V/NULS/g\ndoes not form a minimum spanning tree.\n23.1-5\nLetebe a maximum-weight edge on some cycle of connected graph GD.V; E/ .\nProve that there is a minimum spanning tree of G0D.V; E/NULfeg/that is also a\nminimum spanning tree of G. That is, there is a minimum spanning tree of Gthat\ndoes not include e.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "650": {"page_number": 651, "page_information": "630 Chapter 23 Minimum Spanning Trees\n23.1-6\nShow that a graph has a unique minimum spanning tree if, for every cut of thegraph, there is a unique light edge crossing the cut. Show that the converse is nottrue by giving a counterexample.\n23.1-7\nArgue that if all edge weights of a graph are positive, then any subset of edges thatconnects all vertices and has minimum total weight must be a tree. Give an exampleto show that the same conclusion does not follow if we allow some weights to be\nnonpositive.\n23.1-8\nLetTbe a minimum spanning tree of a graph G,a n dl e t Lbe the sorted list of the\nedge weights of T. Show that for any other minimum spanning tree T\n0ofG,t h e\nlistLis also the sorted list of edge weights of T0.\n23.1-9\nLetTbe a minimum spanning tree of a graph GD.V; E/ ,a n dl e t V0b eas u b s e t\nofV.L e t T0be the subgraph of Tinduced by V0,a n dl e t G0be the subgraph of G\ninduced by V0. Show that if T0is connected, then T0is a minimum spanning tree\nofG0.\n23.1-10\nGiven a graph Gand a minimum spanning tree T, suppose that we decrease the\nweight of one of the edges in T. Show that Tis still a minimum spanning tree\nforG. More formally, let Tbe a minimum spanning tree for Gwith edge weights\ngiven by weight function w. Choose one edge .x; y/2Tand a positive number k,\nand de\ufb01ne the weight function w0by\nw0.u; /ETB/D(\nw.u;/ETB/ if.u; /ETB/\u00a4.x; y/ ;\nw.x;y//NULkif.u; /ETB/D.x; y/ :\nShow that Tis a minimum spanning tree for Gwith edge weights given by w0.\n23.1-11 ?\nGiven a graph Gand a minimum spanning tree T, suppose that we decrease the\nweight of one of the edges not in T. Give an algorithm for \ufb01nding the minimum\nspanning tree in the modi\ufb01ed graph.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "651": {"page_number": 652, "page_information": "23.2 The algorithms of Kruskal and Prim 631\n23.2 The algorithms of Kruskal and Prim\nThe two minimum-spanning-tree algorithms described in this section elaborate on\nthe generic method. They each use a speci\ufb01c rule to determine a safe edge in line 3of G\nENERIC -MST. In Kruskal\u2019s algorithm, the set Ais a forest whose vertices are\nall those of the given graph. The safe edge added to Ais always a least-weight\nedge in the graph that connects two distinct components. In Prim\u2019s algorithm, the\nsetAforms a single tree. The safe edge added to Ais always a least-weight edge\nconnecting the tree to a vertex not in the tree.\nKruskal\u2019s algorithm\nKruskal\u2019s algorithm \ufb01nds a safe edge to add to the growing forest by \ufb01nding, of all\nthe edges that connect any two trees in the forest, an edge .u; /ETB/ of least weight.\nLetC1andC2denote the two trees that are connected by .u; /ETB/ .S i n c e .u; /ETB/ must\nbe a light edge connecting C1to some other tree, Corollary 23.2 implies that .u; /ETB/\ni sas a f ee d g ef o r C1. Kruskal\u2019s algorithm quali\ufb01es as a greedy algorithm because\nat each step it adds to the forest an edge of least possible weight.\nOur implementation of Kruskal\u2019s algorithm is like the algorithm to compute\nconnected components from Section 21.1. It uses a disjoint-set data structure to\nmaintain several disjoint sets of elements. Each set contains the vertices in one tree\nof the current forest. The operation F IND-SET.u/returns a representative element\nfrom the set that contains u. Thus, we can determine whether two vertices uand/ETB\nbelong to the same tree by testing whether F IND-SET.u/equals F IND-SET./ETB/.T o\ncombine trees, Kruskal\u2019s algorithm calls the U NION procedure.\nMST-K RUSKAL .G; w/\n1AD;\n2foreach vertex /ETB2G:V\n3M AKE-SET./ETB/\n4 sort the edges of G:Einto nondecreasing order by weight w\n5foreach edge .u; /ETB/2G:E, taken in nondecreasing order by weight\n6 ifFIND-SET.u/\u00a4FIND-SET./ETB/\n7 ADA[f.u; /ETB/g\n8U NION .u; /ETB/\n9return A\nFigure 23.4 shows how Kruskal\u2019s algorithm works. Lines 1\u20133 initialize the set A\nto the empty set and create jVjtrees, one containing each vertex. The forloop in\nlines 5\u20138 examines edges in order of weight, from lowest to highest. The loop", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "652": {"page_number": 653, "page_information": "632 Chapter 23 Minimum Spanning Trees\nb\na\nhc\ngid\nfe4\n81187\n9\n1014 4\n2 12\n76(a) (b)\n(c) (d)\n(e)\n(g)(f)\n(h)b\na\nhc\ngid\nfe4\n81187\n9\n1014 4\n2 1762\nb\na\nhc\ngid\nfe4\n81187\n9\n1014 4\n2 1762b\na\nhc\ngid\nfe4\n81187\n9\n1014 4\n2 1762\nb\na\nhc\ngid\nfe4\n81187\n9\n1014 4\n2 1762b\na\nhc\ngid\nfe4\n81187\n9\n1014 4\n2 1762\nb\na\nhc\ngid\nfe4\n81187\n9\n1014 4\n2 1762b\na\nhc\ngid\nfe4\n81187\n9\n1014 4\n2 1762\nFigure 23.4 The execution of Kruskal\u2019s algorithm on the graph from Figure 23.1. Shaded edges\nbelong to the forest Abeing grown. The algorithm considers each edge in sorted order by weight.\nAn arrow points to the edge under consideration at each step of the algorithm. If the edge joins two\ndistinct trees in the forest, it is added to the forest, thereby merging the two trees.\nchecks, for each edge .u; /ETB/ , whether the endpoints uand/ETBbelong to the same\ntree. If they do, then the edge .u; /ETB/ cannot be added to the forest without creating\na cycle, and the edge is discarded. Otherwise, the two vertices belong to differenttrees. In this case, line 7 adds the edge .u; /ETB/ toA, and line 8 merges the vertices\nin the two trees.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "653": {"page_number": 654, "page_information": "23.2 The algorithms of Kruskal and Prim 633\n(i) (j)\n(k) (l)\n(n) (m)b\na\nhc\ngid\nfe4\n81187\n9\n1014 4\n2 176b\na\nhc\ngid\nfe4\n81187\n9\n1014 4\n2 1762 2\nb\na\nhc\ngid\nfe4\n81187\n9\n1014 4\n2 1762b\na\nhc\ngid\nfe4\n81187\n9\n1014 4\n2 176\nb\na\nhc\ngid\nfe4\n81187\n9\n1014 4\n2 176b\na\nhc\ngid\nfe4\n81187\n9\n1014 4\n2 17622\n2\nFigure 23.4, continued Further steps in the execution of Kruskal\u2019s algorithm.\nThe running time of Kruskal\u2019s algorithm for a graph GD.V; E/ depends\non how we implement the disjoint-set data structure. We assume that we usethe disjoint-set-forest implementation of Section 21.3 with the union-by-rank andpath-compression heuristics, since it is the asymptotically fastest implementationknown. Initializing the set Ain line 1 takes O.1/ time, and the time to sort the\nedges in line 4 is O.E lgE/. (We will account for the cost of the jVjM\nAKE-SET\noperations in the forloop of lines 2\u20133 in a moment.) The forloop of lines 5\u20138\nperforms O.E/ FIND-SETand U NION operations on the disjoint-set forest. Along\nwith thejVjMAKE-SEToperations, these take a total of O..VCE/ \u02db.V // time,\nwhere \u02dbis the very slowly growing function de\ufb01ned in Section 21.4. Because we\nassume that Gis connected, we have jEj/NAKjVj/NUL1, and so the disjoint-set opera-\ntions take O.E\u02db.V // time. Moreover, since \u02db.jVj/DO.lgV/DO.lgE/,t h et o -\ntal running time of Kruskal\u2019s algorithm is O.E lgE/. Observing thatjEj<jVj2,\nwe have lgjEjDO.lgV/, and so we can restate the running time of Kruskal\u2019s\nalgorithm as O.E lgV/.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "654": {"page_number": 655, "page_information": "634 Chapter 23 Minimum Spanning Trees\nPrim\u2019s algorithm\nLike Kruskal\u2019s algorithm, Prim\u2019s algorithm is a special case of the generic min-\nimum-spanning-tree method from Section 23.1. Prim\u2019s algorithm operates muchlike Dijkstra\u2019s algorithm for \ufb01nding shortest paths in a graph, which we shall see inSection 24.3. Prim\u2019s algorithm has the property that the edges in the set Aalways\nform a single tree. As Figure 23.5 shows, the tree starts from an arbitrary rootvertex rand grows until the tree spans all the vertices in V. Each step adds to the\ntreeAa light edge that connects Ato an isolated vertex\u2014one on which no edge\nofAis incident. By Corollary 23.2, this rule adds only edges that are safe for A;\ntherefore, when the algorithm terminates, the edges in Aform a minimum spanning\ntree. This strategy quali\ufb01es as greedy since at each step it adds to the tree an edgethat contributes the minimum amount possible to the tree\u2019s weight.\nIn order to implement Prim\u2019s algorithm ef\ufb01ciently, we need a fast way to select\na new edge to add to the tree formed by the edges in A. In the pseudocode below,\nthe connected graph Gand the root rof the minimum spanning tree to be grown\nare inputs to the algorithm. During execution of the algorithm, all vertices thatarenotin the tree reside in a min-priority queue Qbased on a keyattribute. For\neach vertex /ETB, the attribute /ETB:keyis the minimum weight of any edge connecting /ETB\nto a vertex in the tree; by convention, /ETB:keyD1 if there is no such edge. The\nattribute /ETB:/EMnames the parent of /ETBin the tree. The algorithm implicitly maintains\nthe set Afrom G\nENERIC -MST as\nADf./ETB; /ETB:/EM/W/ETB2V/NULfrg/NULQg:\nWhen the algorithm terminates, the min-priority queue Qis empty; the minimum\nspanning tree AforGis thus\nADf./ETB; /ETB:/EM/W/ETB2V/NULfrgg:\nMST-P RIM. G ;w;r/\n1foreachu2G:V\n2 u:keyD1\n3 u:/EMDNIL\n4r:keyD0\n5QDG:V\n6while Q\u00a4;\n7 uDEXTRACT -MIN.Q/\n8 foreach/ETB2G:Adj\u0152u/c141\n9 if/ETB2Qandw.u;/ETB/ < /ETB: key\n10 /ETB:/EMDu\n11 /ETB:keyDw.u;/ETB/", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "655": {"page_number": 656, "page_information": "23.2 The algorithms of Kruskal and Prim 635\n(a) (b)\n(c) (d)\n(e) (f)\n(g) (h)\n(i)b\na\nhc\ngid\nfe4\n81187\n9\n1014 4\n2 12\n76b\na\nhc\ngid\nfe4\n81187\n9\n1014 4\n2 12\n76\nb\na\nhc\ngid\nfe4\n81187\n9\n1014 4\n2 12\n76b\na\nhc\ngid\nfe4\n81187\n9\n1014 4\n2 1762\nb\na\nhc\ngid\nfe4\n81187\n9\n1014 4\n2 1762b\na\nhc\ngid\nfe4\n81187\n9\n1014 4\n2 1762\nb\na\nhc\ngid\nfe4\n81187\n9\n1014 4\n2 1762b\na\nhc\ngid\nfe4\n81187\n9\n1014 4\n2 1762\nb\na\nhc\ngid\nfe4\n81187\n9\n1014 4\n2 1762\nFigure 23.5 The execution of Prim\u2019s algorithm on the graph from Figure 23.1. The root vertex\nisa. Shaded edges are in the tree being grown, and black vertices are in the tree. At each step of\nthe algorithm, the vertices in the tree determine a cut of the graph, and a light edge crossing the cut\nis added to the tree. In the second step, for example, the algorithm has a choice of adding either\nedge .b; c/ or edge .a; h/ to the tree since both are light edges crossing the cut.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "656": {"page_number": 657, "page_information": "636 Chapter 23 Minimum Spanning Trees\nFigure 23.5 shows how Prim\u2019s algorithm works. Lines 1\u20135 set the key of each\nvertex to1(except for the root r, whose key is set to 0so that it will be the\n\ufb01rst vertex processed), set the parent of each vertex to NIL, and initialize the min-\npriority queue Qto contain all the vertices. The algorithm maintains the following\nthree-part loop invariant:\nPrior to each iteration of the while loop of lines 6\u201311,\n1.ADf./ETB; /ETB:/EM/W/ETB2V/NULfrg/NULQg.\n2. The vertices already placed into the minimum spanning tree are those in\nV/NULQ.\n3. For all vertices /ETB2Q,i f/ETB:/EM\u00a4NIL,t h e n /ETB:key<1and/ETB:keyis\nthe weight of a light edge ./ETB; /ETB:/EM/ connecting /ETBto some vertex already\nplaced into the minimum spanning tree.\nLine 7 identi\ufb01es a vertex u2Qincident on a light edge that crosses the cut\n.V/NULQ; Q/ (with the exception of the \ufb01rst iteration, in which uDrdue to line 4).\nRemoving ufrom the set Qadds it to the set V/NULQof vertices in the tree, thus\nadding .u; u:/EM/ toA.T h e forloop of lines 8\u201311 updates the keyand/EMattributes\nof every vertex /ETBadjacent to ubut not in the tree, thereby maintaining the third\npart of the loop invariant.\nThe running time of Prim\u2019s algorithm depends on how we implement the min-\npriority queue Q. If we implement Qas a binary min-heap (see Chapter 6), we\ncan use the B UILD -MIN-HEAP procedure to perform lines 1\u20135 in O.V / time. The\nbody of the while loop executesjVjtimes, and since each E XTRACT -MINopera-\ntion takes O.lgV/time, the total time for all calls to E XTRACT -MINisO.V lgV/.\nTheforloop in lines 8\u201311 executes O.E/ times altogether, since the sum of the\nlengths of all adjacency lists is 2jEj. Within the forloop, we can implement the\ntest for membership in Qin line 9 in constant time by keeping a bit for each vertex\nthat tells whether or not it is in Q, and updating the bit when the vertex is removed\nfrom Q. The assignment in line 11 involves an implicit D ECREASE -KEYopera-\ntion on the min-heap, which a binary min-heap supports in O.lgV/time. Thus,\nthe total time for Prim\u2019s algorithm is O.V lgVCElgV/DO.E lgV/,w h i c hi s\nasymptotically the same as for our implementation of Kruskal\u2019s algorithm.\nWe can improve the asymptotic running time of Prim\u2019s algorithm by using Fi-\nbonacci heaps. Chapter 19 shows that if a Fibonacci heap holds jVjelements, an\nEXTRACT -MINoperation takes O.lgV/amortized time and a D ECREASE -KEY\noperation (to implement line 11) takes O.1/ amortized time. Therefore, if we use a\nFibonacci heap to implement the min-priority queue Q, the running time of Prim\u2019s\nalgorithm improves to O.ECVlgV/.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "657": {"page_number": 658, "page_information": "23.2 The algorithms of Kruskal and Prim 637\nExercises\n23.2-1\nKruskal\u2019s algorithm can return different spanning trees for the same input graph G,\ndepending on how it breaks ties when the edges are sorted into order. Show that\nfor each minimum spanning tree TofG, there is a way to sort the edges of Gin\nKruskal\u2019s algorithm so that the algorithm returns T.\n23.2-2\nSuppose that we represent the graph GD.V; E/ as an adjacency matrix. Give a\nsimple implementation of Prim\u2019s algorithm for this case that runs in O.V2/time.\n23.2-3\nFor a sparse graph GD.V; E/ ,w h e r ejEjD\u201a.V / , is the implementation of\nPrim\u2019s algorithm with a Fibonacci heap asymptotically faster than the binary-heapimplementation? What about for a dense graph, where jEjD\u201a.V\n2/?H o w\nmust the sizesjEjandjVjbe related for the Fibonacci-heap implementation to\nbe asymptotically faster than the binary-heap implementation?\n23.2-4\nSuppose that all edge weights in a graph are integers in the range from 1tojVj.\nHow fast can you make Kruskal\u2019s algorithm run? What if the edge weights areintegers in the range from 1toWfor some constant W?\n23.2-5\nSuppose that all edge weights in a graph are integers in the range from 1tojVj.\nHow fast can you make Prim\u2019s algorithm run? What if the edge weights are integersin the range from 1toWfor some constant W?\n23.2-6 ?\nSuppose that the edge weights in a graph are uniformly distributed over the half-\nopen interval \u01520; 1/ . Which algorithm, Kruskal\u2019s or Prim\u2019s, can you make run\nfaster?\n23.2-7 ?\nSuppose that a graph Ghas a minimum spanning tree already computed. How\nquickly can we update the minimum spanning tree if we add a new vertex andincident edges to G?\n23.2-8\nProfessor Borden proposes a new divide-and-conquer algorithm for computing\nminimum spanning trees, which goes as follows. Given a graph GD.V; E/ ,\npartition the set Vof vertices into two sets V\n1andV2such thatjV1jandjV2jdiffer", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "658": {"page_number": 659, "page_information": "638 Chapter 23 Minimum Spanning Trees\nby at most 1.L e t E1be the set of edges that are incident only on vertices in V1,a n d\nletE2be the set of edges that are incident only on vertices in V2. Recursively solve\na minimum-spanning-tree problem on each of the two subgraphs G1D.V1;E1/\nandG2D.V2;E2/. Finally, select the minimum-weight edge in Ethat crosses the\ncut.V1;V2/, and use this edge to unite the resulting two minimum spanning trees\ninto a single spanning tree.\nEither argue that the algorithm correctly computes a minimum spanning tree\nofG, or provide an example for which the algorithm fails.\nProblems\n23-1 Second-best minimum spanning tree\nLetGD.V; E/ be an undirected, connected graph whose weight function is\nwWE!R, and suppose thatjEj/NAKjVjand all edge weights are distinct.\nWe de\ufb01ne a second-best minimum spanning tree as follows. Let Tbe the set\nof all spanning trees of G,a n dl e t T0be a minimum spanning tree of G.T h e n\nasecond-best minimum spanning tree is a spanning tree Tsuch that w.T/D\nmin T002T/NULfT0gfw.T00/g.\na.Show that the minimum spanning tree is unique, but that the second-best mini-\nmum spanning tree need not be unique.\nb.LetTbe the minimum spanning tree of G. Prove that Gcontains edges\n.u; /ETB/2Tand.x; y/62Tsuch that T/NULf.u; /ETB/g[f.x; y/gis a second-best\nminimum spanning tree of G.\nc.LetTbe a spanning tree of Gand, for any two vertices u; /ETB2V,l e tmax\u0152u; /ETB/c141\ndenote an edge of maximum weight on the unique simple path between uand/ETB\ninT. Describe an O.V2/-time algorithm that, given T, computes max\u0152u; /ETB/c141 for\nallu; /ETB2V.\nd.Give an ef\ufb01cient algorithm to compute the second-best minimum spanning tree\nofG.\n23-2 Minimum spanning tree in sparse graphs\nFor a very sparse connected graph GD.V; E/ , we can further improve upon the\nO.ECVlgV/running time of Prim\u2019s algorithm with Fibonacci heaps by prepro-\ncessing Gto decrease the number of vertices before running Prim\u2019s algorithm. In\nparticular, we choose, for each vertex u, the minimum-weight edge .u; /ETB/ incident\nonu, and we put .u; /ETB/ into the minimum spanning tree under construction. We", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "659": {"page_number": 660, "page_information": "Problems for Chapter 23 639\nthen contract all chosen edges (see Section B.4). Rather than contracting these\nedges one at a time, we \ufb01rst identify sets of vertices that are united into the samenew vertex. Then we create the graph that would have resulted from contractingthese edges one at a time, but we do so by \u201crenaming\u201d edges according to the setsinto which their endpoints were placed. Several edges from the original graph maybe renamed the same as each other. In such a case, only one edge results, and itsweight is the minimum of the weights of the corresponding original edges.\nInitially, we set the minimum spanning tree Tbeing constructed to be empty,\nand for each edge .u; /ETB/2E, we initialize the attributes .u; /ETB/: origD.u; /ETB/\nand.u; /ETB/: cDw.u;/ETB/ .W e u s e t h e orig attribute to reference the edge from the\ninitial graph that is associated with an edge in the contracted graph. The cattribute\nholds the weight of an edge, and as edges are contracted, we update it according tothe above scheme for choosing edge weights. The procedure MST-R\nEDUCE takes\ninputs GandT, and it returns a contracted graph G0with updated attributes orig0\nandc0. The procedure also accumulates edges of Ginto the minimum spanning\ntreeT.\nMST-R EDUCE .G; T /\n1foreach/ETB2G:V\n2 /ETB:markDFALSE\n3M AKE-SET./ETB/\n4foreachu2G:V\n5 ifu:mark ==FALSE\n6 choose /ETB2G:Adj\u0152u/c141such that .u; /ETB/: cis minimized\n7U NION .u; /ETB/\n8 TDT[f.u; /ETB/: origg\n9 u:markD/ETB:markDTRUE\n10G0:VDfFIND-SET./ETB/W/ETB2G:Vg\n11G0:ED;\n12foreach.x; y/2G:E\n13 uDFIND-SET.x/\n14 /ETBDFIND-SET.y/\n15 if.u; /ETB/62G0:E\n16 G0:EDG0:E[f.u; /ETB/g\n17 .u; /ETB/: orig0D.x; y/: orig\n18 .u; /ETB/:c0D.x; y/: c\n19 else if .x; y/: c<. u ;/ETB / : c0\n20 .u; /ETB/: orig0D.x; y/: orig\n21 .u; /ETB/:c0D.x; y/: c\n22 construct adjacency lists G0:AdjforG0\n23return G0andT", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "660": {"page_number": 661, "page_information": "640 Chapter 23 Minimum Spanning Trees\na.LetTbe the set of edges returned by MST-R EDUCE ,a n dl e t Abe the minimum\nspanning tree of the graph G0formed by the call MST-P RIM.G0;c0;r/,w h e r e c0\nis the weight attribute on the edges of G0:Eandris any vertex in G0:V. Prove\nthatT[f.x; y/: orig0W.x; y/2Agis a minimum spanning tree of G.\nb.Argue thatjG0:Vj/DC4jVj=2.\nc.Show how to implement MST-R EDUCE so that it runs in O.E/ time. ( Hint:\nUse simple data structures.)\nd.Suppose that we run kphases of MST-R EDUCE , using the output G0produced\nby one phase as the input Gto the next phase and accumulating edges in T.\nArgue that the overall running time of the kphases is O.kE/ .\ne.Suppose that after running kphases of MST-R EDUCE , as in part (d), we run\nPrim\u2019s algorithm by calling MST-P RIM.G0;c0;r/,w h e r e G0, with weight at-\ntribute c0, is returned by the last phase and ris any vertex in G0:V.S h o wh o w\nto pick kso that the overall running time is O.E lg lgV/. Argue that your\nchoice of kminimizes the overall asymptotic running time.\nf.F o rw h a tv a l u e so fjEj(in terms ofjVj) does Prim\u2019s algorithm with preprocess-\ning asymptotically beat Prim\u2019s algorithm without preprocessing?\n23-3 Bottleneck spanning tree\nAbottleneck spanning tree Tof an undirected graph Gis a spanning tree of G\nwhose largest edge weight is minimum over all spanning trees of G. We say that\nthe value of the bottleneck spanning tree is the weight of the maximum-weightedge in T.\na.Argue that a minimum spanning tree is a bottleneck spanning tree.\nPart (a) shows that \ufb01nding a bottleneck spanning tree is no harder than \ufb01nding\na minimum spanning tree. In the remaining parts, we will show how to \ufb01nd abottleneck spanning tree in linear time.\nb.Give a linear-time algorithm that given a graph Gand an integer b, determines\nwhether the value of the bottleneck spanning tree is at most b.\nc.Use your algorithm for part (b) as a subroutine in a linear-time algorithm for\nthe bottleneck-spanning-tree problem. ( Hint: You may want to use a subroutine\nthat contracts sets of edges, as in the MST-R\nEDUCE procedure described in\nProblem 23-2.)", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "661": {"page_number": 662, "page_information": "Notes for Chapter 23 641\n23-4 Alternative minimum-spanning-tree algorithms\nIn this problem, we give pseudocode for three different algorithms. Each one takesa connected graph and a weight function as input and returns a set of edges T.F o r\neach algorithm, either prove that Tis a minimum spanning tree or prove that Tis\nnot a minimum spanning tree. Also describe the most ef\ufb01cient implementation ofeach algorithm, whether or not it computes a minimum spanning tree.\na.M\nAYBE -MST-A .G; w/\n1 sort the edges into nonincreasing order of edge weights w\n2TDE\n3foreach edge e, taken in nonincreasing order by weight\n4 ifT/NULfegis a connected graph\n5 TDT/NULfeg\n6return T\nb.MAYBE -MST-B .G; w/\n1TD;\n2foreach edge e, taken in arbitrary order\n3 ifT[feghas no cycles\n4 TDT[feg\n5return T\nc.MAYBE -MST-C .G; w/\n1TD;\n2foreach edge e, taken in arbitrary order\n3 TDT[feg\n4 ifThas a cycle c\n5l e t e0be a maximum-weight edge on c\n6 TDT/NULfe0g\n7return T\nChapter notes\nTarjan [330] surveys the minimum-spanning-tree problem and provides excellent\nadvanced material. Graham and Hell [151] compiled a history of the minimum-spanning-tree problem.\nTarjan attributes the \ufb01rst minimum-spanning-tree algorithm to a 1926 paper by\nO. Bor\u02d9 uvka. Bor\u02d9 uvka\u2019s algorithm consists of running O.lgV/iterations of the", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "662": {"page_number": 663, "page_information": "642 Chapter 23 Minimum Spanning Trees\nprocedure MST-R EDUCE described in Problem 23-2. Kruskal\u2019s algorithm was\nreported by Kruskal [222] in 1956. The algorithm commonly known as Prim\u2019salgorithm was indeed invented by Prim [285], but it was also invented earlier byV. Jarn\u00b4 \u0131k in 1930.\nThe reason underlying why greedy algorithms are effective at \ufb01nding minimum\nspanning trees is that the set of forests of a graph forms a graphic matroid. (SeeSection 16.4.)\nWhenjEjD/DEL.V lgV/, Prim\u2019s algorithm, implemented with Fibonacci heaps,\nruns in O.E/ time. For sparser graphs, using a combination of the ideas from\nPrim\u2019s algorithm, Kruskal\u2019s algorithm, and Bor\u02d9 uvka\u2019s algorithm, together with ad-\nvanced data structures, Fredman and Tarjan [114] give an algorithm that runs inO.E lg\n/ETXV/time. Gabow, Galil, Spencer, and Tarjan [120] improved this algo-\nrithm to run in O.E lg lg/ETXV/time. Chazelle [60] gives an algorithm that runs\ninO.Ey\u02db.E;V // time, wherey\u02db.E;V / is the functional inverse of Ackermann\u2019s\nfunction. (See the chapter notes for Chapter 21 for a brief discussion of Acker-\nmann\u2019s function and its inverse.) Unlike previous minimum-spanning-tree algo-\nrithms, Chazelle\u2019s algorithm does not follow the greedy method.\nA related problem is spanning-tree veri\ufb01cation , in which we are given a graph\nGD.V; E/ and a tree T/DC2E, and we wish to determine whether Tis a minimum\nspanning tree of G. King [203] gives a linear-time algorithm to verify a spanning\ntree, building on earlier work of Koml\u00b4 os [215] and Dixon, Rauch, and Tarjan [90].\nThe above algorithms are all deterministic and fall into the comparison-based\nmodel described in Chapter 8. Karger, Klein, and Tarjan [195] give a randomized\nminimum-spanning-tree algorithm that runs in O.VCE/expected time. This\nalgorithm uses recursion in a manner similar to the linear-time selection algorithmin Section 9.3: a recursive call on an auxiliary problem identi\ufb01es a subset of theedges E\n0that cannot be in any minimum spanning tree. Another recursive call\nonE/NULE0then \ufb01nds the minimum spanning tree. The algorithm also uses ideas\nfrom Bor\u02d9 uvka\u2019s algorithm and King\u2019s algorithm for spanning-tree veri\ufb01cation.\nFredman and Willard [116] showed how to \ufb01nd a minimum spanning tree in\nO.VCE/time using a deterministic algorithm that is not comparison based. Their\nalgorithm assumes that the data are b-bit integers and that the computer memory\nconsists of addressable b-bit words.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "663": {"page_number": 664, "page_information": "24 Single-Source Shortest Paths\nProfessor Patrick wishes to \ufb01nd the shortest possible route from Phoenix to Indi-\nanapolis. Given a road map of the United States on which the distance betweeneach pair of adjacent intersections is marked, how can she determine this shortestroute?\nOne possible way would be to enumerate all the routes from Phoenix to Indi-\nanapolis, add up the distances on each route, and select the shortest. It is easy tosee, however, that even disallowing routes that contain cycles, Professor Patrickwould have to examine an enormous number of possibilities, most of which aresimply not worth considering. For example, a route from Phoenix to Indianapolisthat passes through Seattle is obviously a poor choice, because Seattle is severalhundred miles out of the way.\nIn this chapter and in Chapter 25, we show how to solve such problems ef-\n\ufb01ciently. In a shortest-paths problem , we are given a weighted, directed graph\nGD.V; E/ , with weight function wWE! Rmapping edges to real-valued\nweights. The weight w.p/ of path pDh/ETB\n0;/ETB1;:::;/ETB kiis the sum of the weights\nof its constituent edges:\nw.p/DkX\niD1w./ETB i/NUL1;/ETBi/:\nWe de\ufb01ne the shortest-path weight \u0131.u;/ETB/ from uto/ETBby\n\u0131.u;/ETB/D(\nminfw.p/Wup;/ETBgif there is a path from uto/ETB;\n1 otherwise :\nAshortest path from vertex uto vertex /ETBis then de\ufb01ned as any path pwith weight\nw.p/D\u0131.u;/ETB/ .\nIn the Phoenix-to-Indianapolis example, we can model the road map as a graph:\nvertices represent intersections, edges represent road segments between intersec-tions, and edge weights represent road distances. Our goal is to \ufb01nd a shortest pathfrom a given intersection in Phoenix to a given intersection in Indianapolis.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "664": {"page_number": 665, "page_information": "644 Chapter 24 Single-Source Shortest Paths\nEdge weights can represent metrics other than distances, such as time, cost,\npenalties, loss, or any other quantity that accumulates linearly along a path andthat we would want to minimize.\nThe breadth-\ufb01rst-search algorithm from Section 22.2 is a shortest-paths algo-\nrithm that works on unweighted graphs, that is, graphs in which each edge has unitweight. Because many of the concepts from breadth-\ufb01rst search arise in the studyof shortest paths in weighted graphs, you might want to review Section 22.2 beforeproceeding.\nVariants\nIn this chapter, we shall focus on the single-source shortest-paths problem :g i v e n\nag r a p h GD.V; E/ , we want to \ufb01nd a shortest path from a given source vertex\ns2Vto each vertex /ETB2V. The algorithm for the single-source problem can\nsolve many other problems, including the following variants.\nSingle-destination shortest-paths problem: Find a shortest path to a given des-\ntination vertex tfrom each vertex /ETB. By reversing the direction of each edge in\nthe graph, we can reduce this problem to a single-source problem.\nSingle-pair shortest-path problem: Find a shortest path from uto/ETBfor given\nvertices uand/ETB. If we solve the single-source problem with source vertex u,\nwe solve this problem also. Moreover, all known algorithms for this problemhave the same worst-case asymptotic running time as the best single-sourcealgorithms.\nAll-pairs shortest-paths problem: Find a shortest path from uto/ETBfor every pair\nof vertices uand/ETB. Although we can solve this problem by running a single-\nsource algorithm once from each vertex, we usually can solve it faster. Addi-tionally, its structure is interesting in its own right. Chapter 25 addresses theall-pairs problem in detail.\nOptimal substructure of a shortest path\nShortest-paths algorithms typically rely on the property that a shortest path be-\ntween two vertices contains other shortest paths within it. (The Edmonds-Karpmaximum-\ufb02ow algorithm in Chapter 26 also relies on this property.) Recallthat optimal substructure is one of the key indicators that dynamic programming(Chapter 15) and the greedy method (Chapter 16) might apply. Dijkstra\u2019s algo-rithm, which we shall see in Section 24.3, is a greedy algorithm, and the Floyd-Warshall algorithm, which \ufb01nds shortest paths between all pairs of vertices (seeSection 25.2), is a dynamic-programming algorithm. The following lemma states\nthe optimal-substructure property of shortest paths more precisely.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "665": {"page_number": 666, "page_information": "Chapter 24 Single-Source Shortest Paths 645\nLemma 24.1 (Subpaths of shortest paths are shortest paths)\nGiven a weighted, directed graph GD.V; E/ with weight function wWE!R,\nletpDh/ETB0;/ETB1;:::;/ETB kibe a shortest path from vertex /ETB0to vertex /ETBkand, for any\niandjsuch that 0/DC4i/DC4j/DC4k,l e tpijDh/ETBi;/ETBiC1;:::;/ETB jibe the subpath of p\nfrom vertex /ETBito vertex /ETBj. Then, pijis a shortest path from /ETBito/ETBj.\nProof If we decompose path pinto/ETB0p0i;/ETBipij;/ETBjpjk;/ETBk, then we have that\nw.p/Dw.p 0i/Cw.p ij/Cw.p jk/. Now, assume that there is a path p0\nijfrom /ETBi\nto/ETBjwith weight w.p0\nij/<w . p ij/. Then, /ETB0p0i;/ETBip0\nij;/ETBjpjk;/ETBkis a path from /ETB0\nto/ETBkwhose weight w.p 0i/Cw.p0\nij/Cw.p jk/is less than w.p/ , which contradicts\nthe assumption that pis a shortest path from /ETB0to/ETBk.\nNegative-weight edges\nSome instances of the single-source shortest-paths problem may include edges\nwhose weights are negative. If the graph GD.V; E/ contains no negative-\nweight cycles reachable from the source s, then for all /ETB2V, the shortest-path\nweight \u0131.s; /ETB/ remains well de\ufb01ned, even if it has a negative value. If the graph\ncontains a negative-weight cycle reachable from s, however, shortest-path weights\nare not well de\ufb01ned. No path from sto a vertex on the cycle can be a short-\nest path\u2014we can always \ufb01nd a path with lower weight by following the proposed\n\u201cshortest\u201d path and then traversing the negative-weight cycle. If there is a negative-weight cycle on some path from sto/ETB,w ed e \ufb01 n e \u0131.s; /ETB/D/NUL1 .\nFigure 24.1 illustrates the effect of negative weights and negative-weight cy-\ncles on shortest-path weights. Because there is only one path from stoa(the\npathhs; ai), we have \u0131.s;a/Dw.s;a/D3. Similarly, there is only one path\nfrom stob,a n ds o \u0131.s; b/Dw.s;a/Cw.a;b/D3C./NUL4/D/NUL1.T h e r e a r e\nin\ufb01nitely many paths from stoc:hs; ci,hs; c; d; ci,hs; c; d; c; d; ci, and so on.\nBecause the cyclehc;d;cihas weight 6C./NUL3/D3>0 , the shortest path from s\ntoc\nishs;ci, with weight \u0131.s; c/Dw.s;c/D5. Similarly, the shortest path from s\ntodishs;c;di, with weight \u0131.s; d/Dw.s;c/Cw.c;d/D11. Analogously, there\nare in\ufb01nitely many paths from stoe:hs; ei,hs; e; f; ei,hs; e; f; e; f; ei,a n ds o\non. Because the cycle he; f; eihas weight 3C./NUL6/D/NUL3<0 ,h o w e v e r ,t h e r e\nis no shortest path from stoe. By traversing the negative-weight cycle he; f; ei\narbitrarily many times, we can \ufb01nd paths from stoewith arbitrarily large negative\nweights, and so \u0131.s; e/D/NUL1 . Similarly, \u0131.s; f /D/NUL1 . Because gis reachable\nfrom f, we can also \ufb01nd paths with arbitrarily large negative weights from stog,\nand so \u0131.s; g/D/NUL1 . Vertices h,i,a n d jalso form a negative-weight cycle. They\nare not reachable from s, however, and so \u0131.s; h/D\u0131.s; i/D\u0131.s; j/D1 .", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "666": {"page_number": 667, "page_information": "646 Chapter 24 Single-Source Shortest Paths\n5c\n11d 6\n\u20133\n\u2013\u221ee\n\u2013\u221ef 3\n\u201363a\n\u20131b\n0s \u2013\u221eg\u20134\n53\n284\n7\u221eh\n\u221ei\n2\n\u221e\nj\u20138 3\nFigure 24.1 Negative edge weights in a directed graph. The shortest-path weight from source s\nappears within each vertex. Because vertices eandfform a negative-weight cycle reachable from s,\nthey have shortest-path weights of /NUL1. Because vertex gis reachable from a vertex whose shortest-\npath weight is/NUL1, it, too, has a shortest-path weight of /NUL1. Vertices such as h,i,a n d jare not\nreachable from s, and so their shortest-path weights are 1, even though they lie on a negative-weight\ncycle.\nSome shortest-paths algorithms, such as Dijkstra\u2019s algorithm, assume that all\nedge weights in the input graph are nonnegative, as in the road-map example. Oth-\ners, such as the Bellman-Ford algorithm, allow negative-weight edges in the in-put graph and produce a correct answer as long as no negative-weight cycles arereachable from the source. Typically, if there is such a negative-weight cycle, thealgorithm can detect and report its existence.\nCycles\nCan a shortest path contain a cycle? As we have just seen, it cannot contain a\nnegative-weight cycle. Nor can it contain a positive-weight cycle, since remov-ing the cycle from the path produces a path with the same source and destinationvertices and a lower path weight. That is, if pDh/ETB\n0;/ETB1;:::;/ETB kii sap a t ha n d\ncDh/ETBi;/ETBiC1;:::;/ETB jiis a positive-weight cycle on this path (so that /ETBiD/ETBjand\nw.c/ > 0 ), then the path p0Dh/ETB0;/ETB1;:::;/ETB i;/ETBjC1;/ETBjC2;:::;/ETB kihas weight\nw.p0/Dw.p//NULw.c/ < w.p/ ,a n ds o pcannot be a shortest path from /ETB0to/ETBk.\nThat leaves only 0-weight cycles. We can remove a 0-weight cycle from any\npath to produce another path whose weight is the same. Thus, if there is a shortestpath from a source vertex sto a destination vertex /ETBthat contains a 0-weight cycle,\nthen there is another shortest path from sto/ETBwithout this cycle. As long as a\nshortest path has 0-weight cycles, we can repeatedly remove these cycles from the\npath until we have a shortest path that is cycle-free. Therefore, without loss of\ngenerality we can assume that when we are \ufb01nding shortest paths, they have nocycles, i.e., they are simple paths. Since any acyclic path in a graph GD.V; E/", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "667": {"page_number": 668, "page_information": "Chapter 24 Single-Source Shortest Paths 647\ncontains at mostjVjdistinct vertices, it also contains at most jVj/NUL1edges. Thus,\nwe can restrict our attention to shortest paths of at most jVj/NUL1edges.\nRepresenting shortest paths\nWe often wish to compute not only shortest-path weights, but the vertices on short-\nest paths as well. We represent shortest paths similarly to how we representedbreadth-\ufb01rst trees in Section 22.2. Given a graph GD.V; E/ , we maintain for\neach vertex /ETB2Vapredecessor /ETB:/EM that is either another vertex or\nNIL.T h e\nshortest-paths algorithms in this chapter set the /EMattributes so that the chain of pre-\ndecessors originating at a vertex /ETBruns backwards along a shortest path from sto/ETB.\nThus, given a vertex /ETBfor which /ETB:/EM\u00a4NIL, the procedure P RINT -PATH. G ;s ;/ETB/\nfrom Section 22.2 will print a shortest path from sto/ETB.\nIn the midst of executing a shortest-paths algorithm, however, the /EMvalues might\nnot indicate shortest paths. As in breadth-\ufb01rst search, we shall be interested in thepredecessor subgraph G\n/EMD.V/EM;E/EM/induced by the /EMvalues. Here again, we\nde\ufb01ne the vertex set V/EMto be the set of vertices of Gwith non- NILpredecessors,\nplus the source s:\nV/EMDf/ETB2VW/ETB:/EM\u00a4NILg[fsg:\nThe directed edge set E/EMis the set of edges induced by the /EMvalues for vertices\ninV/EM:\nE/EMDf./ETB:/EM; /ETB/2EW/ETB2V/EM/NULfsgg:\nWe shall prove that the /EMvalues produced by the algorithms in this chapter have\nthe property that at termination G/EMis a \u201cshortest-paths tree\u201d\u2014informally, a rooted\ntree containing a shortest path from the source sto every vertex that is reachable\nfrom s. A shortest-paths tree is like the breadth-\ufb01rst tree from Section 22.2, but it\ncontains shortest paths from the source de\ufb01ned in terms of edge weights instead ofnumbers of edges. To be precise, let GD.V; E/ be a weighted, directed graph\nwith weight function wWE!R, and assume that Gcontains no negative-weight\ncycles reachable from the source vertex s2V, so that shortest paths are well\nde\ufb01ned. A shortest-paths tree rooted at sis a directed subgraph G\n0D.V0;E0/,\nwhere V0/DC2VandE0/DC2E, such that\n1.V0is the set of vertices reachable from sinG,\n2.G0forms a rooted tree with root s,a n d\n3. for all /ETB2V0, the unique simple path from sto/ETBinG0is a shortest path from s\nto/ETBinG.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "668": {"page_number": 669, "page_information": "648 Chapter 24 Single-Source Shortest Paths\n(a) (b) (c)06\n67 2 1 243\n53stx\nyz39\n51 106\n67 2 1 243\n53stx\nyz39\n51 106\n67 2 1 243\n53stx\nyz39\n51 1\nFigure 24.2 (a) A weighted, directed graph with shortest-path weights from source s.(b)The\nshaded edges form a shortest-paths tree rooted at the source s.(c)Another shortest-paths tree with\nthe same root.\nShortest paths are not necessarily unique, and neither are shortest-paths trees. For\nexample, Figure 24.2 shows a weighted, directed graph and two shortest-paths treeswith the same root.\nRelaxation\nThe algorithms in this chapter use the technique of relaxation . For each vertex\n/ETB2V, we maintain an attribute /ETB:d, which is an upper bound on the weight of\na shortest path from source sto/ETB. We call /ETB:dashortest-path estimate .W e\ninitialize the shortest-path estimates and predecessors by the following \u201a.V / -time\nprocedure:\nI\nNITIALIZE -SINGLE -SOURCE .G; s/\n1foreach vertex /ETB2G:V\n2 /ETB:dD1\n3 /ETB:/EMDNIL\n4s:dD0\nAfter initialization, we have /ETB:/EMDNILfor all /ETB2V,s:dD0,a n d /ETB:dD1 for\n/ETB2V/NULfsg.\nThe process of relaxing an edge .u; /ETB/ consists of testing whether we can im-\nprove the shortest path to /ETBfound so far by going through uand, if so, updat-\ning/ETB:dand/ETB:/EM. A relaxation step1may decrease the value of the shortest-path\n1\nThe use of the term is historical. The outcome of a relaxation step can be viewed as a relaxation\nof the constraint /ETB:d/DC4u:dCw.u;/ETB/ , which, by the triangle inequality (Lemma 24.10), must be\nsatis\ufb01ed if u:dD\u0131.s; u/ and/ETB:dD\u0131.s; /ETB/ .T h a ti s ,i f /ETB:d/DC4u:dCw.u;/ETB/ , there is no \u201cpressure\u201dIt may seem strange that the term \u201crelaxation\u201d is used for an operation that tightens an upper bound.\nso the constraint is \u201crelaxed.\u201d to satisfy this constraint,", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "669": {"page_number": 670, "page_information": "Chapter 24 Single-Source Shortest Paths 649\nuv\n592\nuv\n572RELAX (u,v,w)\n(a) (b)uv\n562\nuv\n562RELAX (u,v,w)\nFigure 24.3 Relaxing an edge .u; /ETB/ with weight w.u;/ETB/D2. The shortest-path estimate of each\nvertex appears within the vertex. (a)Because /ETB:d>u : dCw.u;/ETB/ prior to relaxation, the value\nof/ETB:ddecreases. (b)Here, /ETB:d/DC4u:dCw.u;/ETB/ before relaxing the edge, and so the relaxation step\nleaves /ETB:dunchanged.\nestimate /ETB:dand update /ETB\u2019s predecessor attribute /ETB:/EM. The following code per-\nforms a relaxation step on edge .u; /ETB/ inO.1/ time:\nRELAX . u ;/ETB;w/\n1if/ETB:d>u : dCw.u;/ETB/\n2 /ETB:dDu:dCw.u;/ETB/\n3 /ETB:/EMDu\nFigure 24.3 shows two examples of relaxing an edge, one in which a shortest-path\nestimate decreases and one in which no estimate changes.\nEach algorithm in this chapter calls I NITIALIZE -SINGLE -SOURCE a n dt h e nr e -\npeatedly relaxes edges. Moreover, relaxation is the only means by which shortest-\npath estimates and predecessors change. The algorithms in this chapter differ in\nhow many times they relax each edge and the order in which they relax edges. Dijk-\nstra\u2019s algorithm and the shortest-paths algorithm for directed acyclic graphs relaxeach edge exactly once. The Bellman-Ford algorithm relaxes each edge jVj/NUL1\ntimes.\nProperties of shortest paths and relaxation\nTo prove the algorithms in this chapter correct, we shall appeal to several prop-\nerties of shortest paths and relaxation. We state these properties here, and Sec-tion 24.5 proves them formally. For your reference, each property stated here in-cludes the appropriate lemma or corollary number from Section 24.5. The latter\ufb01ve of these properties, which refer to shortest-path estimates or the predecessorsubgraph, implicitly assume that the graph is initialized with a call to I\nNITIALIZE -\nSINGLE -SOURCE .G; s/ and that the only way that shortest-path estimates and the\npredecessor subgraph change are by some sequence of relaxation steps.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "670": {"page_number": 671, "page_information": "650 Chapter 24 Single-Source Shortest Paths\nTriangle inequality (Lemma 24.10)\nFor any edge .u; /ETB/2E,w eh a v e \u0131.s; /ETB//DC4\u0131.s; u/Cw.u;/ETB/ .\nUpper-bound property (Lemma 24.11)\nWe always have /ETB:d/NAK\u0131.s; /ETB/ for all vertices /ETB2V, and once /ETB:dachieves the\nvalue \u0131.s; /ETB/ , it never changes.\nNo-path property (Corollary 24.12)\nIf there is no path from sto/ETB,t h e nw ea l w a y sh a v e /ETB:dD\u0131.s; /ETB/D1 .\nConvergence property (Lemma 24.14)\nIfs;u!/ETBis a shortest path in Gfor some u; /ETB2V,a n di f u:dD\u0131.s; u/ at\nany time prior to relaxing edge .u; /ETB/ ,t h e n /ETB:dD\u0131.s; /ETB/ at all times afterward.\nPath-relaxation property (Lemma 24.15)\nIfpDh/ETB0;/ETB1;:::;/ETB kiis a shortest path from sD/ETB0to/ETBk, and we relax the\nedges of pin the order ./ETB0;/ETB1/; ./ETB 1;/ETB2/ ;:::;. /ETB k/NUL1;/ETBk/,t h e n /ETBk:dD\u0131.s; /ETB k/.\nThis property holds regardless of any other relaxation steps that occur, even ifthey are intermixed with relaxations of the edges of p.\nPredecessor-subgraph property (Lemma 24.17)\nOnce /ETB:dD\u0131.s; /ETB/ for all /ETB2V, the predecessor subgraph is a shortest-paths\ntree rooted at s.\nChapter outline\nSection 24.1 presents the Bellman-Ford algorithm, which solves the single-source\nshortest-paths problem in the general case in which edges can have negative weight.The Bellman-Ford algorithm is remarkably simple, and it has the further bene\ufb01tof detecting whether a negative-weight cycle is reachable from the source. Sec-\ntion 24.2 gives a linear-time algorithm for computing shortest paths from a single\nsource in a directed acyclic graph. Section 24.3 covers Dijkstra\u2019s algorithm, whichhas a lower running time than the Bellman-Ford algorithm but requires the edgeweights to be nonnegative. Section 24.4 shows how we can use the Bellman-Fordalgorithm to solve a special case of linear programming. Finally, Section 24.5proves the properties of shortest paths and relaxation stated above.\nWe require some conventions for doing arithmetic with in\ufb01nities. We shall as-\nsume that for any real number a\u00a4/NUL1 ,w eh a v e aC1D1C aD1 . Also, to\nmake our proofs hold in the presence of negative-weight cycles, we shall assumethat for any real number a\u00a41 ,w eh a v e aC./NUL1/D./NUL1/CaD/NUL1 .\nAll algorithms in this chapter assume that the directed graph Gis stored in the\nadjacency-list representation. Additionally, stored with each edge is its weight, sothat as we traverse each adjacency list, we can determine the edge weights in O.1/\ntime per edge.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "671": {"page_number": 672, "page_information": "24.1 The Bellman-Ford algorithm 651\n24.1 The Bellman-Ford algorithm\nTheBellman-Ford algorithm solves the single-source shortest-paths problem in\nthe general case in which edge weights may be negative. Given a weighted, di-rected graph GD.V; E/ with source sand weight function wWE! R,t h e\nBellman-Ford algorithm returns a boolean value indicating whether or not there is\na negative-weight cycle that is reachable from the source. If there is such a cy-\ncle, the algorithm indicates that no solution exists. If there is no such cycle, thealgorithm produces the shortest paths and their weights.\nThe algorithm relaxes edges, progressively decreasing an estimate /ETB:don the\nweight of a shortest path from the source sto each vertex /ETB2Vuntil it achieves\nthe actual shortest-path weight \u0131.s; /ETB/ . The algorithm returns\nTRUE if and only if\nthe graph contains no negative-weight cycles that are reachable from the source.\nBELLMAN -FORD. G ;w;s/\n1I NITIALIZE -SINGLE -SOURCE .G; s/\n2foriD1tojG:Vj/NUL1\n3 foreach edge .u; /ETB/2G:E\n4R ELAX . u ;/ETB;w/\n5foreach edge .u; /ETB/2G:E\n6 if/ETB:d>u : dCw.u;/ETB/\n7 return FALSE\n8return TRUE\nFigure 24.4 shows the execution of the Bellman-Ford algorithm on a graph\nwith 5vertices. After initializing the dand/EMvalues of all vertices in line 1,\nthe algorithm makes jVj/NUL1passes over the edges of the graph. Each pass is\none iteration of the forloop of lines 2\u20134 and consists of relaxing each edge of the\ngraph once. Figures 24.4(b)\u2013(e) show the state of the algorithm after each of thefour passes over the edges. After making jVj/NUL1passes, lines 5\u20138 check for a\nnegative-weight cycle and return the appropriate boolean value. (We\u2019ll see a littlelater why this check works.)\nThe Bellman-Ford algorithm runs in time O.VE/ , since the initialization in\nline 1 takes \u201a.V / time, each of thejVj/NUL1passes over the edges in lines 2\u20134\ntakes \u201a.E/ time, and the forloop of lines 5\u20137 takes O.E/ time.\nTo prove the correctness of the Bellman-Ford algorithm, we start by showing that\nif there are no negative-weight cycles, the algorithm computes correct shortest-pathweights for all vertices reachable from the source.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "672": {"page_number": 673, "page_information": "652 Chapter 24 Single-Source Shortest Paths\n(a) (b) (c)\n(d)05\n97 86\n7\n(e)tx\ns\nyz \u20134  \u2013 3  \u2013 2 2\n74\n\u20132205\n97 86\n7tx\ns\nyz \u20134  \u2013 3  \u2013 2 2\n74\n2205\n97 86\n7tx\ns\nyz \u20134  \u2013 3  \u2013 2 6\n74\n2205\n97 86\n7tx\ns\nyz \u20134  \u2013 3  \u2013 2 6\n7\u221e\n\u221e205\n97 86\n7tx\ns\nyz \u20134  \u2013 3  \u2013 2 \u221e\n\u221e2\u221e\n\u221e\nFigure 24.4 The execution of the Bellman-Ford algorithm. The source is vertex s.T h e dval-\nues appear within the vertices, and shaded edges indicate predecessor values: if edge .u; /ETB/ is\nshaded, then /ETB:/EMDu. In this particular example, each pass relaxes the edges in the order\n.t; x/; .t; y/; .t; \u00b4/; .x; t/; .y; x/; .y; \u00b4/; .\u00b4; x/; .\u00b4; s/; .s; t/; .s; y/ .(a)The situation just before the\n\ufb01rst pass over the edges. (b)\u2013(e) The situation after each successive pass over the edges. The d\nand/EMvalues in part (e) are the \ufb01nal values. The Bellman-Ford algorithm returns TRUE in this\nexample.\nLemma 24.2\nLetGD.V; E/ be a weighted, directed graph with source sand weight func-\ntionwWE! R, and assume that Gcontains no negative-weight cycles that are\nreachable from s. Then, after thejVj/NUL1iterations of the forloop of lines 2\u20134\nof B ELLMAN -FORD,w eh a v e /ETB:dD\u0131.s; /ETB/ for all vertices /ETBthat are reachable\nfrom s.\nProof We prove the lemma by appealing to the path-relaxation property. Con-\nsider any vertex /ETBthat is reachable from s,a n dl e t pDh/ETB0;/ETB1;:::;/ETB ki,w h e r e\n/ETB0Dsand/ETBkD/ETB, be any shortest path from sto/ETB. Because shortest paths are\nsimple, phas at mostjVj/NUL1edges, and so k/DC4jVj/NUL1. Each of thejVj/NUL1itera-\ntions of the forloop of lines 2\u20134 relaxes all jEjedges. Among the edges relaxed in\ntheith iteration, for iD1 ;2;:::;k ,i s./ETBi/NUL1;/ETBi/. By the path-relaxation property,\ntherefore, /ETB:dD/ETBk:dD\u0131.s; /ETB k/D\u0131.s; /ETB/ .\n", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "673": {"page_number": 674, "page_information": "24.1 The Bellman-Ford algorithm 653\nCorollary 24.3\nLetGD.V; E/ be a weighted, directed graph with source vertex sand weight\nfunction wWE! R, and assume that Gcontains no negative-weight cycles that\nare reachable from s. Then, for each vertex /ETB2V, there is a path from sto/ETBif\nand only if B ELLMAN -FORD terminates with /ETB:d<1when it is run on G.\nProof The proof is left as Exercise 24.1-2.\nTheorem 24.4 (Correctness of the Bellman-Ford algorithm)\nLet B ELLMAN -FORD be run on a weighted, directed graph GD.V; E/ with\nsource sand weight function wWE!R.I fGcontains no negative-weight cycles\nthat are reachable from s, then the algorithm returns TRUE ,w eh a v e /ETB:dD\u0131.s; /ETB/\nfor all vertices /ETB2V, and the predecessor subgraph G/EMis a shortest-paths tree\nrooted at s.I fGdoes contain a negative-weight cycle reachable from s, then the\nalgorithm returns FALSE .\nProof Suppose that graph Gcontains no negative-weight cycles that are reach-\nable from the source s. We \ufb01rst prove the claim that at termination, /ETB:dD\u0131.s; /ETB/\nfor all vertices /ETB2V. If vertex /ETBis reachable from s, then Lemma 24.2 proves this\nclaim. If /ETBis not reachable from s, then the claim follows from the no-path prop-\nerty. Thus, the claim is proven. The predecessor-subgraph property, along with theclaim, implies that G\n/EMis a shortest-paths tree. Now we use the claim to show that\nBELLMAN -FORD returns TRUE . At termination, we have for all edges .u; /ETB/2E,\n/ETB:dD\u0131.s; /ETB/\n/DC4\u0131.s; u/Cw.u;/ETB/ (by the triangle inequality)\nDu:dCw.u;/ETB/ ;\nand so none of the tests in line 6 causes B ELLMAN -FORD to return FALSE .T h e r e -\nfore, it returns TRUE .\nNow, suppose that graph Gcontains a negative-weight cycle that is reachable\nfrom the source s; let this cycle be cDh/ETB0;/ETB1;:::;/ETB ki,w h e r e /ETB0D/ETBk. Then,\nkX\niD1w./ETB i/NUL1;/ETBi/<0: (24.1)\nAssume for the purpose of contradiction that the Bellman-Ford algorithm returns\nTRUE . Thus, /ETBi:d/DC4/ETBi/NUL1:dCw./ETB i/NUL1;/ETBi/foriD1 ;2;:::;k . Summing the\ninequalities around cycle cgives us", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "674": {"page_number": 675, "page_information": "654 Chapter 24 Single-Source Shortest Paths\nkX\niD1/ETBi:d/DC4kX\niD1./ETBi/NUL1:dCw./ETB i/NUL1;/ETBi//\nDkX\niD1/ETBi/NUL1:dCkX\niD1w./ETB i/NUL1;/ETBi/:\nSince /ETB0D/ETBk, each vertex in cappears exactly once in each of the summationsPk\niD1/ETBi:dandPk\niD1/ETBi/NUL1:d,a n ds o\nkX\niD1/ETBi:dDkX\niD1/ETBi/NUL1:d:\nMoreover, by Corollary 24.3, /ETBi:dis \ufb01nite for iD1 ;2;:::;k . Thus,\n0/DC4kX\niD1w./ETB i/NUL1;/ETBi/;\nwhich contradicts inequality (24.1). We conclude that the Bellman-Ford algorithm\nreturns TRUE if graph Gcontains no negative-weight cycles reachable from the\nsource, and FALSE otherwise.\nExercises\n24.1-1\nRun the Bellman-Ford algorithm on the directed graph of Figure 24.4, using ver-tex\u00b4as the source. In each pass, relax edges in the same order as in the \ufb01gure, and\nshow the dand/EMvalues after each pass. Now, change the weight of edge .\u00b4; x/\nto4and run the algorithm again, using sas the source.\n24.1-2\nProve Corollary 24.3.\n24.1-3\nGiven a weighted, directed graph GD.V; E/ with no negative-weight cycles,\nletmbe the maximum over all vertices /ETB2Vof the minimum number of edges\nin a shortest path from the source sto/ETB. (Here, the shortest path is by weight, not\nthe number of edges.) Suggest a simple change to the Bellman-Ford algorithm that\nallows it to terminate in mC1passes, even if mis not known in advance.\n24.1-4\nModify the Bellman-Ford algorithm so that it sets /ETB:dto/NUL1 for all vertices /ETBfor\nwhich there is a negative-weight cycle on some path from the source to /ETB.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "675": {"page_number": 676, "page_information": "24.2 Single-source shortest paths in directed acyclic graphs 655\n24.1-5 ?\nLetGD.V; E/ be a weighted, directed graph with weight function wWE! R.\nGive an O.VE/ -time algorithm to \ufb01nd, for each vertex /ETB2V,t h ev a l u e \u0131/ETX./ETB/D\nmin u2Vf\u0131.u;/ETB/g.\n24.1-6 ?\nSuppose that a weighted, directed graph GD.V; E/ has a negative-weight cycle.\nGive an ef\ufb01cient algorithm to list the vertices of one such cycle. Prove that youralgorithm is correct.\n24.2 Single-source shortest paths in directed acyclic graphs\nBy relaxing the edges of a weighted dag (directed acyclic graph) GD.V; E/\naccording to a topological sort of its vertices, we can compute shortest paths froma single source in \u201a.VCE/time. Shortest paths are always well de\ufb01ned in a dag,\nsince even if there are negative-weight edges, no negative-weight cycles can exist.\nThe algorithm starts by topologically sorting the dag (see Section 22.4) to im-\npose a linear ordering on the vertices. If the dag contains a path from vertex uto\nvertex /ETB,t h e n uprecedes /ETBin the topological sort. We make just one pass over the\nvertices in the topologically sorted order. As we process each vertex, we relax eachedge that leaves the vertex.\nD\nAG-SHORTEST -PATHS . G ;w;s/\n1 topologically sort the vertices of G\n2I NITIALIZE -SINGLE -SOURCE .G; s/\n3foreach vertex u, taken in topologically sorted order\n4 foreach vertex /ETB2G:Adj\u0152u/c141\n5R ELAX . u ;/ETB;w/\nFigure 24.5 shows the execution of this algorithm.\nThe running time of this algorithm is easy to analyze. As shown in Section 22.4,\nthe topological sort of line 1 takes \u201a.VCE/time. The call of I NITIALIZE -\nSINGLE -SOURCE in line 2 takes \u201a.V / time. The forloop of lines 3\u20135 makes one\niteration per vertex. Altogether, the forloop of lines 4\u20135 relaxes each edge exactly\nonce. (We have used an aggregate analysis here.) Because each iteration of theinnerforloop takes \u201a.1/ time, the total running time is \u201a.VCE/, which is linear\nin the size of an adjacency-list representation of the graph.\nThe following theorem shows that the D\nAG-SHORTEST -PATHS procedure cor-\nrectly computes the shortest paths.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "676": {"page_number": 677, "page_information": "656 Chapter 24 Single-Source Shortest Paths\n2\u221e\u221e 051 6\n34\u221e \u221e \u221e7\u2013 1 \u2013 2\n2\n(a)x t s ry z\n2 51 6\n347\u2013 1 \u2013 2\n2\n(c)x t s ry z\n2 51 6\n347\u2013 1 \u2013 2\n2\n(e)x t s ry z\n2 51 6\n347\u2013 1 \u2013 2\n2\n(g)x t s ry z2 51 6\n347\u2013 1 \u2013 2\n2\n(b)x t s ry z\n2 51 6\n347\u2013 1 \u2013 2\n2\n(d)x t s ry z\n2 51 6\n347\u2013 1 \u2013 2\n2\n(f)x t s ry z\u221e 0 \u221e \u221e 26\n\u221e 0 26 54\n\u221e 0 2653\u221e 0 265 3\u221e 0 2 664\u221e \u221e 0 \u221e \u221e \u221e\nFigure 24.5 The execution of the algorithm for shortest paths in a directed acyclic graph. The\nvertices are topologically sorted from left to right. The source vertex is s.T h e dvalues appear\nwithin the vertices, and shaded edges indicate the /EMvalues. (a)The situation before the \ufb01rst iteration\nof the forloop of lines 3\u20135. (b)\u2013(g) The situation after each iteration of the forloop of lines 3\u20135.\nThe newly blackened vertex in each iteration was used as uin that iteration. The values shown in\npart (g) are the \ufb01nal values.\nTheorem 24.5\nIf a weighted, directed graph GD.V; E/ has source vertex sand no cycles, then\nat the termination of the D AG-SHORTEST -PATHS procedure, /ETB:dD\u0131.s; /ETB/ for all\nvertices /ETB2V, and the predecessor subgraph G/EMis a shortest-paths tree.\nProof We \ufb01rst show that /ETB:dD\u0131.s; /ETB/ for all vertices /ETB2Vat termina-\ntion. If /ETBis not reachable from s,t h e n /ETB:dD\u0131.s; /ETB/D1 by the no-path\nproperty. Now, suppose that /ETBis reachable from s, so that there is a short-\nest path pDh/ETB0;/ETB1;:::;/ETB ki,w h e r e /ETB0Dsand/ETBkD/ETB. Because we pro-", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "677": {"page_number": 678, "page_information": "24.2 Single-source shortest paths in directed acyclic graphs 657\ncess the vertices in topologically sorted order, we relax the edges on pin the\norder ./ETB0;/ETB1/; ./ETB 1;/ETB2/ ;:::;. /ETB k/NUL1;/ETBk/. The path-relaxation property implies that\n/ETBi:dD\u0131.s; /ETB i/at termination for iD0; 1; : : : ; k . Finally, by the predecessor-\nsubgraph property, G/EMis a shortest-paths tree.\nAn interesting application of this algorithm arises in determining critical paths\ninPERT chart2analysis. Edges represent jobs to be performed, and edge weights\nrepresent the times required to perform particular jobs. If edge .u; /ETB/ enters ver-\ntex/ETBand edge ./ETB; x/ leaves /ETB, then job .u; /ETB/ must be performed before job ./ETB; x/ .\nA path through this dag represents a sequence of jobs that must be performed in aparticular order. A critical path is alongest path through the dag, corresponding\nto the longest time to perform any sequence of jobs. Thus, the weight of a criticalpath provides a lower bound on the total time to perform all the jobs. We can \ufb01nd\na critical path by either\n/SInegating the edge weights and running D AG-SHORTEST -PATHS ,o r\n/SIrunning D AG-SHORTEST -PATHS , with the modi\ufb01cation that we replace \u201c 1\u201d\nby \u201c/NUL1\u201d in line 2 of I NITIALIZE -SINGLE -SOURCE and \u201c >\u201db y\u201c <\u201di nt h e\nRELAX procedure.\nExercises\n24.2-1\nRun D AG-SHORTEST -PATHS on the directed graph of Figure 24.5, using vertex r\nas the source.\n24.2-2\nSuppose we change line 3 of D AG-SHORTEST -PATHS to read\n3forthe \ufb01rstjVj/NUL1vertices, taken in topologically sorted order\nShow that the procedure would remain correct.\n24.2-3\nThe PERT chart formulation given above is somewhat unnatural. In a more natu-ral structure, vertices would represent jobs and edges would represent sequencingconstraints; that is, edge .u; /ETB/ would indicate that job umust be performed before\njob/ETB. We would then assign weights to vertices, not edges. Modify the D\nAG-\nSHORTEST -PATHS procedure so that it \ufb01nds a longest path in a directed acyclic\ngraph with weighted vertices in linear time.\n2\u201cPERT\u201d is an acronym for \u201cprogram evaluation and review technique.\u201d", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "678": {"page_number": 679, "page_information": "658 Chapter 24 Single-Source Shortest Paths\n24.2-4\nGive an ef\ufb01cient algorithm to count the total number of paths in a directed acyclicgraph. Analyze your algorithm.\n24.3 Dijkstra\u2019s algorithm\nDijkstra\u2019s algorithm solves the single-source shortest-paths problem on a weighted,directed graph GD.V; E/ for the case in which all edge weights are nonnegative.\nIn this section, therefore, we assume that w.u;/ETB//NAK0for each edge .u; /ETB/2E.A s\nwe shall see, with a good implementation, the running time of Dijkstra\u2019s algorithmis lower than that of the Bellman-Ford algorithm.\nDijkstra\u2019s algorithm maintains a set Sof vertices whose \ufb01nal shortest-path\nweights from the source shave already been determined. The algorithm repeat-\nedly selects the vertex u2V/NULSwith the minimum shortest-path estimate, adds u\ntoS, and relaxes all edges leaving u. In the following implementation, we use a\nmin-priority queue Qof vertices, keyed by their dvalues.\nD\nIJKSTRA . G ;w;s/\n1I NITIALIZE -SINGLE -SOURCE .G; s/\n2SD;\n3QDG:V\n4while Q\u00a4;\n5 uDEXTRACT -MIN.Q/\n6 SDS[fug\n7 foreach vertex /ETB2G:Adj\u0152u/c141\n8R ELAX . u ;/ETB;w/\nDijkstra\u2019s algorithm relaxes edges as shown in Figure 24.6. Line 1 initializes\nthedand/EMvalues in the usual way, and line 2 initializes the set Sto the empty\nset. The algorithm maintains the invariant that QDV/NULSat the start of each\niteration of the while loop of lines 4\u20138. Line 3 initializes the min-priority queue Q\nto contain all the vertices in V;s i n c e SD; at that time, the invariant is true after\nline 3. Each time through the while loop of lines 4\u20138, line 5 extracts a vertex ufrom\nQDV/NULSand line 6 adds it to set S, thereby maintaining the invariant. (The \ufb01rst\ntime through this loop, uDs.) Vertex u, therefore, has the smallest shortest-path\nestimate of any vertex in V/NULS. Then, lines 7\u20138 relax each edge .u; /ETB/ leaving u,\nthus updating the estimate /ETB:dand the predecessor /ETB:/EM if we can improve the\nshortest path to /ETBfound so far by going through u. Observe that the algorithm\nnever inserts vertices into Qafter line 3 and that each vertex is extracted from Q", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "679": {"page_number": 680, "page_information": "24.3 Dijkstra\u2019s algorithm 659\n0\u221e\u221e\n\u221e\u221e0\u221e\u221e1\n210\n5\n(c)10\n508\n514\n7\n08\n513\n70859\n70\n59\n786 4 3 29\n7stx\nyz\n1\n210\n5\n(f)6 4 3 29\n7stx\nyz1\n210\n5\n(b)6 4 3 29\n7stx\nyz\n1\n210\n5\n(e)6 4 3 29\n7stx\nyz1\n210\n5\n(a)6 4 3 29\n7stx\nyz\n1\n210\n5\n(d)6 4 3 29\n7stx\nyz\nFigure 24.6 The execution of Dijkstra\u2019s algorithm. The source sis the leftmost vertex. The\nshortest-path estimates appear within the vertices, and shaded edges indicate predecessor values.Black vertices are in the set S, and white vertices are in the min-priority queue QDV/NULS.(a)The\nsituation just before the \ufb01rst iteration of the while loop of lines 4\u20138. The shaded vertex has the mini-\nmum dvalue and is chosen as vertex uin line 5. (b)\u2013(f) The situation after each successive iteration\nof the while loop. The shaded vertex in each part is chosen as vertex uin line 5 of the next iteration.\nThedvalues and predecessors shown in part (f) are the \ufb01nal values.\nand added to Sexactly once, so that the while loop of lines 4\u20138 iterates exactly jVj\ntimes.\nBecause Dijkstra\u2019s algorithm always chooses the \u201clightest\u201d or \u201cclosest\u201d vertex\ninV/NULSto add to set S, we say that it uses a greedy strategy. Chapter 16 explains\ngreedy strategies in detail, but you need not have read that chapter to understandDijkstra\u2019s algorithm. Greedy strategies do not always yield optimal results in gen-eral, but as the following theorem and its corollary show, Dijkstra\u2019s algorithm doesindeed compute shortest paths. The key is to show that each time it adds a vertex u\nto set S,w eh a v e u:dD\u0131.s; u/ .\nTheorem 24.6 (Correctness of Dijkstra\u2019s algorithm)\nDijkstra\u2019s algorithm, run on a weighted, directed graph GD.V; E/ with non-\nnegative weight function wand source s, terminates with u:dD\u0131.s; u/ for all\nvertices u2V.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "680": {"page_number": 681, "page_information": "660 Chapter 24 Single-Source Shortest Paths\np1Sp2u\nys\nx\nFigure 24.7 The proof of Theorem 24.6. Set Sis nonempty just before vertex uis added to it. We\ndecompose a shortest path pfrom source sto vertex uintosp1;x!yp2;u,w h e r e yis the \ufb01rst\nvertex on the path that is not in Sandx2Simmediately precedes y. Vertices xandyare distinct,\nbut we may have sDxoryDu.P a t h p2may or may not reenter set S.\nProof We use the following loop invariant:\nAt the start of each iteration of the while loop of lines 4\u20138, /ETB:dD\u0131.s; /ETB/\nfor each vertex /ETB2S.\nIt suf\ufb01ces to show for each vertex u2V,w eh a v e u:dD\u0131.s; u/ at the time when u\nis added to set S. Once we show that u:dD\u0131.s; u/ , we rely on the upper-bound\nproperty to show that the equality holds at all times thereafter.\nInitialization: Initially, SD;, and so the invariant is trivially true.\nMaintenance: We wish to show that in each iteration, u:dD\u0131.s; u/ for the vertex\nadded to set S. For the purpose of contradiction, let ube the \ufb01rst vertex for\nwhich u:d\u00a4\u0131.s; u/ when it is added to set S. We shall focus our attention\non the situation at the beginning of the iteration of the while loop in which u\nis added to Sand derive the contradiction that u:dD\u0131.s; u/ at that time by\nexamining a shortest path from stou.W e m u s t h a v e u\u00a4sbecause sis the\n\ufb01rst vertex added to set Sands:dD\u0131.s; s/D0at that time. Because u\u00a4s,\nwe also have that S\u00a4; just before uis added to S. There must be some\npath from stou, for otherwise u:dD\u0131.s; u/D1 by the no-path property,\nwhich would violate our assumption that u:d\u00a4\u0131.s; u/ . Because there is at\nleast one path, there is a shortest path pfrom stou. Prior to adding utoS,\npathpconnects a vertex in S, namely s, to a vertex in V/NULS, namely u.L e tu s\nconsider the \ufb01rst vertex yalong psuch that y2V/NULS,a n dl e t x2Sbey\u2019s\npredecessor along p. Thus, as Figure 24.7 illustrates, we can decompose path p\nintosp1;x!yp2;u. (Either of paths p1orp2m a yh a v en oe d g e s . )\nWe claim that y:dD\u0131.s; y/ when uis added to S. To prove this claim, ob-\nserve that x2S. Then, because we chose uas the \ufb01rst vertex for which\nu:d\u00a4\u0131.s; u/ when it is added to S,w eh a d x:dD\u0131.s; x/ when xwas added", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "681": {"page_number": 682, "page_information": "24.3 Dijkstra\u2019s algorithm 661\ntoS. Edge .x; y/ was relaxed at that time, and the claim follows from the\nconvergence property.\nWe can now obtain a contradiction to prove that u:dD\u0131.s; u/ . Because y\nappears before uon a shortest path from stouand all edge weights are non-\nnegative (notably those on path p2), we have \u0131.s; y//DC4\u0131.s; u/ , and thus\ny:dD\u0131.s; y/\n/DC4\u0131.s; u/ (24.2)\n/DC4u:d (by the upper-bound property) .\nBut because both vertices uandywere in V/NULSwhen uwas chosen in line 5,\nwe have u:d/DC4y:d. Thus, the two inequalities in (24.2) are in fact equalities,\ngiving\ny:dD\u0131.s; y/D\u0131.s; u/Du:d:\nConsequently, u:dD\u0131.s; u/ , which contradicts our choice of u. We conclude\nthatu:dD\u0131.s; u/ when uis added to S, and that this equality is maintained at\nall times thereafter.\nTermination: At termination, QD; which, along with our earlier invariant that\nQDV/NULS, implies that SDV. Thus, u:dD\u0131.s; u/ for all vertices u2V.\nCorollary 24.7\nIf we run Dijkstra\u2019s algorithm on a weighted, directed graph GD.V; E/ with\nnonnegative weight function wand source s, then at termination, the predecessor\nsubgraph G/EMis a shortest-paths tree rooted at s.\nProof Immediate from Theorem 24.6 and the predecessor-subgraph property.\nAnalysis\nHow fast is Dijkstra\u2019s algorithm? It maintains the min-priority queue Qby call-\ning three priority-queue operations: I NSERT (implicit in line 3), E XTRACT -MIN\n(line 5), and D ECREASE -KEY(implicit in R ELAX , which is called in line 8). The\nalgorithm calls both I NSERT and E XTRACT -MINonce per vertex. Because each\nvertex u2Vis added to set Sexactly once, each edge in the adjacency list Adj\u0152u/c141\nis examined in the forloop of lines 7\u20138 exactly once during the course of the al-\ngorithm. Since the total number of edges in all the adjacency lists is jEj,t h i sfor\nloop iterates a total of jEjtimes, and thus the algorithm calls D ECREASE -KEYat\nmostjEjtimes overall. (Observe once again that we are using aggregate analysis.)\nThe running time of Dijkstra\u2019s algorithm depends on how we implement the\nmin-priority queue. Consider \ufb01rst the case in which we maintain the min-priority", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "682": {"page_number": 683, "page_information": "662 Chapter 24 Single-Source Shortest Paths\nqueue by taking advantage of the vertices being numbered 1 to jVj.W e s i m p l y\nstore /ETB:din the /ETBth entry of an array. Each I NSERT and D ECREASE -KEYoperation\ntakes O.1/ time, and each E XTRACT -MINoperation takes O.V / t i m e( s i n c ew e\nhave to search through the entire array), for a total time of O.V2CE/DO.V2/.\nIf the graph is suf\ufb01ciently sparse\u2014in particular, EDo.V2=lgV/\u2014we can\nimprove the algorithm by implementing the min-priority queue with a binary min-heap. (As discussed in Section 6.5, the implementation should make sure thatvertices and corresponding heap elements maintain handles to each other.) Each\nE\nXTRACT -MINoperation then takes time O.lgV/. As before, there are jVjsuch\noperations. The time to build the binary min-heap is O.V / . Each D ECREASE -KEY\noperation takes time O.lgV/, and there are still at most jEjsuch operations. The\ntotal running time is therefore O..VCE/lgV/,w h i c hi s O.E lgV/if all vertices\nare reachable from the source. This running time improves upon the straightfor-ward O.V\n2/-time implementation if EDo.V2=lgV/.\nWe can in fact achieve a running time of O.V lgVCE/by implementing the\nmin-priority queue with a Fibonacci heap (see Chapter 19). The amortized cost\nof each of thejVjEXTRACT -MINoperations is O.lgV/, and each D ECREASE -\nKEYcall, of which there are at most jEj, takes only O.1/ amortized time. His-\ntorically, the development of Fibonacci heaps was motivated by the observationthat Dijkstra\u2019s algorithm typically makes many more D\nECREASE -KEYcalls than\nEXTRACT -MINcalls, so that any method of reducing the amortized time of each\nDECREASE -KEYoperation to o.lgV/without increasing the amortized time of\nEXTRACT -MINwould yield an asymptotically faster implementation than with bi-\nnary heaps.\nDijkstra\u2019s algorithm resembles both breadth-\ufb01rst search (see Section 22.2) and\nPrim\u2019s algorithm for computing minimum spanning trees (see Section 23.2). It islike breadth-\ufb01rst search in that set Scorresponds to the set of black vertices in a\nbreadth-\ufb01rst search; just as vertices in Shave their \ufb01nal shortest-path weights, so\ndo black vertices in a breadth-\ufb01rst search have their correct breadth-\ufb01rst distances.Dijkstra\u2019s algorithm is like Prim\u2019s algorithm in that both algorithms use a min-priority queue to \ufb01nd the \u201clightest\u201d vertex outside a given set (the set Sin Dijkstra\u2019s\nalgorithm and the tree being grown in Prim\u2019s algorithm), add this vertex into theset, and adjust the weights of the remaining vertices outside the set accordingly.\nExercises\n24.3-1\nRun Dijkstra\u2019s algorithm on the directed graph of Figure 24.2, \ufb01rst using vertex s\nas the source and then using vertex \u00b4as the source. In the style of Figure 24.6,\nshow the dand/EMvalues and the vertices in set Safter each iteration of the while\nloop.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "683": {"page_number": 684, "page_information": "24.3 Dijkstra\u2019s algorithm 663\n24.3-2\nGive a simple example of a directed graph with negative-weight edges for whichDijkstra\u2019s algorithm produces incorrect answers. Why doesn\u2019t the proof of Theo-rem 24.6 go through when negative-weight edges are allowed?\n24.3-3\nSuppose we change line 4 of Dijkstra\u2019s algorithm to the following.\n4whilejQj>1\nThis change causes the while loop to executejVj/NUL1times instead ofjVjtimes. Is\nthis proposed algorithm correct?\n24.3-4\nProfessor Gaedel has written a program that he claims implements Dijkstra\u2019s al-gorithm. The program produces /ETB:dand/ETB:/EM for each vertex /ETB2V.G i v e a n\nO.VCE/-time algorithm to check the output of the professor\u2019s program. It should\ndetermine whether the dand/EMattributes match those of some shortest-paths tree.\nYou may assume that all edge weights are nonnegative.\n24.3-5\nProfessor Newman thinks that he has worked out a simpler proof of correctnessfor Dijkstra\u2019s algorithm. He claims that Dijkstra\u2019s algorithm relaxes the edges ofevery shortest path in the graph in the order in which they appear on the path, andtherefore the path-relaxation property applies to every vertex reachable from thesource. Show that the professor is mistaken by constructing a directed graph for\nwhich Dijkstra\u2019s algorithm could relax the edges of a shortest path out of order.\n24.3-6\nWe are given a directed graph GD.V; E/ on which each edge .u; /ETB/2Ehas an\nassociated value r.u;/ETB/ , which is a real number in the range 0/DC4r.u;/ETB//DC41that\nrepresents the reliability of a communication channel from vertex uto vertex /ETB.\nWe interpret r.u;/ETB/ as the probability that the channel from uto/ETBwill not fail,\nand we assume that these probabilities are independent. Give an ef\ufb01cient algorithmto \ufb01nd the most reliable path between two given vertices.\n24.3-7\nLetGD.V; E/ be a weighted, directed graph with positive weight function\nwWE!f1 ;2;:::;Wgfor some positive integer W, and assume that no two ver-\ntices have the same shortest-path weights from source vertex s. Now suppose that\nwe de\ufb01ne an unweighted, directed graph G\n0D.V[V0;E0/by replacing each\nedge .u; /ETB/2Ewith w.u;/ETB/ unit-weight edges in series. How many vertices\ndoes G0have? Now suppose that we run a breadth-\ufb01rst search on G0. Show that", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "684": {"page_number": 685, "page_information": "664 Chapter 24 Single-Source Shortest Paths\nthe order in which the breadth-\ufb01rst search of G0colors vertices in Vblack is the\nsame as the order in which Dijkstra\u2019s algorithm extracts the vertices of Vfrom the\npriority queue when it runs on G.\n24.3-8\nLetGD.V; E/ be a weighted, directed graph with nonnegative weight function\nwWE!f0; 1; : : : ; Wgfor some nonnegative integer W. Modify Dijkstra\u2019s algo-\nrithm to compute the shortest paths from a given source vertex sinO.W VCE/\ntime.\n24.3-9\nModify your algorithm from Exercise 24.3-8 to run in O..VCE/lgW/time.\n(Hint: How many distinct shortest-path estimates can there be in V/NULSat any\npoint in time?)\n24.3-10\nSuppose that we are given a weighted, directed graph GD.V; E/ in which edges\nthat leave the source vertex smay have negative weights, all other edge weights\nare nonnegative, and there are no negative-weight cycles. Argue that Dijkstra\u2019salgorithm correctly \ufb01nds shortest paths from sin this graph.\n24.4 Difference constraints and shortest paths\nChapter 29 studies the general linear-programming problem, in which we wish to\noptimize a linear function subject to a set of linear inequalities. In this section, weinvestigate a special case of linear programming that we reduce to \ufb01nding shortestpaths from a single source. We can then solve the single-source shortest-pathsproblem that results by running the Bellman-Ford algorithm, thereby also solvingthe linear-programming problem.\nLinear programming\nIn the general linear-programming problem ,w ea r eg i v e na n m/STXnmatrix A,\nanm-vector b,a n da n n-vector c. W ew i s ht o\ufb01 n dav e c t o r xofnelements that\nmaximizes the objective functionP\nn\niD1cixisubject to the mconstraints given by\nAx/DC4b.\nAlthough the simplex algorithm, which is the focus of Chapter 29, does not\nalways run in time polynomial in the size of its input, there are other linear-programming algorithms that do run in polynomial time. We offer here two reasons\nto understand the setup of linear-programming problems. First, if we know that we", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "685": {"page_number": 686, "page_information": "24.4 Difference constraints and shortest paths 665\ncan cast a given problem as a polynomial-sized linear-programming problem, then\nwe immediately have a polynomial-time algorithm to solve the problem. Second,faster algorithms exist for many special cases of linear programming. For exam-ple, the single-pair shortest-path problem (Exercise 24.4-4) and the maximum-\ufb02owproblem (Exercise 26.1-5) are special cases of linear programming.\nSometimes we don\u2019t really care about the objective function; we just wish to \ufb01nd\nanyfeasible solution , that is, any vector xthat satis\ufb01es Ax/DC4b, or to determine\nthat no feasible solution exists. We shall focus on one such feasibility problem .\nSystems of difference constraints\nIn asystem of difference constraints , each row of the linear-programming matrix A\ncontains one 1and one/NUL1, and all other entries of Aare0. Thus, the constraints\ngiven by Ax/DC4bare a set of mdifference constraints involving nunknowns, in\nwhich each constraint is a simple linear inequality of the form\nx\nj/NULxi/DC4bk;\nwhere 1/DC4i;j/DC4n,i\u00a4j,a n d 1/DC4k/DC4m.\nFor example, consider the problem of \ufb01nding a 5-vector xD.xi/that satis\ufb01es /EOT\n1/NUL1000\n1000/NUL1\n0100/NUL1\n/NUL10100\n/NUL10010\n00/NUL110\n00/NUL101\n000/NUL11\u02d8\n\u02c7\nx1\nx2\nx3\nx4\nx5/CR\n/DC4/EOT\n0\n/NUL1\n1\n54\n/NUL1\n/NUL3\n/NUL3\u02d8\n:\nThis problem is equivalent to \ufb01nding values for the unknowns x1;x2;x3;x4;x5,\nsatisfying the following 8difference constraints:\nx1/NULx2/DC4 0, (24.3)\nx1/NULx5/DC4/NUL 1, (24.4)\nx2/NULx5/DC4 1, (24.5)\nx3/NULx1/DC4 5, (24.6)\nx4/NULx1/DC4 4, (24.7)\nx4/NULx3/DC4/NUL 1, (24.8)\nx5/NULx3/DC4/NUL 3, (24.9)\nx5/NULx4/DC4/NUL 3. (24.10)", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "686": {"page_number": 687, "page_information": "666 Chapter 24 Single-Source Shortest Paths\nOne solution to this problem is xD./NUL5;/NUL3; 0;/NUL1;/NUL4/, which you can verify di-\nrectly by checking each inequality. In fact, this problem has more than one solution.Another is x\n0D. 0 ;2;5 ;4;1 / . These two solutions are related: each component\nofx0is5larger than the corresponding component of x. This fact is not mere\ncoincidence.\nLemma 24.8\nLetxD.x1;x2;:::;x n/be a solution to a system Ax/DC4bof difference con-\nstraints, and let dbe any constant. Then xCdD.x1Cd;x 2Cd;:::;x nCd/\nis a solution to Ax/DC4bas well.\nProof For each xiandxj,w eh a v e .xjCd//NUL.xiCd/Dxj/NULxi. Thus, if x\nsatis\ufb01es Ax/DC4b, so does xCd.\nSystems of difference constraints occur in many different applications. For ex-\nample, the unknowns ximay be times at which events are to occur. Each constraint\nstates that at least a certain amount of time, or at most a certain amount of time,must elapse between two events. Perhaps the events are jobs to be performed dur-ing the assembly of a product. If we apply an adhesive that takes 2 hours to set at\ntimex\n1and we have to wait until it sets to install a part at time x2, then we have the\nconstraint that x2/NAKx1C2or, equivalently, that x1/NULx2/DC4/NUL2. Alternatively, we\nmight require that the part be installed after the adhesive has been applied but nolater than the time that the adhesive has set halfway. In this case, we get the pair ofconstraints x\n2/NAKx1andx2/DC4x1C1or, equivalently, x1/NULx2/DC40andx2/NULx1/DC41.\nConstraint graphs\nWe can interpret systems of difference constraints from a graph-theoretic point\nof view. In a system Ax/DC4bof difference constraints, we view the m/STXn\nlinear-programming matrix Aas the transpose of an incidence matrix (see Exer-\ncise 22.1-7) for a graph with nvertices and medges. Each vertex /ETBiin the graph,\nforiD1 ;2;:::;n , corresponds to one of the nunknown variables xi. Each di-\nrected edge in the graph corresponds to one of the minequalities involving two\nunknowns.\nMore formally, given a system Ax/DC4bof difference constraints, the correspond-\ningconstraint graph is a weighted, directed graph GD.V; E/ ,w h e r e\nVDf/ETB0;/ETB1;:::;/ETB ng\nand\nEDf./ETBi;/ETBj/Wxj/NULxi/DC4bkis a constraintg\n[f./ETB0;/ETB1/; ./ETB 0;/ETB2/; ./ETB 0;/ETB3/ ;:::;. /ETB 0;/ETBn/g:", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "687": {"page_number": 688, "page_information": "24.4 Difference constraints and shortest paths 667\n0\n0\n0000 \u20131\n1\n5\n4\n\u20131\u20133 \u201330\u20135\n\u20133\n0 \u20131\u20134\nv3v2v1\nv5\nv0\nv4\nFigure 24.8 The constraint graph corresponding to the system (24.3)\u2013(24.10) of difference con-\nstraints. The value of \u0131./ETB0;/ETBi/appears in each vertex /ETBi. One feasible solution to the system is\nxD./NUL5;/NUL3; 0;/NUL1;/NUL4/.\nThe constraint graph contains the additional vertex /ETB0, as we shall see shortly, to\nguarantee that the graph has some vertex which can reach all other vertices. Thus,the vertex set Vconsists of a vertex /ETB\nifor each unknown xi, plus an additional\nvertex /ETB0. The edge set Econtains an edge for each difference constraint, plus\nan edge ./ETB0;/ETBi/for each unknown xi.I fxj/NULxi/DC4bkis a difference constraint,\nthen the weight of edge ./ETBi;/ETBj/isw./ETB i;/ETBj/Dbk. The weight of each edge leav-\ning/ETB0is0. Figure 24.8 shows the constraint graph for the system (24.3)\u2013(24.10)\nof difference constraints.\nThe following theorem shows that we can \ufb01nd a solution to a system of differ-\nence constraints by \ufb01nding shortest-path weights in the corresponding constraint\ngraph.\nTheorem 24.9\nGiven a system Ax/DC4bof difference constraints, let GD.V; E/ be the corre-\nsponding constraint graph. If Gcontains no negative-weight cycles, then\nxD.\u0131./ETB 0;/ETB1/; \u0131./ETB 0;/ETB2/; \u0131./ETB 0;/ETB3/ ;:::;\u0131 . /ETB 0;/ETBn// (24.11)\nis a feasible solution for the system. If Gcontains a negative-weight cycle, then\nthere is no feasible solution for the system.\nProof We \ufb01rst show that if the constraint graph contains no negative-weight\ncycles, then equation (24.11) gives a feasible solution. Consider any edge\n./ETBi;/ETBj/2E. By the triangle inequality, \u0131./ETB0;/ETBj//DC4\u0131./ETB0;/ETBi/Cw./ETB i;/ETBj/or,\nequivalently, \u0131./ETB0;/ETBj//NUL\u0131./ETB0;/ETBi//DC4w./ETB i;/ETBj/. Thus, letting xiD\u0131./ETB0;/ETBi/and", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "688": {"page_number": 689, "page_information": "668 Chapter 24 Single-Source Shortest Paths\nxjD\u0131./ETB0;/ETBj/satis\ufb01es the difference constraint xj/NULxi/DC4w./ETB i;/ETBj/that corre-\nsponds to edge ./ETBi;/ETBj/.\nNow we show that if the constraint graph contains a negative-weight cycle, then\nthe system of difference constraints has no feasible solution. Without loss of gen-erality, let the negative-weight cycle be cDh/ETB\n1;/ETB2;:::;/ETB ki,w h e r e /ETB1D/ETBk.\n(The vertex /ETB0cannot be on cycle c, because it has no entering edges.) Cycle c\ncorresponds to the following difference constraints:\nx2/NULx1/DC4w./ETB 1;/ETB2/;\nx3/NULx2/DC4w./ETB 2;/ETB3/;\n:::\nxk/NUL1/NULxk/NUL2/DC4w./ETB k/NUL2;/ETBk/NUL1/;\nxk/NULxk/NUL1/DC4w./ETB k/NUL1;/ETBk/:\nWe will assume that xhas a solution satisfying each of these kinequalities and then\nderive a contradiction. The solution must also satisfy the inequality that results\nwhen we sum the kinequalities together. If we sum the left-hand sides, each\nunknown xiis added in once and subtracted out once (remember that /ETB1D/ETBk\nimplies x1Dxk), so that the left-hand side of the sum is 0. The right-hand side\nsums to w.c/ , and thus we obtain 0/DC4w.c/ . But since cis a negative-weight cycle,\nw.c/ < 0 , and we obtain the contradiction that 0/DC4w.c/ < 0 .\nSolving systems of difference constraints\nTheorem 24.9 tells us that we can use the Bellman-Ford algorithm to solve a\nsystem of difference constraints. Because the constraint graph contains edgesfrom the source vertex /ETB\n0to all other vertices, any negative-weight cycle in the\nconstraint graph is reachable from /ETB0. If the Bellman-Ford algorithm returns\nTRUE , then the shortest-path weights give a feasible solution to the system. In\nFigure 24.8, for example, the shortest-path weights provide the feasible solutionxD./NUL5;/NUL3; 0;/NUL1;/NUL4/, and by Lemma 24.8, xD.d/NUL5; d/NUL3; d; d/NUL1; d/NUL4/\nis also a feasible solution for any constant d. If the Bellman-Ford algorithm returns\nFALSE , there is no feasible solution to the system of difference constraints.\nA system of difference constraints with mconstraints on nunknowns produces\na graph with nC1vertices and nCmedges. Thus, using the Bellman-Ford\nalgorithm, we can solve the system in O..nC1/.nCm//DO.n2Cnm/ time.\nExercise 24.4-5 asks you to modify the algorithm to run in O.nm/ time, even if m\nis much less than n.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "689": {"page_number": 690, "page_information": "24.4 Difference constraints and shortest paths 669\nExercises\n24.4-1\nFind a feasible solution or determine that no feasible solution exists for the follow-ing system of difference constraints:\nx\n1/NULx2/DC4 1,\nx1/NULx4/DC4/NUL 4,\nx2/NULx3/DC4 2,\nx2/NULx5/DC4 7,\nx2/NULx6/DC4 5,\nx3/NULx6/DC410,\nx4/NULx2/DC4 2,\nx5/NULx1/DC4/NUL 1,\nx5/NULx4/DC4 3,\nx6/NULx3/DC4/NUL 8.\n24.4-2\nFind a feasible solution or determine that no feasible solution exists for the follow-ing system of difference constraints:\nx\n1/NULx2/DC4 4,\nx1/NULx5/DC4 5,\nx2/NULx4/DC4/NUL 6,\nx3/NULx2/DC4 1,\nx4/NULx1/DC4 3,\nx4/NULx3/DC4 5,\nx4/NULx5/DC410,\nx5/NULx3/DC4/NUL 4,\nx5/NULx4/DC4/NUL 8.\n24.4-3\nCan any shortest-path weight from the new vertex /ETB0in a constraint graph be posi-\ntive? Explain.\n24.4-4\nExpress the single-pair shortest-path problem as a linear program.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "690": {"page_number": 691, "page_information": "670 Chapter 24 Single-Source Shortest Paths\n24.4-5\nShow how to modify the Bellman-Ford algorithm slightly so that when we use itto solve a system of difference constraints with minequalities on nunknowns, the\nrunning time is O.nm/ .\n24.4-6\nSuppose that in addition to a system of difference constraints, we want to handleequality constraints of the form x\niDxjCbk. Show how to adapt the Bellman-\nFord algorithm to solve this variety of constraint system.\n24.4-7\nShow how to solve a system of difference constraints by a Bellman-Ford-like algo-rithm that runs on a constraint graph without the extra vertex /ETB\n0.\n24.4-8 ?\nLetAx/DC4bb eas y s t e mo f mdifference constraints in nunknowns. Show that the\nBellman-Ford algorithm, when run on the corresponding constraint graph, maxi-mizesP\nn\niD1xisubject to Ax/DC4bandxi/DC40for all xi.\n24.4-9 ?\nShow that the Bellman-Ford algorithm, when run on the constraint graph for a sys-temAx/DC4bof difference constraints, minimizes the quantity .maxfx\nig/NULminfxig/\nsubject to Ax/DC4b. Explain how this fact might come in handy if the algorithm is\nused to schedule construction jobs.\n24.4-10\nSuppose that every row in the matrix Aof a linear program Ax/DC4bcorresponds to\na difference constraint, a single-variable constraint of the form xi/DC4bk, or a single-\nvariable constraint of the form /NULxi/DC4bk. Show how to adapt the Bellman-Ford\nalgorithm to solve this variety of constraint system.\n24.4-11\nGive an ef\ufb01cient algorithm to solve a system Ax/DC4bof difference constraints\nwhen all of the elements of bare real-valued and all of the unknowns ximust be\nintegers.\n24.4-12 ?\nGive an ef\ufb01cient algorithm to solve a system Ax/DC4bof difference constraints\nwhen all of the elements of bare real-valued and a speci\ufb01ed subset of some, but\nnot necessarily all, of the unknowns ximust be integers.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "691": {"page_number": 692, "page_information": "24.5 Proofs of shortest-paths properties 671\n24.5 Proofs of shortest-paths properties\nThroughout this chapter, our correctness arguments have relied on the triangle\ninequality, upper-bound property, no-path property, convergence property, path-relaxation property, and predecessor-subgraph property. We stated these propertieswithout proof at the beginning of this chapter. In this section, we prove them.\nThe triangle inequality\nIn studying breadth-\ufb01rst search (Section 22.2), we proved as Lemma 22.1 a sim-\nple property of shortest distances in unweighted graphs. The triangle inequality\ngeneralizes the property to weighted graphs.\nLemma 24.10 (Triangle inequality)\nLetGD.V; E/ be a weighted, directed graph with weight function wWE! R\nand source vertex s. Then, for all edges .u; /ETB/2E,w eh a v e\n\u0131.s; /ETB//DC4\u0131.s; u/Cw.u;/ETB/ :\nProof Suppose that pis a shortest path from source sto vertex /ETB.T h e n phas\nno more weight than any other path from sto/ETB. Speci\ufb01cally, path phas no more\nweight than the particular path that takes a shortest path from source sto vertex u\nand then takes edge .u; /ETB/ .\nExercise 24.5-3 asks you to handle the case in which there is no shortest path\nfrom sto/ETB.\nEffects of relaxation on shortest-path estimates\nThe next group of lemmas describes how shortest-path estimates are affected when\nwe execute a sequence of relaxation steps on the edges of a weighted, directedgraph that has been initialized by I\nNITIALIZE -SINGLE -SOURCE .\nLemma 24.11 (Upper-bound property)\nLetGD.V; E/ be a weighted, directed graph with weight function wWE! R.\nLets2Vbe the source vertex, and let the graph be initialized by I NITIALIZE -\nSINGLE -SOURCE .G; s/ . Then, /ETB:d/NAK\u0131.s; /ETB/ for all /ETB2V, and this invariant is\nmaintained over any sequence of relaxation steps on the edges of G. Moreover,\nonce /ETB:dachieves its lower bound \u0131.s; /ETB/ , it never changes.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "692": {"page_number": 693, "page_information": "672 Chapter 24 Single-Source Shortest Paths\nProof We prove the invariant /ETB:d/NAK\u0131.s; /ETB/ for all vertices /ETB2Vby induction\nover the number of relaxation steps.\nFor the basis, /ETB:d/NAK\u0131.s; /ETB/ is certainly true after initialization, since /ETB:dD1\nimplies /ETB:d/NAK\u0131.s; /ETB/ for all /ETB2V/NULfsg, and since s:dD0/NAK\u0131.s; s/ (note that\n\u0131.s; s/D/NUL1 ifsis on a negative-weight cycle and 0otherwise).\nFor the inductive step, consider the relaxation of an edge .u; /ETB/ . By the inductive\nhypothesis, x:d/NAK\u0131.s; x/ for all x2Vprior to the relaxation. The only dvalue\nthat may change is /ETB:d. If it changes, we have\n/ETB:dDu:dCw.u;/ETB/\n/NAK\u0131.s; u/Cw.u;/ETB/ (by the inductive hypothesis)\n/NAK\u0131.s; /ETB/ (by the triangle inequality) ,\nand so the invariant is maintained.\nTo see that the value of /ETB:dnever changes once /ETB:dD\u0131.s; /ETB/ , note that having\nachieved its lower bound, /ETB:dcannot decrease because we have just shown that\n/ETB:d/NAK\u0131.s; /ETB/ , and it cannot increase because relaxation steps do not increase d\nvalues.\nCorollary 24.12 (No-path property)Suppose that in a weighted, directed graph GD.V; E/ with weight function\nwWE! R, no path connects a source vertex s2Vto a given vertex /ETB2V.\nThen, after the graph is initialized by I\nNITIALIZE -SINGLE -SOURCE .G; s/ ,w e\nhave /ETB:dD\u0131.s; /ETB/D1 , and this equality is maintained as an invariant over\nany sequence of relaxation steps on the edges of G.\nProof By the upper-bound property, we always have 1D \u0131.s; /ETB//DC4/ETB:d,a n d\nthus/ETB:dD1D \u0131.s; /ETB/ .\nLemma 24.13\nLetGD.V; E/ be a weighted, directed graph with weight function wWE! R,\nand let .u; /ETB/2E. Then, immediately after relaxing edge .u; /ETB/ by executing\nRELAX . u ;/ETB;w/ ,w eh a v e /ETB:d/DC4u:dCw.u;/ETB/ .\nProof If, just prior to relaxing edge .u; /ETB/ ,w eh a v e /ETB:d>u : dCw.u;/ETB/ ,t h e n\n/ETB:dDu:dCw.u;/ETB/ afterward. If, instead, /ETB:d/DC4u:dCw.u;/ETB/ just before\nthe relaxation, then neither u:dnor/ETB:dchanges, and so /ETB:d/DC4u:dCw.u;/ETB/\nafterward.\nLemma 24.14 (Convergence property)LetGD.V; E/ be a weighted, directed graph with weight function wWE!R,\nlets2Vbe a source vertex, and let s;u!/ETBbe a shortest path in Gfor", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "693": {"page_number": 694, "page_information": "24.5 Proofs of shortest-paths properties 673\nsome vertices u; /ETB2V. Suppose that Gis initialized by I NITIALIZE -SINGLE -\nSOURCE .G; s/ and then a sequence of relaxation steps that includes the call\nRELAX . u ;/ETB;w/ is executed on the edges of G.I fu:dD\u0131.s; u/ at any time\nprior to the call, then /ETB:dD\u0131.s; /ETB/ at all times after the call.\nProof By the upper-bound property, if u:dD\u0131.s; u/ at some point prior to re-\nlaxing edge .u; /ETB/ , then this equality holds thereafter. In particular, after relaxing\nedge .u; /ETB/ ,w eh a v e\n/ETB:d/DC4u:dCw.u;/ETB/ (by Lemma 24.13)\nD\u0131.s; u/Cw.u;/ETB/\nD\u0131.s; /ETB/ (by Lemma 24.1) .\nBy the upper-bound property, /ETB:d/NAK\u0131.s; /ETB/ , from which we conclude that\n/ETB:dD\u0131.s; /ETB/ , and this equality is maintained thereafter.\nLemma 24.15 (Path-relaxation property)\nLetGD.V; E/ be a weighted, directed graph with weight function wWE! R,\nand let s2Vbe a source vertex. Consider any shortest path pDh/ETB0;/ETB1;:::;/ETB ki\nfrom sD/ETB0to/ETBk.I fGis initialized by I NITIALIZE -SINGLE -SOURCE .G; s/ and\nthen a sequence of relaxation steps occurs that includes, in order, relaxing the edges./ETB\n0;/ETB1/; ./ETB 1;/ETB2/ ;:::;. /ETB k/NUL1;/ETBk/,t h e n /ETBk:dD\u0131.s; /ETB k/after these relaxations and\nat all times afterward. This property holds no matter what other edge relaxationsoccur, including relaxations that are intermixed with relaxations of the edges of p.\nProof We show by induction that after the ith edge of path pis relaxed, we have\n/ETB\ni:dD\u0131.s; /ETB i/. For the basis, iD0, and before any edges of phave been relaxed,\nwe have from the initialization that /ETB0:dDs:dD0D\u0131.s; s/ . By the upper-bound\nproperty, the value of s:dnever changes after initialization.\nFor the inductive step, we assume that /ETBi/NUL1:dD\u0131.s; /ETB i/NUL1/,a n dw ee x a m i n e\nwhat happens when we relax edge ./ETBi/NUL1;/ETBi/. By the convergence property, after\nrelaxing this edge, we have /ETBi:dD\u0131.s; /ETB i/, and this equality is maintained at all\ntimes thereafter.\nRelaxation and shortest-paths trees\nWe now show that once a sequence of relaxations has caused the shortest-path es-\ntimates to converge to shortest-path weights, the predecessor subgraph G/EMinduced\nby the resulting /EMvalues is a shortest-paths tree for G. We start with the follow-\ning lemma, which shows that the predecessor subgraph always forms a rooted tree\nwhose root is the source.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "694": {"page_number": 695, "page_information": "674 Chapter 24 Single-Source Shortest Paths\nLemma 24.16\nLetGD.V; E/ be a weighted, directed graph with weight function wWE! R,\nlets2Vbe a source vertex, and assume that Gcontains no negative-weight\ncycles that are reachable from s. Then, after the graph is initialized by I NITIALIZE -\nSINGLE -SOURCE .G; s/ , the predecessor subgraph G/EMforms a rooted tree with\nroots, and any sequence of relaxation steps on edges of Gmaintains this property\nas an invariant.\nProof Initially, the only vertex in G/EMis the source vertex, and the lemma is triv-\nially true. Consider a predecessor subgraph G/EMthat arises after a sequence of\nrelaxation steps. We shall \ufb01rst prove that G/EMis acyclic. Suppose for the sake of\ncontradiction that some relaxation step creates a cycle in the graph G/EM.L e tt h ec y -\ncle be cDh/ETB0;/ETB1;:::;/ETB ki,w h e r e /ETBkD/ETB0. Then, /ETBi:/EMD/ETBi/NUL1foriD1 ;2;:::;k\nand, without loss of generality, we can assume that relaxing edge ./ETBk/NUL1;/ETBk/created\nthe cycle in G/EM.\nWe claim that all vertices on cycle care reachable from the source s. Why?\nEach vertex on chas a non- NILpredecessor, and so each vertex on cwas assigned\na \ufb01nite shortest-path estimate when it was assigned its non- NIL/EMvalue. By the\nupper-bound property, each vertex on cycle chas a \ufb01nite shortest-path weight,\nwhich implies that it is reachable from s.\nWe shall examine the shortest-path estimates on cjust prior to the call\nRELAX ./ETBk/NUL1;/ETBk;w/ and show that cis a negative-weight cycle, thereby contra-\ndicting the assumption that Gcontains no negative-weight cycles that are reachable\nfrom the source. Just before the call, we have /ETBi:/EMD/ETBi/NUL1foriD1 ;2;:::;k/NUL1.\nThus, for iD1 ;2;:::;k/NUL1, the last update to /ETBi:dwas by the assignment\n/ETBi:dD/ETBi/NUL1:dCw./ETB i/NUL1;/ETBi/.I f/ETBi/NUL1:dchanged since then, it decreased. Therefore,\njust before the call R ELAX ./ETBk/NUL1;/ETBk;w/,w eh a v e\n/ETBi:d/NAK/ETBi/NUL1:dCw./ETB i/NUL1;/ETBi/ for all iD1 ;2;:::;k/NUL1: (24.12)\nBecause /ETBk:/EMis changed by the call, immediately beforehand we also have the\nstrict inequality\n/ETBk:d>/ETB k/NUL1:dCw./ETB k/NUL1;/ETBk/:\nSumming this strict inequality with the k/NUL1inequalities (24.12), we obtain the\nsum of the shortest-path estimates around cycle c:\nkX\niD1/ETBi:d>kX\niD1./ETBi/NUL1:dCw./ETB i/NUL1;/ETBi//\nDkX\niD1/ETBi/NUL1:dCkX\niD1w./ETB i/NUL1;/ETBi/:", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "695": {"page_number": 696, "page_information": "24.5 Proofs of shortest-paths properties 675\nsux\nyzv\nFigure 24.9 Showing that a simple path in G/EMfrom source sto vertex /ETBis unique. If there are two\npaths p1(s;u;x!\u00b4;/ETB)a n d p2(s;u;y!\u00b4;/ETB), where x\u00a4y,t h e n \u00b4:/EMDx\nand\u00b4:/EMDy, a contradiction.\nBut\nkX\niD1/ETBi:dDkX\niD1/ETBi/NUL1:d;\nsince each vertex in the cycle cappears exactly once in each summation. This\nequality implies\n0>kX\niD1w./ETB i/NUL1;/ETBi/:\nThus, the sum of weights around the cycle cis negative, which provides the desired\ncontradiction.\nWe have now proven that G/EMis a directed, acyclic graph. To show that it forms\na rooted tree with root s, it suf\ufb01ces (see Exercise B.5-2) to prove that for each\nvertex /ETB2V/EM, there is a unique simple path from sto/ETBinG/EM.\nWe \ufb01rst must show that a path from sexists for each vertex in V/EM.T h e v e r -\ntices in V/EMare those with non- NIL/EMvalues, plus s. The idea here is to prove by\ninduction that a path exists from sto all vertices in V/EM. We leave the details as\nExercise 24.5-6.\nTo complete the proof of the lemma, we must now show that for any vertex\n/ETB2V/EM, the graph G/EMcontains at most one simple path from sto/ETB. Suppose other-\nwise. That is, suppose that, as Figure 24.9 illustrates, G/EMcontains two simple paths\nfrom sto some vertex /ETB:p1, which we decompose into s;u;x!\u00b4;/ETB,\nandp2, which we decompose into s;u;y!\u00b4;/ETB,w h e r e x\u00a4y(though u\ncould be sand\u00b4could be /ETB). But then, \u00b4:/EMDxand\u00b4:/EMDy, which implies\nthe contradiction that xDy. We conclude that G/EMcontains a unique simple path\nfrom sto/ETB, and thus G/EMforms a rooted tree with root s.\nWe can now show that if, after we have performed a sequence of relaxation steps,\nall vertices have been assigned their true shortest-path weights, then the predeces-sor subgraph G\n/EMis a shortest-paths tree.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "696": {"page_number": 697, "page_information": "676 Chapter 24 Single-Source Shortest Paths\nLemma 24.17 (Predecessor-subgraph property)\nLetGD.V; E/ be a weighted, directed graph with weight function wWE! R,\nlets2Vbe a source vertex, and assume that Gcontains no negative-weight cycles\nthat are reachable from s. Let us call I NITIALIZE -SINGLE -SOURCE .G; s/ and then\nexecute any sequence of relaxation steps on edges of Gthat produces /ETB:dD\u0131.s; /ETB/\nfor all /ETB2V. Then, the predecessor subgraph G/EMis a shortest-paths tree rooted\nats.\nProof We must prove that the three properties of shortest-paths trees given on\npage 647 hold for G/EM. To show the \ufb01rst property, we must show that V/EMis the set\nof vertices reachable from s. By de\ufb01nition, a shortest-path weight \u0131.s; /ETB/ is \ufb01nite\nif and only if /ETBis reachable from s, and thus the vertices that are reachable from s\nare exactly those with \ufb01nite dvalues. But a vertex /ETB2V/NULfsghas been assigned\na \ufb01nite value for /ETB:dif and only if /ETB:/EM\u00a4NIL. Thus, the vertices in V/EMare exactly\nthose reachable from s.\nThe second property follows directly from Lemma 24.16.\nIt remains, therefore, to prove the last property of shortest-paths trees: for each\nvertex /ETB2V/EM, the unique simple path sp;/ETBinG/EMis a shortest path from sto/ETB\ninG.L e t pDh/ETB0;/ETB1;:::;/ETB ki,w h e r e /ETB0Dsand/ETBkD/ETB.F o r iD1 ;2;:::;k ,\nwe have both /ETBi:dD\u0131.s; /ETB i/and/ETBi:d/NAK/ETBi/NUL1:dCw./ETB i/NUL1;/ETBi/, from which we\nconclude w./ETB i/NUL1;/ETBi//DC4\u0131.s; /ETB i//NUL\u0131.s; /ETB i/NUL1/. Summing the weights along path p\nyields\nw.p/DkX\niD1w./ETB i/NUL1;/ETBi/\n/DC4kX\niD1.\u0131.s; /ETB i//NUL\u0131.s; /ETB i/NUL1//\nD\u0131.s; /ETB k//NUL\u0131.s; /ETB 0/ (because the sum telescopes)\nD\u0131.s; /ETB k/ (because \u0131.s; /ETB 0/D\u0131.s; s/D0).\nThus, w.p//DC4\u0131.s; /ETB k/.S i n c e \u0131.s; /ETB k/is a lower bound on the weight of any path\nfrom sto/ETBk, we conclude that w.p/D\u0131.s; /ETB k/, and thus pis a shortest path\nfrom sto/ETBD/ETBk.\nExercises\n24.5-1\nGive two shortest-paths trees for the directed graph of Figure 24.2 (on page 648)other than the two shown.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "697": {"page_number": 698, "page_information": "24.5 Proofs of shortest-paths properties 677\n24.5-2\nGive an example of a weighted, directed graph GD.V; E/ with weight function\nwWE! Rand source vertex ssuch that Gsatis\ufb01es the following property: For\nevery edge .u; /ETB/2E, there is a shortest-paths tree rooted at sthat contains .u; /ETB/\nand another shortest-paths tree rooted at sthat does not contain .u; /ETB/ .\n24.5-3\nEmbellish the proof of Lemma 24.10 to handle cases in which shortest-pathweights are1or/NUL1.\n24.5-4\nLetGD.V; E/ be a weighted, directed graph with source vertex s,a n dl e t G\nbe initialized by I\nNITIALIZE -SINGLE -SOURCE .G; s/ . Prove that if a sequence of\nrelaxation steps sets s:/EMto a non- NILvalue, then Gcontains a negative-weight\ncycle.\n24.5-5\nLetGD.V; E/ be a weighted, directed graph with no negative-weight edges. Let\ns2Vbe the source vertex, and suppose that we allow /ETB:/EMto be the predecessor\nof/ETBonanyshortest path to /ETBfrom source sif/ETB2V/NULfsgis reachable from s,\nand NILotherwise. Give an example of such a graph Gand an assignment of /EM\nvalues that produces a cycle in G/EM. (By Lemma 24.16, such an assignment cannot\nbe produced by a sequence of relaxation steps.)\n24.5-6\nLetGD.V; E/ be a weighted, directed graph with weight function wWE!R\nand no negative-weight cycles. Let s2Vbe the source vertex, and let Gbe initial-\nized by I NITIALIZE -SINGLE -SOURCE .G; s/ . Prove that for every vertex /ETB2V/EM,\nthere exists a path from sto/ETBinG/EMand that this property is maintained as an\ninvariant over any sequence of relaxations.\n24.5-7\nLetGD.V; E/ be a weighted, directed graph that contains no negative-weight\ncycles. Let s2Vbe the source vertex, and let Gbe initialized by I NITIALIZE -\nSINGLE -SOURCE .G; s/ . Prove that there exists a sequence of jVj/NUL1relaxation\nsteps that produces /ETB:dD\u0131.s; /ETB/ for all /ETB2V.\n24.5-8\nLetGbe an arbitrary weighted, directed graph with a negative-weight cycle reach-\nable from the source vertex s. Show how to construct an in\ufb01nite sequence of relax-\nations of the edges of Gsuch that every relaxation causes a shortest-path estimate\nto change.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "698": {"page_number": 699, "page_information": "678 Chapter 24 Single-Source Shortest Paths\nProblems\n24-1 Yen\u2019s improvement to Bellman-Ford\nSuppose that we order the edge relaxations in each pass of the Bellman-Ford al-gorithm as follows. Before the \ufb01rst pass, we assign an arbitrary linear order/ETB\n1;/ETB2;:::;/ETB jVjto the vertices of the input graph GD.V; E/ . Then, we parti-\ntion the edge set EintoEf[Eb,w h e r e EfDf./ETBi;/ETBj/2EWi<jgand\nEbDf./ETBi;/ETBj/2EWi>jg. (Assume that Gcontains no self-loops, so that every\nedge is in either EforEb.) De\ufb01ne GfD.V; E f/andGbD.V; E b/.\na.Prove that Gfis acyclic with topological sort h/ETB1;/ETB2;:::;/ETB jVjiand that Gbis\nacyclic with topological sort h/ETBjVj;/ETBjVj/NUL1;:::;/ETB 1i.\nSuppose that we implement each pass of the Bellman-Ford algorithm in the fol-\nlowing way. We visit each vertex in the order /ETB1;/ETB2;:::;/ETB jVj, relaxing edges of Ef\nthat leave the vertex. We then visit each vertex in the order /ETBjVj;/ETBjVj/NUL1;:::;/ETB 1,\nrelaxing edges of Ebthat leave the vertex.\nb.Prove that with this scheme, if Gcontains no negative-weight cycles that are\nreachable from the source vertex s, then after onlydjVj=2epasses over the\nedges, /ETB:dD\u0131.s; /ETB/ for all vertices /ETB2V.\nc.Does this scheme improve the asymptotic running time of the Bellman-Ford\nalgorithm?\n24-2 Nesting boxes\nAd-dimensional box with dimensions .x1;x2;:::;x d/nests within another box\nwith dimensions .y1;y2;:::;y d/if there exists a permutation /EMonf1 ;2;:::;dg\nsuch that x/EM.1/<y 1,x/EM.2/<y 2,..., x/EM.d/<y d.\na.Argue that the nesting relation is transitive.\nb.Describe an ef\ufb01cient method to determine whether or not one d-dimensional\nbox nests inside another.\nc.Suppose that you are given a set of nd-dimensional boxes fB1;B2;:::;B ng.\nGive an ef\ufb01cient algorithm to \ufb01nd the longest sequence hBi1;Bi2;:::;B ikiof\nboxes such that Bijnests within BijC1forjD1 ;2;:::;k/NUL1. Express the\nrunning time of your algorithm in terms of nandd.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "699": {"page_number": 700, "page_information": "Problems for Chapter 24 679\n24-3 Arbitrage\nArbitrage is the use of discrepancies in currency exchange rates to transform one\nunit of a currency into more than one unit of the same currency. For example,suppose that 1U.S. dollar buys 49Indian rupees, 1Indian rupee buys 2Japanese\nyen, and 1Japanese yen buys 0:0107 U.S. dollars. Then, by converting currencies,\na trader can start with 1U.S. dollar and buy 49/STX2/STX0:0107D1:0486 U.S. dollars,\nthus turning a pro\ufb01t of 4:86 percent.\nSuppose that we are given ncurrencies c\n1;c2;:::;c nand an n/STXntable Rof\nexchange rates, such that one unit of currency cibuys R\u0152i;j/c141 units of currency cj.\na.Give an ef\ufb01cient algorithm to determine whether or not there exists a sequence\nof currencieshci1;ci2;:::;c ikisuch that\nR\u0152i 1;i2/c141/SOHR\u0152i 2;i3/c141/SOH/SOH/SOHR\u0152i k/NUL1;ik/c141/SOHR\u0152i k;i1/c141>1:\nAnalyze the running time of your algorithm.\nb.Give an ef\ufb01cient algorithm to print out such a sequence if one exists. Analyze\nthe running time of your algorithm.\n24-4 Gabow\u2019s scaling algorithm for single-source shortest paths\nAscaling algorithm solves a problem by initially considering only the highest-\norder bit of each relevant input value (such as an edge weight). It then re\ufb01nes theinitial solution by looking at the two highest-order bits. It progressively looks atmore and more high-order bits, re\ufb01ning the solution each time, until it has exam-ined all bits and computed the correct solution.\nIn this problem, we examine an algorithm for computing the shortest paths from\na single source by scaling edge weights. We are given a directed graph GD.V; E/\nwith nonnegative integer edge weights w.L e t WDmax\n.u;/ETB/ 2Efw.u;/ETB/g.O u r\ngoal is to develop an algorithm that runs in O.E lgW/time. We assume that all\nvertices are reachable from the source.\nThe algorithm uncovers the bits in the binary representation of the edge weights\none at a time, from the most signi\ufb01cant bit to the least signi\ufb01cant bit. Speci\ufb01cally,letkDdlg.WC1/ebe the number of bits in the binary representation of W,\nand for iD1 ;2;:::;k ,l e tw\ni.u; /ETB/D/EOT\nw.u;/ETB/=2k/NULi\u02d8\n.T h a t i s , wi.u; /ETB/ is the\n\u201cscaled-down\u201d version of w.u;/ETB/ g i v e nb yt h e imost signi\ufb01cant bits of w.u;/ETB/ .\n(Thus, wk.u; /ETB/Dw.u;/ETB/ for all .u; /ETB/2E.) For example, if kD5and\nw.u;/ETB/D25, which has the binary representation h11001i,t h e n w3.u; /ETB/D\nh110iD 6. As another example with kD5,i fw.u;/ETB/Dh00100iD 4,t h e n\nw3.u; /ETB/Dh001iD1. Let us de\ufb01ne \u0131i.u; /ETB/ as the shortest-path weight from\nvertex uto vertex /ETBusing weight function wi. Thus, \u0131k.u; /ETB/D\u0131.u;/ETB/ for all\nu; /ETB2V. For a given source vertex s, the scaling algorithm \ufb01rst computes the", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "700": {"page_number": 701, "page_information": "680 Chapter 24 Single-Source Shortest Paths\nshortest-path weights \u01311.s; /ETB/ for all /ETB2V, then computes \u01312.s; /ETB/ for all /ETB2V,\nand so on, until it computes \u0131k.s; /ETB/ for all /ETB2V. We assume throughout that\njEj/NAKjVj/NUL1, and we shall see that computing \u0131ifrom \u0131i/NUL1takes O.E/ time, so\nthat the entire algorithm takes O.kE/DO.E lgW/time.\na.Suppose that for all vertices /ETB2V,w eh a v e \u0131.s; /ETB//DC4jEj. Show that we can\ncompute \u0131.s; /ETB/ for all /ETB2VinO.E/ time.\nb.Show that we can compute \u01311.s; /ETB/ for all /ETB2VinO.E/ time.\nLet us now focus on computing \u0131ifrom \u0131i/NUL1.\nc.Prove that for iD2;3 ;:::;k , we have either wi.u; /ETB/D2wi/NUL1.u; /ETB/ or\nwi.u; /ETB/D2wi/NUL1.u; /ETB/C1. Then, prove that\n2\u0131i/NUL1.s; /ETB//DC4\u0131i.s; /ETB//DC42\u0131i/NUL1.s; /ETB/CjVj/NUL1\nfor all /ETB2V.\nd.De\ufb01ne for iD2;3 ;:::;k and all .u; /ETB/2E,\nywi.u; /ETB/Dwi.u; /ETB/C2\u0131i/NUL1.s; u//NUL2\u0131i/NUL1.s; /ETB/ :\nProve that for iD2;3 ;:::;k and all u; /ETB2V, the \u201creweighted\u201d value ywi.u; /ETB/\nof edge .u; /ETB/ is a nonnegative integer.\ne.Now, de\ufb01ney\u0131i.s; /ETB/ as the shortest-path weight from sto/ETBusing the weight\nfunctionywi. Prove that for iD2;3 ;:::;k and all /ETB2V,\n\u0131i.s; /ETB/Dy\u0131i.s; /ETB/C2\u0131i/NUL1.s; /ETB/\nand thaty\u0131i.s; /ETB//DC4jEj.\nf.Show how to compute \u0131i.s; /ETB/ from \u0131i/NUL1.s; /ETB/ for all /ETB2VinO.E/ time, and\nconclude that we can compute \u0131.s; /ETB/ for all /ETB2VinO.E lgW/time.\n24-5 Karp\u2019s minimum mean-weight cycle algorithm\nLetGD.V; E/ be a directed graph with weight function wWE! R,a n dl e t\nnDjVj.W ed e \ufb01 n et h e mean weight of a cycle cDhe1;e2;:::;e kiof edges in E\nto be\n/SYN.c/D1\nkkX\niD1w.e i/:", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "701": {"page_number": 702, "page_information": "Problems for Chapter 24 681\nLet/SYN/ETXDmin c/SYN.c/ ,w h e r e cranges over all directed cycles in G. We call a cycle c\nfor which /SYN.c/D/SYN/ETXaminimum mean-weight cycle . This problem investigates\nan ef\ufb01cient algorithm for computing /SYN/ETX.\nAssume without loss of generality that every vertex /ETB2Vis reachable from a\nsource vertex s2V.L e t \u0131.s; /ETB/ be the weight of a shortest path from sto/ETB,a n dl e t\n\u0131k.s; /ETB/ be the weight of a shortest path from sto/ETBconsisting of exactly kedges.\nIf there is no path from sto/ETBwith exactly kedges, then \u0131k.s; /ETB/D1 .\na.Show that if /SYN/ETXD0,t h e n Gcontains no negative-weight cycles and \u0131.s; /ETB/D\nmin 0/DC4k/DC4n/NUL1\u0131k.s; /ETB/ for all vertices /ETB2V.\nb.Show that if /SYN/ETXD0,t h e n\nmax\n0/DC4k/DC4n/NUL1\u0131n.s; /ETB//NUL\u0131k.s; /ETB/\nn/NULk/NAK0\nfor all vertices /ETB2V.(Hint: Use both properties from part (a).)\nc.Letcbe a0-weight cycle, and let uand/ETBbe any two vertices on c. Suppose\nthat/SYN/ETXD0and that the weight of the simple path from uto/ETBalong the cycle\nisx. Prove that \u0131.s; /ETB/D\u0131.s; u/Cx.(Hint: The weight of the simple path\nfrom /ETBtoualong the cycle is/NULx.)\nd.Show that if /SYN/ETXD0, then on each minimum mean-weight cycle there exists a\nvertex /ETBsuch that\nmax\n0/DC4k/DC4n/NUL1\u0131n.s; /ETB//NUL\u0131k.s; /ETB/\nn/NULkD0:\n(Hint: Show how to extend a shortest path to any vertex on a minimum mean-\nweight cycle along the cycle to make a shortest path to the next vertex on thecycle.)\ne.Show that if /SYN\n/ETXD0,t h e n\nmin\n/ETB2Vmax\n0/DC4k/DC4n/NUL1\u0131n.s; /ETB//NUL\u0131k.s; /ETB/\nn/NULkD0:\nf.Show that if we add a constant tto the weight of each edge of G,t h e n /SYN/ETX\nincreases by t. Use this fact to show that\n/SYN/ETXDmin\n/ETB2Vmax\n0/DC4k/DC4n/NUL1\u0131n.s; /ETB//NUL\u0131k.s; /ETB/\nn/NULk:\ng.Give an O.VE/ -time algorithm to compute /SYN/ETX.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "702": {"page_number": 703, "page_information": "682 Chapter 24 Single-Source Shortest Paths\n24-6 Bitonic shortest paths\nA sequence is bitonic if it monotonically increases and then monotonically de-\ncreases, or if by a circular shift it monotonically increases and then monotonicallydecreases. For example the sequences h1; 4; 6; 8; 3;/NUL2i,h9; 2;/NUL4;/NUL10;/NUL5i,a n d\nh1; 2; 3; 4iare bitonic, buth1; 3; 12; 4; 2; 10iis not bitonic. (See Problem 15-3 for\nthe bitonic euclidean traveling-salesman problem.)\nSuppose that we are given a directed graph GD.V; E/ with weight function\nwWE!R, where all edge weights are unique, and we wish to \ufb01nd single-source\nshortest paths from a source vertex s. We are given one additional piece of infor-\nmation: for each vertex /ETB2V, the weights of the edges along any shortest path\nfrom sto/ETBform a bitonic sequence.\nGive the most ef\ufb01cient algorithm you can to solve this problem, and analyze its\nrunning time.\nChapter notes\nDijkstra\u2019s algorithm [88] appeared in 1959, but it contained no mention of a priorityqueue. The Bellman-Ford algorithm is based on separate algorithms by Bellman\n[38] and Ford [109]. Bellman describes the relation of shortest paths to difference\nconstraints. Lawler [224] describes the linear-time algorithm for shortest paths ina dag, which he considers part of the folklore.\nWhen edge weights are relatively small nonnegative integers, we have more ef-\n\ufb01cient algorithms to solve the single-source shortest-paths problem. The sequenceof values returned by the E\nXTRACT -MINcalls in Dijkstra\u2019s algorithm monoton-\nically increases over time. As discussed in the chapter notes for Chapter 6, in\nthis case several data structures can implement the various priority-queue opera-\ntions more ef\ufb01ciently than a binary heap or a Fibonacci heap. Ahuja, Mehlhorn,\nOrlin, and Tarjan [8] give an algorithm that runs in O.ECVp\nlgW/time on\ngraphs with nonnegative edge weights, where Wis the largest weight of any edge\nin the graph. The best bounds are by Thorup [337], who gives an algorithm thatruns in O.E lg lgV/time, and by Raman [291], who gives an algorithm that runs\ninO/NUL\nECVmin\u02da\n.lgV/\n1=3C/SI;.lgW/1=4C/SI/TAB/SOH\ntime. These two algorithms use an\namount of space that depends on the word size of the underlying machine. Al-\nthough the amount of space used can be unbounded in the size of the input, it canbe reduced to be linear in the size of the input using randomized hashing.\nFor undirected graphs with integer weights, Thorup [336] gives an O.VCE/-\ntime algorithm for single-source shortest paths. In contrast to the algorithms men-tioned in the previous paragraph, this algorithm is not an implementation of Dijk-", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "703": {"page_number": 704, "page_information": "Notes for Chapter 24 683\nstra\u2019s algorithm, since the sequence of values returned by E XTRACT -MINcalls\ndoes not monotonically increase over time.\nFor graphs with negative edge weights, an algorithm due to Gabow and Tar-\njan [122] runs in O.p\nVElg.V W // time, and one by Goldberg [137] runs in\nO.p\nVElgW/time, where WDmax .u;/ETB/ 2Efjw.u;/ETB/jg.\nCherkassky, Goldberg, and Radzik [64] conducted extensive experiments com-\nparing various shortest-path algorithms.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "704": {"page_number": 705, "page_information": "25 All-Pairs Shortest Paths\nIn this chapter, we consider the problem of \ufb01nding shortest paths between all pairs\nof vertices in a graph. This problem might arise in making a table of distances be-tween all pairs of cities for a road atlas. As in Chapter 24, we are given a weighted,directed graph GD.V; E/ with a weight function wWE! Rthat maps edges\nto real-valued weights. We wish to \ufb01nd, for every pair of vertices u; /ETB2V,a\nshortest (least-weight) path from uto/ETB, where the weight of a path is the sum of\nthe weights of its constituent edges. We typically want the output in tabular form:the entry in u\u2019s row and /ETB\u2019s column should be the weight of a shortest path from u\nto/ETB.\nWe can solve an all-pairs shortest-paths problem by running a single-source\nshortest-paths algorithm jVjtimes, once for each vertex as the source. If all\nedge weights are nonnegative, we can use Dijkstra\u2019s algorithm. If we usethe linear-array implementation of the min-priority queue, the running time isO.V\n3CVE/DO.V3/. The binary min-heap implementation of the min-priority\nqueue yields a running time of O.VE lgV/, which is an improvement if the graph\nis sparse. Alternatively, we can implement the min-priority queue with a Fibonacciheap, yielding a running time of O.V\n2lgVCVE/.\nIf the graph has negative-weight edges, we cannot use Dijkstra\u2019s algorithm. In-\nstead, we must run the slower Bellman-Ford algorithm once from each vertex. Theresulting running time is O.V\n2E/, which on a dense graph is O.V4/. In this chap-\nter we shall see how to do better. We also investigate the relation of the all-pairsshortest-paths problem to matrix multiplication and study its algebraic structure.\nUnlike the single-source algorithms, which assume an adjacency-list represen-\ntation of the graph, most of the algorithms in this chapter use an adjacency-matrix representation. (Johnson\u2019s algorithm for sparse graphs, in Section 25.3,uses adjacency lists.) For convenience, we assume that the vertices are numbered1 ;2;:::;jVj, so that the input is an n/STXnmatrix Wrepresenting the edge weights\nof an n-vertex directed graph GD.V; E/ .T h a ti s , WD.w\nij/,w h e r e", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "705": {"page_number": 706, "page_information": "Chapter 25 All-Pairs Shortest Paths 685\nwijD/c128\n0 ifiDj;\nthe weight of directed edge .i; j / ifi\u00a4jand.i; j /2E;\n1 ifi\u00a4jand.i; j /62E:(25.1)\nWe allow negative-weight edges, but we assume for the time being that the input\ngraph contains no negative-weight cycles.\nThe tabular output of the all-pairs shortest-paths algorithms presented in this\nchapter is an n/STXnmatrix DD.dij/, where entry dijcontains the weight of a\nshortest path from vertex ito vertex j. That is, if we let \u0131.i;j/ denote the shortest-\npath weight from vertex ito vertex j(as in Chapter 24), then dijD\u0131.i;j/ at\ntermination.\nTo solve the all-pairs shortest-paths problem on an input adjacency matrix, we\nneed to compute not only the shortest-path weights but also a predecessor matrix\n\u2026D./EMij/,w h e r e /EMijisNILif either iDjor there is no path from itoj,\nand otherwise /EMijis the predecessor of jon some shortest path from i.J u s t a s\nthe predecessor subgraph G/EMfrom Chapter 24 is a shortest-paths tree for a given\nsource vertex, the subgraph induced by the ith row of the \u2026matrix should be a\nshortest-paths tree with root i. For each vertex i2V,w ed e \ufb01 n et h e predecessor\nsubgraph ofGforiasG/EM;iD.V/EM;i;E/EM;i/,w h e r e\nV/EM;iDfj2VW/EMij\u00a4NILg[fig\nand\nE/EM;iDf./EMij;j/Wj2V/EM;i/NULfigg:\nIfG/EM;iis a shortest-paths tree, then the following procedure, which is a modi\ufb01ed\nversion of the P RINT -PATH procedure from Chapter 22, prints a shortest path from\nvertex ito vertex j.\nPRINT -ALL-PAIRS -SHORTEST -PATH. \u2026 ;i;j/\n1ifi==j\n2 print i\n3elseif /EMij==NIL\n4 print \u201cno path from\u201d i\u201cto\u201dj\u201cexists\u201d\n5elsePRINT -ALL-PAIRS -SHORTEST -PATH. \u2026 ;i;/EM ij/\n6 print j\nIn order to highlight the essential features of the all-pairs algorithms in this chapter,\nwe won\u2019t cover the creation and properties of predecessor matrices as extensivelyas we dealt with predecessor subgraphs in Chapter 24. Some of the exercises cover\nthe basics.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "706": {"page_number": 707, "page_information": "686 Chapter 25 All-Pairs Shortest Paths\nChapter outline\nSection 25.1 presents a dynamic-programming algorithm based on matrix multi-\nplication to solve the all-pairs shortest-paths problem. Using the technique of \u201cre-peated squaring,\u201d we can achieve a running time of \u201a.V\n3lgV/. Section 25.2 gives\nanother dynamic-programming algorithm, the Floyd-Warshall algorithm, whichruns in time \u201a.V\n3/. Section 25.2 also covers the problem of \ufb01nding the tran-\nsitive closure of a directed graph, which is related to the all-pairs shortest-pathsproblem. Finally, Section 25.3 presents Johnson\u2019s algorithm, which solves the all-pairs shortest-paths problem in O.V\n2lgVCVE/ time and is a good choice for\nlarge, sparse graphs.\nBefore proceeding, we need to establish some conventions for adjacency-matrix\nrepresentations. First, we shall generally assume that the input graph GD.V; E/\nhasnvertices, so that nDjVj. Second, we shall use the convention of denoting\nmatrices by uppercase letters, such as W,L,o rD, and their individual elements\nby subscripted lowercase letters, such as wij,lij,o rdij. Some matrices will have\nparenthesized superscripts, as in L.m/D/NUL\nl.m/\nij/SOH\norD.m/D/NUL\nd.m/\nij/SOH\n, to indicate\niterates. Finally, for a given n/STXnmatrix A, we shall assume that the value of nis\nstored in the attribute A:rows .\n25.1 Shortest paths and matrix multiplication\nThis section presents a dynamic-programming algorithm for the all-pairs shortest-\npaths problem on a directed graph GD.V; E/ . Each major loop of the dynamic\nprogram will invoke an operation that is very similar to matrix multiplication, sothat the algorithm will look like repeated matrix multiplication. We shall start bydeveloping a \u201a.V\n4/-time algorithm for the all-pairs shortest-paths problem and\nthen improve its running time to \u201a.V3lgV/.\nBefore proceeding, let us brie\ufb02y recap the steps given in Chapter 15 for devel-\noping a dynamic-programming algorithm.\n1. Characterize the structure of an optimal solution.\n2. Recursively de\ufb01ne the value of an optimal solution.\n3. Compute the value of an optimal solution in a bottom-up fashion.\nWe reserve the fourth step\u2014constructing an optimal solution from computed in-\nformation\u2014for the exercises.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "707": {"page_number": 708, "page_information": "25.1 Shortest paths and matrix multiplication 687\nThe structure of a shortest path\nWe start by characterizing the structure of an optimal solution. For the all-pairs\nshortest-paths problem on a graph GD.V; E/ , we have proven (Lemma 24.1)\nthat all subpaths of a shortest path are shortest paths. Suppose that we representthe graph by an adjacency matrix WD.w\nij/. Consider a shortest path pfrom\nvertex ito vertex j, and suppose that pcontains at most medges. Assuming that\nthere are no negative-weight cycles, mis \ufb01nite. If iDj,t h e n phas weight 0\nand no edges. If vertices iandjare distinct, then we decompose path pinto\nip0\n;k!j, where path p0now contains at most m/NUL1edges. By Lemma 24.1,\np0is a shortest path from itok,a n ds o \u0131.i;j/D\u0131.i;k/Cwkj.\nA recursive solution to the all-pairs shortest-paths problem\nNow, let l.m/\nijbe the minimum weight of any path from vertex ito vertex jthat\ncontains at most medges. When mD0, there is a shortest path from itojwith\nno edges if and only if iDj. Thus,\nl.0/\nijD(\n0 ifiDj;\n1 ifi\u00a4j:\nForm/NAK1, we compute l.m/\nijas the minimum of l.m/NUL1/\nij (the weight of a shortest\npath from itojconsisting of at most m/NUL1edges) and the minimum weight of any\npath from itojconsisting of at most medges, obtained by looking at all possible\npredecessors kofj. Thus, we recursively de\ufb01ne\nl.m/\nijDmin/DLE\nl.m/NUL1/\nij ;min\n1/DC4k/DC4n\u02da\nl.m/NUL1/\nikCwkj/TAB/DC1\nD min\n1/DC4k/DC4n\u02da\nl.m/NUL1/\nikCwkj/TAB\n: (25.2)\nThe latter equality follows since wjjD0for all j.\nWhat are the actual shortest-path weights \u0131.i;j/ ? If the graph contains\nno negative-weight cycles, then for every pair of vertices iandjfor which\n\u0131.i;j/ <1, there is a shortest path from itojthat is simple and thus contains at\nmost n/NUL1edges. A path from vertex ito vertex jwith more than n/NUL1edges\ncannot have lower weight than a shortest path from itoj. The actual shortest-path\nweights are therefore given by\n\u0131.i;j/Dl.n/NUL1/\nijDl.n/\nijDl.nC1/\nijD/SOH/SOH/SOH : (25.3)", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "708": {"page_number": 709, "page_information": "688 Chapter 25 All-Pairs Shortest Paths\nComputing the shortest-path weights bottom up\nTaking as our input the matrix WD.wij/, we now compute a series of matrices\nL.1/;L.2/;:::;L.n/NUL1/, where for mD1 ;2;:::;n/NUL1,w eh a v e L.m/D/NUL\nl.m/\nij/SOH\n.\nThe \ufb01nal matrix L.n/NUL1/contains the actual shortest-path weights. Observe that\nl.1/\nijDwijfor all vertices i;j2V,a n ds o L.1/DW.\nThe heart of the algorithm is the following procedure, which, given matrices\nL.m/NUL1/andW, returns the matrix L.m/. That is, it extends the shortest paths com-\nputed so far by one more edge.\nEXTEND -SHORTEST -PATHS .L; W /\n1nDL:rows\n2l e t L0D/NUL\nl0\nij/SOH\nbe a new n/STXnmatrix\n3foriD1ton\n4 forjD1ton\n5 l0\nijD1\n6 forkD1ton\n7 l0\nijDmin.l0\nij;likCwkj/\n8return L0\nThe procedure computes a matrix L0D.l0\nij/, which it returns at the end. It does so\nby computing equation (25.2) for all iandj,u s i n g LforL.m/NUL1/andL0forL.m/.\n(It is written without the superscripts to make its input and output matrices inde-pendent of m.) Its running time is \u201a.n\n3/due to the three nested forloops.\nNow we can see the relation to matrix multiplication. Suppose we wish to com-\npute the matrix product CDA/SOHBof two n/STXnmatrices AandB. Then, for\ni;jD1 ;2;:::;n , we compute\ncijDnX\nkD1aik/SOHbkj: (25.4)\nObserve that if we make the substitutions\nl.m/NUL1/!a;\nw!b;\nl.m/!c;\nmin!C ;\nC!/SOH\nin equation (25.2), we obtain equation (25.4). Thus, if we make these changes to\nEXTEND -SHORTEST -PATHS and also replace1(the identity for min) by 0(the", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "709": {"page_number": 710, "page_information": "25.1 Shortest paths and matrix multiplication 689\nidentity forC), we obtain the same \u201a.n3/-time procedure for multiplying square\nmatrices that we saw in Section 4.2:\nSQUARE -MATRIX -MULTIPLY .A; B/\n1nDA:rows\n2l e t Cb ean e w n/STXnmatrix\n3foriD1ton\n4 forjD1ton\n5 cijD0\n6 forkD1ton\n7 cijDcijCaik/SOHbkj\n8return C\nReturning to the all-pairs shortest-paths problem, we compute the shortest-path\nweights by extending shortest paths edge by edge. Letting A/SOHBdenote the ma-\ntrix \u201cproduct\u201d returned by E XTEND -SHORTEST -PATHS .A; B/ , we compute the se-\nquence of n/NUL1matrices\nL.1/D L.0//SOHWDW;\nL.2/D L.1//SOHWDW2;\nL.3/D L.2//SOHWDW3;\n:::\nL.n/NUL1/DL.n/NUL2//SOHWDWn/NUL1:\nAs we argued above, the matrix L.n/NUL1/DWn/NUL1contains the shortest-path weights.\nThe following procedure computes this sequence in \u201a.n4/time.\nSLOW -ALL-PAIRS -SHORTEST -PATHS .W /\n1nDW:rows\n2L.1/DW\n3formD2ton/NUL1\n4l e t L.m/b ean e w n/STXnmatrix\n5 L.m/DEXTEND -SHORTEST -PATHS .L.m/NUL1/;W/\n6return L.n/NUL1/\nFigure 25.1 shows a graph and the matrices L.m/computed by the procedure\nSLOW -ALL-PAIRS -SHORTEST -PATHS .\nImproving the running time\nOur goal, however, is not to compute alltheL.m/matrices: we are interested\nonly in matrix L.n/NUL1/. Recall that in the absence of negative-weight cycles, equa-", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "710": {"page_number": 711, "page_information": "690 Chapter 25 All-Pairs Shortest Paths\n2\n1 3\n5 434\n82\n671\u20134 \u20135\nL.1/D/EOT03 81/NUL 4\n1 01 17\n1 4011\n21/NUL 501\n111 60\u02d8\nL.2/D/EOT038 2 /NUL4\n30/NUL41 7\n1 40 5 1 1\n2/NUL1/NUL50/NUL2\n81 16 0\u02d8\nL.3/D/EOT03/NUL32/NUL4\n30/NUL41/NUL1\n740 5 1 1\n2/NUL1/NUL50/NUL2\n851 60\u02d8\nL.4/D/EOT01/NUL32/NUL4\n30/NUL41/NUL1\n740 53\n2/NUL1/NUL50/NUL2\n851 60\u02d8\nFigure 25.1 A directed graph and the sequence of matrices L.m/computed by S LOW -ALL-PAIRS -\nSHORTEST -PAT HS . You might want to verify that L.5/,d e \ufb01 n e da s L.4//SOHW, equals L.4/, and thus\nL.m/DL.4/for all m/NAK4.\ntion (25.3) implies L.m/DL.n/NUL1/for all integers m/NAKn/NUL1. Just as tradi-\ntional matrix multiplication is associative, so is matrix multiplication de\ufb01ned by\nthe E XTEND -SHORTEST -PATHS procedure (see Exercise 25.1-4). Therefore, we\ncan compute L.n/NUL1/with onlydlg.n/NUL1/ematrix products by computing the se-\nquence\nL.1/D W;\nL.2/D W2DW/SOHW;\nL.4/D W4DW2/SOHW2\nL.8/D W8DW4/SOHW4;\n:::\nL.2dlg.n/NUL1/e/DW2dlg.n/NUL1/eDW2dlg.n/NUL1/e/NUL1/SOHW2dlg.n/NUL1/e/NUL1:\nSince 2dlg.n/NUL1/e/NAKn/NUL1, the \ufb01nal product L.2dlg.n/NUL1/e/is equal to L.n/NUL1/.\nThe following procedure computes the above sequence of matrices by using this\ntechnique of repeated squaring .", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "711": {"page_number": 712, "page_information": "25.1 Shortest paths and matrix multiplication 691\n12\n35 \u20131 2123\n456\u20134 \u20138 10 7\nFigure 25.2 A weighted, directed graph for use in Exercises 25.1-1, 25.2-1, and 25.3-1.\nFASTER -ALL-PAIRS -SHORTEST -PATHS .W /\n1nDW:rows\n2L.1/DW\n3mD1\n4while m<n/NUL1\n5l e t L.2m/be a new n/STXnmatrix\n6 L.2m/DEXTEND -SHORTEST -PATHS .L.m/;L.m//\n7 mD2m\n8return L.m/\nIn each iteration of the while loop of lines 4\u20137, we compute L.2m/D/NUL\nL.m//SOH2,\nstarting with mD1. At the end of each iteration, we double the value\nofm. The \ufb01nal iteration computes L.n/NUL1/by actually computing L.2m/for some\nn/NUL1/DC42m < 2n/NUL2. By equation (25.3), L.2m/DL.n/NUL1/. The next time the test\nin line 4 is performed, mhas been doubled, so now m/NAKn/NUL1, the test fails, and\nthe procedure returns the last matrix it computed.\nBecause each of the dlg.n/NUL1/ematrix products takes \u201a.n3/time, F ASTER -\nALL-PAIRS -SHORTEST -PATHS runs in \u201a.n3lgn/time. Observe that the code\nis tight, containing no elaborate data structures, and the constant hidden in the\n\u201a-notation is therefore small.\nExercises\n25.1-1\nRun S LOW -ALL-PAIRS -SHORTEST -PATHS on the weighted, directed graph of\nFigure 25.2, showing the matrices that result for each iteration of the loop. Then\ndo the same for F ASTER -ALL-PAIRS -SHORTEST -PATHS .\n25.1-2\nWhy do we require that wiiD0for all 1/DC4i/DC4n?", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "712": {"page_number": 713, "page_information": "692 Chapter 25 All-Pairs Shortest Paths\n25.1-3\nWhat does the matrix\nL.0/D/NUL\n01 1 /SOH/SOH/SOH 1\n1 01 /SOH/SOH/SOH 1\n11 0/SOH/SOH/SOH 1\n:::::::::::::::\n111/SOH /SOH /SOH 0/SOH\nused in the shortest-paths algorithms correspond to in regular matrix multiplica-\ntion?\n25.1-4\nShow that matrix multiplication de\ufb01ned by E XTEND -SHORTEST -PATHS is asso-\nciative.\n25.1-5\nShow how to express the single-source shortest-paths problem as a product of ma-trices and a vector. Describe how evaluating this product corresponds to a Bellman-Ford-like algorithm (see Section 24.1).\n25.1-6\nSuppose we also wish to compute the vertices on shortest paths in the algorithms ofthis section. Show how to compute the predecessor matrix \u2026from the completed\nmatrix Lof shortest-path weights in O.n\n3/time.\n25.1-7\nWe can also compute the vertices on shortest paths as we compute the shortest-\npath weights. De\ufb01ne /EM.m/\nijas the predecessor of vertex jon any minimum-weight\npath from itojthat contains at most medges. Modify the E XTEND -SHORTEST -\nPATHS and S LOW -ALL-PAIRS -SHORTEST -PATHS procedures to compute the ma-\ntrices \u2026.1/;\u2026.2/;:::;\u2026.n/NUL1/as the matrices L.1/;L.2/;:::;L.n/NUL1/are computed.\n25.1-8\nThe F ASTER -ALL-PAIRS -SHORTEST -PATHS procedure, as written, requires us to\nstoredlg.n/NUL1/ematrices, each with n2elements, for a total space requirement of\n\u201a.n2lgn/. Modify the procedure to require only \u201a.n2/space by using only two\nn/STXnmatrices.\n25.1-9\nModify F ASTER -ALL-PAIRS -SHORTEST -PATHS so that it can determine whether\nthe graph contains a negative-weight cycle.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "713": {"page_number": 714, "page_information": "25.2 The Floyd-Warshall algorithm 693\n25.1-10\nGive an ef\ufb01cient algorithm to \ufb01nd the length (number of edges) of a minimum-length negative-weight cycle in a graph.\n25.2 The Floyd-Warshall algorithm\nIn this section, we shall use a different dynamic-programming formulation to solvethe all-pairs shortest-paths problem on a directed graph GD.V; E/ . The result-\ning algorithm, known as the Floyd-Warshall algorithm , runs in \u201a.V\n3/time. As\nbefore, negative-weight edges may be present, but we assume that there are nonegative-weight cycles. As in Section 25.1, we follow the dynamic-programmingprocess to develop the algorithm. After studying the resulting algorithm, wepresent a similar method for \ufb01nding the transitive closure of a directed graph.\nThe structure of a shortest path\nIn the Floyd-Warshall algorithm, we characterize the structure of a shortest path\ndifferently from how we characterized it in Section 25.1. The Floyd-Warshall algo-rithm considers the intermediate vertices of a shortest path, where an intermediate\nvertex of a simple path pDh/ETB\n1;/ETB2;:::;/ETB liis any vertex of pother than /ETB1or/ETBl,\nthat is, any vertex in the set f/ETB2;/ETB3;:::;/ETB l/NUL1g.\nThe Floyd-Warshall algorithm relies on the following observation. Under our\nassumption that the vertices of GareVDf1 ;2;:::;ng, let us consider a subset\nf1 ;2;:::;kgof vertices for some k. For any pair of vertices i;j2V, consider all\npaths from itojwhose intermediate vertices are all drawn from f1 ;2;:::;kg,a n d\nletpbe a minimum-weight path from among them. (Path pis simple.) The Floyd-\nWarshall algorithm exploits a relationship between path pand shortest paths from i\ntojwith all intermediate vertices in the set f1 ;2;:::;k/NUL1g. The relationship\ndepends on whether or not kis an intermediate vertex of path p.\n/SIIfkis not an intermediate vertex of path p, then all intermediate vertices of\npath pare in the setf1 ;2;:::;k/NUL1g. Thus, a shortest path from vertex i\nto vertex jwith all intermediate vertices in the set f1 ;2;:::;k/NUL1gis also a\nshortest path from itojwith all intermediate vertices in the set f1 ;2;:::;kg.\n/SIIfkis an intermediate vertex of path p, then we decompose pintoip1;kp2;j,\nas Figure 25.3 illustrates. By Lemma 24.1, p1is a shortest path from itok\nwith all intermediate vertices in the set f1 ;2;:::;kg. In fact, we can make a\nslightly stronger statement. Because vertex kis not an intermediate vertex of\npathp1, all intermediate vertices of p1are in the setf1 ;2;:::;k/NUL1g.T h e r e -", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "714": {"page_number": 715, "page_information": "694 Chapter 25 All-Pairs Shortest Paths\nik\njp1 p2\np: all intermediate vertices in f1 ;2;:::;kgall intermediate vertices in f1 ;2;:::;k/NUL1g all intermediate vertices in f1 ;2;:::;k/NUL1g\nFigure 25.3 Path pis a shortest path from vertex ito vertex j,a n d kis the highest-numbered\nintermediate vertex of p.P a t h p1, the portion of path pfrom vertex ito vertex k, has all intermediate\nvertices in the setf1 ;2;:::;k/NUL1g. The same holds for path p2from vertex kto vertex j.\nfore, p1is a shortest path from itokwith all intermediate vertices in the set\nf1 ;2;:::;k/NUL1g. Similarly, p2is a shortest path from vertex kto vertex jwith\nall intermediate vertices in the set f1 ;2;:::;k/NUL1g.\nA recursive solution to the all-pairs shortest-paths problem\nBased on the above observations, we de\ufb01ne a recursive formulation of shortest-\npath estimates that differs from the one in Section 25.1. Let d.k/\nijbe the weight\nof a shortest path from vertex ito vertex jfor which all intermediate vertices\nare in the setf1 ;2;:::;kg.W h e n kD0, a path from vertex ito vertex jwith\nno intermediate vertex numbered higher than 0has no intermediate vertices at all.\nSuch a path has at most one edge, and hence d.0/\nijDwij. Following the above\ndiscussion, we de\ufb01ne d.k/\nijrecursively by\nd.k/\nijD(\nwij ifkD0;\nmin/NUL\nd.k/NUL1/\nij;d.k/NUL1/\nikCd.k/NUL1/\nkj/SOH\nifk/NAK1:(25.5)\nBecause for any path, all intermediate vertices are in the set f1 ;2;:::;ng,t h em a -\ntrixD.n/D/NUL\nd.n/\nij/SOH\ngives the \ufb01nal answer: d.n/\nijD\u0131.i;j/ for all i;j2V.\nComputing the shortest-path weights bottom up\nBased on recurrence (25.5), we can use the following bottom-up procedure to com-\npute the values d.k/\nijin order of increasing values of k. Its input is an n/STXnmatrix W\nde\ufb01ned as in equation (25.1). The procedure returns the matrix D.n/of shortest-\npath weights.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "715": {"page_number": 716, "page_information": "25.2 The Floyd-Warshall algorithm 695\nFLOYD -WARSHALL .W /\n1nDW:rows\n2D.0/DW\n3forkD1ton\n4l e t D.k/D/NUL\nd.k/\nij/SOH\nb ean e w n/STXnmatrix\n5 foriD1ton\n6 forjD1ton\n7 d.k/\nijDmin/NUL\nd.k/NUL1/\nij;d.k/NUL1/\nikCd.k/NUL1/\nkj/SOH\n8return D.n/\nFigure 25.4 shows the matrices D.k/computed by the Floyd-Warshall algorithm\nfor the graph in Figure 25.1.\nThe running time of the Floyd-Warshall algorithm is determined by the triply\nnested forloops of lines 3\u20137. Because each execution of line 7 takes O.1/ time,\nthe algorithm runs in time \u201a.n3/. As in the \ufb01nal algorithm in Section 25.1, the\ncode is tight, with no elaborate data structures, and so the constant hidden in the\n\u201a-notation is small. Thus, the Floyd-Warshall algorithm is quite practical for even\nmoderate-sized input graphs.\nConstructing a shortest path\nThere are a variety of different methods for constructing shortest paths in the Floyd-\nWarshall algorithm. One way is to compute the matrix Dof shortest-path weights\nand then construct the predecessor matrix \u2026from the Dmatrix. Exercise 25.1-6\nasks you to implement this method so that it runs in O.n3/time. Given the pre-\ndecessor matrix \u2026,t h eP RINT -ALL-PAIRS -SHORTEST -PATH procedure will print\nthe vertices on a given shortest path.\nAlternatively, we can compute the predecessor matrix \u2026while the algorithm\ncomputes the matrices D.k/. Speci\ufb01cally, we compute a sequence of matrices\n\u2026.0/;\u2026.1/;:::;\u2026.n/,w h e r e \u2026D\u2026.n/and we de\ufb01ne /EM.k/\nijas the predecessor of\nvertex jon a shortest path from vertex iwith all intermediate vertices in the set\nf1 ;2;:::;kg.\nWe can give a recursive formulation of /EM.k/\nij.W h e n kD0, a shortest path from i\ntojhas no intermediate vertices at all. Thus,\n/EM.0/\nijD(\nNIL ifiDjorwijD1 ;\ni ifi\u00a4jandwij<1:(25.6)\nFork/NAK1, if we take the path i;k;j,w h e r e k\u00a4j, then the predecessor\nofjwe choose is the same as the predecessor of jwe chose on a shortest path\nfrom kwith all intermediate vertices in the set f1 ;2;:::;k/NUL1g. Otherwise, we", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "716": {"page_number": 717, "page_information": "696 Chapter 25 All-Pairs Shortest Paths\nD.0/D/EOT03 81/NUL 4\n1 01 17\n1 4011\n21/NUL 501\n111 60\u02d8\n\u2026.0/D/EOT\nNIL 11 NIL 1\nNIL NIL NIL 22\nNIL 3 NIL NIL NIL\n4 NIL 4 NIL NIL\nNIL NIL NIL 5 NIL\u02d8\nD.1/D/EOT03 81/NUL 4\n1 01 17\n1 4011\n25/NUL50/NUL2\n111 60\u02d8\n\u2026.1/D/EOT\nNIL 11 NIL 1\nNIL NIL NIL 22\nNIL 3 NIL NIL NIL\n414 NIL 1\nNIL NIL NIL 5 NIL\u02d8\nD.2/D/EOT03 8 4/NUL4\n1 01 17\n1 40 5 1 1\n25/NUL50/NUL2\n111 60\u02d8\n\u2026.2/D/EOT\nNIL 1121\nNIL NIL NIL 22\nNIL 3 NIL 22\n414 NIL 1\nNIL NIL NIL 5 NIL\u02d8\nD.3/D/EOT038 4 /NUL4\n1 01 17\n1 40 5 1 1\n2/NUL1/NUL50/NUL2\n111 60\u02d8\n\u2026.3/D/EOT\nNIL 1121\nNIL NIL NIL 22\nNIL 3 NIL 22\n434 NIL 1\nNIL NIL NIL 5 NIL\u02d8\nD.4/D/EOT03/NUL14/NUL4\n30/NUL41/NUL1\n740 53\n2/NUL1/NUL50/NUL2\n851 60\u02d8\n\u2026.4/D/EOT\nNIL 1421\n4 NIL 421\n43 NIL 21\n434 NIL 1\n4345 NIL\u02d8\nD.5/D/EOT01/NUL32/NUL4\n30/NUL41/NUL1\n740 53\n2/NUL1/NUL50/NUL2\n851 60\u02d8\n\u2026.5/D/EOT\nNIL 3451\n4 NIL 421\n43 NIL 21\n434 NIL 1\n4345 NIL\u02d8\nFigure 25.4 The sequence of matrices D.k/and\u2026.k/computed by the Floyd-Warshall algorithm\nfor the graph in Figure 25.1.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "717": {"page_number": 718, "page_information": "25.2 The Floyd-Warshall algorithm 697\nchoose the same predecessor of jthat we chose on a shortest path from iwith all\nintermediate vertices in the set f1 ;2;:::;k/NUL1g. Formally, for k/NAK1,\n/EM.k/\nijD(\n/EM.k/NUL1/\nij ifd.k/NUL1/\nij/DC4d.k/NUL1/\nikCd.k/NUL1/\nkj;\n/EM.k/NUL1/\nkjifd.k/NUL1/\nij >d.k/NUL1/\nikCd.k/NUL1/\nkj:(25.7)\nWe leave the incorporation of the \u2026.k/matrix computations into the F LOYD -\nWARSHALL procedure as Exercise 25.2-3. Figure 25.4 shows the sequence of \u2026.k/\nmatrices that the resulting algorithm computes for the graph of Figure 25.1. The\nexercise also asks for the more dif\ufb01cult task of proving that the predecessor sub-\ngraph G/EM;iis a shortest-paths tree with root i. Exercise 25.2-7 asks for yet another\nway to reconstruct shortest paths.\nTransitive closure of a directed graph\nGiven a directed graph GD.V; E/ with vertex set VDf1 ;2;:::;ng, we might\nwish to determine whether Gcontains a path from itojfor all vertex pairs\ni;j2V.W ed e \ufb01 n et h e transitive closure ofGas the graph G/ETXD.V; E/ETX/,w h e r e\nE/ETXDf.i; j /Wthere is a path from vertex ito vertex jinGg:\nOne way to compute the transitive closure of a graph in \u201a.n3/time is to assign\na weight of 1to each edge of Eand run the Floyd-Warshall algorithm. If there is a\npath from vertex ito vertex j,w eg e t dij<n. Otherwise, we get dijD1 .\nThere is another, similar way to compute the transitive closure of Gin\u201a.n3/\ntime that can save time and space in practice. This method substitutes the logicaloperations_(logical OR) and^(logical AND) for the arithmetic operations min\nandCin the Floyd-Warshall algorithm. For i;j;kD1 ;2;:::;n ,w ed e \ufb01 n e t\n.k/\nijto\nbe1if there exists a path in graph Gfrom vertex ito vertex jwith all intermediate\nvertices in the setf1 ;2;:::;kg,a n d 0otherwise. We construct the transitive closure\nG/ETXD.V; E/ETX/by putting edge .i; j / intoE/ETXif and only if t.n/\nijD1. A recursive\nde\ufb01nition of t.k/\nij, analogous to recurrence (25.5), is\nt.0/\nijD(\n0ifi\u00a4jand.i; j /62E;\n1ifiDjor.i; j /2E;\nand for k/NAK1,\nt.k/\nijDt.k/NUL1/\nij_/NUL\nt.k/NUL1/\nik^t.k/NUL1/\nkj/SOH\n: (25.8)\nAs in the Floyd-Warshall algorithm, we compute the matrices T.k/D/NUL\nt.k/\nij/SOH\nin\norder of increasing k.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "718": {"page_number": 719, "page_information": "698 Chapter 25 All-Pairs Shortest Paths\n1 2\n4 3\nT.0/D/NUL1000\n0111\n0110\n1011/SOH\nT.1/D/NUL1000\n0111\n0110\n1011/SOH\nT.2/D/NUL1000\n0111\n0111\n1011/SOH\nT.3/D/NUL1000\n01110111\n1111/SOH\nT.4/D/NUL1000\n11111111\n1111/SOH\nFigure 25.5 A directed graph and the matrices T.k/computed by the transitive-closure algorithm.\nTRANSITIVE -CLOSURE .G/\n1nDjG:Vj\n2l e t T.0/D/NUL\nt.0/\nij/SOH\nb ean e w n/STXnmatrix\n3foriD1ton\n4 forjD1ton\n5 ifi==jor.i; j /2G:E\n6 t.0/\nijD1\n7 elset.0/\nijD0\n8forkD1ton\n9l e t T.k/D/NUL\nt.k/\nij/SOH\nbe a new n/STXnmatrix\n10 foriD1ton\n11 forjD1ton\n12 t.k/\nijDt.k/NUL1/\nij_/NUL\nt.k/NUL1/\nik^t.k/NUL1/\nkj/SOH\n13return T.n/\nFigure 25.5 shows the matrices T.k/computed by the T RANSITIVE -CLOSURE\nprocedure on a sample graph. The T RANSITIVE -CLOSURE procedure, like the\nFloyd-Warshall algorithm, runs in \u201a.n3/time. On some computers, though, log-\nical operations on single-bit values execute faster than arithmetic operations on\ninteger words of data. Moreover, because the direct transitive-closure algorithm\nuses only boolean values rather than integer values, its space requirement is less", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "719": {"page_number": 720, "page_information": "25.2 The Floyd-Warshall algorithm 699\nthan the Floyd-Warshall algorithm\u2019s by a factor corresponding to the size of a word\nof computer storage.\nExercises\n25.2-1\nRun the Floyd-Warshall algorithm on the weighted, directed graph of Figure 25.2.Show the matrix D\n.k/that results for each iteration of the outer loop.\n25.2-2\nShow how to compute the transitive closure using the technique of Section 25.1.\n25.2-3\nModify the F LOYD -WARSHALL procedure to compute the \u2026.k/matrices according\nto equations (25.6) and (25.7). Prove rigorously that for all i2V, the predecessor\nsubgraph G/EM;iis a shortest-paths tree with root i.(Hint: To show that G/EM;iis\nacyclic, \ufb01rst show that /EM.k/\nijDlimplies d.k/\nij/NAKd.k/\nilCwlj, according to the\nde\ufb01nition of /EM.k/\nij. Then, adapt the proof of Lemma 24.16.)\n25.2-4\nAs it appears above, the Floyd-Warshall algorithm requires \u201a.n3/space, since we\ncompute d.k/\nijfori;j;kD1 ;2;:::;n . Show that the following procedure, which\nsimply drops all the superscripts, is correct, and thus only \u201a.n2/space is required.\nFLOYD -WARSHALL0.W /\n1nDW:rows\n2DDW\n3forkD1ton\n4 foriD1ton\n5 forjD1ton\n6 dijDmin.dij;dikCdkj/\n7return D\n25.2-5\nSuppose that we modify the way in which equation (25.7) handles equality:\n/EM.k/\nijD(\n/EM.k/NUL1/\nij ifd.k/NUL1/\nij <d.k/NUL1/\nikCd.k/NUL1/\nkj;\n/EM.k/NUL1/\nkjifd.k/NUL1/\nij/NAKd.k/NUL1/\nikCd.k/NUL1/\nkj:\nIs this alternative de\ufb01nition of the predecessor matrix \u2026correct?", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "720": {"page_number": 721, "page_information": "700 Chapter 25 All-Pairs Shortest Paths\n25.2-6\nHow can we use the output of the Floyd-Warshall algorithm to detect the presenceof a negative-weight cycle?\n25.2-7\nAnother way to reconstruct shortest paths in the Floyd-Warshall algorithm uses\nvalues /RS\n.k/\nijfori;j;kD1 ;2;:::;n ,w h e r e /RS.k/\nijis the highest-numbered interme-\ndiate vertex of a shortest path from itojin which all intermediate vertices are\nin the setf1 ;2;:::;kg. Give a recursive formulation for /RS.k/\nij, modify the F LOYD -\nWARSHALL procedure to compute the /RS.k/\nijvalues, and rewrite the P RINT -ALL-\nPAIRS -SHORTEST -PATH procedure to take the matrix \u02c6D/NUL\n/RS.n/\nij/SOH\nas an input.\nHow is the matrix \u02c6like the stable in the matrix-chain multiplication problem of\nSection 15.2?\n25.2-8\nGive an O.VE/ -time algorithm for computing the transitive closure of a directed\ngraph GD.V; E/ .\n25.2-9\nSuppose that we can compute the transitive closure of a directed acyclic graph inf.jVj;jEj/time, where fis a monotonically increasing function of jVjandjEj.\nShow that the time to compute the transitive closure G\n/ETXD.V; E/ETX/of a general\ndirected graph GD.V; E/ is then f.jVj;jEj/CO.VCE/ETX/.\n25.3 Johnson\u2019s algorithm for sparse graphs\nJohnson\u2019s algorithm \ufb01nds shortest paths between all pairs in O.V2lgVCVE/\ntime. For sparse graphs, it is asymptotically faster than either repeated squaring ofmatrices or the Floyd-Warshall algorithm. The algorithm either returns a matrix of\nshortest-path weights for all pairs of vertices or reports that the input graph contains\na negative-weight cycle. Johnson\u2019s algorithm uses as subroutines both Dijkstra\u2019salgorithm and the Bellman-Ford algorithm, which Chapter 24 describes.\nJohnson\u2019s algorithm uses the technique of reweighting , which works as follows.\nIf all edge weights win a graph GD.V; E/ are nonnegative, we can \ufb01nd short-\nest paths between all pairs of vertices by running Dijkstra\u2019s algorithm once fromeach vertex; with the Fibonacci-heap min-priority queue, the running time of thisall-pairs algorithm is O.V\n2lgVCVE/.I fGhas negative-weight edges but no\nnegative-weight cycles, we simply compute a new set of nonnegative edge weights", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "721": {"page_number": 722, "page_information": "25.3 Johnson\u2019s algorithm for sparse graphs 701\nthat allows us to use the same method. The new set of edge weights ywmust satisfy\ntwo important properties:\n1. For all pairs of vertices u; /ETB2V,ap a t h pis a shortest path from uto/ETBusing\nweight function wif and only if pis also a shortest path from uto/ETBusing\nweight functionyw.\n2. For all edges .u; /ETB/ , the new weightyw.u;/ETB/ is nonnegative.\nAs we shall see in a moment, we can preprocess Gto determine the new weight\nfunctionywinO.VE/ time.\nPreserving shortest paths by reweighting\nThe following lemma shows how easily we can reweight the edges to satisfy the\n\ufb01rst property above. We use \u0131to denote shortest-path weights derived from weight\nfunction wandy\u0131to denote shortest-path weights derived from weight function yw.\nLemma 25.1 (Reweighting does not change shortest paths)\nGiven a weighted, directed graph GD.V; E/ with weight function wWE! R,\nlethWV! Rbe any function mapping vertices to real numbers. For each edge\n.u; /ETB/2E,d e \ufb01 n e\nyw.u;/ETB/Dw.u;/ETB/Ch.u//NULh./ETB/ : (25.9)\nLetpDh/ETB0;/ETB1;:::;/ETB kibe any path from vertex /ETB0to vertex /ETBk.T h e n pis a\nshortest path from /ETB0to/ETBkwith weight function wif and only if it is a shortest path\nwith weight function yw.T h a ti s , w.p/D\u0131./ETB0;/ETBk/if and only ifyw.p/Dy\u0131./ETB0;/ETBk/.\nFurthermore, Ghas a negative-weight cycle using weight function wif and only\nifGhas a negative-weight cycle using weight function yw.\nProof We start by showing that\nyw.p/Dw.p/Ch./ETB 0//NULh./ETB k/: (25.10)\nWe have\nyw.p/DkX\niD1yw./ETB i/NUL1;/ETBi/\nDkX\niD1.w./ETB i/NUL1;/ETBi/Ch./ETB i/NUL1//NULh./ETB i//\nDkX\niD1w./ETB i/NUL1;/ETBi/Ch./ETB 0//NULh./ETB k/ (because the sum telescopes)\nDw.p/Ch./ETB 0//NULh./ETB k/:", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "722": {"page_number": 723, "page_information": "702 Chapter 25 All-Pairs Shortest Paths\nTherefore, any path pfrom /ETB0to/ETBkhasyw.p/Dw.p/Ch./ETB 0//NULh./ETB k/.B e -\ncause h./ETB 0/andh./ETB k/do not depend on the path, if one path from /ETB0to/ETBkis\nshorter than another using weight function w, then it is also shorter using yw. Thus,\nw.p/D\u0131./ETB0;/ETBk/if and only ifyw.p/Dy\u0131./ETB0;/ETBk/.\nFinally, we show that Ghas a negative-weight cycle using weight function wif\nand only if Ghas a negative-weight cycle using weight function yw. Consider any\ncycle cDh/ETB0;/ETB1;:::;/ETB ki,w h e r e /ETB0D/ETBk. By equation (25.10),\nyw.c/Dw.c/Ch./ETB 0//NULh./ETB k/\nDw.c/ ;\nand thus chas negative weight using wif and only if it has negative weight us-\ningyw.\nProducing nonnegative weights by reweighting\nOur next goal is to ensure that the second property holds: we want yw.u;/ETB/ to be\nnonnegative for all edges .u; /ETB/2E. Given a weighted, directed graph GD\n.V; E/ with weight function wWE! R,w em a k ean e wg r a p h G0D.V0;E0/,\nwhere V0DV[fsgfor some new vertex s62VandE0DE[f.s; /ETB/W/ETB2Vg.\nWe extend the weight function wso that w.s;/ETB/D0for all /ETB2V. Note that\nbecause shas no edges that enter it, no shortest paths in G0, other than those with\nsource s, contain s. Moreover, G0has no negative-weight cycles if and only if G\nhas no negative-weight cycles. Figure 25.6(a) shows the graph G0corresponding\nto the graph Gof Figure 25.1.\nNow suppose that GandG0have no negative-weight cycles. Let us de\ufb01ne\nh./ETB/D\u0131.s; /ETB/ for all /ETB2V0. By the triangle inequality (Lemma 24.10),\nwe have h./ETB//DC4h.u/Cw.u;/ETB/ for all edges .u; /ETB/2E0. Thus, if we de-\n\ufb01ne the new weights ywby reweighting according to equation (25.9), we have\nyw.u;/ETB/Dw.u;/ETB/Ch.u//NULh./ETB//NAK0, and we have satis\ufb01ed the second property.\nFigure 25.6(b) shows the graph G0from Figure 25.6(a) with reweighted edges.\nComputing all-pairs shortest paths\nJohnson\u2019s algorithm to compute all-pairs shortest paths uses the Bellman-Ford al-\ngorithm (Section 24.1) and Dijkstra\u2019s algorithm (Section 24.3) as subroutines. It\nassumes implicitly that the edges are stored in adjacency lists. The algorithm re-\nturns the usualjVj/STXjVjmatrix DDdij,w h e r e dijD\u0131.i;j/ , or it reports that\nthe input graph contains a negative-weight cycle. As is typical for an all-pairs\nshortest-paths algorithm, we assume that the vertices are numbered from 1tojVj.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "723": {"page_number": 724, "page_information": "25.3 Johnson\u2019s algorithm for sparse graphs 703\n2\n1\n5434\n82\n67 10\n0\n0\n0\n00\n0\n2/1\n2/\u20133\n2/2 0/\u201342/3 0/\u20134\n0/1 2/\u201312/70/4\n0/5 2/3\n2/20/\u20131\n0/\u20135\n2/\u201324/82/5\n2/1\n2/6(a)\n(c)(b)\u20134\n\u20134\u20131\n\u20135\n\u2013532\n1\n5440\n132\n210 05\n1\n0\n4\n00\n00\n\u20134\u20131\n\u20135\n03\n2\n1\n544 0\n132\n210 0003\n(d)2\n1\n5440\n132\n210 0003\n(e)2\n1\n544 0\n132\n210 0003\n(f)2\n1\n544 0\n132\n210 0003\n(g)2\n1\n544 0\n132\n210 0003\n0/0 0/00/00/0\n0/00 0\nFigure 25.6 Johnson\u2019s all-pairs shortest-paths algorithm run on the graph of Figure 25.1. Ver-\ntex numbers appear outside the vertices. (a)The graph G0with the original weight function w.\nThe new vertex sis black. Within each vertex /ETBish./ETB/D\u0131.s; /ETB/ .(b)After reweighting each\nedge .u; /ETB/ with weight function yw.u;/ETB/Dw.u;/ETB/Ch.u//NULh./ETB/.(c)\u2013(g) The result of running\nis black, and shaded edges are in the shortest-paths tree computed by the algorithm. Within each\nvertex /ETBare the valuesy\u0131.u;/ETB/ and\u0131.u; /ETB/ , separated by a slash. The value du/ETBD\u0131.u; /ETB/ is equal to\ny\u0131. /ETB/Ch./ETB//NULh.u/Dijkstra\u2019s algorithm on each vertex of Gusing weight function wy. In each part, the source vertex u\n. u;", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "724": {"page_number": 725, "page_information": "704 Chapter 25 All-Pairs Shortest Paths\nJOHNSON .G; w/\n1 compute G0,w h e r e G0:VDG:V[fsg,\nG0:EDG:E[f.s; /ETB/W/ETB2G:Vg,a n d\nw.s;/ETB/D0for all /ETB2G:V\n2ifBELLMAN -FORD.G0;w;s/ ==FALSE\n3 print \u201cthe input graph contains a negative-weight cycle\u201d\n4else for each vertex /ETB2G0:V\n5 set h./ETB/ to the value of \u0131.s; /ETB/\ncomputed by the Bellman-Ford algorithm\n6 foreach edge .u; /ETB/2G0:E\n7yw.u;/ETB/Dw.u;/ETB/Ch.u//NULh./ETB/\n8l e t DD.du/ETB/be a new n/STXnmatrix\n9 foreach vertex u2G:V\n10 run D IJKSTRA .G;yw;u/ to computey\u0131.u;/ETB/ for all /ETB2G:V\n11 foreach vertex /ETB2G:V\n12 du/ETBDy\u0131.u;/ETB/Ch./ETB//NULh.u/\n13 return D\nThis code simply performs the actions we speci\ufb01ed earlier. Line 1 produces G0.\nLine 2 runs the Bellman-Ford algorithm on G0with weight function wand source\nvertex s.I fG0, and hence G, contains a negative-weight cycle, line 3 reports the\nproblem. Lines 4\u201312 assume that G0contains no negative-weight cycles. Lines 4\u20135\nseth./ETB/ to the shortest-path weight \u0131.s; /ETB/ computed by the Bellman-Ford algo-\nrithm for all /ETB2V0. Lines 6\u20137 compute the new weights yw. For each pair of ver-\nticesu; /ETB2V,t h eforloop of lines 9\u201312 computes the shortest-path weight y\u0131.u;/ETB/\nby calling Dijkstra\u2019s algorithm once from each vertex in V. Line 12 stores in\nmatrix entry du/ETBthe correct shortest-path weight \u0131.u;/ETB/ , calculated using equa-\ntion (25.10). Finally, line 13 returns the completed Dmatrix. Figure 25.6 depicts\nthe execution of Johnson\u2019s algorithm.\nIf we implement the min-priority queue in Dijkstra\u2019s algorithm by a Fibonacci\nheap, Johnson\u2019s algorithm runs in O.V2lgVCVE/ time. The simpler binary min-\nheap implementation yields a running time of O.VE lgV/, which is still asymp-\ntotically faster than the Floyd-Warshall algorithm if the graph is sparse.\nExercises\n25.3-1\nUse Johnson\u2019s algorithm to \ufb01nd the shortest paths between all pairs of vertices inthe graph of Figure 25.2. Show the values of handywcomputed by the algorithm.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "725": {"page_number": 726, "page_information": "Problems for Chapter 25 705\n25.3-2\nWhat is the purpose of adding the new vertex stoV, yielding V0?\n25.3-3\nSuppose that w.u;/ETB//NAK0for all edges .u; /ETB/2E. What is the relationship\nbetween the weight functions wandyw?\n25.3-4\nProfessor Greenstreet claims that there is a simpler way to reweight edges thanthe method used in Johnson\u2019s algorithm. Letting w\n/ETXDmin .u;/ETB/ 2Efw.u;/ETB/g,j u s t\nde\ufb01neyw.u;/ETB/Dw.u;/ETB//NULw/ETXfor all edges .u; /ETB/2E. What is wrong with the\nprofessor\u2019s method of reweighting?\n25.3-5\nSuppose that we run Johnson\u2019s algorithm on a directed graph Gwith weight func-\ntionw. Show that if Gcontains a 0-weight cycle c,t h e nyw.u;/ETB/D0for every\nedge .u; /ETB/ inc.\n25.3-6\nProfessor Michener claims that there is no need to create a new source vertex inline 1 of J\nOHNSON . He claims that instead we can just use G0DGand let sbe any\nvertex. Give an example of a weighted, directed graph Gfor which incorporating\nthe professor\u2019s idea into J OHNSON causes incorrect answers. Then show that if G\nis strongly connected (every vertex is reachable from every other vertex), the resultsreturned by J\nOHNSON with the professor\u2019s modi\ufb01cation are correct.\nProblems\n25-1 Transitive closure of a dynamic graphSuppose that we wish to maintain the transitive closure of a directed graph GD\n.V; E/ as we insert edges into E. That is, after each edge has been inserted, we\nwant to update the transitive closure of the edges inserted so far. Assume that thegraph Ghas no edges initially and that we represent the transitive closure as a\nboolean matrix.\na.Show how to update the transitive closure G\n/ETXD.V; E/ETX/of a graph GD.V; E/\ninO.V2/time when a new edge is added to G.\nb.Give an example of a graph Gand an edge esuch that /DEL.V2/time is required\nto update the transitive closure after the insertion of eintoG, no matter what\nalgorithm is used.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "726": {"page_number": 727, "page_information": "706 Chapter 25 All-Pairs Shortest Paths\nc.Describe an ef\ufb01cient algorithm for updating the transitive closure as edges are\ninserted into the graph. For any sequence of ninsertions, your algorithm should\nrun in total timePn\niD1tiDO.V3/,w h e r e tiis the time to update the transitive\nclosure upon inserting the ith edge. Prove that your algorithm attains this time\nbound.\n25-2 Shortest paths in /SI-dense graphs\nAg r a p h GD.V; E/ is/SI-dense ifjEjD\u201a.V1C/SI/for some constant /SIin the\nrange 0</SI/DC41.B y u s i n g d-ary min-heaps (see Problem 6-2) in shortest-paths\nalgorithms on /SI-dense graphs, we can match the running times of Fibonacci-heap-\nbased algorithms without using as complicated a data structure.\na.What are the asymptotic running times for I NSERT ,E XTRACT -MIN,a n d\nDECREASE -KEY,a saf u n c t i o no f dand the number nof elements in a d-ary\nmin-heap? What are these running times if we choose dD\u201a.n\u02db/for some\nconstant 0<\u02db/DC41? Compare these running times to the amortized costs of\nthese operations for a Fibonacci heap.\nb.Show how to compute shortest paths from a single source on an /SI-dense directed\ngraph GD.V; E/ with no negative-weight edges in O.E/ time. ( Hint: Pickd\na saf u n c t i o no f /SI.)\nc.Show how to solve the all-pairs shortest-paths problem on an /SI-dense directed\ngraph GD.V; E/ with no negative-weight edges in O.VE/ time.\nd.Show how to solve the all-pairs shortest-paths problem in O.VE/ time on an\n/SI-dense directed graph GD.V; E/ that may have negative-weight edges but\nhas no negative-weight cycles.\nChapter notes\nLawler [224] has a good discussion of the all-pairs shortest-paths problem, al-though he does not analyze solutions for sparse graphs. He attributes the matrix-multiplication algorithm to the folklore. The Floyd-Warshall algorithm is due toFloyd [105], who based it on a theorem of Warshall [349] that describes how to\ncompute the transitive closure of boolean matrices. Johnson\u2019s algorithm is taken\nfrom [192].\nSeveral researchers have given improved algorithms for computing shortest\npaths via matrix multiplication. Fredman [111] shows how to solve the all-pairs shortest paths problem using O.V\n5=2/comparisons between sums of edge", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "727": {"page_number": 728, "page_information": "Notes for Chapter 25 707\nweights and obtains an algorithm that runs in O.V3.lg lgV=lgV/1=3/time, which\nis slightly better than the running time of the Floyd-Warshall algorithm. Han [159]reduced the running time to O.V\n3.lg lgV=lgV/5=4/. Another line of research\ndemonstrates that we can apply algorithms for fast matrix multiplication (see thechapter notes for Chapter 4) to the all-pairs shortest paths problem. Let O.n\n!/be\nthe running time of the fastest algorithm for multiplying n/STXnmatrices; currently\n! < 2:376 [78]. Galil and Margalit [123, 124] and Seidel [308] designed algo-\nrithms that solve the all-pairs shortest paths problem in undirected, unweighted\ngraphs in .V!p.V // time, where p.n/ denotes a particular function that is poly-\nlogarithmically bounded in n. In dense graphs, these algorithms are faster than\ntheO.VE/ time needed to perform jVjbreadth-\ufb01rst searches. Several researchers\nhave extended these results to give algorithms for solving the all-pairs shortestpaths problem in undirected graphs in which the edge weights are integers in therangef1 ;2;:::;Wg. The asymptotically fastest such algorithm, by Shoshan and\nZwick [316], runs in time O.W V\n!p.V W // .\nKarger, Koller, and Phillips [196] and independently McGeoch [247] have given\na time bound that depends on E/ETX, the set of edges in Ethat participate in some\nshortest path. Given a graph with nonnegative edge weights, their algorithms run in\nO.VE/ETXCV2lgV/time and improve upon running Dijkstra\u2019s algorithm jVjtimes\nwhenjE/ETXjDo.E/ .\nBaswana, Hariharan, and Sen [33] examined decremental algorithms for main-\ntaining all-pairs shortest paths and transitive-closure information. Decremen-\ntal algorithms allow a sequence of intermixed edge deletions and queries; by\ncomparison, Problem 25-1, in which edges are inserted, asks for an incremen-tal algorithm. The algorithms by Baswana, Hariharan, and Sen are randomizedand, when a path exists, their transitive-closure algorithm can fail to report itwith probability 1=n\ncfor an arbitrary c>0 . The query times are O.1/ with\nhigh probability. For transitive closure, the amortized time for each update isO.V\n4=3lg1=3V/. For all-pairs shortest paths, the update times depend on the\nqueries. For queries just giving the shortest-path weights, the amortized time perupdate is O.V\n3=Elg2V/. To report the actual shortest path, the amortized up-\ndate time is min .O.V3=2p\nlgV/ ;O . V3=Elg2V/ /. Demetrescu and Italiano [84]\nshowed how to handle update and query operations when edges are both insertedand deleted, as long as each given edge has a bounded range of possible valuesdrawn from the real numbers.\nAho, Hopcroft, and Ullman [5] de\ufb01ned an algebraic structure known as a \u201cclosed\nsemiring,\u201d which serves as a general framework for solving path problems in di-\nrected graphs. Both the Floyd-Warshall algorithm and the transitive-closure algo-rithm from Section 25.2 are instantiations of an all-pairs algorithm based on closedsemirings. Maggs and Plotkin [240] showed how to \ufb01nd minimum spanning treesusing a closed semiring.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "728": {"page_number": 729, "page_information": "26 Maximum Flow\nJust as we can model a road map as a directed graph in order to \ufb01nd the shortest\npath from one point to another, we can also interpret a directed graph as a \u201c\ufb02ownetwork\u201d and use it to answer questions about material \ufb02ows. Imagine a mate-rial coursing through a system from a source, where the material is produced, toa sink, where it is consumed. The source produces the material at some steadyrate, and the sink consumes the material at the same rate. The \u201c\ufb02ow\u201d of the mate-rial at any point in the system is intuitively the rate at which the material moves.Flow networks can model many problems, including liquids \ufb02owing through pipes,parts through assembly lines, current through electrical networks, and informationthrough communication networks.\nWe can think of each directed edge in a \ufb02ow network as a conduit for the mate-\nrial. Each conduit has a stated capacity, given as a maximum rate at which the ma-terial can \ufb02ow through the conduit, such as 200gallons of liquid per hour through\nap i p eo r 20amperes of electrical current through a wire. Vertices are conduit\njunctions, and other than the source and sink, material \ufb02ows through the vertices\nwithout collecting in them. In other words, the rate at which material enters a ver-tex must equal the rate at which it leaves the vertex. We call this property \u201c\ufb02owconservation,\u201d and it is equivalent to Kirchhoff\u2019s current law when the material iselectrical current.\nIn the maximum-\ufb02ow problem, we wish to compute the greatest rate at which\nwe can ship material from the source to the sink without violating any capacityconstraints. It is one of the simplest problems concerning \ufb02ow networks and, aswe shall see in this chapter, this problem can be solved by ef\ufb01cient algorithms.Moreover, we can adapt the basic techniques used in maximum-\ufb02ow algorithms tosolve other network-\ufb02ow problems.\nThis chapter presents two general methods for solving the maximum-\ufb02ow prob-\nlem. Section 26.1 formalizes the notions of \ufb02ow networks and \ufb02ows, formallyde\ufb01ning the maximum-\ufb02ow problem. Section 26.2 describes the classical method\nof Ford and Fulkerson for \ufb01nding maximum \ufb02ows. An application of this method,", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "729": {"page_number": 730, "page_information": "26.1 Flow networks 709\n\ufb01nding a maximum matching in an undirected bipartite graph, appears in Sec-\ntion 26.3. Section 26.4 presents the push-relabel method, which underlies many ofthe fastest algorithms for network-\ufb02ow problems. Section 26.5 covers the \u201crelabel-to-front\u201d algorithm, a particular implementation of the push-relabel method thatruns in time O.V\n3/. Although this algorithm is not the fastest algorithm known,\nit illustrates some of the techniques used in the asymptotically fastest algorithms,and it is reasonably ef\ufb01cient in practice.\n26.1 Flow networks\nIn this section, we give a graph-theoretic de\ufb01nition of \ufb02ow networks, discuss theirproperties, and de\ufb01ne the maximum-\ufb02ow problem precisely. We also introducesome helpful notation.\nFlow networks and \ufb02ows\nA\ufb02ow network GD.V; E/ is a directed graph in which each edge .u; /ETB/2E\nhas a nonnegative capacity c.u;/ETB//NAK0. We further require that if Econtains an\nedge .u; /ETB/ , then there is no edge ./ETB; u/ in the reverse direction. (We shall see\nshortly how to work around this restriction.) If .u; /ETB/62E, then for convenience\nwe de\ufb01ne c.u;/ETB/D0, and we disallow self-loops. We distinguish two vertices\nin a \ufb02ow network: a source sand asinkt. For convenience, we assume that each\nvertex lies on some path from the source to the sink. That is, for each vertex /ETB2V,\nthe \ufb02ow network contains a path s;/ETB;t. The graph is therefore connected\nand, since each vertex other than shas at least one entering edge, jEj/NAKjVj/NUL1.\nFigure 26.1 shows an example of a \ufb02ow network.\nWe are now ready to de\ufb01ne \ufb02ows more formally. Let GD.V; E/ be a \ufb02ow\nnetwork with a capacity function c.L e t sbe the source of the network, and let tbe\nthe sink. A \ufb02ow inGis a real-valued function fWV/STXV! Rthat satis\ufb01es the\nfollowing two properties:\nCapacity constraint: For all u; /ETB2V, we require 0/DC4\nf. u ;/ETB//DC4c.u;/ETB/ .\nFlow conservation: For all u2V/NULfs; tg, we require\nX\n/ETB2Vf. /ETB;u /DX\n/ETB2Vf. u ;/ETB/:\nWhen .u; /ETB/62E, there can be no \ufb02ow from uto/ETB,a n d f. u ;/ETB/D0.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "730": {"page_number": 731, "page_information": "710 Chapter 26 Maximum Flow\nst1612\n20794\n13\n144Edmonton\nCalgarySaskatoon\nReginaVancouver Winnipeg\nst11/1612/12\n15/207/7 4/91/4\n8/13\n11/144/4\n(a) (b)v1 v1\nv2 v2v3 v3\nv4 v4\nFigure 26.1 (a) A \ufb02ow network GD.V; E/ for the Lucky Puck Company\u2019s trucking problem.\nThe Vancouver factory is the source s, and the Winnipeg warehouse is the sink t. The company ships\npucks through intermediate cities, but only c.u;/ETB/ crates per day can go from city uto city /ETB. Each\nedge is labeled with its capacity. (b)A\ufb02 o w finGwith valuejfjD19. Each edge .u; /ETB/ is labeled\nbyf. u ;/ETB/ = c. u ;/ETB/ . The slash notation merely separates the \ufb02ow and capacity; it does not indicate\ndivision.\nWe call the nonnegative quantity f. u ;/ETB/ the \ufb02ow from vertex uto vertex /ETB.T h e\nvaluejfjof a \ufb02ow fis de\ufb01ned as\njfjDX\n/ETB2Vf. s ;/ETB//NULX\n/ETB2Vf. /ETB;s/; (26.1)\nthat is, the total \ufb02ow out of the source minus the \ufb02ow into the source. (Here, the j/SOHj\nnotation denotes \ufb02ow value, not absolute value or cardinality.) Typically, a \ufb02ow\nnetwork will not have any edges into the source, and the \ufb02ow into the source, givenby the summationP\n/ETB2Vf. /ETB;s/ , will be 0. We include it, however, because when\nwe introduce residual networks later in this chapter, the \ufb02ow into the source willbecome signi\ufb01cant. In the maximum-\ufb02ow problem , we are given a \ufb02ow network G\nwith source sand sink t, and we wish to \ufb01nd a \ufb02ow of maximum value.\nBefore seeing an example of a network-\ufb02ow problem, let us brie\ufb02y explore the\nde\ufb01nition of \ufb02ow and the two \ufb02ow properties. The capacity constraint simply\nsays that the \ufb02ow from one vertex to another must be nonnegative and must not\nexceed the given capacity. The \ufb02ow-conservation property says that the total \ufb02ow\ninto a vertex other than the source or sink must equal the total \ufb02ow out of that\nvertex\u2014informally, \u201c\ufb02ow in equals \ufb02ow out.\u201d\nAn example of \ufb02ow\nA \ufb02ow network can model the trucking problem shown in Figure 26.1(a). The\nLucky Puck Company has a factory (source s) in Vancouver that manufactures\nhockey pucks, and it has a warehouse (sink t) in Winnipeg that stocks them. Lucky", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "731": {"page_number": 732, "page_information": "26.1 Flow networks 711\nst1612\n20794\n13\n144\n(a) (b)v1\nv2v3\nv410st1612\n20794\n13\n144v1\nv2v3\nv4v\u203210\n10\nFigure 26.2 Converting a network with antiparallel edges to an equivalent one with no antiparallel\nedges. (a)A \ufb02ow network containing both the edges ./ETB1;/ETB2/and./ETB2;/ETB1/.(b)An equivalent network\nwith no antiparallel edges. We add the new vertex /ETB0, and we replace edge ./ETB1;/ETB2/by the pair of\nedges ./ETB1;/ETB0/and./ETB0;/ETB2/, both with the same capacity as ./ETB1;/ETB2/.\nPuck leases space on trucks from another \ufb01rm to ship the pucks from the factory\nto the warehouse. Because the trucks travel over speci\ufb01ed routes (edges) betweencities (vertices) and have a limited capacity, Lucky Puck can ship at most c.u;/ETB/\ncrates per day between each pair of cities uand/ETBin Figure 26.1(a). Lucky Puck\nhas no control over these routes and capacities, and so the company cannot alter\nthe \ufb02ow network shown in Figure 26.1(a). They need to determine the largest\nnumber pof crates per day that they can ship and then to produce this amount, since\nthere is no point in producing more pucks than they can ship to their warehouse.Lucky Puck is not concerned with how long it takes for a given puck to get fromthe factory to the warehouse; they care only that pcrates per day leave the factory\nandpcrates per day arrive at the warehouse.\nWe can model the \u201c\ufb02ow\u201d of shipments with a \ufb02ow in this network because the\nnumber of crates shipped per day from one city to another is subject to a capacityconstraint. Additionally, the model must obey \ufb02ow conservation, for in a steadystate, the rate at which pucks enter an intermediate city must equal the rate at whichthey leave. Otherwise, crates would accumulate at intermediate cities.\nModeling problems with antiparallel edges\nSuppose that the trucking \ufb01rm offered Lucky Puck the opportunity to lease space\nfor 10 crates in trucks going from Edmonton to Calgary. It would seem natural toadd this opportunity to our example and form the network shown in Figure 26.2(a).This network suffers from one problem, however: it violates our original assump-tion that if an edge ./ETB\n1;/ETB2/2E,t h e n ./ETB2;/ETB1/62E. We call the two edges ./ETB1;/ETB2/\nand./ETB2;/ETB1/antiparallel . Thus, if we wish to model a \ufb02ow problem with antipar-\nallel edges, we must transform the network into an equivalent one containing no", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "732": {"page_number": 733, "page_information": "712 Chapter 26 Maximum Flow\nantiparallel edges. Figure 26.2(b) displays this equivalent network. We choose\none of the two antiparallel edges, in this case ./ETB1;/ETB2/, and split it by adding a new\nvertex /ETB0and replacing edge ./ETB1;/ETB2/with the pair of edges ./ETB1;/ETB0/and./ETB0;/ETB2/.\nWe also set the capacity of both new edges to the capacity of the original edge.The resulting network satis\ufb01es the property that if an edge is in the network, thereverse edge is not. Exercise 26.1-1 asks you to prove that the resulting network isequivalent to the original one.\nThus, we see that a real-world \ufb02ow problem might be most naturally modeled\nby a network with antiparallel edges. It will be convenient to disallow antipar-\nallel edges, however, and so we have a straightforward way to convert a networkcontaining antiparallel edges into an equivalent one with no antiparallel edges.\nNetworks with multiple sources and sinks\nA maximum-\ufb02ow problem may have several sources and sinks, rather than just\none of each. The Lucky Puck Company, for example, might actually have a setofmfactoriesfs\n1;s2;:::;s mgand a set of nwarehousesft1;t2;:::;t ng,a ss h o w n\nin Figure 26.3(a). Fortunately, this problem is no harder than ordinary maximum\ufb02ow.\nWe can reduce the problem of determining a maximum \ufb02ow in a network with\nmultiple sources and multiple sinks to an ordinary maximum-\ufb02ow problem. Fig-\nure 26.3(b) shows how to convert the network from (a) to an ordinary \ufb02ow network\nwith only a single source and a single sink. We add a supersource sand add a\ndirected edge .s; s\ni/with capacity c.s;s i/D1 for each iD1 ;2;:::;m .W ea l s o\ncreate a new supersink tand add a directed edge .ti;t/with capacity c.ti;t/D1\nfor each iD1 ;2;:::;n . Intuitively, any \ufb02ow in the network in (a) corresponds to\na \ufb02ow in the network in (b), and vice versa. The single source ssimply provides\nas much \ufb02ow as desired for the multiple sources si, and the single sink tlikewise\nconsumes as much \ufb02ow as desired for the multiple sinks ti. Exercise 26.1-2 asks\nyou to prove formally that the two problems are equivalent.\nExercises\n26.1-1\nShow that splitting an edge in a \ufb02ow network yields an equivalent network. Moreformally, suppose that \ufb02ow network Gcontains edge .u; /ETB/ , and we create a new\n\ufb02ow network G\n0by creating a new vertex xand replacing .u; /ETB/ by new edges\n.u; x/ and.x; /ETB/ withc.u;x/Dc.x;/ETB/Dc.u;/ETB/ . Show that a maximum \ufb02ow\ninG0has the same value as a maximum \ufb02ow in G.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "733": {"page_number": 734, "page_information": "26.1 Flow networks 713\n10\n(a)12\n5\n8\n14\n7\n11\n23\n15\n6\n20\n13\n1810\n12\n5\n8\n14\n7\n11\n23\n15\n6\n20\n13\n18\u221e\u221e\u221e\u221e\n\u221e\n\u221e\n\u221e\u221es1 s1\ns2 s2\ns3 s3\ns4 s4\ns5 s5t1 t1\nt2 t2\nt3 t3\n(b)st\nFigure 26.3 Converting a multiple-source, multiple- sink maximum-\ufb02ow problem into a problem\nwith a single source and a single sink. (a)A \ufb02ow network with \ufb01ve sources SDfs1;s2;s3;s4;s5g\nand three sinks TDft1;t2;t3g.(b)An equivalent single-source, single-sink \ufb02ow network. We add\na supersource sand an edge with in\ufb01nite capacity from sto each of the multiple sources. We also\nadd a supersink tand an edge with in\ufb01nite capacity from each of the multiple sinks to t.\n26.1-2\nExtend the \ufb02ow properties and de\ufb01nitions to the multiple-source, multiple-sinkproblem. Show that any \ufb02ow in a multiple-source, multiple-sink \ufb02ow networkcorresponds to a \ufb02ow of identical value in the single-source, single-sink networkobtained by adding a supersource and a supersink, and vice versa.\n26.1-3\nSuppose that a \ufb02ow network GD.V; E/ violates the assumption that the network\ncontains a path s;/ETB;tfor all vertices /ETB2V.L e t ube a vertex for which there\nis no path s;u;t. Show that there must exist a maximum \ufb02ow finGsuch\nthatf. u ;/ETB/Df. /ETB;u /D0for all vertices /ETB2V.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "734": {"page_number": 735, "page_information": "714 Chapter 26 Maximum Flow\n26.1-4\nLetfbe a \ufb02ow in a network, and let \u02dbbe a real number. The scalar \ufb02ow product ,\ndenoted \u02dbf, is a function from V/STXVtoRde\ufb01ned by\n.\u02dbf /.u; /ETB/D\u02db/SOHf. u ;/ETB/:\nProve that the \ufb02ows in a network form a convex set . That is, show that if f1andf2\nare \ufb02ows, then so is \u02dbf1C.1/NUL\u02db/f 2for all \u02dbin the range 0/DC4\u02db/DC41.\n26.1-5\nState the maximum-\ufb02ow problem as a linear-programming problem.\n26.1-6\nProfessor Adam has two children who, unfortunately, dislike each other. The prob-lem is so severe that not only do they refuse to walk to school together, but in facteach one refuses to walk on any block that the other child has stepped on that day.The children have no problem with their paths crossing at a corner. Fortunatelyboth the professor\u2019s house and the school are on corners, but beyond that he is notsure if it is going to be possible to send both of his children to the same school.The professor has a map of his town. Show how to formulate the problem of de-termining whether both his children can go to the same school as a maximum-\ufb02owproblem.\n26.1-7\nSuppose that, in addition to edge capacities, a \ufb02ow network has vertex capacities .\nThat is each vertex /ETBhas a limit l./ETB/ on how much \ufb02ow can pass though /ETB.S h o w\nhow to transform a \ufb02ow network GD.V; E/ with vertex capacities into an equiv-\nalent \ufb02ow network G\n0D.V0;E0/without vertex capacities, such that a maximum\n\ufb02ow in G0has the same value as a maximum \ufb02ow in G. How many vertices and\nedges does G0have?\n26.2 The Ford-Fulkerson method\nThis section presents the Ford-Fulkerson method for solving the maximum-\ufb02ow\nproblem. We call it a \u201cmethod\u201d rather than an \u201calgorithm\u201d because it encompassesseveral implementations with differing running times. The Ford-Fulkerson methoddepends on three important ideas that transcend the method and are relevant tomany \ufb02ow algorithms and problems: residual networks, augmenting paths, andcuts. These ideas are essential to the important max-\ufb02ow min-cut theorem (The-orem 26.6), which characterizes the value of a maximum \ufb02ow in terms of cuts of", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "735": {"page_number": 736, "page_information": "26.2 The Ford-Fulkerson method 715\nthe \ufb02ow network. We end this section by presenting one speci\ufb01c implementation\nof the Ford-Fulkerson method and analyzing its running time.\nThe Ford-Fulkerson method iteratively increases the value of the \ufb02ow. We start\nwith f. u ;/ETB/D0for all u; /ETB2V, giving an initial \ufb02ow of value 0. At each\niteration, we increase the \ufb02ow value in Gby \ufb01nding an \u201caugmenting path\u201d in an\nassociated \u201cresidual network\u201d Gf. Once we know the edges of an augmenting\npath in Gf, we can easily identify speci\ufb01c edges in Gfor which we can change\nthe \ufb02ow so that we increase the value of the \ufb02ow. Although each iteration of the\nFord-Fulkerson method increases the value of the \ufb02ow, we shall see that the \ufb02ow\non any particular edge of Gmay increase or decrease; decreasing the \ufb02ow on some\nedges may be necessary in order to enable an algorithm to send more \ufb02ow from thesource to the sink. We repeatedly augment the \ufb02ow until the residual network hasno more augmenting paths. The max-\ufb02ow min-cut theorem will show that upontermination, this process yields a maximum \ufb02ow.\nF\nORD-FULKERSON -METHOD . G ;s ;t/\n1 initialize \ufb02ow fto0\n2while there exists an augmenting path pin the residual network Gf\n3 augment \ufb02ow falong p\n4return f\nIn order to implement and analyze the Ford-Fulkerson method, we need to intro-\nduce several additional concepts.\nResidual networks\nIntuitively, given a \ufb02ow network Gand a \ufb02ow f, the residual network Gfconsists\nof edges with capacities that represent how we can change the \ufb02ow on edges of G.\nAn edge of the \ufb02ow network can admit an amount of additional \ufb02ow equal to theedge\u2019s capacity minus the \ufb02ow on that edge. If that value is positive, we placethat edge into G\nfwith a \u201cresidual capacity\u201d of cf.u; /ETB/Dc.u;/ETB//NULf. u ;/ETB/ .\nThe only edges of Gthat are in Gfare those that can admit more \ufb02ow; those\nedges .u; /ETB/ whose \ufb02ow equals their capacity have cf.u; /ETB/D0, and they are not\ninGf.\nThe residual network Gfmay also contain edges that are not in G,h o w e v e r .\nAs an algorithm manipulates the \ufb02ow, with the goal of increasing the total \ufb02ow, itmight need to decrease the \ufb02ow on a particular edge. In order to represent a pos-sible decrease of a positive \ufb02ow f. u ;/ETB/ on an edge in G, we place an edge ./ETB; u/\nintoG\nfwith residual capacity cf./ETB; u/Df. u ;/ETB/ \u2014that is, an edge that can admit\n\ufb02ow in the opposite direction to .u; /ETB/ , at most canceling out the \ufb02ow on .u; /ETB/ .\nThese reverse edges in the residual network allow an algorithm to send back \ufb02ow", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "736": {"page_number": 737, "page_information": "716 Chapter 26 Maximum Flow\nit has already sent along an edge. Sending \ufb02ow back along an edge is equiva-\nlent to decreasing the \ufb02ow on the edge, which is a necessary operation in many\nalgorithms.\nMore formally, suppose that we have a \ufb02ow network GD.V; E/ with source s\nand sink t.L e t fbe a \ufb02ow in G, and consider a pair of vertices u; /ETB2V.W e\nde\ufb01ne the residual capacity cf.u; /ETB/ by\ncf.u; /ETB/D/c128\nc.u;/ETB//NULf. u ;/ETB/ if.u; /ETB/2E;\nf. /ETB;u / if./ETB; u/2E;\n0 otherwise :(26.2)\nBecause of our assumption that .u; /ETB/2Eimplies ./ETB; u/62E, exactly one case in\nequation (26.2) applies to each ordered pair of vertices.\nAs an example of equation (26.2), if c.u;/ETB/D16andf. u ;/ETB/D11,t h e nw e\ncan increase f. u ;/ETB/ by up to cf.u; /ETB/D5units before we exceed the capacity\nconstraint on edge .u; /ETB/ . We also wish to allow an algorithm to return up to 11\nunits of \ufb02ow from /ETBtou, and hence cf./ETB; u/D11.\nGiven a \ufb02ow network GD.V; E/ and a \ufb02ow f,t h eresidual network ofG\ninduced by fisGfD.V; E f/,w h e r e\nEfDf.u; /ETB/2V/STXVWcf.u; /ETB/ > 0g: (26.3)\nThat is, as promised above, each edge of the residual network, or residual edge ,\ncan admit a \ufb02ow that is greater than 0. Figure 26.4(a) repeats the \ufb02ow network G\nand \ufb02ow fof Figure 26.1(b), and Figure 26.4(b) shows the corresponding residual\nnetwork Gf. The edges in Efare either edges in Eor their reversals, and thus\njEfj/DC42jEj:\nObserve that the residual network Gfis similar to a \ufb02ow network with capacities\ngiven by cf. It does not satisfy our de\ufb01nition of a \ufb02ow network because it may\ncontain both an edge .u; /ETB/ and its reversal ./ETB; u/ . Other than this difference, a\nresidual network has the same properties as a \ufb02ow network, and we can de\ufb01ne a\n\ufb02ow in the residual network as one that satis\ufb01es the de\ufb01nition of a \ufb02ow, but with\nrespect to capacities cfin the network Gf.\nA \ufb02ow in a residual network provides a roadmap for adding \ufb02ow to the original\n\ufb02ow network. If fis a \ufb02ow in Gandf0is a \ufb02ow in the corresponding residual\nnetwork Gf,w ed e \ufb01 n e f\"f0,t h eaugmentation of \ufb02ow fbyf0, to be a function\nfrom V/STXVtoR,d e \ufb01 n e db y\n.f\"f0/.u; /ETB/D(\nf. u ;/ETB/Cf0.u; /ETB//NULf0./ETB; u/ if.u; /ETB/2E;\n0 otherwise :(26.4)", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "737": {"page_number": 738, "page_information": "26.2 The Ford-Fulkerson method 717\n915\nst512\n57531\n8\n114\nst11/1612/12\n19/207/7 91/4\n12/13\n11/144/4(b)\n(c)11\n5\n34st11/1612/12\n15/207/7 4/91/4\n8/13\n11/144/4\n(d)19\nst512\n1731\n12\n11411\n1\n3v1\nv1v1\nv1v2\nv2v2\nv2v3\nv3v3\nv3v4\nv4v4\nv4(a)\nFigure 26.4 (a) The \ufb02ow network Gand \ufb02ow fof Figure 26.1(b). (b)The residual network Gf\nwith augmenting path pshaded; its residual capacity is cf.p/Dcf./ETB2;/ETB3/D4. Edges with\nresidual capacity equal to 0,s u c ha s ./ETB1;/ETB3/, are not shown, a convention we follow in the remainder\nof this section. (c)The \ufb02ow in Gthat results from augmenting along path pby its residual capacity 4.\nEdges carrying no \ufb02ow, such as ./ETB3;/ETB2/, are labeled only by their capacity, another convention we\nfollow throughout. (d)The residual network induced by the \ufb02ow in (c).\nThe intuition behind this de\ufb01nition follows the de\ufb01nition of the residual network.\nWe increase the \ufb02ow on .u; /ETB/ byf0.u; /ETB/ but decrease it by f0./ETB; u/ because\npushing \ufb02ow on the reverse edge in the residual network signi\ufb01es decreasing the\ufb02ow in the original network. Pushing \ufb02ow on the reverse edge in the residualnetwork is also known as cancellation . For example, if we send 5crates of hockey\npucks from uto/ETBand send 2crates from /ETBtou, we could equivalently (from the\nperspective of the \ufb01nal result) just send 3creates from uto/ETBand none from /ETBtou.\nCancellation of this type is crucial for any maximum-\ufb02ow algorithm.\nLemma 26.1\nLetGD.V; E/ be a \ufb02ow network with source sand sink t,a n dl e t fb ea\ufb02 o w\ninG.L e t G\nfbe the residual network of Ginduced by f,a n dl e t f0be a \ufb02ow\ninGf. Then the function f\"f0de\ufb01ned in equation (26.4) is a \ufb02ow in Gwith\nvaluejf\"f0jDjfjCjf0j.\nProof We \ufb01rst verify that f\"f0obeys the capacity constraint for each edge in E\nand \ufb02ow conservation at each vertex in V/NULfs; tg.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "738": {"page_number": 739, "page_information": "718 Chapter 26 Maximum Flow\nFor the capacity constraint, \ufb01rst observe that if .u; /ETB/2E,t h e n cf./ETB; u/D\nf. u ;/ETB/ . Therefore, we have f0./ETB; u//DC4cf./ETB; u/Df. u ;/ETB/ , and hence\n.f\"f0/.u; /ETB/Df. u ;/ETB/Cf0.u; /ETB//NULf0./ETB; u/ (by equation (26.4))\n/NAKf. u ;/ETB/Cf0.u; /ETB//NULf. u ;/ETB/ (because f0./ETB; u//DC4f. u ;/ETB/ )\nDf0.u; /ETB/\n/NAK0:\nIn addition,.f\"f\n0/.u; /ETB/\nDf. u ;/ETB/Cf0.u; /ETB//NULf0./ETB; u/ (by equation (26.4))\n/DC4f. u ;/ETB/Cf0.u; /ETB/ (because \ufb02ows are nonnegative)\n/DC4f. u ;/ETB/Ccf.u; /ETB/ (capacity constraint)\nDf. u ;/ETB/Cc.u;/ETB//NULf. u ;/ETB/ (de\ufb01nition of cf)\nDc.u;/ETB/ :\nFor \ufb02ow conservation, because both fandf0obey \ufb02ow conservation, we have\nthat for all u2V/NULfs; tg,X\n/ETB2V.f\"f0/.u; /ETB/DX\n/ETB2V.f .u; /ETB/Cf0.u; /ETB//NULf0./ETB; u//\nDX\n/ETB2Vf. u ;/ETB/CX\n/ETB2Vf0.u; /ETB//NULX\n/ETB2Vf0./ETB; u/\nDX\n/ETB2Vf. /ETB;u /CX\n/ETB2Vf0./ETB; u//NULX\n/ETB2Vf0.u; /ETB/\nDX\n/ETB2V.f ./ETB; u/Cf0./ETB; u//NULf0.u; /ETB//\nDX\n/ETB2V.f\"f0/./ETB; u/ ;\nwhere the third line follows from the second by \ufb02ow conservation.\nFinally, we compute the value of f\"f0. Recall that we disallow antiparallel\nedges in G(but not in Gf), and hence for each vertex /ETB2V, we know that there\ncan be an edge .s; /ETB/ or./ETB; s/ , but never both. We de\ufb01ne V1Df/ETBW.s; /ETB/2Eg\nto be the set of vertices with edges from s,a n d V2Df/ETBW./ETB; s/2Egto be the\nset of vertices with edges to s.W e h a v e V1[V2/DC2Vand, because we disallow\nantiparallel edges, V1\\V2D;. We now compute\njf\"f0jDX\n/ETB2V.f\"f0/. s ;/ETB//NULX\n/ETB2V.f\"f0/. /ETB;s/\nDX\n/ETB2V1.f\"f0/. s ;/ETB//NULX\n/ETB2V2.f\"f0/. /ETB;s/; (26.5)", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "739": {"page_number": 740, "page_information": "26.2 The Ford-Fulkerson method 719\nwhere the second line follows because .f\"f0/.w; x/ is0if.w; x/62E.W en o w\napply the de\ufb01nition of f\"f0to equation (26.5), and then reorder and group terms\nto obtain\njf\"f0j\nDX\n/ETB2V1.f .s; /ETB/Cf0.s; /ETB//NULf0./ETB; s///NULX\n/ETB2V2.f ./ETB; s/Cf0./ETB; s//NULf0.s; /ETB//\nDX\n/ETB2V1f. s ;/ETB/CX\n/ETB2V1f0.s; /ETB//NULX\n/ETB2V1f0./ETB; s/\n/NULX\n/ETB2V2f. /ETB;s//NULX\n/ETB2V2f0./ETB; s/CX\n/ETB2V2f0.s; /ETB/\nDX\n/ETB2V1f. s ;/ETB//NULX\n/ETB2V2f. /ETB;s/\nCX\n/ETB2V1f0.s; /ETB/CX\n/ETB2V2f0.s; /ETB//NULX\n/ETB2V1f0./ETB; s//NULX\n/ETB2V2f0./ETB; s/\nDX\n/ETB2V1f. s ;/ETB//NULX\n/ETB2V2f. /ETB;s/CX\n/ETB2V1[V2f0.s; /ETB//NULX\n/ETB2V1[V2f0./ETB; s/ : (26.6)\nIn equation (26.6), we can extend all four summations to sum over V, since each\nadditional term has value 0. (Exercise 26.2-1 asks you to prove this formally.) We\nthus have\njf\"f0jDX\n/ETB2Vf. s ;/ETB//NULX\n/ETB2Vf. /ETB;s/CX\n/ETB2Vf0.s; /ETB//NULX\n/ETB2Vf0./ETB; s/ (26.7)\nDjfjCjf0j:\nAugmenting paths\nGiven a \ufb02ow network GD.V; E/ and a \ufb02ow f,a naugmenting path pis a\nsimple path from stotin the residual network Gf. By the de\ufb01nition of the resid-\nual network, we may increase the \ufb02ow on an edge .u; /ETB/ of an augmenting path\nby up to cf.u; /ETB/ without violating the capacity constraint on whichever of .u; /ETB/\nand./ETB; u/ is in the original \ufb02ow network G.\nThe shaded path in Figure 26.4(b) is an augmenting path. Treating the residual\nnetwork Gfin the \ufb01gure as a \ufb02ow network, we can increase the \ufb02ow through each\nedge of this path by up to 4units without violating a capacity constraint, since the\nsmallest residual capacity on this path is cf./ETB2;/ETB3/D4. We call the maximum\namount by which we can increase the \ufb02ow on each edge in an augmenting path p\ntheresidual capacity ofp,g i v e nb y\ncf.p/Dminfcf.u; /ETB/W.u; /ETB/ is on pg:", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "740": {"page_number": 741, "page_information": "720 Chapter 26 Maximum Flow\nThe following lemma, whose proof we leave as Exercise 26.2-7, makes the above\nargument more precise.\nLemma 26.2\nLetGD.V; E/ be a \ufb02ow network, let fbe a \ufb02ow in G,a n dl e t pbe an augmenting\npath in Gf. De\ufb01ne a function fpWV/STXV!Rby\nfp.u; /ETB/D(\ncf.p/ if.u; /ETB/ is on p;\n0 otherwise :(26.8)\nThen, fpi sa\ufb02 o wi n Gfwith valuejfpjDcf.p/ > 0 .\nThe following corollary shows that if we augment fbyfp, we get another \ufb02ow\ninGwhose value is closer to the maximum. Figure 26.4(c) shows the result of\naugmenting the \ufb02ow ffrom Figure 26.4(a) by the \ufb02ow fpin Figure 26.4(b), and\nFigure 26.4(d) shows the ensuing residual network.\nCorollary 26.3\nLetGD.V; E/ be a \ufb02ow network, let fbe a \ufb02ow in G,a n dl e t pbe an\naugmenting path in Gf.L e t fpbe de\ufb01ned as in equation (26.8), and suppose\nthat we augment fbyfp. Then the function f\"fpi sa\ufb02 o wi n Gwith value\njf\"fpjDjfjCjfpj>jfj.\nProof Immediate from Lemmas 26.1 and 26.2.\nCuts of \ufb02ow networks\nThe Ford-Fulkerson method repeatedly augments the \ufb02ow along augmenting paths\nuntil it has found a maximum \ufb02ow. How do we know that when the algorithmterminates, we have actually found a maximum \ufb02ow? The max-\ufb02ow min-cut theo-rem, which we shall prove shortly, tells us that a \ufb02ow is maximum if and only if itsresidual network contains no augmenting path. To prove this theorem, though, wemust \ufb01rst explore the notion of a cut of a \ufb02ow network.\nAcut.S; T / of \ufb02ow network GD.V; E/ is a partition of VintoSand\nTDV/NULSsuch that s2Sandt2T. (This de\ufb01nition is similar to the def-\ninition of \u201ccut\u201d that we used for minimum spanning trees in Chapter 23, exceptthat here we are cutting a directed graph rather than an undirected graph, and weinsist that s2Sandt2T.) Iffis a \ufb02ow, then the net \ufb02ow f. S;T/ across the\ncut.S; T / is de\ufb01ned to be\nf. S;T/DX\nu2SX\n/ETB2Tf. u ;/ETB//NULX\nu2SX\n/ETB2Tf. /ETB;u /: (26.9)", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "741": {"page_number": 742, "page_information": "26.2 The Ford-Fulkerson method 721\ns t11/1612/12\n15/207/7 4/91/4\n8/13\n11/144/4\nSTv4v3 v1\nv2\nFigure 26.5 Ac u t .S; T / in the \ufb02ow network of Figure 26.1(b), where SDfs; /ETB1;/ETB2gand\nTDf/ETB3;/ETB4;tg. The vertices in Sare black, and the vertices in Tare white. The net \ufb02ow\nacross .S; T / isf. S;T/D19, and the capacity is c.S;T /D26.\nThecapacity of the cut .S; T / is\nc.S;T/DX\nu2SX\n/ETB2Tc.u;/ETB/ : (26.10)\nAminimum cut of a network is a cut whose capacity is minimum over all cuts of\nthe network.\nThe asymmetry between the de\ufb01nitions of \ufb02ow and capacity of a cut is inten-\ntional and important. For capacity, we count only the capacities of edges goingfrom StoT, ignoring edges in the reverse direction. For \ufb02ow, we consider the\n\ufb02ow going from StoTminus the \ufb02ow going in the reverse direction from TtoS.\nThe reason for this difference will become clear later in this section.\nFigure 26.5 shows the cut .fs; /ETB\n1;/ETB2g;f/ETB3;/ETB4;tg/in the \ufb02ow network of Fig-\nure 26.1(b). The net \ufb02ow across this cut is\nf. /ETB 1;/ETB3/Cf. /ETB 2;/ETB4//NULf. /ETB 3;/ETB2/D12C11/NUL4\nD19 ;\nand the capacity of this cut is\nc./ETB 1;/ETB3/Cc./ETB 2;/ETB4/D12C14\nD26 :\nThe following lemma shows that, for a given \ufb02ow f, the net \ufb02ow across any cut\nis the same, and it equals jfj, the value of the \ufb02ow.\nLemma 26.4\nLetfbe a \ufb02ow in a \ufb02ow network Gwith source sand sink t,a n dl e t .S; T / be any\ncut of G. Then the net \ufb02ow across .S; T / isf. S;T/Djfj.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "742": {"page_number": 743, "page_information": "722 Chapter 26 Maximum Flow\nProof We can rewrite the \ufb02ow-conservation condition for any node u2V/NULfs; tg\nas\nX\n/ETB2Vf. u ;/ETB//NULX\n/ETB2Vf. /ETB;u /D0: (26.11)\nTaking the de\ufb01nition of jfjfrom equation (26.1) and adding the left-hand side of\nequation (26.11), which equals 0, summed over all vertices in S/NULfsg,g i v e s\njfjDX\n/ETB2Vf. s ;/ETB//NULX\n/ETB2Vf. /ETB;s/CX\nu2S/NULfsg X\n/ETB2Vf. u ;/ETB//NULX\n/ETB2Vf. /ETB;u /!\n:\nExpanding the right-hand summation and regrouping terms yields\njfjDX\n/ETB2Vf. s ;/ETB//NULX\n/ETB2Vf. /ETB;s/CX\nu2S/NULfsgX\n/ETB2Vf. u ;/ETB//NULX\nu2S/NULfsgX\n/ETB2Vf. /ETB;u /\nDX\n/ETB2V \nf. s ;/ETB/CX\nu2S/NULfsgf. u ;/ETB/!\n/NULX\n/ETB2V \nf. /ETB;s/CX\nu2S/NULfsgf. /ETB;u /!\nDX\n/ETB2VX\nu2Sf. u ;/ETB//NULX\n/ETB2VX\nu2Sf. /ETB;u /:\nBecause VDS[TandS\\TD;, we can split each summation over Vinto\nsummations over SandTto obtain\njfjDX\n/ETB2SX\nu2Sf. u ;/ETB/CX\n/ETB2TX\nu2Sf. u ;/ETB//NULX\n/ETB2SX\nu2Sf. /ETB;u //NULX\n/ETB2TX\nu2Sf. /ETB;u /\nDX\n/ETB2TX\nu2Sf. u ;/ETB//NULX\n/ETB2TX\nu2Sf. /ETB;u /\nC X\n/ETB2SX\nu2Sf. u ;/ETB//NULX\n/ETB2SX\nu2Sf. /ETB;u /!\n:\nThe two summations within the parentheses are actually the same, since for all\nvertices x;y2V, the term f. x;y/ appears once in each summation. Hence, these\nsummations cancel, and we have\njfjDX\nu2SX\n/ETB2Tf. u ;/ETB//NULX\nu2SX\n/ETB2Tf. /ETB;u /\nDf. S;T/:\nA corollary to Lemma 26.4 shows how we can use cut capacities to bound the\nvalue of a \ufb02ow.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "743": {"page_number": 744, "page_information": "26.2 The Ford-Fulkerson method 723\nCorollary 26.5\nThe value of any \ufb02ow fin a \ufb02ow network Gis bounded from above by the capacity\nof any cut of G.\nProof Let.S; T / be any cut of Gand let fbe any \ufb02ow. By Lemma 26.4 and the\ncapacity constraint,\njfjDf. S;T/\nDX\nu2SX\n/ETB2Tf. u ;/ETB//NULX\nu2SX\n/ETB2Tf. /ETB;u /\n/DC4X\nu2SX\n/ETB2Tf. u ;/ETB/\n/DC4X\nu2SX\n/ETB2Tc.u;/ETB/\nDc.S;T/ :\nCorollary 26.5 yields the immediate consequence that the value of a maximum\n\ufb02ow in a network is bounded from above by the capacity of a minimum cut ofthe network. The important max-\ufb02ow min-cut theorem, which we now state andprove, says that the value of a maximum \ufb02ow is in fact equal to the capacity of a\nminimum cut.\nTheorem 26.6 (Max-\ufb02ow min-cut theorem)\nIffis a \ufb02ow in a \ufb02ow network GD.V; E/ with source sand sink t, then the\nfollowing conditions are equivalent:\n1.fis a maximum \ufb02ow in G.\n2. The residual network G\nfcontains no augmenting paths.\n3.jfjDc.S;T/ for some cut .S; T / ofG.\nProof .1/).2/: Suppose for the sake of contradiction that fi sam a x i m u m\n\ufb02ow in Gbut that Gfhas an augmenting path p. Then, by Corollary 26.3, the\n\ufb02ow found by augmenting fbyfp,w h e r e fpis given by equation (26.8), is a \ufb02ow\ninGwith value strictly greater than jfj, contradicting the assumption that fis a\nmaximum \ufb02ow.\n.2/).3/: Suppose that Gfhas no augmenting path, that is, that Gfcontains\nno path from stot.D e \ufb01 n e\nSDf/ETB2VWthere exists a path from sto/ETBinGfg\nandTDV/NULS. The partition .S; T / i sac u t :w eh a v e s2Strivially and t62S\nbecause there is no path from stotinGf. Now consider a pair of vertices", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "744": {"page_number": 745, "page_information": "724 Chapter 26 Maximum Flow\nu2Sand/ETB2T.I f .u; /ETB/2E,w em u s th a v e f. u ;/ETB/Dc.u;/ETB/ ,s i n c e\notherwise .u; /ETB/2Ef, which would place /ETBin set S.I f./ETB; u/2E,w em u s t\nhave f. /ETB;u /D0, because otherwise cf.u; /ETB/Df. /ETB;u / would be positive and\nwe would have .u; /ETB/2Ef, which would place /ETBinS. Of course, if neither .u; /ETB/\nnor./ETB; u/ is inE,t h e n f. u ;/ETB/Df. /ETB;u /D0. We thus have\nf. S;T/DX\nu2SX\n/ETB2Tf. u ;/ETB//NULX\n/ETB2TX\nu2Sf. /ETB;u /\nDX\nu2SX\n/ETB2Tc.u;/ETB//NULX\n/ETB2TX\nu2S0\nDc.S;T/ :\nBy Lemma 26.4, therefore, jfjDf. S;T/Dc.S;T/ .\n.3/).1/: By Corollary 26.5, jfj/DC4c.S;T/ for all cuts .S; T / . The condition\njfjDc.S;T/ thus implies that fi sam a x i m u m\ufb02 o w .\nThe basic Ford-Fulkerson algorithm\nIn each iteration of the Ford-Fulkerson method, we \ufb01nd some augmenting path p\nand use pto modify the \ufb02ow f. As Lemma 26.2 and Corollary 26.3 suggest, we\nreplace fbyf\"fp, obtaining a new \ufb02ow whose value is jfjCjfpj. The follow-\ning implementation of the method computes the maximum \ufb02ow in a \ufb02ow networkGD.V; E/ by updating the \ufb02ow attribute .u; /ETB/: ffor each edge .u; /ETB/2E.\n1\nIf.u; /ETB/62E, we assume implicitly that .u; /ETB/: fD0. We also assume that we\nare given the capacities c.u;/ETB/ along with the \ufb02ow network, and c.u;/ETB/D0\nif.u; /ETB/62E. We compute the residual capacity cf.u; /ETB/ in accordance with the\nformula (26.2). The expression cf.p/in the code is just a temporary variable that\nstores the residual capacity of the path p.\nFORD-FULKERSON . G ;s ;t/\n1foreach edge .u; /ETB/2G:E\n2 .u; /ETB/: fD0\n3while there exists a path pfrom stotin the residual network Gf\n4 cf.p/Dminfcf.u; /ETB/W.u; /ETB/ is inpg\n5 foreach edge .u; /ETB/ inp\n6 if.u; /ETB/2E\n7 .u; /ETB/: fD.u; /ETB/: fCcf.p/\n8 else./ETB; u/: fD./ETB; u/: f/NULcf.p/\n1Recall from Section 22.1 that we represent an attribute ffor edge .u; /ETB/ with the same style of\nnotation\u2014 .u; /ETB/: f\u2014that we use for an attribute of any other object.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "745": {"page_number": 746, "page_information": "26.2 The Ford-Fulkerson method 725\nThe F ORD-FULKERSON algorithm simply expands on the F ORD-FULKERSON -\nMETHOD pseudocode given earlier. Figure 26.6 shows the result of each iteration\nin a sample run. Lines 1\u20132 initialize the \ufb02ow fto0.T h e while loop of lines 3\u20138\nrepeatedly \ufb01nds an augmenting path pinGfand augments \ufb02ow falong pby\nthe residual capacity cf.p/. Each residual edge in path pis either an edge in the\noriginal network or the reversal of an edge in the original network. Lines 6\u20138update the \ufb02ow in each case appropriately, adding \ufb02ow when the residual edge isan original edge and subtracting it otherwise. When no augmenting paths exist, the\n\ufb02owfi sam a x i m u m\ufb02 o w .\nAnalysis of Ford-Fulkerson\nThe running time of F\nORD-FULKERSON depends on how we \ufb01nd the augmenting\npathpin line 3. If we choose it poorly, the algorithm might not even terminate: the\nvalue of the \ufb02ow will increase with successive augmentations, but it need not evenconverge to the maximum \ufb02ow value.\n2If we \ufb01nd the augmenting path by using a\nbreadth-\ufb01rst search (which we saw in Section 22.2), however, the algorithm runs inpolynomial time. Before proving this result, we obtain a simple bound for the casein which we choose the augmenting path arbitrarily and all capacities are integers.\nIn practice, the maximum-\ufb02ow problem often arises with integral capacities. If\nthe capacities are rational numbers, we can apply an appropriate scaling transfor-mation to make them all integral. If f\n/ETXdenotes a maximum \ufb02ow in the transformed\nnetwork, then a straightforward implementation of F ORD-FULKERSON executes\nthewhile loop of lines 3\u20138 at most jf/ETXjtimes, since the \ufb02ow value increases by at\nleast one unit in each iteration.\nWe can perform the work done within the while loop ef\ufb01ciently if we implement\nthe \ufb02ow network GD.V; E/ with the right data structure and \ufb01nd an augmenting\npath by a linear-time algorithm. Let us assume that we keep a data structure cor-\nresponding to a directed graph G0D.V; E0/,w h e r e E0Df.u; /ETB/W.u; /ETB/2Eor\n./ETB; u/2Eg. Edges in the network Ga r ea l s oe d g e si n G0, and therefore we can\neasily maintain capacities and \ufb02ows in this data structure. Given a \ufb02ow fonG,\nthe edges in the residual network Gfconsist of all edges .u; /ETB/ ofG0such that\ncf.u; /ETB/ > 0 ,w h e r e cfconforms to equation (26.2). The time to \ufb01nd a path in\na residual network is therefore O.VCE0/DO.E/ if we use either depth-\ufb01rst\nsearch or breadth-\ufb01rst search. Each iteration of the while loop thus takes O.E/\ntime, as does the initialization in lines 1\u20132, making the total running time of the\nFORD-FULKERSON algorithm O.Ejf/ETXj/.\n2The Ford-Fulkerson method might fail to terminate only if edge capacities are irrational numbers.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "746": {"page_number": 747, "page_information": "726 Chapter 26 Maximum Flow\n12\n4\n4 4/4 4v1\n416410st1612\n20794\n13\n144v1\nst4/164/12\n2074/9\n13\n4/144/4\nst\n754\n4v18\n4\n1320v1\nst4/168/12\n4/2074/9\n4/13\n4/144/4\n410st\n758\n4v14\n9v1\nst8/168/12\n8/2079\n4/13\n4/144/4v2 v2\nv2 v2\nv2 v2v3 v3\nv3 v3\nv3 v3v4 v4\nv4 v4\nv4 v4(b)(a)\n(c)12\n4 444\n4\nFigure 26.6 The execution of the basic Ford-Fulkerson algorithm. (a)\u2013(e) Successive iterations of\nthewhile loop. The left side of each part shows the residual network Gffrom line 3 with a shaded\naugmenting path p. The right side of each part shows the new \ufb02ow fthat results from augmenting f\nbyfp. The residual network in (a) is the input network G.\nWhen the capacities are integral and the optimal \ufb02ow value jf/ETXjis small, the\nrunning time of the Ford-Fulkerson algorithm is good. Figure 26.7(a) shows an ex-ample of what can happen on a simple \ufb02ow network for which jf\n/ETXjis large. A max-\nimum \ufb02ow in this network has value 2,000,000: 1,000,000 units of \ufb02ow traversethe path s!u!t, and another 1,000,000 units traverse the path s!/ETB!t.I f\nthe \ufb01rst augmenting path found by F\nORD-FULKERSON iss!u!/ETB!t,s h o w n\nin Figure 26.7(a), the \ufb02ow has value 1after the \ufb01rst iteration. The resulting resid-\nual network appears in Figure 26.7(b). If the second iteration \ufb01nds the augment-ing path s!/ETB!u!t, as shown in Figure 26.7(b), the \ufb02ow then has value 2.\nFigure 26.7(c) shows the resulting residual network. We can continue, choosingthe augmenting path s!u!/ETB!tin the odd-numbered iterations and the aug-\nmenting path s!/ETB!u!tin the even-numbered iterations. We would perform\na total of 2,000,000 augmentations, increasing the \ufb02ow value by only 1unit in each.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "747": {"page_number": 748, "page_information": "26.2 The Ford-Fulkerson method 727\n4\n12\n11\n211\n28\n89\n4\n49844\n98st127\n44v1\nst8/168/12\n15/207/7 9\n11/13\n11/144/4v1\n10\n19\nst12\n17\n114 3v2v3 v3\nv3v4v4\nv4(d)\n(f)\n4\n984415\nst57\n114v1\nst12/1612/12\n19/207/7 9\n11/13\n11/144/4v1\n3v2v3 v3\nv4v4(e)\n4v2\nv2\nv1\nv28\n8\nFigure 26.6, continued (f) The residual network at the last while loop test. It has no augmenting\npaths, and the \ufb02ow fshown in (e) is therefore a maximum \ufb02ow. The value of the maximum \ufb02ow\nfound is 23.\nThe Edmonds-Karp algorithm\nWe can improve the bound on F ORD-FULKERSON by \ufb01nding the augmenting\npathpin line 3 with a breadth-\ufb01rst search. That is, we choose the augmenting\npath as a shortest path from stotin the residual network, where each edge has\nunit distance (weight). We call the Ford-Fulkerson method so implemented theEdmonds-Karp algorithm . We now prove that the Edmonds-Karp algorithm runs\ninO.VE\n2/time.\nThe analysis depends on the distances to vertices in the residual network Gf.\nThe following lemma uses the notation \u0131f.u; /ETB/ for the shortest-path distance\nfrom uto/ETBinGf, where each edge has unit distance.\nLemma 26.7\nIf the Edmonds-Karp algorithm is run on a \ufb02ow network GD.V; E/ with source s\nand sink t, then for all vertices /ETB2V/NULfs; tg, the shortest-path distance \u0131f.s; /ETB/\nin the residual network Gfincreases monotonically with each \ufb02ow augmentation.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "748": {"page_number": 749, "page_information": "728 Chapter 26 Maximum Flow\n1999,999\n999,999\n1st1,000,0001,000,000 1\n1,000,000\n1,000,000999,999\n11999,999u\nvst1,000,000 1\n1,000,000u\nv999,999\n1999,999\n1st\n1u\nv\n(a) (b) (c)\nFigure 26.7 (a) A \ufb02ow network for which F ORD-FULKERSON can take \u201a.Ejf/ETXj/time,\nwhere f/ETXis a maximum \ufb02ow, shown here with jf/ETXjD2,000,000. The shaded path is an aug-\nmenting path with residual capacity 1.(b)The resulting residual network, with another augmenting\npath whose residual capacity is 1.(c)The resulting residual network.\nProof We will suppose that for some vertex /ETB2V/NULfs; tg, there is a \ufb02ow aug-\nmentation that causes the shortest-path distance from sto/ETBto decrease, and then\nwe will derive a contradiction. Let fbe the \ufb02ow just before the \ufb01rst augmentation\nthat decreases some shortest-path distance, and let f0be the \ufb02ow just afterward.\nLet/ETBbe the vertex with the minimum \u0131f0.s; /ETB/ whose distance was decreased by\nthe augmentation, so that \u0131f0.s; /ETB/ < \u0131 f.s; /ETB/ .L e t pDs;u!/ETBbe a shortest\npath from sto/ETBinGf0,s ot h a t .u; /ETB/2Ef0and\n\u0131f0.s; u/D\u0131f0.s; /ETB//NUL1: (26.12)\nBecause of how we chose /ETB, we know that the distance of vertex ufrom the source s\ndid not decrease, i.e.,\n\u0131f0.s; u//NAK\u0131f.s; u/ : (26.13)\nWe claim that .u; /ETB/62Ef. Why? If we had .u; /ETB/2Ef,t h e nw ew o u l da l s oh a v e\n\u0131f.s; /ETB//DC4\u0131f.s; u/C1(by Lemma 24.10, the triangle inequality)\n/DC4\u0131f0.s; u/C1(by inequality (26.13))\nD\u0131f0.s; /ETB/ (by equation (26.12)) ,\nwhich contradicts our assumption that \u0131f0.s; /ETB/ < \u0131 f.s; /ETB/ .\nHow can we have .u; /ETB/62Efand.u; /ETB/2Ef0? The augmentation must\nhave increased the \ufb02ow from /ETBtou. The Edmonds-Karp algorithm always aug-\nments \ufb02ow along shortest paths, and therefore the shortest path from stouinGf\nhas./ETB; u/ as its last edge. Therefore,\n\u0131f.s; /ETB/D\u0131f.s; u//NUL1\n/DC4\u0131f0.s; u//NUL1(by inequality (26.13))\nD\u0131f0.s; /ETB//NUL2(by equation (26.12)) ,", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "749": {"page_number": 750, "page_information": "26.2 The Ford-Fulkerson method 729\nwhich contradicts our assumption that \u0131f0.s; /ETB/ < \u0131 f.s; /ETB/ . We conclude that our\nassumption that such a vertex /ETBexists is incorrect.\nThe next theorem bounds the number of iterations of the Edmonds-Karp algo-\nrithm.\nTheorem 26.8\nIf the Edmonds-Karp algorithm is run on a \ufb02ow network GD.V; E/ with source s\nand sink t, then the total number of \ufb02ow augmentations performed by the algorithm\nisO.VE/ .\nProof We say that an edge .u; /ETB/ in a residual network Gfiscritical on an aug-\nmenting path pif the residual capacity of pis the residual capacity of .u; /ETB/ ,t h a t\nis, ifcf.p/Dcf.u; /ETB/ . After we have augmented \ufb02ow along an augmenting path,\nany critical edge on the path disappears from the residual network. Moreover, atleast one edge on any augmenting path must be critical. We will show that each ofthejEjedges can become critical at most jVj=2times.\nLetuand/ETBbe vertices in Vthat are connected by an edge in E. Since augment-\ning paths are shortest paths, when .u; /ETB/ is critical for the \ufb01rst time, we have\n\u0131\nf.s; /ETB/D\u0131f.s; u/C1:\nOnce the \ufb02ow is augmented, the edge .u; /ETB/ disappears from the residual network.\nIt cannot reappear later on another augmenting path until after the \ufb02ow from uto/ETB\nis decreased, which occurs only if ./ETB; u/ appears on an augmenting path. If f0is\nthe \ufb02ow in Gwhen this event occurs, then we have\n\u0131f0.s; u/D\u0131f0.s; /ETB/C1:\nSince \u0131f.s; /ETB//DC4\u0131f0.s; /ETB/ by Lemma 26.7, we have\n\u0131f0.s; u/D\u0131f0.s; /ETB/C1\n/NAK\u0131f.s; /ETB/C1\nD\u0131f.s; u/C2:\nConsequently, from the time .u; /ETB/ becomes critical to the time when it next\nbecomes critical, the distance of ufrom the source increases by at least 2.T h e\ndistance of ufrom the source is initially at least 0. The intermediate vertices on a\nshortest path from stoucannot contain s,u,o rt(since .u; /ETB/ on an augmenting\npath implies that u\u00a4t). Therefore, until ubecomes unreachable from the source,\nif ever, its distance is at most jVj/NUL2. Thus, after the \ufb01rst time that .u; /ETB/ becomes\ncritical, it can become critical at most .jVj/NUL2/=2DjVj=2/NUL1times more, for a\ntotal of at mostjVj=2times. Since there are O.E/ pairs of vertices that can have an\nedge between them in a residual network, the total number of critical edges during", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "750": {"page_number": 751, "page_information": "730 Chapter 26 Maximum Flow\nthe entire execution of the Edmonds-Karp algorithm is O.VE/ . Each augmenting\npath has at least one critical edge, and hence the theorem follows.\nBecause we can implement each iteration of F ORD-FULKERSON inO.E/ time\nwhen we \ufb01nd the augmenting path by breadth-\ufb01rst search, the total running time ofthe Edmonds-Karp algorithm is O.VE\n2/. We shall see that push-relabel algorithms\ncan yield even better bounds. The algorithm of Section 26.4 gives a method forachieving an O.V\n2E/running time, which forms the basis for the O.V3/-time\nalgorithm of Section 26.5.\nExercises\n26.2-1\nProve that the summations in equation (26.6) equal the summations in equa-tion (26.7).\n26.2-2\nIn Figure 26.1(b), what is the \ufb02ow across the cut .fs; /ETB\n2;/ETB4g;f/ETB1;/ETB3;tg/?W h a ti s\nthe capacity of this cut?\n26.2-3\nShow the execution of the Edmonds-Karp algorithm on the \ufb02ow network of Fig-ure 26.1(a).\n26.2-4\nIn the example of Figure 26.6, what is the minimum cut corresponding to the max-imum \ufb02ow shown? Of the augmenting paths appearing in the example, which one\ncancels \ufb02ow?\n26.2-5\nRecall that the construction in Section 26.1 that converts a \ufb02ow network with mul-tiple sources and sinks into a single-source, single-sink network adds edges within\ufb01nite capacity. Prove that any \ufb02ow in the resulting network has a \ufb01nite valueif the edges of the original network with multiple sources and sinks have \ufb01nitecapacity.\n26.2-6\nSuppose that each source s\niin a \ufb02ow network with multiple sources and sinks\nproduces exactly piunits of \ufb02ow, so thatP\n/ETB2Vf. s i;/ETB/Dpi. Suppose also\nthat each sink tjconsumes exactly qjunits, so thatP\n/ETB2Vf. /ETB;t j/Dqj,w h e r eP\nipiDP\njqj. Show how to convert the problem of \ufb01nding a \ufb02ow fthat obeys", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "751": {"page_number": 752, "page_information": "26.2 The Ford-Fulkerson method 731\nthese additional constraints into the problem of \ufb01nding a maximum \ufb02ow in a single-\nsource, single-sink \ufb02ow network.\n26.2-7\nProve Lemma 26.2.\n26.2-8\nSuppose that we rede\ufb01ne the residual network to disallow edges into s. Argue that\nthe procedure F ORD-FULKERSON still correctly computes a maximum \ufb02ow.\n26.2-9\nSuppose that both fandf0are \ufb02ows in a network Gand we compute \ufb02ow f\"f0.\nDoes the augmented \ufb02ow satisfy the \ufb02ow conservation property? Does it satisfy\nthe capacity constraint?\n26.2-10\nShow how to \ufb01nd a maximum \ufb02ow in a network GD.V; E/ by a sequence of at\nmostjEjaugmenting paths. ( Hint: Determine the paths after \ufb01nding the maximum\n\ufb02ow.)\n26.2-11\nTheedge connectivity of an undirected graph is the minimum number kof edges\nthat must be removed to disconnect the graph. For example, the edge connectivityof a tree is 1, and the edge connectivity of a cyclic chain of vertices is 2.S h o w\nhow to determine the edge connectivity of an undirected graph GD.V; E/ by\nrunning a maximum-\ufb02ow algorithm on at most jVj\ufb02ow networks, each having\nO.V / vertices and O.E/ edges.\n26.2-12\nSuppose that you are given a \ufb02ow network G,a n d Ghas edges entering the\nsource s.L e t fbe a \ufb02ow in Gin which one of the edges ./ETB; s/ entering the source\nhasf. /ETB;s/D1. Prove that there must exist another \ufb02ow f\n0withf0./ETB; s/D0\nsuch thatjfjDjf0j.G i v ea n O.E/ -time algorithm to compute f0,g i v e n f,a n d\nassuming that all edge capacities are integers.\n26.2-13\nSuppose that you wish to \ufb01nd, among all minimum cuts in a \ufb02ow network Gwith\nintegral capacities, one that contains the smallest number of edges. Show how tomodify the capacities of Gto create a new \ufb02ow network G\n0in which any minimum\ncut in G0is a minimum cut with the smallest number of edges in G.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "752": {"page_number": 753, "page_information": "732 Chapter 26 Maximum Flow\n26.3 Maximum bipartite matching\nSome combinatorial problems can easily be cast as maximum-\ufb02ow problems. The\nmultiple-source, multiple-sink maximum-\ufb02ow problem from Section 26.1 gave usone example. Some other combinatorial problems seem on the surface to have littleto do with \ufb02ow networks, but can in fact be reduced to maximum-\ufb02ow problems.\nThis section presents one such problem: \ufb01nding a maximum matching in a bipartite\ngraph. In order to solve this problem, we shall take advantage of an integralityproperty provided by the Ford-Fulkerson method. We shall also see how to usethe Ford-Fulkerson method to solve the maximum-bipartite-matching problem onag r a p h GD.V; E/ inO.VE/ time.\nThe maximum-bipartite-matching problem\nGiven an undirected graph GD.V; E/ ,amatching is a subset of edges M/DC2E\nsuch that for all vertices /ETB2V, at most one edge of Mis incident on /ETB.W e\nsay that a vertex /ETB2Vismatched by the matching Mif some edge in Mis\nincident on /ETB; otherwise, /ETBisunmatched .Amaximum matching is a matching\nof maximum cardinality, that is, a matching Msuch that for any matching M\n0,\nwe havejMj/NAKjM0j. In this section, we shall restrict our attention to \ufb01nding\nmaximum matchings in bipartite graphs: graphs in which the vertex set can be\npartitioned into VDL[R,w h e r e LandRare disjoint and all edges in E\ngo between LandR. We further assume that every vertex in Vhas at least one\nincident edge. Figure 26.8 illustrates the notion of a matching in a bipartite graph.\nThe problem of \ufb01nding a maximum matching in a bipartite graph has many\npractical applications. As an example, we might consider matching a set Lof ma-\nchines with a set Rof tasks to be performed simultaneously. We take the presence\nof edge .u; /ETB/ inEto mean that a particular machine u2Lis capable of per-\nforming a particular task /ETB2R. A maximum matching provides work for as many\nmachines as possible.\nFinding a maximum bipartite matching\nWe can use the Ford-Fulkerson method to \ufb01nd a maximum matching in an undi-\nrected bipartite graph GD.V; E/ in time polynomial in jVjandjEj. The trick is\nto construct a \ufb02ow network in which \ufb02ows correspond to matchings, as shown inFigure 26.8(c). We de\ufb01ne the corresponding \ufb02ow network G\n0D.V0;E0/for the\nbipartite graph Gas follows. We let the source sand sink tbe new vertices not\ninV,a n dw el e t V0DV[fs; tg. If the vertex partition of GisVDL[R,t h e", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "753": {"page_number": 754, "page_information": "26.3 Maximum bipartite matching 733\nLR LRst\n(a) (c)LR\n(b)\nFigure 26.8 A bipartite graph GD.V; E/ with vertex partition VDL[R.(a)A matching\nwith cardinality 2, indicated by shaded edges. (b)A maximum matching with cardinality 3.(c)The\ncorresponding \ufb02ow network G0with a maximum \ufb02ow shown. Each edge has unit capacity. Shaded\nedges have a \ufb02ow of 1, and all other edges carry no \ufb02ow. The shaded edges from LtoRcorrespond\nto those in the maximum matching from (b).\ndirected edges of G0are the edges of E, directed from LtoR, along withjVjnew\ndirected edges:\nE0Df.s; u/Wu2Lg[f.u; /ETB/W.u; /ETB/2Eg[f./ETB; t/W/ETB2Rg:\nTo complete the construction, we assign unit capacity to each edge in E0.S i n c e\neach vertex in Vhas at least one incident edge, jEj/NAKjVj=2. Thus,jEj/DC4jE0jD\njEjCjVj/DC43jEj,a n ds ojE0jD\u201a.E/ .\nThe following lemma shows that a matching in Gcorresponds directly to a \ufb02ow\ninG\u2019s corresponding \ufb02ow network G0. We say that a \ufb02ow fon a \ufb02ow network\nGD.V; E/ isinteger-valued iff. u ;/ETB/ is an integer for all .u; /ETB/2V/STXV.\nLemma 26.9\nLetGD.V; E/ be a bipartite graph with vertex partition VDL[R,a n dl e t\nG0D.V0;E0/be its corresponding \ufb02ow network. If Mis a matching in G,t h e n\nthere is an integer-valued \ufb02ow finG0with valuejfjDjMj. Conversely, if f\nis an integer-valued \ufb02ow in G0, then there is a matching MinGwith cardinality\njMjDjfj.\nProof We \ufb01rst show that a matching MinGcorresponds to an integer-valued\n\ufb02owfinG0.D e \ufb01 n e fas follows. If .u; /ETB/2M,t h e n f. s ;u /Df. u ;/ETB/D\nf. /ETB;t/D1. For all other edges .u; /ETB/2E0,w ed e \ufb01 n e f. u ;/ETB/D0.I t i s s i m p l e\nto verify that fsatis\ufb01es the capacity constraint and \ufb02ow conservation.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "754": {"page_number": 755, "page_information": "734 Chapter 26 Maximum Flow\nIntuitively, each edge .u; /ETB/2Mcorresponds to one unit of \ufb02ow in G0that\ntraverses the path s!u!/ETB!t. Moreover, the paths induced by edges in M\nare vertex-disjoint, except for sandt. The net \ufb02ow across cut .L[fsg;R[ftg/\nis equal tojMj; thus, by Lemma 26.4, the value of the \ufb02ow is jfjDjMj.\nTo prove the converse, let fbe an integer-valued \ufb02ow in G0,a n dl e t\nMDf.u; /ETB/Wu2L; /ETB2R;andf. u ;/ETB/>0g:\nEach vertex u2Lhas only one entering edge, namely .s; u/ , and its capacity\nis1. Thus, each u2Lhas at most one unit of \ufb02ow entering it, and if one unit of\n\ufb02ow does enter, by \ufb02ow conservation, one unit of \ufb02ow must leave. Furthermore,since fis integer-valued, for each u2L, the one unit of \ufb02ow can enter on at most\none edge and can leave on at most one edge. Thus, one unit of \ufb02ow enters uif and\nonly if there is exactly one vertex /ETB2Rsuch that f. u ;/ETB/D1, and at most one\nedge leaving each u2Lcarries positive \ufb02ow. A symmetric argument applies to\neach/ETB2R. The set Mis therefore a matching.\nTo see thatjMjDjfj, observe that for every matched vertex u2L,w eh a v e\nf. s ;u /D1, and for every edge .u; /ETB/2E/NULM,w eh a v e f. u ;/ETB/D0. Conse-\nquently, f. L[fsg;R[ftg/, the net \ufb02ow across cut .L\n[fsg;R[ftg/, is equal\ntojMj. Applying Lemma 26.4, we have that jfjDf. L[fsg;R[ftg/DjMj.\nBased on Lemma 26.9, we would like to conclude that a maximum matching\nin a bipartite graph Gcorresponds to a maximum \ufb02ow in its corresponding \ufb02ow\nnetwork G0, and we can therefore compute a maximum matching in Gby running\na maximum-\ufb02ow algorithm on G0. The only hitch in this reasoning is that the\nmaximum-\ufb02ow algorithm might return a \ufb02ow in G0for which some f. u ;/ETB/ is\nnot an integer, even though the \ufb02ow value jfjmust be an integer. The following\ntheorem shows that if we use the Ford-Fulkerson method, this dif\ufb01culty cannotarise.\nTheorem 26.10 (Integrality theorem)\nIf the capacity function ctakes on only integral values, then the maximum \ufb02ow f\nproduced by the Ford-Fulkerson method has the property that jfjis an integer.\nMoreover, for all vertices uand/ETB,t h ev a l u eo f f. u ;/ETB/ is an integer.\nProof The proof is by induction on the number of iterations. We leave it as\nExercise 26.3-2.\nWe can now prove the following corollary to Lemma 26.9.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "755": {"page_number": 756, "page_information": "26.3 Maximum bipartite matching 735\nCorollary 26.11\nThe cardinality of a maximum matching Min a bipartite graph Gequals the value\nof a maximum \ufb02ow fin its corresponding \ufb02ow network G0.\nProof We use the nomenclature from Lemma 26.9. Suppose that Mi sam a x -\nimum matching in Gand that the corresponding \ufb02ow finG0is not maximum.\nThen there is a maximum \ufb02ow f0inG0such thatjf0j>jfj. Since the ca-\npacities in G0are integer-valued, by Theorem 26.10, we can assume that f0is\ninteger-valued. Thus, f0corresponds to a matching M0inGwith cardinality\njM0jDjf0j>jfjDjMj, contradicting our assumption that Mis a maximum\nmatching. In a similar manner, we can show that if fis a maximum \ufb02ow in G0, its\ncorresponding matching is a maximum matching on G.\nThus, given a bipartite undirected graph G, we can \ufb01nd a maximum matching by\ncreating the \ufb02ow network G0, running the Ford-Fulkerson method, and directly ob-\ntaining a maximum matching Mfrom the integer-valued maximum \ufb02ow ffound.\nSince any matching in a bipartite graph has cardinality at most min .L; R/DO.V / ,\nthe value of the maximum \ufb02ow in G0isO.V / . We can therefore \ufb01nd a maximum\nmatching in a bipartite graph in time O.VE0/DO.VE/ ,s i n c ejE0jD\u201a.E/ .\nExercises\n26.3-1\nRun the Ford-Fulkerson algorithm on the \ufb02ow network in Figure 26.8(c) and showthe residual network after each \ufb02ow augmentation. Number the vertices in Ltop\nto bottom from 1to5and in Rtop to bottom from 6to9. For each iteration, pick\nthe augmenting path that is lexicographically smallest.\n26.3-2\nProve Theorem 26.10.\n26.3-3\nLetGD.V; E/ be a bipartite graph with vertex partition VDL[R,a n dl e t G\n0\nbe its corresponding \ufb02ow network. Give a good upper bound on the length of any\naugmenting path found in G0during the execution of F ORD-FULKERSON .\n26.3-4 ?\nAperfect matching is a matching in which every vertex is matched. Let GD\n.V; E/ be an undirected bipartite graph with vertex partition VDL[R,w h e r e\njLjDjRj.F o ra n y X/DC2V,d e \ufb01 n et h e neighborhood ofXas\nN.X/Dfy2VW.x; y/2Efor some x2Xg;", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "756": {"page_number": 757, "page_information": "736 Chapter 26 Maximum Flow\nthat is, the set of vertices adjacent to some member of X. Prove Hall\u2019s theorem :\nthere exists a perfect matching in Gif and only ifjAj/DC4jN.A/jfor every subset\nA/DC2L.\n26.3-5 ?\nWe say that a bipartite graph GD.V; E/ ,w h e r e VDL[R,i sd-regular if every\nvertex /ETB2Vhas degree exactly d.E v e r y d-regular bipartite graph has jLjDjRj.\nProve that every d-regular bipartite graph has a matching of cardinality jLjby\narguing that a minimum cut of the corresponding \ufb02ow network has capacity jLj.\n?26.4 Push-relabel algorithms\nIn this section, we present the \u201cpush-relabel\u201d approach to computing maximum\n\ufb02ows. To date, many of the asymptotically fastest maximum-\ufb02ow algorithms are\npush-relabel algorithms, and the fastest actual implementations of maximum-\ufb02ow\nalgorithms are based on the push-relabel method. Push-relabel methods also ef\ufb01-ciently solve other \ufb02ow problems, such as the minimum-cost \ufb02ow problem. Thissection introduces Goldberg\u2019s \u201cgeneric\u201d maximum-\ufb02ow algorithm, which has asimple implementation that runs in O.V\n2E/time, thereby improving upon the\nO.VE2/bound of the Edmonds-Karp algorithm. Section 26.5 re\ufb01nes the generic\nalgorithm to obtain another push-relabel algorithm that runs in O.V3/time.\nPush-relabel algorithms work in a more localized manner than the Ford-\nFulkerson method. Rather than examine the entire residual network to \ufb01nd an aug-menting path, push-relabel algorithms work on one vertex at a time, looking onlyat the vertex\u2019s neighbors in the residual network. Furthermore, unlike the Ford-Fulkerson method, push-relabel algorithms do not maintain the \ufb02ow-conservationproperty throughout their execution. They do, however, maintain a pre\ufb02ow ,w h i c h\nis a function fWV/STXV!Rthat satis\ufb01es the capacity constraint and the following\nrelaxation of \ufb02ow conservation:X\n/ETB2Vf. /ETB;u //NULX\n/ETB2Vf. u ;/ETB//NAK0\nfor all vertices u2V/NULfsg. That is, the \ufb02ow into a vertex may exceed the \ufb02ow\nout. We call the quantity\ne.u/DX\n/ETB2Vf. /ETB;u //NULX\n/ETB2Vf. u ;/ETB/ (26.14)\ntheexcess \ufb02ow into vertex u. The excess at a vertex is the amount by which the\n\ufb02ow in exceeds the \ufb02ow out. We say that a vertex u2V/NULfs; tgisover\ufb02owing if\ne.u/ > 0 .", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "757": {"page_number": 758, "page_information": "26.4 Push-relabel algorithms 737\nWe shall begin this section by describing the intuition behind the push-relabel\nmethod. We shall then investigate the two operations employed by the method:\u201cpushing\u201d pre\ufb02ow and \u201crelabeling\u201d a vertex. Finally, we shall present a genericpush-relabel algorithm and analyze its correctness and running time.\nIntuition\nYou can understand the intuition behind the push-relabel method in terms of \ufb02uid\n\ufb02ows: we consider a \ufb02ow network GD.V; E/ to be a system of interconnected\npipes of given capacities. Applying this analogy to the Ford-Fulkerson method,we might say that each augmenting path in the network gives rise to an additionalstream of \ufb02uid, with no branch points, \ufb02owing from the source to the sink. TheFord-Fulkerson method iteratively adds more streams of \ufb02ow until no more can be\nadded.\nThe generic push-relabel algorithm has a rather different intuition. As before,\ndirected edges correspond to pipes. Vertices, which are pipe junctions, have twointeresting properties. First, to accommodate excess \ufb02ow, each vertex has an out-\ufb02ow pipe leading to an arbitrarily large reservoir that can accumulate \ufb02uid. Second,each vertex, its reservoir, and all its pipe connections sit on a platform whose heightincreases as the algorithm progresses.\nVertex heights determine how \ufb02ow is pushed: we push \ufb02ow only downhill, that\nis, from a higher vertex to a lower vertex. The \ufb02ow from a lower vertex to a higher\nvertex may be positive, but operations that push \ufb02ow push it only downhill. We\ufb01x the height of the source at jVjand the height of the sink at 0. All other vertex\nheights start at 0and increase with time. The algorithm \ufb01rst sends as much \ufb02ow as\npossible downhill from the source toward the sink. The amount it sends is exactlyenough to \ufb01ll each outgoing pipe from the source to capacity; that is, it sends the\ncapacity of the cut .s; V/NULfsg/. When \ufb02ow \ufb01rst enters an intermediate vertex, it\ncollects in the vertex\u2019s reservoir. From there, we eventually push it downhill.\nWe may eventually \ufb01nd that the only pipes that leave a vertex uand are not\nalready saturated with \ufb02ow connect to vertices that are on the same level as uor\nare uphill from u. In this case, to rid an over\ufb02owing vertex uof its excess \ufb02ow, we\nmust increase its height\u2014an operation called \u201crelabeling\u201d vertex u. We increase\nits height to one unit more than the height of the lowest of its neighbors to whichit has an unsaturated pipe. After a vertex is relabeled, therefore, it has at least oneoutgoing pipe through which we can push more \ufb02ow.\nEventually, all the \ufb02ow that can possibly get through to the sink has arrived there.\nNo more can arrive, because the pipes obey the capacity constraints; the amount of\ufb02ow across any cut is still limited by the capacity of the cut. To make the pre\ufb02owa \u201clegal\u201d \ufb02ow, the algorithm then sends the excess collected in the reservoirs ofover\ufb02owing vertices back to the source by continuing to relabel vertices to above", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "758": {"page_number": 759, "page_information": "738 Chapter 26 Maximum Flow\nthe \ufb01xed heightjVjof the source. As we shall see, once we have emptied all the\nreservoirs, the pre\ufb02ow is not only a \u201clegal\u201d \ufb02ow, it is also a maximum \ufb02ow.\nThe basic operations\nFrom the preceding discussion, we see that a push-relabel algorithm performs two\nbasic operations: pushing \ufb02ow excess from a vertex to one of its neighbors andrelabeling a vertex. The situations in which these operations apply depend on theheights of vertices, which we now de\ufb01ne precisely.\nLetGD.V; E/ be a \ufb02ow network with source sand sink t,a n dl e t fbe a\npre\ufb02ow in G. A function hWV! Nis aheight function\n3ifh.s/DjVj,\nh.t/D0,a n d\nh.u//DC4h./ETB/C1\nfor every residual edge .u; /ETB/2Ef. We immediately obtain the following lemma.\nLemma 26.12\nLetGD.V; E/ be a \ufb02ow network, let fbe a pre\ufb02ow in G,a n dl e t hbe a height\nfunction on V. For any two vertices u; /ETB2V,i fh.u/ > h./ETB/C1,t h e n .u; /ETB/ is\nnot an edge in the residual network.\nThe push operationThe basic operation P\nUSH.u; /ETB/ applies if uis an over\ufb02owing vertex, cf.u; /ETB/ > 0 ,\nandh.u/Dh./ETB/C1. The pseudocode below updates the pre\ufb02ow fand the excess\n\ufb02ows for uand/ETB. It assumes that we can compute residual capacity cf.u; /ETB/ in\nconstant time given candf. We maintain the excess \ufb02ow stored at a vertex uas\nthe attribute u:eand the height of uas the attribute u:h. The expression /c129f.u; /ETB/\nis a temporary variable that stores the amount of \ufb02ow that we can push from uto/ETB.\n3In the literature, a height function is typically called a \u201cdistance function,\u201d and the height of a vertex\nis called a \u201cdistance label.\u201d We use the term \u201cheight\u201d because it is more suggestive of the intuitionbehind the algorithm. We retain the use of the term \u201crelabel\u201d to refer to the operation that increases\nthe height of a vertex. The height of a vertex is related to its distance from the sink t, as would be\nfound in a breadth-\ufb01rst search of the transpose G\nT.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "759": {"page_number": 760, "page_information": "26.4 Push-relabel algorithms 739\nPUSH.u; /ETB/\n1//Applies when :uis over\ufb02owing, cf.u; /ETB/ > 0 ,a n d u:hD/ETB:hC1.\n2//Action: Push /c129f.u; /ETB/Dmin.u:e;cf.u; /ETB// units of \ufb02ow from uto/ETB.\n3/c129f.u; /ETB/Dmin.u:e;cf.u; /ETB//\n4if.u; /ETB/2E\n5 .u; /ETB/: fD.u; /ETB/: fC/c129f.u; /ETB/\n6else./ETB; u/: fD./ETB; u/: f/NUL/c129f.u; /ETB/\n7u:eDu:e/NUL/c129f.u; /ETB/\n8/ETB:eD/ETB:eC/c129f.u; /ETB/\nThe code for P USH operates as follows. Because vertex uhas a positive excess u:e\nand the residual capacity of .u; /ETB/ is positive, we can increase the \ufb02ow from uto/ETB\nby/c129f.u; /ETB/Dmin.u:e;cf.u; /ETB// without causing u:eto become negative or the\ncapacity c.u;/ETB/ to be exceeded. Line 3 computes the value /c129f.u; /ETB/ , and lines 4\u20136\nupdate f. Line 5 increases the \ufb02ow on edge .u; /ETB/ , because we are pushing \ufb02ow\nover a residual edge that is also an original edge. Line 6 decreases the \ufb02ow onedge ./ETB; u/ , because the residual edge is actually the reverse of an edge in the\noriginal network. Finally, lines 7\u20138 update the excess \ufb02ows into vertices uand/ETB.\nThus, if fis a pre\ufb02ow before P\nUSH is called, it remains a pre\ufb02ow afterward.\nObserve that nothing in the code for P USH depends on the heights of uand/ETB,\nyet we prohibit it from being invoked unless u:hD/ETB:hC1. Thus, we push excess\n\ufb02ow downhill only by a height differential of 1. By Lemma 26.12, no residual\nedges exist between two vertices whose heights differ by more than 1, and thus,\nas long as the attribute his indeed a height function, we would gain nothing by\nallowing \ufb02ow to be pushed downhill by a height differential of more than 1.\nWe call the operation P USH.u; /ETB/ apush from uto/ETB. If a push operation ap-\nplies to some edge .u; /ETB/ leaving a vertex u, we also say that the push operation\napplies to u.I ti sa saturating push if edge .u; /ETB/ in the residual network becomes\nsaturated (cf.u; /ETB/D0afterward); otherwise, it is a nonsaturating push .I f a n\nedge becomes saturated, it disappears from the residual network. A simple lemmacharacterizes one result of a nonsaturating push.\nLemma 26.13\nAfter a nonsaturating push from uto/ETB, the vertex uis no longer over\ufb02owing.\nProof Since the push was nonsaturating, the amount of \ufb02ow /c129\nf.u; /ETB/ actually\npushed must equal u:eprior to the push. Since u:eis reduced by this amount, it\nbecomes 0after the push.\n", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "760": {"page_number": 761, "page_information": "740 Chapter 26 Maximum Flow\nThe relabel operation\nThe basic operation R ELABEL .u/applies if uis over\ufb02owing and if u:h/DC4/ETB:hfor\nall edges .u; /ETB/2Ef. In other words, we can relabel an over\ufb02owing vertex uif\nfor every vertex /ETBfor which there is residual capacity from uto/ETB, \ufb02ow cannot be\npushed from uto/ETBbecause /ETBis not downhill from u. (Recall that by de\ufb01nition,\nneither the source snor the sink tcan be over\ufb02owing, and so sandtare ineligible\nfor relabeling.)\nRELABEL .u/\n1//Applies when: uis over\ufb02owing and for all /ETB2Vsuch that .u; /ETB/2Ef,\nwe have u:h/DC4/ETB:h.\n2//Action: Increase the height of u.\n3u:hD1Cminf/ETB:hW.u; /ETB/2Efg\nWhen we call the operation R ELABEL .u/, we say that vertex uisrelabeled .N o t e\nthat when uis relabeled, Efmust contain at least one edge that leaves u,s ot h a t\nthe minimization in the code is over a nonempty set. This property follows fromthe assumption that uis over\ufb02owing, which in turn tells us that\nu:eDX\n/ETB2Vf. /ETB;u //NULX\n/ETB2Vf. u ;/ETB/>0:\nSince all \ufb02ows are nonnegative, we must therefore have at least one vertex /ETBsuch\nthat./ETB; u/: f>0.B u t t h e n , cf.u; /ETB/ > 0 , which implies that .u; /ETB/2Ef.T h e\noperation R ELABEL .u/thus gives uthe greatest height allowed by the constraints\non height functions.\nThe generic algorithm\nThe generic push-relabel algorithm uses the following subroutine to create an ini-\ntial pre\ufb02ow in the \ufb02ow network.\nINITIALIZE -PREFLOW .G; s/\n1foreach vertex /ETB2G:V\n2 /ETB:hD0\n3 /ETB:eD0\n4foreach edge .u; /ETB/2G:E\n5 .u; /ETB/: fD0\n6s:hDjG:Vj\n7foreach vertex /ETB2s:Adj\n8 .s; /ETB/: fDc.s;/ETB/\n9 /ETB:eDc.s;/ETB/\n10 s:eDs:e/NULc.s;/ETB/", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "761": {"page_number": 762, "page_information": "26.4 Push-relabel algorithms 741\nINITIALIZE -PREFLOW creates an initial pre\ufb02ow fde\ufb01ned by\n.u; /ETB/: fD(\nc.u;/ETB/ ifuDs;\n0 otherwise :(26.15)\nThat is, we \ufb01ll to capacity each edge leaving the source s, and all other edges carry\nno \ufb02ow. For each vertex /ETBadjacent to the source, we initially have /ETB:eDc.s;/ETB/ ,\nand we initialize s:eto the negative of the sum of these capacities. The generic\nalgorithm also begins with an initial height function h,g i v e nb y\nu:hD(\njVjifuDs;\n0 otherwise :(26.16)\nEquation (26.16) de\ufb01nes a height function because the only edges .u; /ETB/ for which\nu:h>/ETB : hC1are those for which uDs, and those edges are saturated, which\nmeans that they are not in the residual network.\nInitialization, followed by a sequence of push and relabel operations, executed\nin no particular order, yields the G ENERIC -PUSH-RELABEL algorithm:\nGENERIC -PUSH-RELABEL .G/\n1I NITIALIZE -PREFLOW .G; s/\n2while there exists an applicable push or relabel operation\n3 select an applicable push or relabel operation and perform it\nThe following lemma tells us that as long as an over\ufb02owing vertex exists, at least\none of the two basic operations applies.\nLemma 26.14 (An over\ufb02owing vertex can be either pushed or relabeled)\nLetGD.V; E/ be a \ufb02ow network with source sand sink t,l e tfb eap r e \ufb02 o w ,\nand let hbe any height function for f.I fuis any over\ufb02owing vertex, then either a\npush or relabel operation applies to it.\nProof For any residual edge .u; /ETB/ ,w eh a v e h.u//DC4h./ETB/C1because his a\nheight function. If a push operation does not apply to an over\ufb02owing vertex u,\nthen for all residual edges .u; /ETB/ ,w em u s th a v e h.u/ < h./ETB/C1, which implies\nh.u//DC4h./ETB/. Thus, a relabel operation applies to u.\nCorrectness of the push-relabel method\nTo show that the generic push-relabel algorithm solves the maximum-\ufb02ow prob-\nlem, we shall \ufb01rst prove that if it terminates, the pre\ufb02ow fis a maximum \ufb02ow.\nWe shall later prove that it terminates. We start with some observations about theheight function h.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "762": {"page_number": 763, "page_information": "742 Chapter 26 Maximum Flow\nLemma 26.15 (Vertex heights never decrease)\nDuring the execution of the G ENERIC -PUSH-RELABEL procedure on a \ufb02ow net-\nwork GD.V; E/ , for each vertex u2V, the height u:hnever decreases. More-\nover, whenever a relabel operation is applied to a vertex u, its height u:hincreases\nby at least 1.\nProof Because vertex heights change only during relabel operations, it suf\ufb01ces\nto prove the second statement of the lemma. If vertex uis about to be rela-\nbeled, then for all vertices /ETBsuch that .u; /ETB/2Ef,w eh a v e u:h/DC4/ETB:h. Thus,\nu:h<1Cminf/ETB:hW.u; /ETB/2Efg, and so the operation must increase u:h.\nLemma 26.16\nLetGD.V; E/ be a \ufb02ow network with source sand sink t. Then the execution of\nGENERIC -PUSH-RELABEL onGmaintains the attribute has a height function.\nProof The proof is by induction on the number of basic operations performed.\nInitially, his a height function, as we have already observed.\nWe claim that if his a height function, then an operation R ELABEL .u/leaves h\na height function. If we look at a residual edge .u; /ETB/2Efthat leaves u,t h e n\nthe operation R ELABEL .u/ensures that u:h/DC4/ETB:hC1afterward. Now consider\na residual edge .w; u/ that enters u. By Lemma 26.15, w:h/DC4u:hC1before the\noperation R ELABEL .u/implies w:h<u : hC1afterward. Thus, the operation\nRELABEL .u/leaves ha height function.\nNow, consider an operation P USH.u; /ETB/ . This operation may add the edge ./ETB; u/\ntoEf, and it may remove .u; /ETB/ from Ef. In the former case, we have\n/ETB:hDu:h/NUL1<u : hC1,a n ds o hremains a height function. In the latter case,\nremoving .u; /ETB/ from the residual network removes the corresponding constraint,\nandhagain remains a height function.\nThe following lemma gives an important property of height functions.\nLemma 26.17\nLetGD.V; E/ be a \ufb02ow network with source sand sink t,l e tfb eap r e \ufb02 o w\ninG,a n dl e t hbe a height function on V. Then there is no path from the source s\nto the sink tin the residual network Gf.\nProof Assume for the sake of contradiction that Gfcontains a path pfrom stot,\nwhere pDh/ETB0;/ETB1;:::;/ETB ki,/ETB0Ds,a n d /ETBkDt. Without loss of generality, p\nis a simple path, and so k<jVj.F o r iD0; 1; : : : ; k/NUL1, edge ./ETBi;/ETBiC1/2Ef.\nBecause his a height function, h./ETB i//DC4h./ETB iC1/C1foriD0; 1; : : : ; k/NUL1.C o m -\nbining these inequalities over path pyields h.s//DC4h.t/Ck. But because h.t/D0,", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "763": {"page_number": 764, "page_information": "26.4 Push-relabel algorithms 743\nwe have h.s//DC4k<jVj, which contradicts the requirement that h.s/DjVjin a\nheight function.\nWe are now ready to show that if the generic push-relabel algorithm terminates,\nthe pre\ufb02ow it computes is a maximum \ufb02ow.\nTheorem 26.18 (Correctness of the generic push-relabel algorithm)\nIf the algorithm G ENERIC -PUSH-RELABEL terminates when run on a \ufb02ow net-\nwork GD.V; E/ with source sand sink t, then the pre\ufb02ow fit computes is a\nmaximum \ufb02ow for G.\nProof We use the following loop invariant:\nEach time the while loop test in line 2 in G ENERIC -PUSH-RELABEL is\nexecuted, fis a pre\ufb02ow.\nInitialization: INITIALIZE -PREFLOW makes fap r e \ufb02 o w .\nMaintenance: The only operations within the while loop of lines 2\u20133 are push and\nrelabel. Relabel operations affect only height attributes and not the \ufb02ow values;hence they do not affect whether fis a pre\ufb02ow. As argued on page 739, if fis\na pre\ufb02ow prior to a push operation, it remains a pre\ufb02ow afterward.\nTermination: At termination, each vertex in V/NULfs; tgmust have an excess of 0,\nbecause by Lemma 26.14 and the invariant that fis always a pre\ufb02ow, there are\nno over\ufb02owing vertices. Therefore, fis a \ufb02ow. Lemma 26.16 shows that his\na height function at termination, and thus Lemma 26.17 tells us that there is nopath from stotin the residual network G\nf. By the max-\ufb02ow min-cut theorem\n(Theorem 26.6), therefore, fi sam a x i m u m\ufb02 o w .\nAnalysis of the push-relabel method\nTo show that the generic push-relabel algorithm indeed terminates, we shall bound\nthe number of operations it performs. We bound separately each of the three typesof operations: relabels, saturating pushes, and nonsaturating pushes. With knowl-\nedge of these bounds, it is a straightforward problem to construct an algorithm that\nruns in O.V\n2E/time. Before beginning the analysis, however, we prove an im-\nportant lemma. Recall that we allow edges into the source in the residual network.\nLemma 26.19\nLetGD.V; E/ be a \ufb02ow network with source sand sink t,a n dl e t fb eap r e \ufb02 o w\ninG. Then, for any over\ufb02owing vertex x, there is a simple path from xtosin the\nresidual network Gf.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "764": {"page_number": 765, "page_information": "744 Chapter 26 Maximum Flow\nProof For an over\ufb02owing vertex x,l e tUDf/ETBWthere exists a simple path from x\nto/ETBinGfg, and suppose for the sake of contradiction that s62U.L e t\n UDV/NULU.\nWe take the de\ufb01nition of excess from equation (26.14), sum over all vertices\ninU, and note that VDU[\nU, to obtainX\nu2Ue.u/\nDX\nu2U X\n/ETB2Vf. /ETB;u //NULX\n/ETB2Vf. u ;/ETB/!\nDX\nu2U  X\n/ETB2Uf. /ETB;u /CX\n/ETB2\nUf. /ETB;u /!\n/NUL X\n/ETB2Uf. u ;/ETB/CX\n/ETB2\nUf. u ;/ETB/!!\nDX\nu2UX\n/ETB2Uf. /ETB;u /CX\nu2UX\n/ETB2\nUf. /ETB;u //NULX\nu2UX\n/ETB2Uf. u ;/ETB//NULX\nu2UX\n/ETB2\nUf. u ;/ETB/\nDX\nu2UX\n/ETB2\nUf. /ETB;u //NULX\nu2UX\n/ETB2\nUf. u ;/ETB/:\nWe know that the quantityP\nu2Ue.u/ must be positive because e.x/ > 0 ,x2U,\nall vertices other than shave nonnegative excess, and, by assumption, s62U. Thus,\nwe haveX\nu2UX\n/ETB2\nUf. /ETB;u //NULX\nu2UX\n/ETB2\nUf. u ;/ETB/>0: (26.17)\nAll edge \ufb02ows are nonnegative, and so for equation (26.17) to hold, we must haveP\nu2UP\n/ETB2\nUf. /ETB;u / > 0 . Hence, there must exist at least one pair of vertices\nu02Uand/ETB02\nUwith f. /ETB0;u0/>0 .B u t , i f f. /ETB0;u0/>0 , there must be a\nresidual edge .u0;/ETB0/, which means that there is a simple path from xto/ETB0(the\npathx;u0!/ETB0), thus contradicting the de\ufb01nition of U.\nThe next lemma bounds the heights of vertices, and its corollary bounds the\nnumber of relabel operations that are performed in total.\nLemma 26.20\nLetGD.V; E/ be a \ufb02ow network with source sand sink t. At any time during\nthe execution of G ENERIC -PUSH-RELABEL onG,w eh a v e u:h/DC42jVj/NUL1for all\nvertices u2V.\nProof The heights of the source sand the sink tnever change because these\nvertices are by de\ufb01nition not over\ufb02owing. Thus, we always have s:hDjVjand\nt:hD0, both of which are no greater than 2jVj/NUL1.\nNow consider any vertex u2V/NULfs; tg. Initially, u:hD0/DC42jVj/NUL1.W es h a l l\nshow that after each relabeling operation, we still have u:h/DC42jVj/NUL1.W h e n uis", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "765": {"page_number": 766, "page_information": "26.4 Push-relabel algorithms 745\nrelabeled, it is over\ufb02owing, and Lemma 26.19 tells us that there is a simple path p\nfrom utosinGf.L e tpDh/ETB0;/ETB1;:::;/ETB ki,w h e r e /ETB0Du,/ETBkDs,a n d k/DC4jVj/NUL1\nbecause pis simple. For iD0; 1; : : : ; k/NUL1,w eh a v e ./ETBi;/ETBiC1/2Ef,a n d\ntherefore, by Lemma 26.16, /ETBi:h/DC4/ETBiC1:hC1. Expanding these inequalities over\npathpyields u:hD/ETB0:h/DC4/ETBk:hCk/DC4s:hC.jVj/NUL1/D2jVj/NUL1.\nCorollary 26.21 (Bound on relabel operations)\nLetGD.V; E/ be a \ufb02ow network with source sand sink t. Then, during the\nexecution of G ENERIC -PUSH-RELABEL onG, the number of relabel operations is\nat most 2jVj/NUL1per vertex and at most .2jVj/NUL1/.jVj/NUL2/ < 2jVj2overall.\nProof Only thejVj/NUL2vertices in V/NULfs; tgmay be relabeled. Let u2V/NULfs; tg.\nThe operation R ELABEL .u/increases u:h.T h e v a l u e o f u:his initially 0and by\nLemma 26.20, it grows to at most 2jVj/NUL1. Thus, each vertex u2V/NULfs; tg\nis relabeled at most 2jVj/NUL1times, and the total number of relabel operations\nperformed is at most .2jVj/NUL1/.jVj/NUL2/ < 2jVj2.\nLemma 26.20 also helps us to bound the number of saturating pushes.\nLemma 26.22 (Bound on saturating pushes)\nDuring the execution of G ENERIC -PUSH-RELABEL on any \ufb02ow network GD\n.V; E/ , the number of saturating pushes is less than 2jVjjEj.\nProof For any pair of vertices u; /ETB2V, we will count the saturating pushes\nfrom uto/ETBand from /ETBtoutogether, calling them the saturating pushes between u\nand/ETB. If there are any such pushes, at least one of .u; /ETB/ and./ETB; u/ is actually\nan edge in E. Now, suppose that a saturating push from uto/ETBhas occurred.\nAt that time, /ETB:hDu:h/NUL1. In order for another push from uto/ETBto occur\nlater, the algorithm must \ufb01rst push \ufb02ow from /ETBtou, which cannot happen until\n/ETB:hDu:hC1.S i n c e u:hnever decreases, in order for /ETB:hDu:hC1,t h e\nvalue of /ETB:hmust increase by at least 2. Likewise, u:hmust increase by at least 2\nbetween saturating pushes from /ETBtou. Heights start at 0and, by Lemma 26.20,\nnever exceed 2jVj/NUL1, which implies that the number of times any vertex can have\nits height increase by 2is less thanjVj. Since at least one of u:hand/ETB:hmust\nincrease by 2between any two saturating pushes between uand/ETB, there are fewer\nthan2jVjsaturating pushes between uand/ETB. Multiplying by the number of edges\ngives a bound of less than 2jVjjEjon the total number of saturating pushes.\nThe following lemma bounds the number of nonsaturating pushes in the generic\npush-relabel algorithm.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "766": {"page_number": 767, "page_information": "746 Chapter 26 Maximum Flow\nLemma 26.23 (Bound on nonsaturating pushes)\nDuring the execution of G ENERIC -PUSH-RELABEL on any \ufb02ow network GD\n.V; E/ , the number of nonsaturating pushes is less than 4jVj2.jVjCjEj/.\nProof De\ufb01ne a potential function \u02c6DP\n/ETBWe./ETB/>0 /ETB:h. Initially, \u02c6D0,a n dt h e\nvalue of \u02c6may change after each relabeling, saturating push, and nonsaturating\npush. We will bound the amount that saturating pushes and relabelings can con-tribute to the increase of \u02c6. Then we will show that each nonsaturating push must\ndecrease \u02c6by at least 1, and will use these bounds to derive an upper bound on the\nnumber of nonsaturating pushes.\nLet us examine the two ways in which \u02c6might increase. First, relabeling a\nvertex uincreases \u02c6by less than 2jVj, since the set over which the sum is taken is\nthe same and the relabeling cannot increase u\u2019s height by more than its maximum\npossible height, which, by Lemma 26.20, is at most 2jVj/NUL1. Second, a saturating\npush from a vertex uto a vertex /ETBincreases \u02c6by less than 2jVj, since no heights\nchange and only vertex /ETB, whose height is at most 2jVj/NUL1, can possibly become\nover\ufb02owing.\nNow we show that a nonsaturating push from uto/ETBdecreases \u02c6by at least 1.\nWhy? Before the nonsaturating push, uwas over\ufb02owing, and /ETBmay or may not\nhave been over\ufb02owing. By Lemma 26.13, uis no longer over\ufb02owing after the\npush. In addition, unless /ETBis the source, it may or may not be over\ufb02owing after\nthe push. Therefore, the potential function \u02c6has decreased by exactly u:h,a n di t\nhas increased by either 0or/ETB:h.S i n c e u:h/NUL\n/ETB:hD1, the net effect is that the\npotential function has decreased by at least 1.\nThus, during the course of the algorithm, the total amount of increase in \u02c6is\ndue to relabelings and saturated pushes, and Corollary 26.21 and Lemma 26.22constrain the increase to be less than .2jVj/.2jVj\n2/C.2jVj/.2jVjjEj/D\n4jVj2.jVjCjEj/.S i n c e \u02c6/NAK0, the total amount of decrease, and therefore the\ntotal number of nonsaturating pushes, is less than 4jVj2.jVjCjEj/.\nHaving bounded the number of relabelings, saturating pushes, and nonsatu-\nrating push, we have set the stage for the following analysis of the G ENERIC -\nPUSH-RELABEL procedure, and hence of any algorithm based on the push-relabel\nmethod.\nTheorem 26.24\nDuring the execution of G ENERIC -PUSH-RELABEL on any \ufb02ow network GD\n.V; E/ , the number of basic operations is O.V2E/.\nProof Immediate from Corollary 26.21 and Lemmas 26.22 and 26.23.\n", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "767": {"page_number": 768, "page_information": "26.4 Push-relabel algorithms 747\nThus, the algorithm terminates after O.V2E/operations. All that remains is\nto give an ef\ufb01cient method for implementing each operation and for choosing anappropriate operation to execute.\nCorollary 26.25\nThere is an implementation of the generic push-relabel algorithm that runs inO.V\n2E/time on any \ufb02ow network GD.V; E/ .\nProof Exercise 26.4-2 asks you to show how to implement the generic algorithm\nwith an overhead of O.V / per relabel operation and O.1/ per push. It also asks\nyou to design a data structure that allows you to pick an applicable operation inO.1/ time. The corollary then follows.\nExercises\n26.4-1\nProve that, after the procedure I NITIALIZE -PREFLOW .G; s/ terminates, we have\ns:e/DC4/NULjf/ETXj,w h e r e f/ETXis a maximum \ufb02ow for G.\n26.4-2\nShow how to implement the generic push-relabel algorithm using O.V / time per\nrelabel operation, O.1/ time per push, and O.1/ time to select an applicable oper-\nation, for a total time of O.V2E/.\n26.4-3\nProve that the generic push-relabel algorithm spends a total of only O.VE/ time\nin performing all the O.V2/relabel operations.\n26.4-4\nSuppose that we have found a maximum \ufb02ow in a \ufb02ow network GD.V; E/ using\na push-relabel algorithm. Give a fast algorithm to \ufb01nd a minimum cut in G.\n26.4-5\nGive an ef\ufb01cient push-relabel algorithm to \ufb01nd a maximum matching in a bipartitegraph. Analyze your algorithm.\n26.4-6\nSuppose that all edge capacities in a \ufb02ow network GD.V; E/ are in the set\nf1 ;2;:::;kg. Analyze the running time of the generic push-relabel algorithm in\nterms ofjVj,jEj,a n d k.(Hint: How many times can each edge support a nonsat-\nurating push before it becomes saturated?)", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "768": {"page_number": 769, "page_information": "748 Chapter 26 Maximum Flow\n26.4-7\nShow that we could change line 6 of I NITIALIZE -PREFLOW to\n6s:hDjG:Vj/NUL2\nwithout affecting the correctness or asymptotic performance of the generic push-\nrelabel algorithm.\n26.4-8\nLet\u0131f.u; /ETB/ be the distance (number of edges) from uto/ETBin the residual net-\nwork Gf. Show that the G ENERIC -PUSH-RELABEL procedure maintains the\nproperties that u:h<jVjimplies u:h/DC4\u0131f.u; t/ and that u:h/NAKjVjimplies\nu:h/NULjVj/DC4\u0131f.u; s/ .\n26.4-9 ?\nAs in the previous exercise, let \u0131f.u; /ETB/ be the distance from uto/ETBin the residual\nnetwork Gf. Show how to modify the generic push-relabel algorithm to maintain\nthe property that u:h<jVjimplies u:hD\u0131f.u; t/ and that u:h/NAKjVjimplies\nu:h/NULjVjD\u0131f.u; s/ . The total time that your implementation dedicates to main-\ntaining this property should be O.VE/ .\n26.4-10\nShow that the number of nonsaturating pushes executed by the G ENERIC -PUSH-\nRELABEL procedure on a \ufb02ow network GD.V; E/ is at most 4jVj2jEjfor\njVj/NAK4.\n?26.5 The relabel-to-front algorithm\nThe push-relabel method allows us to apply the basic operations in any order at\nall. By choosing the order carefully and managing the network data structure ef\ufb01-\nciently, however, we can solve the maximum-\ufb02ow problem faster than the O.V2E/\nbound given by Corollary 26.25. We shall now examine the relabel-to-front algo-rithm, a push-relabel algorithm whose running time is O.V\n3/, which is asymptot-\nically at least as good as O.V2E/, and even better for dense networks.\nThe relabel-to-front algorithm maintains a list of the vertices in the network.\nBeginning at the front, the algorithm scans the list, repeatedly selecting an over-\ufb02owing vertex uand then \u201cdischarging\u201d it, that is, performing push and relabel\noperations until uno longer has a positive excess. Whenever we relabel a ver-\ntex, we move it to the front of the list (hence the name \u201crelabel-to-front\u201d) and thealgorithm begins its scan anew.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "769": {"page_number": 770, "page_information": "26.5 The relabel-to-front algorithm 749\nThe correctness and analysis of the relabel-to-front algorithm depend on the\nnotion of \u201cadmissible\u201d edges: those edges in the residual network through which\ufb02ow can be pushed. After proving some properties about the network of admissibleedges, we shall investigate the discharge operation and then present and analyze therelabel-to-front algorithm itself.\nAdmissible edges and networks\nIfGD.V; E/ is a \ufb02ow network with source sand sink t,fis a pre\ufb02ow in G,a n d h\nis a height function, then we say that .u; /ETB/ is anadmissible edge ifc\nf.u; /ETB/ > 0\nandh.u/Dh./ETB/C1. Otherwise, .u; /ETB/ isinadmissible .T h eadmissible network\nisGf;hD.V; E f;h/,w h e r e Ef;his the set of admissible edges.\nThe admissible network consists of those edges through which we can push \ufb02ow.\nThe following lemma shows that this network is a directed acyclic graph (dag).\nLemma 26.26 (The admissible network is acyclic)\nIfGD.V; E/ is a \ufb02ow network, fis a pre\ufb02ow in G,a n d his a height function\nonG, then the admissible network Gf;hD.V; E f;h/is acyclic.\nProof The proof is by contradiction. Suppose that Gf;hcontains a cycle pD\nh/ETB0;/ETB1;:::;/ETB ki,w h e r e /ETB0D/ETBkandk>0 . Since each edge in pis admissible, we\nhave h./ETB i/NUL1/Dh./ETB i/C1foriD1 ;2;:::;k . Summing around the cycle gives\nkX\niD1h./ETB i/NUL1/DkX\niD1.h./ETB i/C1/\nDkX\niD1h./ETB i/Ck:\nBecause each vertex in cycle pappears once in each of the summations, we derive\nthe contradiction that 0Dk.\nThe next two lemmas show how push and relabel operations change the admis-\nsible network.\nLemma 26.27\nLetGD.V; E/ be a \ufb02ow network, let fb eap r e \ufb02 o wi n G, and suppose that the\nattribute his a height function. If a vertex uis over\ufb02owing and .u; /ETB/ is an ad-\nmissible edge, then P USH.u; /ETB/ applies. The operation does not create any new\nadmissible edges, but it may cause .u; /ETB/ to become inadmissible.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "770": {"page_number": 771, "page_information": "750 Chapter 26 Maximum Flow\nProof By the de\ufb01nition of an admissible edge, we can push \ufb02ow from uto/ETB.\nSince uis over\ufb02owing, the operation P USH.u; /ETB/ applies. The only new residual\nedge that pushing \ufb02ow from uto/ETBcan create is ./ETB; u/ .S i n c e /ETB:hDu:h/NUL1,\nedge ./ETB; u/ cannot become admissible. If the operation is a saturating push, then\ncf.u; /ETB/D0afterward and .u; /ETB/ becomes inadmissible.\nLemma 26.28\nLetGD.V; E/ be a \ufb02ow network, let fb eap r e \ufb02 o wi n G, and suppose that\nthe attribute his a height function. If a vertex uis over\ufb02owing and there are no\nadmissible edges leaving u,t h e nR ELABEL .u/applies. After the relabel operation,\nthere is at least one admissible edge leaving u, but there are no admissible edges\nentering u.\nProof Ifuis over\ufb02owing, then by Lemma 26.14, either a push or a relabel op-\neration applies to it. If there are no admissible edges leaving u,t h e nn o\ufb02 o w\ncan be pushed from uand so R ELABEL .u/applies. After the relabel operation,\nu:hD1Cminf/ETB:hW.u; /ETB/2Efg. Thus, if /ETBis a vertex that realizes the mini-\nmum in this set, the edge .u; /ETB/ becomes admissible. Hence, after the relabel, there\nis at least one admissible edge leaving u.\nTo show that no admissible edges enter uafter a relabel operation, suppose that\nthere is a vertex /ETBsuch that ./ETB; u/ is admissible. Then, /ETB:hDu:hC1after the\nrelabel, and so /ETB:h>u : hC1just before the relabel. But by Lemma 26.12, no\nresidual edges exist between vertices whose heights differ by more than 1.M o r e -\nover, relabeling a vertex does not change the residual network. Thus, ./ETB; u/ is not\nin the residual network, and hence it cannot be in the admissible network.\nNeighbor lists\nEdges in the relabel-to-front algorithm are organized into \u201cneighbor lists.\u201d Given\na \ufb02ow network GD.V; E/ ,t h eneighbor list u:Nfor a vertex u2Vis a singly\nlinked list of the neighbors of uinG. Thus, vertex /ETBappears in the list u:Nif\n.u; /ETB/2Eor./ETB; u/2E. The neighbor list u:Ncontains exactly those vertices /ETB\nfor which there may be a residual edge .u; /ETB/ . The attribute u:N:head points to\nthe \ufb01rst vertex in u:N,a n d /ETB:next-neighbor points to the vertex following /ETBin a\nneighbor list; this pointer is NILif/ETBis the last vertex in the neighbor list.\nThe relabel-to-front algorithm cycles through each neighbor list in an arbitrary\norder that is \ufb01xed throughout the execution of the algorithm. For each vertex u,\nthe attribute u:current points to the vertex currently under consideration in u:N.\nInitially, u:current is set to u:N:head .", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "771": {"page_number": 772, "page_information": "26.5 The relabel-to-front algorithm 751\nDischarging an over\ufb02owing vertex\nAn over\ufb02owing vertex uisdischarged by pushing all of its excess \ufb02ow through\nadmissible edges to neighboring vertices, relabeling uas necessary to cause edges\nleaving uto become admissible. The pseudocode goes as follows.\nDISCHARGE .u/\n1while u:e>0\n2 /ETBDu:current\n3 if/ETB==NIL\n4R ELABEL .u/\n5 u:currentDu:N:head\n6 elseif cf.u; /ETB/ > 0 andu:h==/ETB:hC1\n7P USH.u; /ETB/\n8 elseu:currentD/ETB:next-neighbor\nFigure 26.9 steps through several iterations of the while loop of lines 1\u20138, which\nexecutes as long as vertex uhas positive excess. Each iteration performs exactly\none of three actions, depending on the current vertex /ETBin the neighbor list u:N.\n1. If /ETBisNIL, then we have run off the end of u:N. Line 4 relabels vertex u,\nand then line 5 resets the current neighbor of uto be the \ufb01rst one in u:N.\n(Lemma 26.29 below states that the relabel operation applies in this situation.)\n2. If /ETBis non- NIL and.u; /ETB/ is an admissible edge (determined by the test in\nline 6), then line 7 pushes some (or possibly all) of u\u2019s excess to vertex /ETB.\n3. If /ETBis non- NILbut.u; /ETB/ is inadmissible, then line 8 advances u:current one\nposition further in the neighbor list u:N.\nObserve that if D ISCHARGE is called on an over\ufb02owing vertex u, then the last\naction performed by D ISCHARGE must be a push from u. Why? The procedure\nterminates only when u:ebecomes zero, and neither the relabel operation nor ad-\nvancing the pointer u:current affects the value of u:e.\nWe must be sure that when P USH or R ELABEL is called by D ISCHARGE ,t h e\noperation applies. The next lemma proves this fact.\nLemma 26.29\nIf D ISCHARGE calls P USH.u; /ETB/ in line 7, then a push operation applies to .u; /ETB/ .\nIf D ISCHARGE calls R ELABEL .u/in line 4, then a relabel operation applies to u.\nProof The tests in lines 1 and 6 ensure that a push operation occurs only if the\noperation applies, which proves the \ufb01rst statement in the lemma.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "772": {"page_number": 773, "page_information": "752 Chapter 26 Maximum Flow\ns\n\u2013265\n432106\nx\n0y\n19z\n05/5 814/14s\nx\nz\ns\n\u2013265\n432106\nx\n0y\n19z\n0814/14s\nxz\n5/5\ns\n\u2013265\n432106\nx\n0y\n11z\n88/814/14\n5/5s\nx\nzs\nx\nz123\ns\nx\nz4\n5\ns\nxz6\ns\nxz7\ns\nxz8\ns\nxz9(a)\n(b)\n(c)\nFigure 26.9 Discharging a vertex y. It takes 15iterations of the while loop of D ISCHARGE to push\nall the excess \ufb02ow from y. Only the neighbors of yand edges of the \ufb02ow network that enter or leave y\nare shown. In each part of the \ufb01gure, the number inside each vertex is its excess at the beginning of\nthe \ufb01rst iteration shown in the part, and each vertex is shown at its height throughout the part. The\nneighbor list y:Nat the beginning of each iteration appears on the right, with the iteration number\non top. The shaded neighbor is y:current .(a)Initially, there are 19units of excess to push from y,\nandy:currentDs. Iterations 1, 2, and 3 just advance y:current , since there are no admissible edges\nleaving y. I ni t e r a t i o n4 , y:currentDNIL(shown by the shading being below the neighbor list),\nand so yis relabeled and y:current is reset to the head of the neighbor list. (b)After relabeling,\nvertex yhas height 1. In iterations 5 and 6, edges .y; s/ and.y; x/ are found to be inadmissible, but\niteration 7 pushes 8units of excess \ufb02ow from yto\u00b4. Because of the push, y:current does not advance\nin this iteration. (c)Because the push in iteration 7 saturated edge .y; \u00b4/ , it is found inadmissible in\niteration 8. In iteration 9, y:currentDNIL,a n ds ov e r t e x yis again relabeled and y:current is reset.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "773": {"page_number": 774, "page_information": "26.5 The relabel-to-front algorithm 753\ns\n\u2013265\n432106\nx\n5y\n6\nz\n858/814/14s\n\u2013265\n432106\nx\n0y\n11\nz\n88/814/14\n5/5\ns\n\u2013265\n432106\nx\n5y\n6\nz\n88/814/14\n5\ns\n\u2013205\n432106\nx\n5y\n0\nz\n858/88/14s\nxz10\ns\nxz11\ns\nxz12\ns\nxz13\ns\nxz14\ns\nxz15\n(f)(d)\n(e)\n(g)\nFigure 26.9, continued (d) In iteration 10, .y; s/ is inadmissible, but iteration 11 pushes 5units\nof excess \ufb02ow from ytox.(e)Because y:current did not advance in iteration 11, iteration 12\n\ufb01nds .y; x/ to be inadmissible. Iteration 13 \ufb01nds .y; \u00b4/ inadmissible, and iteration 14 relabels ver-\ntexyand resets y:current .(f)Iteration 15 pushes 6units of excess \ufb02ow from ytos.(g)Vertex y\nnow has no excess \ufb02ow, and D ISCHARGE terminates. In this example, D ISCHARGE both starts and\n\ufb01nishes with the current pointer at the head of the neighbor list, but in general this need not be the\ncase.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "774": {"page_number": 775, "page_information": "754 Chapter 26 Maximum Flow\nTo prove the second statement, according to the test in line 1 and Lemma 26.28,\nwe need only show that all edges leaving uare inadmissible. If a call to\nDISCHARGE .u/starts with the pointer u:current at the head of u\u2019s neighbor list\nand \ufb01nishes with it off the end of the list, then all of u\u2019s outgoing edges are in-\nadmissible and a relabel operation applies. It is possible, however, that during acall to D\nISCHARGE .u/, the pointer u:current traverses only part of the list be-\nfore the procedure returns. Calls to D ISCHARGE on other vertices may then oc-\ncur, but u:current will continue moving through the list during the next call to\nDISCHARGE .u/. We now consider what happens during a complete pass through\nthe list, which begins at the head of u:Nand \ufb01nishes with u:currentDNIL.O n c e\nu:current reaches the end of the list, the procedure relabels uand begins a new\npass. For the u:current pointer to advance past a vertex /ETB2u:Nduring a pass, the\nedge .u; /ETB/ must be deemed inadmissible by the test in line 6. Thus, by the time\nthe pass completes, every edge leaving uhas been determined to be inadmissible\nat some time during the pass. The key observation is that at the end of the pass,\nevery edge leaving uis still inadmissible. Why? By Lemma 26.27, pushes cannot\ncreate any admissible edges, regardless of which vertex the \ufb02ow is pushed from.\nThus, any admissible edge must be created by a relabel operation. But the vertex u\nis not relabeled during the pass, and by Lemma 26.28, any other vertex /ETBthat is\nrelabeled during the pass (resulting from a call of D ISCHARGE ./ETB/) has no entering\nadmissible edges after relabeling. Thus, at the end of the pass, all edges leaving u\nremain inadmissible, which completes the proof.\nThe relabel-to-front algorithm\nIn the relabel-to-front algorithm, we maintain a linked list Lconsisting of all ver-\ntices in V/NULfs; tg. A key property is that the vertices in Lare topologically sorted\naccording to the admissible network, as we shall see in the loop invariant that fol-\nlows. (Recall from Lemma 26.26 that the admissible network is a dag.)\nThe pseudocode for the relabel-to-front algorithm assumes that the neighbor\nlistsu:Nhave already been created for each vertex u. It also assumes that u:next\npoints to the vertex that follows uin list Land that, as usual, u:nextDNILifuis\nthe last vertex in the list.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "775": {"page_number": 776, "page_information": "26.5 The relabel-to-front algorithm 755\nRELABEL -TO-FRONT . G ;s ;t/\n1I NITIALIZE -PREFLOW .G; s/\n2LDG:V/NULfs; tg, in any order\n3foreach vertex u2G:V/NULfs; tg\n4 u:currentDu:N:head\n5uDL:head\n6while u\u00a4NIL\n7 old-heightDu:h\n8D ISCHARGE .u/\n9 ifu:h>old-height\n10 move uto the front of list L\n11 uDu:next\nThe relabel-to-front algorithm works as follows. Line 1 initializes the pre\ufb02ow\nand heights to the same values as in the generic push-relabel algorithm. Line 2initializes the list Lto contain all potentially over\ufb02owing vertices, in any order.\nLines 3\u20134 initialize the current pointer of each vertex uto the \ufb01rst vertex in u\u2019s\nneighbor list.\nAs Figure 26.10 illustrates, the while loop of lines 6\u201311 runs through the list L,\ndischarging vertices. Line 5 makes it start with the \ufb01rst vertex in the list. Eachtime through the loop, line 8 discharges a vertex u.I fuwas relabeled by the\nD\nISCHARGE procedure, line 10 moves it to the front of list L. We can determine\nwhether uwas relabeled by comparing its height before the discharge operation,\nsaved into the variable old-height in line 7, with its height afterward, in line 9.\nLine 11 makes the next iteration of the while loop use the vertex following uin\nlistL. If line 10 moved uto the front of the list, the vertex used in the next iteration\nis the one following uin its new position in the list.\nTo show that R ELABEL -TO-FRONT computes a maximum \ufb02ow, we shall show\nthat it is an implementation of the generic push-relabel algorithm. First, ob-serve that it performs push and relabel operations only when they apply, sinceLemma 26.29 guarantees that D\nISCHARGE performs them only when they apply.\nIt remains to show that when R ELABEL -TO-FRONT terminates, no basic opera-\ntions apply. The remainder of the correctness argument relies on the followingloop invariant:\nAt each test in line 6 of R\nELABEL -TO-FRONT , list Lis a topological sort\nof the vertices in the admissible network Gf;hD.V; E f;h/, and no vertex\nbefore uin the list has excess \ufb02ow.\nInitialization: Immediately after I NITIALIZE -PREFLOW has been run, s:hDjVj\nand/ETB:hD0for all /ETB2V/NULfsg.S i n c ejVj/NAK2(because Vcontains at", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "776": {"page_number": 777, "page_information": "756 Chapter 26 Maximum Flow\ns\n\u2013265\n432106\nx\n12y\n14z\n0t\n058 1 0\n71614/1412/12L:xyz\nN:s\ny\nz\nts\nxzx\ny\nt(a)\ns\n\u2013265\n432106\nx\n0y\n19z\n0t\n75/5 81 014/14 12/12L:xyz\nN:s\ny\nz\nts\nxzx\ny\nt(b)\n77/16\ns\n\u2013205\n432106\nx\n5y\n0\nz\n8t\n758/8\n108/14\n12/12L: x yz\nN: s\nyz\nts\nx\nzx\ny\nt(c)\n77/16\nFigure 26.10 The action of R ELABEL -TO-FRONT .(a)A \ufb02ow network just before the \ufb01rst iteration\nof the while loop. Initially, 26units of \ufb02ow leave source s. On the right is shown the initial list\nLDhx;y;\u00b4i, where initially uDx. Under each vertex in list Lis its neighbor list, with the current\nneighbor shaded. Vertex xis discharged. It is relabeled to height 1,5units of excess \ufb02ow are pushed\ntoy,a n dt h e 7remaining units of excess are pushed to the sink t. Because xis relabeled, it moves\nto the head of L, which in this case does not change the structure of L.(b)After x, the next vertex\ninLthat is discharged is y. Figure 26.9 shows the detailed action of discharging yin this situation.\nBecause yis relabeled, it is moved to the head of L.(c)Vertex xnow follows yinL, and so it is\nagain discharged, pushing all 5units of excess \ufb02ow to t. Because vertex xis not relabeled in this\ndischarge operation, it remains in place in list L.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "777": {"page_number": 778, "page_information": "26.5 The relabel-to-front algorithm 757\ns\n\u2013205\n432106\nx\n0y0\nz\n8t\n1258/8\n108/14\n12/12L: x yz\nN: s\ny\nz\nts\nxzx\ny\nt(d)\n712/16\ns\n\u2013205\n432106\nx\n0y0\nz\n0t\n2058/8\n8/108/14\n12/12L: x y z\nN: s\nyz\nts\nx\nzx\ny\nt(e)\n12/167\nFigure 26.10, continued (d) Since vertex \u00b4follows vertex xinL, it is discharged. It is relabeled\nto height 1and all 8units of excess \ufb02ow are pushed to t. Because \u00b4is relabeled, it moves to the\nfront of L.(e)Vertex ynow follows vertex \u00b4inLand is therefore discharged. But because yhas no\nexcess, D ISCHARGE immediately returns, and yremains in place in L.V e r t e x xis then discharged.\nBecause it, too, has no excess, D ISCHARGE again returns, and xremains in place in L.RELABEL -\nTO-FRONT has reached the end of list Land terminates. There are no over\ufb02owing vertices, and the\npre\ufb02ow is a maximum \ufb02ow.\nleast sandt), no edge can be admissible. Thus, Ef;hD;, and any ordering of\nV/NULfs; tgis a topological sort of Gf;h.\nBecause uis initially the head of the list L, there are no vertices before it and\nso there are none before it with excess \ufb02ow.\nMaintenance: To see that each iteration of the while loop maintains the topolog-\nical sort, we start by observing that the admissible network is changed only by\npush and relabel operations. By Lemma 26.27, push operations do not cause\nedges to become admissible. Thus, only relabel operations can create admissi-ble edges. After a vertex uis relabeled, however, Lemma 26.28 states that there\nare no admissible edges entering ubut there may be admissible edges leaving u.\nThus, by moving uto the front of L, the algorithm ensures that any admissible\nedges leaving usatisfy the topological sort ordering.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "778": {"page_number": 779, "page_information": "758 Chapter 26 Maximum Flow\nTo see that no vertex preceding uinLhas excess \ufb02ow, we denote the vertex\nthat will be uin the next iteration by u0. The vertices that will precede u0in the\nnext iteration include the current u(due to line 11) and either no other vertices\n(ifuis relabeled) or the same vertices as before (if uis not relabeled). When u\nis discharged, it has no excess \ufb02ow afterward. Thus, if uis relabeled during\nthe discharge, no vertices preceding u0have excess \ufb02ow. If uis not relabeled\nduring the discharge, no vertices before it on the list acquired excess \ufb02ow duringthis discharge, because Lremained topologically sorted at all times during the\ndischarge (as just pointed out, admissible edges are created only by relabeling,\nnot pushing), and so each push operation causes excess \ufb02ow to move only tovertices further down the list (or to sort). Again, no vertices preceding u\n0have\nexcess \ufb02ow.\nTermination: When the loop terminates, uis just past the end of L,a n ds ot h e\nloop invariant ensures that the excess of every vertex is 0. Thus, no basic oper-\nations apply.\nAnalysis\nWe shall now show that R ELABEL -TO-FRONT runs in O.V3/time on any \ufb02ow\nnetwork GD.V; E/ . Since the algorithm is an implementation of the generic\npush-relabel algorithm, we shall take advantage of Corollary 26.21, which pro-\nvides an O.V / bound on the number of relabel operations executed per vertex and\nanO.V2/bound on the total number of relabel operations overall. In addition, Ex-\nercise 26.4-3 provides an O.VE/ bound on the total time spent performing relabel\noperations, and Lemma 26.22 provides an O.VE/ bound on the total number of\nsaturating push operations.\nTheorem 26.30\nThe running time of R ELABEL -TO-FRONT on any \ufb02ow network GD.V; E/\nisO.V3/.\nProof Let us consider a \u201cphase\u201d of the relabel-to-front algorithm to be the time\nbetween two consecutive relabel operations. There are O.V2/phases, since there\nareO.V2/relabel operations. Each phase consists of at most jVjcalls to D IS-\nCHARGE , which we can see as follows. If D ISCHARGE does not perform a re-\nlabel operation, then the next call to D ISCHARGE is further down the list L,a n d\nthe length of Lis less thanjVj.I f D ISCHARGE does perform a relabel, the next\ncall to D ISCHARGE belongs to a different phase. Since each phase contains at\nmostjVjcalls to D ISCHARGE and there are O.V2/phases, the number of times\nDISCHARGE is called in line 8 of R ELABEL -TO-FRONT isO.V3/. Thus, the total", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "779": {"page_number": 780, "page_information": "26.5 The relabel-to-front algorithm 759\nwork performed by the while loop in R ELABEL -TO-FRONT , excluding the work\nperformed within D ISCHARGE ,i sa tm o s t O.V3/.\nWe must now bound the work performed within D ISCHARGE during the ex-\necution of the algorithm. Each iteration of the while loop within D ISCHARGE\nperforms one of three actions. We shall analyze the total amount of work involved\nin performing each of these actions.\nWe start with relabel operations (lines 4\u20135). Exercise 26.4-3 provides an O.VE/\ntime bound on all the O.V2/relabels that are performed.\nNow, suppose that the action updates the u:current pointer in line 8. This action\noccurs O.degree .u// times each time a vertex uis relabeled, and O.V/SOHdegree .u//\ntimes overall for the vertex. For all vertices, therefore, the total amount of workdone in advancing pointers in neighbor lists is O.VE/ by the handshaking lemma\n(Exercise B.4-1).\nThe third type of action performed by D\nISCHARGE is a push operation (line 7).\nWe already know that the total number of saturating push operations is O.VE/ .\nObserve that if a nonsaturating push is executed, D ISCHARGE immediately returns,\nsince the push reduces the excess to 0. Thus, there can be at most one nonsaturating\npush per call to D ISCHARGE .A sw eh a v eo b s e r v e d ,D ISCHARGE is called O.V3/\ntimes, and thus the total time spent performing nonsaturating pushes is O.V3/.\nThe running time of R ELABEL -TO-FRONT is therefore O.V3CVE/,w h i c h\nisO.V3/.\nExercises\n26.5-1\nIllustrate the execution of R ELABEL -TO-FRONT in the manner of Figure 26.10 for\nthe \ufb02ow network in Figure 26.1(a). Assume that the initial ordering of vertices in L\nish/ETB1;/ETB2;/ETB3;/ETB4iand that the neighbor lists are\n/ETB1:NDh s; /ETB 2;/ETB3i;\n/ETB2:NDh s; /ETB 1;/ETB3;/ETB4i;\n/ETB3:NDh /ETB1;/ETB2;/ETB4;ti;\n/ETB4:NDh /ETB2;/ETB3;ti:\n26.5-2 ?\nWe would like to implement a push-relabel algorithm in which we maintain a \ufb01rst-in, \ufb01rst-out queue of over\ufb02owing vertices. The algorithm repeatedly discharges thevertex at the head of the queue, and any vertices that were not over\ufb02owing beforethe discharge but are over\ufb02owing afterward are placed at the end of the queue.After the vertex at the head of the queue is discharged, it is removed. When the", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "780": {"page_number": 781, "page_information": "760 Chapter 26 Maximum Flow\nqueue is empty, the algorithm terminates. Show how to implement this algorithm\nto compute a maximum \ufb02ow in O.V3/time.\n26.5-3\nShow that the generic algorithm still works if R ELABEL updates u:hby sim-\nply computing u:hDu:hC1. How would this change affect the analysis of\nRELABEL -TO-FRONT ?\n26.5-4 ?\nShow that if we always discharge a highest over\ufb02owing vertex, we can make the\npush-relabel method run in O.V3/time.\n26.5-5\nSuppose that at some point in the execution of a push-relabel algorithm, there existsan integer 0<k/DC4jVj/NUL1for which no vertex has /ETB:hDk. Show that all\nvertices with /ETB:h>k are on the source side of a minimum cut. If such a kexists,\nthegap heuristic updates every vertex /ETB2V/NULfsgfor which /ETB:h>k, to set\n/ETB:hDmax./ETB:h;jVjC1/. Show that the resulting attribute his a height function.\n(The gap heuristic is crucial in making implementations of the push-relabel methodperform well in practice.)\nProblems\n26-1 Escape problemAnn/STXngrid is an undirected graph consisting of nrows and ncolumns of vertices,\nas shown in Figure 26.11. We denote the vertex in the ith row and the jth column\nby.i; j / . All vertices in a grid have exactly four neighbors, except for the boundary\nvertices, which are the points .i; j / for which iD1,iDn,jD1,o rjDn.\nGiven m/DC4n\n2starting points .x1;y1/; .x 2;y2/ ;:::;. x m;ym/in the grid, the\nescape problem is to determine whether or not there are mvertex-disjoint paths\nfrom the starting points to any mdifferent points on the boundary. For example,\nthe grid in Figure 26.11(a) has an escape, but the grid in Figure 26.11(b) does not.\na.Consider a \ufb02ow network in which vertices, as well as edges, have capacities.\nThat is, the total positive \ufb02ow entering any given vertex is subject to a capacity\nconstraint. Show that determining the maximum \ufb02ow in a network with edge\nand vertex capacities can be reduced to an ordinary maximum-\ufb02ow problem ona \ufb02ow network of comparable size.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "781": {"page_number": 782, "page_information": "Problems for Chapter 26 761\n(a) (b)\nFigure 26.11 Grids for the escape problem. Starting points are black, and other grid vertices are\nwhite. (a)A grid with an escape, shown by shaded paths. (b)A grid with no escape.\nb.Describe an ef\ufb01cient algorithm to solve the escape problem, and analyze its\nrunning time.\n26-2 Minimum path cover\nApath cover of a directed graph GD.V; E/ is a set Pof vertex-disjoint paths\nsuch that every vertex in Vis included in exactly one path in P. Paths may start\nand end anywhere, and they may be of any length, including 0.Aminimum path\ncover ofGis a path cover containing the fewest possible paths.\na.Give an ef\ufb01cient algorithm to \ufb01nd a minimum path cover of a directed acyclic\ngraph GD.V; E/ .(Hint: Assuming that VDf1 ;2;:::;ng, construct the\ngraph G0D.V0;E0/,w h e r e\nV0Dfx0;x1;:::;x ng[fy0;y1;:::;y ng;\nE0Df.x0;xi/Wi2Vg[f.yi;y0/Wi2Vg[f.xi;yj/W.i; j /2Eg;\nand run a maximum-\ufb02ow algorithm.)\nb.Does your algorithm work for directed graphs that contain cycles? Explain.\n26-3 Algorithmic consulting\nProfessor Gore wants to open up an algorithmic consulting company. He has iden-ti\ufb01ed nimportant subareas of algorithms (roughly corresponding to different por-\ntions of this textbook), which he represents by the set ADfA\n1;A2;:::;A ng.I n\neach subarea Ak, he can hire an expert in that area for ckdollars. The consulting\ncompany has lined up a set JDfJ1;J2;:::;J mgof potential jobs. In order to\nperform job Ji, the company needs to have hired experts in a subset Ri/DC2Aof", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "782": {"page_number": 783, "page_information": "762 Chapter 26 Maximum Flow\nsubareas. Each expert can work on multiple jobs simultaneously. If the company\nchooses to accept job Ji, it must have hired experts in all subareas in Ri, and it will\ntake in revenue of pidollars.\nProfessor Gore\u2019s job is to determine which subareas to hire experts in and which\njobs to accept in order to maximize the net revenue, which is the total income fromjobs accepted minus the total cost of employing the experts.\nConsider the following \ufb02ow network G. It contains a source vertex s, vertices\nA\n1;A2;:::;A n, vertices J1;J2;:::;J m, and a sink vertex t.F o r kD1 ;2:::;n ,\nthe \ufb02ow network contains an edge .s; A k/with capacity c.s;A k/Dck,a n d\nforiD1 ;2;:::;m , the \ufb02ow network contains an edge .Ji;t/with capacity\nc.J i;t/Dpi.F o r kD1 ;2;:::;n andiD1 ;2;:::;m ,i fAk2Ri,t h e n G\ncontains an edge .Ak;Ji/with capacity c.A k;Ji/D1 .\na.Show that if Ji2Tfor a \ufb01nite-capacity cut .S; T / ofG,t h e n Ak2Tfor each\nAk2Ri.\nb.Show how to determine the maximum net revenue from the capacity of a mini-\nmum cut of Gand the given pivalues.\nc.Give an ef\ufb01cient algorithm to determine which jobs to accept and which experts\nto hire. Analyze the running time of your algorithm in terms of m,n,a n d\nrDPm\niD1jRij.\n26-4 Updating maximum \ufb02ow\nLetGD.V; E/ be a \ufb02ow network with source s,s i n k t, and integer capacities.\nSuppose that we are given a maximum \ufb02ow in G.\na.Suppose that we increase the capacity of a single edge .u; /ETB/2Eby1.G i v e\nanO.VCE/-time algorithm to update the maximum \ufb02ow.\nb.Suppose that we decrease the capacity of a single edge .u; /ETB/2Eby1.G i v e\nanO.VCE/-time algorithm to update the maximum \ufb02ow.\n26-5 Maximum \ufb02ow by scaling\nLetGD.V; E/ be a \ufb02ow network with source s,s i n k t, and an integer capac-\nityc.u;/ETB/ on each edge .u; /ETB/2E.L e t CDmax .u;/ETB/ 2Ec.u;/ETB/ .\na.Argue that a minimum cut of Ghas capacity at most CjEj.\nb.For a given number K, show how to \ufb01nd an augmenting path of capacity at\nleastKinO.E/ time, if such a path exists.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "783": {"page_number": 784, "page_information": "Problems for Chapter 26 763\nWe can use the following modi\ufb01cation of F ORD-FULKERSON -METHOD to com-\npute a maximum \ufb02ow in G:\nMAX-FLOW -BY-SCALING . G ;s ;t/\n1CDmax .u;/ETB/ 2Ec.u;/ETB/\n2 initialize \ufb02ow fto0\n3KD2blgCc\n4while K/NAK1\n5 while there exists an augmenting path pof capacity at least K\n6 augment \ufb02ow falong p\n7 KDK=2\n8return f\nc.Argue that M AX-FLOW -BY-SCALING returns a maximum \ufb02ow.\nd.Show that the capacity of a minimum cut of the residual network Gfis at most\n2KjEjeach time line 4 is executed.\ne.Argue that the inner while loop of lines 5\u20136 executes O.E/ times for each value\nofK.\nf.Conclude that M AX-FLOW -BY-SCALING can be implemented so that it runs\ninO.E2lgC/time.\n26-6 The Hopcroft-Karp bipartite matching algorithm\nIn this problem, we describe a faster algorithm, due to Hopcroft and Karp, for\n\ufb01nding a maximum matching in a bipartite graph. The algorithm runs in O.p\nVE /\ntime. Given an undirected, bipartite graph GD.V; E/ ,w h e r e VDL[Rand\nall edges have exactly one endpoint in L,l e tMbe a matching in G. We say that\nas i m p l ep a t h PinGis anaugmenting path with respect to Mif it starts at an\nunmatched vertex in L, ends at an unmatched vertex in R, and its edges belong\nalternately to MandE/NULM. (This de\ufb01nition of an augmenting path is related\nto, but different from, an augmenting path in a \ufb02ow network.) In this problem,we treat a path as a sequence of edges, rather than as a sequence of vertices. Ashortest augmenting path with respect to a matching Mis an augmenting path\nwith a minimum number of edges.\nGiven two sets AandB,t h esymmetric difference A\u02daBis de\ufb01ned as .A/NULB/[\n.B/NULA/, that is, the elements that are in exactly one of the two sets.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "784": {"page_number": 785, "page_information": "764 Chapter 26 Maximum Flow\na.Show that if Mis a matching and Pis an augmenting path with respect to M,\nthen the symmetric difference M\u02daPis a matching andjM\u02daPjDjMjC1.\nShow that if P1;P2;:::;P kare vertex-disjoint augmenting paths with respect\ntoM, then the symmetric difference M\u02da.P1[P2[/SOH/SOH/SOH[ Pk/is a matching\nwith cardinalityjMjCk.\nThe general structure of our algorithm is the following:\nHOPCROFT -KARP.G/\n1MD;\n2repeat\n3l e t PDfP1;P2;:::;P kgbe a maximal set of vertex-disjoint\nshortest augmenting paths with respect to M\n4 MDM\u02da.P1[P2[/SOH/SOH/SOH[ Pk/\n5until P==;\n6return M\nThe remainder of this problem asks you to analyze the number of iterations in\nthe algorithm (that is, the number of iterations in the repeat loop) and to describe\nan implementation of line 3.\nb.Given two matchings MandM/ETXinG, show that every vertex in the graph\nG0D.V; M\u02daM/ETX/has degree at most 2. Conclude that G0is a disjoint\nunion of simple paths or cycles. Argue that edges in each such simple path\nor cycle belong alternately to MorM/ETX. Prove that ifjMj/DC4jM/ETXj,t h e n\nM\u02daM/ETXcontains at leastjM/ETXj/NULjMjvertex-disjoint augmenting paths with\nrespect to M.\nLetlbe the length of a shortest augmenting path with respect to a matching M,a n d\nletP1;P2;:::;P kbe a maximal set of vertex-disjoint augmenting paths of length l\nwith respect to M.L e tM0DM\u02da.P1[/SOH/SOH/SOH[ Pk/, and suppose that Pi sas h o r t e s t\naugmenting path with respect to M0.\nc.Show that if Pis vertex-disjoint from P1;P2;:::;P k,t h e n Phas more than l\nedges.\nd.Now suppose that Pis not vertex-disjoint from P1;P2;:::;P k.L e t Abe the\nset of edges .M\u02daM0/\u02daP. Show that AD.P1[P2[/SOH/SOH/SOH[ Pk/\u02daPand\nthatjAj/NAK.kC1/l. Conclude that Phas more than ledges.\ne.Prove that if a shortest augmenting path with respect to Mhasledges, the size\nof the maximum matching is at most jMjCjVj=.lC1/.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "785": {"page_number": 786, "page_information": "Notes for Chapter 26 765\nf.Show that the number of repeat loop iterations in the algorithm is at\nmost 2p\njVj.(Hint: By how much can Mgrow after iteration numberp\njVj?)\ng.Give an algorithm that runs in O.E/ time to \ufb01nd a maximal set of vertex-\ndisjoint shortest augmenting paths P1;P2;:::;P kfor a given matching M.\nConclude that the total running time of H OPCROFT -KARP isO.p\nVE / .\nChapter notes\nAhuja, Magnanti, and Orlin [7], Even [103], Lawler [224], Papadimitriou and Stei-\nglitz [271], and Tarjan [330] are good references for network \ufb02ow and related algo-\nrithms. Goldberg, Tardos, and Tarjan [139] also provide a nice survey of algorithmsfor network-\ufb02ow problems, and Schrijver [304] has written an interesting reviewof historical developments in the \ufb01eld of network \ufb02ows.\nThe Ford-Fulkerson method is due to Ford and Fulkerson [109], who originated\nthe formal study of many of the problems in the area of network \ufb02ow, includingthe maximum-\ufb02ow and bipartite-matching problems. Many early implementationsof the Ford-Fulkerson method found augmenting paths using breadth-\ufb01rst search;Edmonds and Karp [102], and independently Dinic [89], proved that this strategyyields a polynomial-time algorithm. A related idea, that of using \u201cblocking \ufb02ows,\u201dwas also \ufb01rst developed by Dinic [89]. Karzanov [202] \ufb01rst developed the idea ofpre\ufb02ows. The push-relabel method is due to Goldberg [136] and Goldberg and Tar-jan [140]. Goldberg and Tarjan gave an O.V\n3/-time algorithm that uses a queue to\nmaintain the set of over\ufb02owing vertices, as well as an algorithm that uses dynamic\ntrees to achieve a running time of O.VE lg.V2=EC2//. Several other researchers\nhave developed push-relabel maximum-\ufb02ow algorithms. Ahuja and Orlin [9] andAhuja, Orlin, and Tarjan [10] gave algorithms that used scaling. Cheriyan andMaheshwari [62] proposed pushing \ufb02ow from the over\ufb02owing vertex of maximumheight. Cheriyan and Hagerup [61] suggested randomly permuting the neighborlists, and several researchers [14, 204, 276] developed clever derandomizations ofthis idea, leading to a sequence of faster algorithms. The algorithm of King, Rao,and Tarjan [204] is the fastest such algorithm and runs in O.VE log\nE=.V lgV/V/\ntime.\nThe asymptotically fastest algorithm to date for the maximum-\ufb02ow problem, by\nGoldberg and Rao [138], runs in time O.min.V2=3;E1=2/Elg.V2=EC2/lgC/,\nwhere CDmax .u;/ETB/ 2Ec.u;/ETB/ . This algorithm does not use the push-relabel\nmethod but instead is based on \ufb01nding blocking \ufb02ows. All previous maximum-\ufb02ow algorithms, including the ones in this chapter, use some notion of distance\n(the push-relabel algorithms use the analogous notion of height), with a length of 1", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "786": {"page_number": 787, "page_information": "766 Chapter 26 Maximum Flow\nassigned implicitly to each edge. This new algorithm takes a different approach and\nassigns a length of 0to high-capacity edges and a length of 1to low-capacity edges.\nInformally, with respect to these lengths, shortest paths from the source to the sinktend have high capacity, which means that fewer iterations need be performed.\nIn practice, push-relabel algorithms currently dominate augmenting-path or\nlinear-programming based algorithms for the maximum-\ufb02ow problem. A studyby Cherkassky and Goldberg [63] underscores the importance of using two heuris-tics when implementing a push-relabel algorithm. The \ufb01rst heuristic is to peri-\nodically perform a breadth-\ufb01rst search of the residual network in order to obtain\nmore accurate height values. The second heuristic is the gap heuristic, described inExercise 26.5-5. Cherkassky and Goldberg conclude that the best choice of push-relabel variants is the one that chooses to discharge the over\ufb02owing vertex with themaximum height.\nThe best algorithm to date for maximum bipartite matching, discovered by\nHopcroft and Karp [176], runs in O.p\nVE / time and is described in Problem 26-6.\nThe book by Lov\u00b4 asz and Plummer [239] is an excellent reference on matching\nproblems.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "787": {"page_number": 788, "page_information": "", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "788": {"page_number": 789, "page_information": "VII Selected Topics", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "789": {"page_number": 790, "page_information": "Introduction\nThis part contains a selection of algorithmic topics that extend and complement\nearlier material in this book. Some chapters introduce new models of computation\nsuch as circuits or parallel computers. Others cover specialized domains such ascomputational geometry or number theory. The last two chapters discuss some ofthe known limitations to the design of ef\ufb01cient algorithms and introduce techniquesfor coping with those limitations.\nChapter 27 presents an algorithmic model for parallel computing based on dy-\nnamic multithreading. The chapter introduces the basics of the model, showing\nhow to quantify parallelism in terms of the measures of work and span. It then\ninvestigates several interesting multithreaded algorithms, including algorithms for\nmatrix multiplication and merge sorting.\nChapter 28 studies ef\ufb01cient algorithms for operating on matrices. It presents\ntwo general methods\u2014LU decomposition and LUP decomposition\u2014for solvinglinear equations by Gaussian elimination in O.n\n3/time. It also shows that matrix\ninversion and matrix multiplication can be performed equally fast. The chapter\nconcludes by showing how to compute a least-squares approximate solution when\na set of linear equations has no exact solution.\nChapter 29 studies linear programming, in which we wish to maximize or mini-\nmize an objective, given limited resources and competing constraints. Linear pro-gramming arises in a variety of practical application areas. This chapter covers howto formulate and solve linear programs. The solution method covered is the sim-plex algorithm, which is the oldest algorithm for linear programming. In contrastto many algorithms in this book, the simplex algorithm does not run in polynomialtime in the worst case, but it is fairly ef\ufb01cient and widely used in practice.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "790": {"page_number": 791, "page_information": "770 Part VII Selected Topics\nChapter 30 studies operations on polynomials and shows how to use a well-\nknown signal-processing technique\u2014the f ast Fourier transf orm (FFT)\u2014to multi-\nply two degree- npolynomials in O.n lgn/time. It also investigates ef\ufb01cient im-\nplementations of the FFT, including a parallel circuit.\nChapter 31 presents number-theoretic algorithms. After reviewing elementary\nnumber theory, it presents Euclid\u2019s algorithm for computing greatest common di-visors. Next, it studies algorithms for solving modular linear equations and forraising one number to a power modulo another number. Then, it explores an impor-\ntant application of number-theoretic algorithms: the RSA public-key cryptosystem.\nThis cryptosystem can be used not only to encrypt messages so that an adversarycannot read them, but also to provide digital signatures. The chapter then presentsthe Miller-Rabin randomized primality test, with which we can \ufb01nd large primesef\ufb01ciently\u2014an essential requirement for the RSA system. Finally, the chapter cov-ers Pollard\u2019s \u201crho\u201d heuristic for factoring integers and discusses the state of the artof integer factorization.\nChapter 32 studies the problem of \ufb01nding all occurrences of a given pattern\nstring in a given text string, a problem that arises frequently in text-editing pro-\ngrams. After examining the naive approach, the chapter presents an elegant ap-\nproach due to Rabin and Karp. Then, after showing an ef\ufb01cient solution basedon \ufb01nite automata, the chapter presents the Knuth-Morris-Pratt algorithm, whichmodi\ufb01es the automaton-based algorithm to save space by cleverly preprocessingthe pattern.\nChapter 33 considers a few problems in computational geometry. After dis-\ncussing basic primitives of computational geometry, the chapter shows how to usea \u201csweeping\u201d method to ef\ufb01ciently determine whether a set of line segments con-tains any intersections. Two clever algorithms for \ufb01nding the convex hull of a set ofpoints\u2014Graham\u2019s scan and Jarvis\u2019s march\u2014also illustrate the power of sweepingmethods. The chapter closes with an ef\ufb01cient algorithm for \ufb01nding the closest pairfrom among a given set of points in the plane.\nChapter 34 concerns NP-complete problems. Many interesting computational\nproblems are NP-complete, but no polynomial-time algorithm is known for solvingany of them. This chapter presents techniques for determining when a problem isNP-complete. Several classic problems are proved to be NP-complete: determiningwhether a graph has a hamiltonian cycle, determining whether a boolean formulais satis\ufb01able, and determining whether a given set of numbers has a subset thatadds up to a given target value. The chapter also proves that the famous traveling-\nsalesman problem is NP-complete.\nChapter 35 shows how to \ufb01nd approximate solutions to NP-complete problems\nef\ufb01ciently by using approximation algorithms. For some NP-complete problems,approximate solutions that are near optimal are quite easy to produce, but for otherseven the best approximation algorithms known work progressively more poorly as", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "791": {"page_number": 792, "page_information": "Part VII Selected Topics 771\nthe problem size increases. Then, there are some problems for which we can invest\nincreasing amounts of computation time in return for increasingly better approx-imate solutions. This chapter illustrates these possibilities with the vertex-coverproblem (unweighted and weighted versions), an optimization version of 3-CNFsatis\ufb01ability, the traveling-salesman problem, the set-covering problem, and thesubset-sum problem.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "792": {"page_number": 793, "page_information": "27 Multithreaded Algorithms\nThe vast majority of algorithms in this book are serial algorithms suitable for\nrunning on a uniprocessor computer in which only one instruction executes at atime. In this chapter, we shall extend our algorithmic model to encompass parallel\nalgorithms , which can run on a multiprocessor computer that permits multiple\ninstructions to execute concurrently. In particular, we shall explore the elegantmodel of dynamic multithreaded algorithms, which are amenable to algorithmicdesign and analysis, as well as to ef\ufb01cient implementation in practice.\nParallel computers\u2014computers with multiple processing units\u2014have become\nincreasingly common, and they span a wide range of prices and performance. Rela-\ntively inexpensive desktop and laptop chip multiprocessors contain a single multi-\ncore integrated-circuit chip that houses multiple processing \u201ccores,\u201d each of which\nis a full-\ufb02edged processor that can access a common memory. At an intermedi-ate price/performance point are clusters built from individual computers\u2014oftensimple PC-class machines\u2014with a dedicated network interconnecting them. The\nhighest-priced machines are supercomputers, which often use a combination of\ncustom architectures and custom networks to deliver the highest performance interms of instructions executed per second.\nMultiprocessor computers have been around, in one form or another, for\ndecades. Although the computing community settled on the random-access ma-chine model for serial computing early on in the history of computer science, nosingle model for parallel computing has gained as wide acceptance. A major rea-son is that vendors have not agreed on a single architectural model for parallelcomputers. For example, some parallel computers feature shared memory ,w h e r e\neach processor can directly access any location of memory. Other parallel com-puters employ distributed memory , where each processor\u2019s memory is private, and\nan explicit message must be sent between processors in order for one processor toaccess the memory of another. With the advent of multicore technology, however,every new laptop and desktop machine is now a shared-memory parallel computer,", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "793": {"page_number": 794, "page_information": "Chapter 27 Multithreaded Algorithms 773\nand the trend appears to be toward shared-memory multiprocessing. Although time\nwill tell, that is the approach we shall take in this chapter.\nOne common means of programming chip multiprocessors and other shared-\nmemory parallel computers is by using static threading , which provides a software\nabstraction of \u201cvirtual processors,\u201d or threads , sharing a common memory. Each\nthread maintains an associated program counter and can execute code indepen-dently of the other threads. The operating system loads a thread onto a processorfor execution and switches it out when another thread needs to run. Although the\noperating system allows programmers to create and destroy threads, these opera-\ntions are comparatively slow. Thus, for most applications, threads persist for theduration of a computation, which is why we call them \u201cstatic.\u201d\nUnfortunately, programming a shared-memory parallel computer directly using\nstatic threads is dif\ufb01cult and error-prone. One reason is that dynamically parti-tioning the work among the threads so that each thread receives approximatelythe same load turns out to be a complicated undertaking. For any but the sim-plest of applications, the programmer must use complex communication protocolsto implement a scheduler to load-balance the work. This state of affairs has ledtoward the creation of concurrency platforms , which provide a layer of software\nthat coordinates, schedules, and manages the parallel-computing resources. Someconcurrency platforms are built as runtime libraries, but others provide full-\ufb02edgedparallel languages with compiler and runtime support.\nDynamic multithreaded programming\nOne important class of concurrency platform is dynamic multithreading ,w h i c hi s\nthe model we shall adopt in this chapter. Dynamic multithreading allows program-mers to specify parallelism in applications without worrying about communication\nprotocols, load balancing, and other vagaries of static-thread programming. The\nconcurrency platform contains a scheduler, which load-balances the computationautomatically, thereby greatly simplifying the programmer\u2019s chore. Although thefunctionality of dynamic-multithreading environments is still evolving, almost allsupport two features: nested parallelism and parallel loops. Nested parallelismallows a subroutine to be \u201cspawned,\u201d allowing the caller to proceed while thespawned subroutine is computing its result. A parallel loop is like an ordinaryforloop, except that the iterations of the loop can execute concurrently.\nThese two features form the basis of the model for dynamic multithreading that\nwe shall study in this chapter. A key aspect of this model is that the programmerneeds to specify only the logical parallelism within a computation, and the threadswithin the underlying concurrency platform schedule and load-balance the compu-tation among themselves. We shall investigate multithreaded algorithms written for", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "794": {"page_number": 795, "page_information": "774 Chapter 27 Multithreaded Algorithms\nthis model, as well how the underlying concurrency platform can schedule compu-\ntations ef\ufb01ciently.\nOur model for dynamic multithreading offers several important advantages:\n/SIIt is a simple extension of our serial programming model. We can describe amultithreaded algorithm by adding to our pseudocode just three \u201cconcurrency\u201dkeywords: parallel ,spawn ,a n d sync . Moreover, if we delete these concur-\nrency keywords from the multithreaded pseudocode, the resulting text is serialpseudocode for the same problem, which we call the \u201cserialization\u201d of the mul-tithreaded algorithm.\n/SIIt provides a theoretically clean way to quantify parallelism based on the no-tions of \u201cwork\u201d and \u201cspan.\u201d\n/SIMany multithreaded algorithms involving nested parallelism follow naturallyfrom the divide-and-conquer paradigm. Moreover, just as serial divide-and-conquer algorithms lend themselves to analysis by solving recurrences, so do\nmultithreaded algorithms.\n/SIThe model is faithful to how parallel-computing practice is evolving. A grow-\ning number of concurrency platforms support one variant or another of dynamicmultithreading, including Cilk [51, 118], Cilk++ [71], OpenMP [59], Task Par-allel Library [230], and Threading Building Blocks [292].\nSection 27.1 introduces the dynamic multithreading model and presents the met-\nrics of work, span, and parallelism, which we shall use to analyze multithreadedalgorithms. Section 27.2 investigates how to multiply matrices with multithread-ing, and Section 27.3 tackles the tougher problem of multithreading merge sort.\n27.1 The basics of dynamic multithreading\nWe shall begin our exploration of dynamic multithreading using the example ofcomputing Fibonacci numbers recursively. Recall that the Fibonacci numbers arede\ufb01ned by recurrence (3.22):\nF\n0D0;\nF1D1;\nFiDFi/NUL1CFi/NUL2 fori/NAK2:\nHere is a simple, recursive, serial algorithm to compute the nth Fibonacci number:", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "795": {"page_number": 796, "page_information": "27.1 The basics of dynamic multithreading 775\nFIB.0/\nFIB.0/ FIB.0/ FIB.0/\nFIB.0/FIB.1/ FIB.1/\nFIB.1/FIB.1/\nFIB.1/ FIB.1/ FIB.1/\nFIB.1/FIB.2/\nFIB.2/ FIB.2/ FIB.2/\nFIB.2/FIB.3/ FIB.3/\nFIB.3/FIB.4/\nFIB.4/FIB.5/FIB.6/\nFigure 27.1 The tree of recursive procedure instances when computing F IB.6/. Each instance of\nFIBwith the same argument does the same work to produce the same result, providing an inef\ufb01cient\nbut interesting way to compute Fibonacci numbers.\nFIB.n/\n1ifn/DC41\n2 return n\n3elsexDFIB.n/NUL1/\n4 yDFIB.n/NUL2/\n5 return xCy\nYou would not really want to compute large Fibonacci numbers this way, be-\ncause this computation does much repeated work. Figure 27.1 shows the tree ofrecursive procedure instances that are created when computing F\n6. For example,\na call to F IB.6/recursively calls F IB.5/and then F IB.4/. But, the call to F IB.5/\nalso results in a call to F IB.4/. Both instances of F IB.4/return the same result\n(F4D3). Since the F IBprocedure does not memoize, the second call to F IB.4/\nreplicates the work that the \ufb01rst call performs.\nLetT .n/ denote the running time of F IB.n/.S i n c eF IB.n/contains two recur-\nsive calls plus a constant amount of extra work, we obtain the recurrence\nT .n/DT. n/NUL1/CT. n/NUL2/C\u201a.1/ :\nThis recurrence has solution T .n/D\u201a.F n/, which we can show using the substi-\ntution method. For an inductive hypothesis, assume that T .n//DC4aFn/NULb,w h e r e\na>1 andb>0 are constants. Substituting, we obtain", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "796": {"page_number": 797, "page_information": "776 Chapter 27 Multithreaded Algorithms\nT .n//DC4.aF n/NUL1/NULb/C.aF n/NUL2/NULb/C\u201a.1/\nDa.F n/NUL1CFn/NUL2//NUL2bC\u201a.1/\nDaFn/NULb/NUL.b/NUL\u201a.1//\n/DC4aFn/NULb\nif we choose blarge enough to dominate the constant in the \u201a.1/ . We can then\nchoose alarge enough to satisfy the initial condition. The analytical bound\nT .n/D\u201a./RSn/; (27.1)\nwhere /RSD.1Cp\n5/=2 is the golden ratio, now follows from equation (3.25).\nSince Fngrows exponentially in n, this procedure is a particularly slow way to\ncompute Fibonacci numbers. (See Problem 31-3 for much faster ways.)\nAlthough the F IBprocedure is a poor way to compute Fibonacci numbers, it\nmakes a good example for illustrating key concepts in the analysis of multithreadedalgorithms. Observe that within F\nIB.n/, the two recursive calls in lines 3 and 4 to\nFIB.n/NUL1/and F IB.n/NUL2/, respectively, are independent of each other: they could\nbe called in either order, and the computation performed by one in no way affectsthe other. Therefore, the two recursive calls can run in parallel.\nWe augment our pseudocode to indicate parallelism by adding the concurrency\nkeywords spawn andsync . Here is how we can rewrite the F\nIBprocedure to use\ndynamic multithreading:\nP-F IB.n/\n1ifn/DC41\n2 return n\n3elsexDspawn P-F IB.n/NUL1/\n4 yDP-F IB.n/NUL2/\n5 sync\n6 return xCy\nNotice that if we delete the concurrency keywords spawn andsync from P-F IB,\nthe resulting pseudocode text is identical to F IB(other than renaming the procedure\nin the header and in the two recursive calls). We de\ufb01ne the serialization of a mul-\ntithreaded algorithm to be the serial algorithm that results from deleting the multi-threaded keywords: spawn ,sync , and when we examine parallel loops, parallel .\nIndeed, our multithreaded pseudocode has the nice property that a serialization isalways ordinary serial pseudocode to solve the same problem.\nNested parallelism occurs when the keyword spawn precedes a procedure call,\nas in line 3. The semantics of a spawn differs from an ordinary procedure call inthat the procedure instance that executes the spawn\u2014the parent \u2014may continue\nto execute in parallel with the spawned subroutine\u2014its child \u2014instead of waiting", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "797": {"page_number": 798, "page_information": "27.1 The basics of dynamic multithreading 777\nfor the child to complete, as would normally happen in a serial execution. In this\ncase, while the spawned child is computing P-F IB.n/NUL1/, the parent may go on\nto compute P-F IB.n/NUL2/in line 4 in parallel with the spawned child. Since the\nP-F IBprocedure is recursive, these two subroutine calls themselves create nested\nparallelism, as do their children, thereby creating a potentially vast tree of subcom-putations, all executing in parallel.\nThe keyword spawn does not say, however, that a procedure must execute con-\ncurrently with its spawned children, only that it may. The concurrency keywords\nexpress the logical parallelism of the computation, indicating which parts of the\ncomputation may proceed in parallel. At runtime, it is up to a scheduler to deter-\nmine which subcomputations actually run concurrently by assigning them to avail-able processors as the computation unfolds. We shall discuss the theory behindschedulers shortly.\nA procedure cannot safely use the values returned by its spawned children until\nafter it executes a sync statement, as in line 5. The keyword sync indicates that\nthe procedure must wait as necessary for all its spawned children to complete be-\nfore proceeding to the statement after the sync .I n t h e P - F\nIBprocedure, a sync\nis required before the return statement in line 6 to avoid the anomaly that would\noccur if xandywere summed before xwas computed. In addition to explicit\nsynchronization provided by the sync statement, every procedure executes a sync\nimplicitly before it returns, thus ensuring that all its children terminate before itdoes.\nA model for multithreaded execution\nIt helps to think of a multithreaded computation \u2014the set of runtime instruc-\ntions executed by a processor on behalf of a multithreaded program\u2014as a directed\nacyclic graph GD.V; E/ , called a computation dag . As an example, Figure 27.2\nshows the computation dag that results from computing P-F\nIB.4/. Conceptually,\nthe vertices in Vare instructions, and the edges in Erepresent dependencies be-\ntween instructions, where .u; /ETB/2Emeans that instruction umust execute before\ninstruction /ETB. For convenience, however, if a chain of instructions contains no\nparallel control (no spawn ,sync ,o rreturn from a spawn\u2014via either an explicit\nreturn statement or the return that happens implicitly upon reaching the end of\na procedure), we may group them into a single strand , each of which represents\none or more instructions. Instructions involving parallel control are not includedin strands, but are represented in the structure of the dag. For example, if a strandhas two successors, one of them must have been spawned, and a strand with mul-tiple predecessors indicates the predecessors joined because of a sync statement.\nThus, in the general case, the set Vforms the set of strands, and the set Eof di-\nrected edges represents dependencies between strands induced by parallel control.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "798": {"page_number": 799, "page_information": "778 Chapter 27 Multithreaded Algorithms\nP-FIB(1) P-FIB(0)P-FIB(3)P-FIB(4)\nP-FIB(1)P-FIB(1)\nP-FIB(0)P-FIB(2)\nP-FIB(2)\nFigure 27.2 A directed acyclic graph representing the computation of P-F IB.4/. Each circle rep-\nresents one strand, with black circles representing either base cases or the part of the procedure\n(instance) up to the spawn of P-F IB.n/NUL1/in line 3, shaded circles representing the part of the pro-\ncedure that calls P-F IB.n/NUL2/in line 4 up to the sync in line 5, where it suspends until the spawn of\nP-F IB.n/NUL1/returns, and white circles representing the part of the procedure after the sync where\nit sums xandyup to the point where it returns the result. Each group of strands belonging to the\nsame procedure is surrounded by a rounded rectangle, lightly shaded for spawned procedures and\nheavily shaded for called procedures. Spawn edges and call edges point downward, continuation\nedges point horizontally to the right, and return edges point upward. Assuming that each strand takesunit time, the work equals 17time units, since there are 17strands, and the span is 8time units, since\nthe critical path\u2014shown with shaded edges\u2014contains 8strands.\nIfGhas a directed path from strand uto strand /ETB, we say that the two strands are\n(logically) in series . Otherwise, strands uand/ETBare(logically) in parallel .\nWe can picture a multithreaded computation as a dag of strands embedded in a\ntree of procedure instances. For example, Figure 27.1 shows the tree of procedureinstances for P-F\nIB.6/without the detailed structure showing strands. Figure 27.2\nzooms in on a section of that tree, showing the strands that constitute each proce-dure. All directed edges connecting strands run either within a procedure or alongundirected edges in the procedure tree.\nWe can classify the edges of a computation dag to indicate the kind of dependen-\ncies between the various strands. A continuation edge .u; u\n0/, drawn horizontally\nin Figure 27.2, connects a strand uto its successor u0within the same procedure\ninstance. When a strand uspawns a strand /ETB, the dag contains a spawn edge .u; /ETB/ ,\nwhich points downward in the \ufb01gure. Call edges , representing normal procedure\ncalls, also point downward. Strand uspawning strand /ETBdiffers from ucalling /ETB\nin that a spawn induces a horizontal continuation edge from uto the strand u0fol-", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "799": {"page_number": 800, "page_information": "27.1 The basics of dynamic multithreading 779\nlowing uin its procedure, indicating that u0is free to execute at the same time\nas/ETB, whereas a call induces no such edge. When a strand ureturns to its calling\nprocedure and xis the strand immediately following the next sync in the calling\nprocedure, the computation dag contains return edge .u; x/ , which points upward.\nA computation starts with a single initial strand \u2014the black vertex in the procedure\nlabeled P-F IB.4/in Figure 27.2\u2014and ends with a single \ufb01nal strand \u2014the white\nvertex in the procedure labeled P-F IB.4/.\nWe shall study the execution of multithreaded algorithms on an ideal paral-\nlel computer , which consists of a set of processors and a sequentially consistent\nshared memory. Sequential consistency means that the shared memory, which mayin reality be performing many loads and stores from the processors at the sametime, produces the same results as if at each step, exactly one instruction from oneof the processors is executed. That is, the memory behaves as if the instructionswere executed sequentially according to some global linear order that preserves theindividual orders in which each processor issues its own instructions. For dynamicmultithreaded computations, which are scheduled onto processors automaticallyby the concurrency platform, the shared memory behaves as if the multithreadedcomputation\u2019s instructions were interleaved to produce a linear order that preservesthe partial order of the computation dag. Depending on scheduling, the orderingcould differ from one run of the program to another, but the behavior of any exe-cution can be understood by assuming that the instructions are executed in somelinear order consistent with the computation dag.\nIn addition to making assumptions about semantics, the ideal-parallel-computer\nmodel makes some performance assumptions. Speci\ufb01cally, it assumes that eachprocessor in the machine has equal computing power, and it ignores the cost ofscheduling. Although this last assumption may sound optimistic, it turns out thatfor algorithms with suf\ufb01cient \u201cparallelism\u201d (a term we shall de\ufb01ne precisely in amoment), the overhead of scheduling is generally minimal in practice.\nPerformance measures\nWe can gauge the theoretical ef\ufb01ciency of a multithreaded algorithm by using two\nmetrics: \u201cwork\u201d and \u201cspan.\u201d The work of a multithreaded computation is the total\ntime to execute the entire computation on one processor. In other words, the workis the sum of the times taken by each of the strands. For a computation dag inwhich each strand takes unit time, the work is just the number of vertices in thedag. The span is the longest time to execute the strands along any path in the dag.\nAgain, for a dag in which each strand takes unit time, the span equals the number ofvertices on a longest or critical path in the dag. (Recall from Section 24.2 that we\ncan \ufb01nd a critical path in a dag GD.V; E/ in\u201a.VCE/time.) For example, the\ncomputation dag of Figure 27.2 has 17vertices in all and 8vertices on its critical", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "800": {"page_number": 801, "page_information": "780 Chapter 27 Multithreaded Algorithms\npath, so that if each strand takes unit time, its work is 17time units and its span\nis8time units.\nThe actual running time of a multithreaded computation depends not only on\nits work and its span, but also on how many processors are available and howthe scheduler allocates strands to processors. To denote the running time of amultithreaded computation on Pprocessors, we shall subscript by P. For example,\nwe might denote the running time of an algorithm on Pprocessors by T\nP.T h e\nwork is the running time on a single processor, or T1. The span is the running time\nif we could run each strand on its own processor\u2014in other words, if we had an\nunlimited number of processors\u2014and so we denote the span by T1.\nThe work and span provide lower bounds on the running time TPof a multi-\nthreaded computation on Pprocessors:\n/SIIn one step, an ideal parallel computer with Pprocessors can do at most P\nunits of work, and thus in TPtime, it can perform at most PT Pwork. Since the\ntotal work to do is T1,w eh a v e PT P/NAKT1. Dividing by Pyields the work law :\nTP/NAKT1=P : (27.2)\n/SIAP-processor ideal parallel computer cannot run any faster than a machine\nwith an unlimited number of processors. Looked at another way, a machine\nwith an unlimited number of processors can emulate a P-processor machine by\nusing just Pof its processors. Thus, the span law follows:\nTP/NAKT1: (27.3)\nWe de\ufb01ne the speedup of a computation on Pprocessors by the ratio T1=TP,\nwhich says how many times faster the computation is on Pprocessors than\non1processor. By the work law, we have TP/NAKT1=P, which implies that\nT1=TP/DC4P. Thus, the speedup on Pprocessors can be at most P. When the\nspeedup is linear in the number of processors, that is, when T1=TPD\u201a.P / ,t h e\ncomputation exhibits linear speedup ,a n dw h e n T1=TPDP,w eh a v e perfect\nlinear speedup .\nThe ratio T1=T1of the work to the span gives the parallelism of the multi-\nthreaded computation. We can view the parallelism from three perspectives. As aratio, the parallelism denotes the average amount of work that can be performed inparallel for each step along the critical path. As an upper bound, the parallelismgives the maximum possible speedup that can be achieved on any number of pro-cessors. Finally, and perhaps most important, the parallelism provides a limit onthe possibility of attaining perfect linear speedup. Speci\ufb01cally, once the number ofprocessors exceeds the parallelism, the computation cannot possibly achieve per-fect linear speedup. To see this last point, suppose that P> T\n1=T1, in which case", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "801": {"page_number": 802, "page_information": "27.1 The basics of dynamic multithreading 781\nthe span law implies that the speedup satis\ufb01es T1=TP/DC4T1=T1<P . Moreover,\nif the number Pof processors in the ideal parallel computer greatly exceeds the\nparallelism\u2014that is, if P/GST1=T1\u2014then T1=TP/FSP, so that the speedup is\nmuch less than the number of processors. In other words, the more processors weuse beyond the parallelism, the less perfect the speedup.\nAs an example, consider the computation P-F\nIB.4/in Figure 27.2, and assume\nthat each strand takes unit time. Since the work is T1D17and the span is T1D8,\nthe parallelism is T1=T1D17=8D2:125 . Consequently, achieving much more\nthan double the speedup is impossible, no matter how many processors we em-\nploy to execute the computation. For larger input sizes, however, we shall see that\nP-F IB.n/exhibits substantial parallelism.\nWe de\ufb01ne the (parallel) slackness of a multithreaded computation executed\non an ideal parallel computer with Pprocessors to be the ratio .T1=T1/=PD\nT1=.P T 1/, which is the factor by which the parallelism of the computation ex-\nceeds the number of processors in the machine. Thus, if the slackness is less than 1,\nwe cannot hope to achieve perfect linear speedup, because T1=.P T 1/<1 and the\nspan law imply that the speedup on Pprocessors satis\ufb01es T1=TP/DC4T1=T1<P .\nIndeed, as the slackness decreases from 1toward 0, the speedup of the computation\ndiverges further and further from perfect linear speedup. If the slackness is greaterthan1, however, the work per processor is the limiting constraint. As we shall see,\nas the slackness increases from 1, a good scheduler can achieve closer and closer\nto perfect linear speedup.\nScheduling\nGood performance depends on more than just minimizing the work and span. The\nstrands must also be scheduled ef\ufb01ciently onto the processors of the parallel ma-\nchine. Our multithreaded programming model provides no way to specify which\nstrands to execute on which processors. Instead, we rely on the concurrency plat-form\u2019s scheduler to map the dynamically unfolding computation to individual pro-cessors. In practice, the scheduler maps the strands to static threads, and the op-erating system schedules the threads on the processors themselves, but this extralevel of indirection is unnecessary for our understanding of scheduling. We canjust imagine that the concurrency platform\u2019s scheduler maps strands to processorsdirectly.\nA multithreaded scheduler must schedule the computation with no advance\nknowledge of when strands will be spawned or when they will complete\u2014it mustoperate on-line . Moreover, a good scheduler operates in a distributed fashion,\nwhere the threads implementing the scheduler cooperate to load-balance the com-putation. Provably good on-line, distributed schedulers exist, but analyzing themis complicated.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "802": {"page_number": 803, "page_information": "782 Chapter 27 Multithreaded Algorithms\nInstead, to keep our analysis simple, we shall investigate an on-line centralized\nscheduler, which knows the global state of the computation at any given time. Inparticular, we shall analyze greedy schedulers , which assign as many strands to\nprocessors as possible in each time step. If at least Pstrands are ready to execute\nduring a time step, we say that the step is a complete step , and a greedy scheduler\nassigns any Pof the ready strands to processors. Otherwise, fewer than Pstrands\nare ready to execute, in which case we say that the step is an incomplete step ,a n d\nthe scheduler assigns each ready strand to its own processor.\nFrom the work law, the best running time we can hope for on Pprocessors\nisT\nPDT1=P, and from the span law the best we can hope for is TPDT1.\nThe following theorem shows that greedy scheduling is provably good in that itachieves the sum of these two lower bounds as an upper bound.\nTheorem 27.1\nOn an ideal parallel computer with Pprocessors, a greedy scheduler executes a\nmultithreaded computation with work T\n1and span T1in time\nTP/DC4T1=PCT1: (27.4)\nProof We start by considering the complete steps. In each complete step, the\nPprocessors together perform a total of Pwork. Suppose for the purpose of\ncontradiction that the number of complete steps is strictly greater than bT1=Pc.\nThen, the total work of the complete steps is at least\nP/SOH.bT1=PcC1/DPbT1=PcCP\nDT1/NUL.T1modP/CP(by equation (3.8))\n>T 1 (by inequality (3.9)) .\nThus, we obtain the contradiction that the Pprocessors would perform more work\nthan the computation requires, which allows us to conclude that the number ofcomplete steps is at most bT\n1=Pc.\nNow, consider an incomplete step. Let Gbe the dag representing the entire\ncomputation, and without loss of generality, assume that each strand takes unittime. (We can replace each longer strand by a chain of unit-time strands.) Let G\n0\nbe the subgraph of Gthat has yet to be executed at the start of the incomplete step,\nand let G00be the subgraph remaining to be executed after the incomplete step. A\nlongest path in a dag must necessarily start at a vertex with in-degree 0. Since an\nincomplete step of a greedy scheduler executes all strands with in-degree 0inG0,\nthe length of a longest path in G00must be 1less than the length of a longest path\ninG0. In other words, an incomplete step decreases the span of the unexecuted dag\nby1. Hence, the number of incomplete steps is at most T1.\nSince each step is either complete or incomplete, the theorem follows.\n", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "803": {"page_number": 804, "page_information": "27.1 The basics of dynamic multithreading 783\nThe following corollary to Theorem 27.1 shows that a greedy scheduler always\nperforms well.\nCorollary 27.2\nThe running time TPof any multithreaded computation scheduled by a greedy\nscheduler on an ideal parallel computer with Pprocessors is within a factor of 2\nof optimal.\nProof LetT/ETX\nPbe the running time produced by an optimal scheduler on a machine\nwithPprocessors, and let T1andT1be the work and span of the computation,\nrespectively. Since the work and span laws\u2014inequalities (27.2) and (27.3)\u2014giveusT\n/ETX\nP/NAKmax.T1=P; T 1/, Theorem 27.1 implies that\nTP/DC4T1=PCT1\n/DC42/SOHmax.T1=P; T 1/\n/DC42T/ETX\nP:\nThe next corollary shows that, in fact, a greedy scheduler achieves near-perfect\nlinear speedup on any multithreaded computation as the slackness grows.\nCorollary 27.3\nLetTPbe the running time of a multithreaded computation produced by a greedy\nscheduler on an ideal parallel computer with Pprocessors, and let T1andT1be\nthe work and span of the computation, respectively. Then, if P/FST1=T1,w e\nhave TP/EMT1=P, or equivalently, a speedup of approximately P.\nProof If we suppose that P/FST1=T1,t h e nw ea l s oh a v e T1/FST1=P,a n d\nhence Theorem 27.1 gives us TP/DC4T1=PCT1/EMT1=P. Since the work\nlaw (27.2) dictates that TP/NAKT1=P, we conclude that TP/EMT1=P, or equiva-\nlently, that the speedup is T1=TP/EMP.\nThe/FSsymbol denotes \u201cmuch less,\u201d but how much is \u201cmuch less\u201d? As a rule\nof thumb, a slackness of at least 10\u2014that is, 10times more parallelism than pro-\ncessors\u2014generally suf\ufb01ces to achieve good speedup. Then, the span term in thegreedy bound, inequality (27.4), is less than 10% of the work-per-processor term,\nwhich is good enough for most engineering situations. For example, if a computa-\ntion runs on only 10 or 100 processors, it doesn\u2019t make sense to value parallelism\nof, say 1,000,000 over parallelism of 10,000, even with the factor of 100 differ-ence. As Problem 27-2 shows, sometimes by reducing extreme parallelism, wecan obtain algorithms that are better with respect to other concerns and which stillscale up well on reasonable numbers of processors.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "804": {"page_number": 805, "page_information": "784 Chapter 27 Multithreaded Algorithms\nA\n(a) (b)BA\nB\nWork: T1.A[B/DT1.A/CT1.B/\nSpan: T1.A[B/DT1.A/CT1.B/Work: T1.A[B/DT1.A/CT1.B/\nSpan: T1.A[B/Dmax.T1.A/; T 1.B/)\nFigure 27.3 The work and span of composed subcomputations. (a)When two subcomputations\nare joined in series, the work of the composition is the sum of their work, and the span of the\ncomposition is the sum of their spans. (b)When two subcomputations are joined in parallel, the\nwork of the composition remains the sum of their work, but the span of the composition is only themaximum of their spans.\nAnalyzing multithreaded algorithms\nWe now have all the tools we need to analyze multithreaded algorithms and provide\ngood bounds on their running times on various numbers of processors. Analyzingthe work is relatively straightforward, since it amounts to nothing more than ana-lyzing the running time of an ordinary serial algorithm\u2014namely, the serializationof the multithreaded algorithm\u2014which you should already be familiar with, sincethat is what most of this textbook is about! Analyzing the span is more interesting,but generally no harder once you get the hang of it. We shall investigate the basicideas using the P-F\nIBprogram.\nAnalyzing the work T1.n/of P-F IB.n/poses no hurdles, because we\u2019ve already\ndone it. The original F IBprocedure is essentially the serialization of P-F IB,a n d\nhence T1.n/DT .n/D\u201a./RSn/from equation (27.1).\nFigure 27.3 illustrates how to analyze the span. If two subcomputations are\njoined in series, their spans add to form the span of their composition, whereas\nif they are joined in parallel, the span of their composition is the maximum of the\nspans of the two subcomputations. For P-F IB.n/, the spawned call to P-F IB.n/NUL1/\nin line 3 runs in parallel with the call to P-F IB.n/NUL2/in line 4. Hence, we can\nexpress the span of P-F IB.n/as the recurrence\nT1.n/Dmax.T1.n/NUL1/; T 1.n/NUL2//C\u201a.1/\nDT1.n/NUL1/C\u201a.1/ ;\nwhich has solution T1.n/D\u201a.n/ .\nThe parallelism of P-F IB.n/isT1.n/=T 1.n/D\u201a./RSn=n/, which grows dra-\nmatically as ngets large. Thus, on even the largest parallel computers, a modest", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "805": {"page_number": 806, "page_information": "27.1 The basics of dynamic multithreading 785\nvalue for nsuf\ufb01ces to achieve near perfect linear speedup for P-F IB.n/, because\nthis procedure exhibits considerable parallel slackness.\nParallel loops\nMany algorithms contain loops all of whose iterations can operate in parallel. As\nwe shall see, we can parallelize such loops using the spawn andsync keywords,\nbut it is much more convenient to specify directly that the iterations of such loopscan run concurrently. Our pseudocode provides this functionality via the parallel\nconcurrency keyword, which precedes the forkeyword in a forloop statement.\nAs an example, consider the problem of multiplying an n/STXnmatrix AD.a\nij/\nby an n-vector xD.xj/. The resulting n-vector yD.yi/is given by the equation\nyiDnX\njD1aijxj;\nforiD1 ;2;:::;n . We can perform matrix-vector multiplication by computing all\nthe entries of yin parallel as follows:\nMAT-VEC.A; x/\n1nDA:rows\n2l e t ybe a new vector of length n\n3parallel for iD1ton\n4 yiD0\n5parallel for iD1ton\n6 forjD1ton\n7 yiDyiCaijxj\n8return y\nIn this code, the parallel for keywords in lines 3 and 5 indicate that the itera-\ntions of the respective loops may be run concurrently. A compiler can implementeachparallel for loop as a divide-and-conquer subroutine using nested parallelism.\nFor example, the parallel for loop in lines 5\u20137 can be implemented with the call\nM\nAT-VEC-MAIN-LOOP. A ;x;y;n;1 ;n / , where the compiler produces the auxil-\niary subroutine M AT-VEC-MAIN-LOOP as follows:", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "806": {"page_number": 807, "page_information": "786 Chapter 27 Multithreaded Algorithms\n1,1 2,2 3,3 4,4 5,5 6,6 7,7 8,81,2 3,4 5,6 7,81,4 5,81,8\nFigure 27.4 A dag representing the computation of M AT-VEC-MAIN-LOOP. A ;x;y;8 ;1 ;8 / .T h e\ntwo numbers within each rounded rectangle give t he values of the last two parameters ( iandi0in\nthe procedure header) in the invocation (spawn or call) of the procedure. The black circles repre-\nsent strands corresponding to either the base case or the part of the procedure up to the spawn of\nMAT-VEC-MAIN-LOOP in line 5; the shaded circles represent strands corresponding to the part of\nthe procedure that calls M AT-VEC-MAIN-LOOP in line 6 up to the sync in line 7, where it suspends\nuntil the spawned subroutine in line 5 returns; and the white circles represent strands corresponding\nto the (negligible) part of the procedure after the sync up to the point where it returns.\nMAT-VEC-MAIN-LOOP. A ;x;y;n;i;i0/\n1ifi==i0\n2 forjD1ton\n3 yiDyiCaijxj\n4elsemidDb.iCi0/=2c\n5 spawn MAT-VEC-MAIN-LOOP. A ;x;y;n;i; mid/\n6M AT-VEC-MAIN-LOOP. A ;x;y;n; midC1; i0/\n7 sync\nThis code recursively spawns the \ufb01rst half of the iterations of the loop to execute\nin parallel with the second half of the iterations and then executes a sync , thereby\ncreating a binary tree of execution where the leaves are individual loop iterations,as shown in Figure 27.4.\nTo calculate the work T\n1.n/of M AT-VECon an n/STXnmatrix, we simply compute\nthe running time of its serialization, which we obtain by replacing the parallel for\nloops with ordinary forloops. Thus, we have T1.n/D\u201a.n2/, because the qua-\ndratic running time of the doubly nested loops in lines 5\u20137 dominates. This analysis", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "807": {"page_number": 808, "page_information": "27.1 The basics of dynamic multithreading 787\nseems to ignore the overhead for recursive spawning in implementing the parallel\nloops, however. In fact, the overhead of recursive spawning does increase the workof a parallel loop compared with that of its serialization, but not asymptotically.To see why, observe that since the tree of recursive procedure instances is a fullbinary tree, the number of internal nodes is 1fewer than the number of leaves (see\nExercise B.5-3). Each internal node performs constant work to divide the iterationrange, and each leaf corresponds to an iteration of the loop, which takes at leastconstant time ( \u201a.n/ time in this case). Thus, we can amortize the overhead of re-\ncursive spawning against the work of the iterations, contributing at most a constant\nfactor to the overall work.\nAs a practical matter, dynamic-multithreading concurrency platforms sometimes\ncoarsen the leaves of the recursion by executing several iterations in a single leaf,\neither automatically or under programmer control, thereby reducing the overheadof recursive spawning. This reduced overhead comes at the expense of also reduc-ing the parallelism, however, but if the computation has suf\ufb01cient parallel slack-ness, near-perfect linear speedup need not be sacri\ufb01ced.\nWe must also account for the overhead of recursive spawning when analyzing the\nspan of a parallel-loop construct. Since the depth of recursive calling is logarithmic\nin the number of iterations, for a parallel loop with niterations in which the ith\niteration has span iter\n1.i/, the span is\nT1.n/D\u201a.lgn/Cmax\n1/DC4i/DC4niter 1.i/ :\nFor example, for M AT-VECon an n/STXnmatrix, the parallel initialization loop in\nlines 3\u20134 has span \u201a.lgn/, because the recursive spawning dominates the constant-\ntime work of each iteration. The span of the doubly nested loops in lines 5\u20137is\u201a.n/ , because each iteration of the outer parallel for loop contains niterations\nof the inner (serial) forloop. The span of the remaining code in the procedure\nis constant, and thus the span is dominated by the doubly nested loops, yieldingan overall span of \u201a.n/ for the whole procedure. Since the work is \u201a.n\n2/,t h e\nparallelism is \u201a.n2/=\u201a.n/D\u201a.n/ . (Exercise 27.1-6 asks you to provide an\nimplementation with even more parallelism.)\nRace conditions\nA multithreaded algorithm is deterministic if it always does the same thing on the\nsame input, no matter how the instructions are scheduled on the multicore com-puter. It is nondeterministic if its behavior might vary from run to run. Often, a\nmultithreaded algorithm that is intended to be deterministic fails to be, because itcontains a \u201cdeterminacy race.\u201d\nRace conditions are the bane of concurrency. Famous race bugs include the\nTherac-25 radiation therapy machine, which killed three people and injured sev-", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "808": {"page_number": 809, "page_information": "788 Chapter 27 Multithreaded Algorithms\neral others, and the North American Blackout of 2003, which left over 50 million\npeople without power. These pernicious bugs are notoriously hard to \ufb01nd. You canrun tests in the lab for days without a failure only to discover that your softwaresporadically crashes in the \ufb01eld.\nAdeterminacy race occurs when two logically parallel instructions access the\nsame memory location and at least one of the instructions performs a write. Thefollowing procedure illustrates a race condition:\nR\nACE-EXAMPLE ./\n1xD0\n2parallel for iD1to2\n3 xDxC1\n4 print x\nAfter initializing xto0in line 1, R ACE-EXAMPLE creates two parallel strands,\neach of which increments xin line 3. Although it might seem that R ACE-\nEXAMPLE should always print the value 2(its serialization certainly does), it could\ninstead print the value 1. Let\u2019s see how this anomaly might occur.\nWhen a processor increments x, the operation is not indivisible, but is composed\nof a sequence of instructions:\n1. Read xfrom memory into one of the processor\u2019s registers.\n2. Increment the value in the register.\n3. Write the value in the register back into xin memory.\nFigure 27.5(a) illustrates a computation dag representing the execution of R ACE-\nEXAMPLE , with the strands broken down to individual instructions. Recall that\nsince an ideal parallel computer supports sequential consistency, we can view theparallel execution of a multithreaded algorithm as an interleaving of instructionsthat respects the dependencies in the dag. Part (b) of the \ufb01gure shows the valuesin an execution of the computation that elicits the anomaly. The value xis stored\nin memory, and r\n1andr2are processor registers. In step 1, one of the processors\nsetsxto0. In steps 2 and 3, processor 1 reads xfrom memory into its register r1\nand increments it, producing the value 1inr1. At that point, processor 2 comes\ninto the picture, executing instructions 4\u20136. Processor 2 reads xfrom memory into\nregister r2; increments it, producing the value 1inr2; and then stores this value\nintox, setting xto1. Now, processor 1 resumes with step 7, storing the value 1\ninr1intox, which leaves the value of xunchanged. Therefore, step 8 prints the\nvalue 1, rather than 2, as the serialization would print.\nWe can see what has happened. If the effect of the parallel execution were that\nprocessor 1 executed all its instructions before processor 2, the value 2would be", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "809": {"page_number": 810, "page_information": "27.1 The basics of dynamic multithreading 789\nincrr1 3r1 =x 2\nx = r1 7incrr2 5r2 =  x 4\nx = r2 6x = 0 1\nprint x 8\n(a)step xr1 r2\n1\n2345670000011\u2013011111\u2013\u2013\u20130111\n(b)\nFigure 27.5 Illustration of the determinacy race in R ACE-EXAMPLE .(a)A computation dag show-\ning the dependencies among individual instructions. The processor registers are r1and r2. Instruc-\ntions unrelated to the race, such as the implementation of loop control, are omitted. (b)An execution\nsequence that elicits the bug, showing the values of xin memory and registers r1and r2for each\nstep in the execution sequence.\nprinted. Conversely, if the effect were that processor 2 executed all its instructions\nbefore processor 1, the value 2would still be printed. When the instructions of the\ntwo processors execute at the same time, however, it is possible, as in this exampleexecution, that one of the updates to xis lost.\nOf course, many executions do not elicit the bug. For example, if the execution\norder were h1; 2; 3; 7; 4; 5; 6; 8 iorh1; 4; 5; 6; 2; 3; 7; 8 i, we would get the cor-\nrect result. That\u2019s the problem with determinacy races. Generally, most orderings\nproduce correct results\u2014such as any in which the instructions on the left executebefore the instructions on the right, or vice versa. But some orderings generateimproper results when the instructions interleave. Consequently, races can be ex-\ntremely hard to test for. You can run tests for days and never see the bug, only to\nexperience a catastrophic system crash in the \ufb01eld when the outcome is critical.\nAlthough we can cope with races in a variety of ways, including using mutual-\nexclusion locks and other methods of synchronization, for our purposes, we shallsimply ensure that strands that operate in parallel are independent :t h e y h a v e n o\ndeterminacy races among them. Thus, in a parallel for construct, all the iterations\nshould be independent. Between a spawn and the corresponding sync , the code\nof the spawned child should be independent of the code of the parent, including\ncode executed by additional spawned or called children. Note that arguments to aspawned child are evaluated in the parent before the actual spawn occurs, and thusthe evaluation of arguments to a spawned subroutine is in series with any accessesto those arguments after the spawn.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "810": {"page_number": 811, "page_information": "790 Chapter 27 Multithreaded Algorithms\nAs an example of how easy it is to generate code with races, here is a faulty\nimplementation of multithreaded matrix-vector multiplication that achieves a spanof\u201a.lgn/by parallelizing the inner forloop:\nM\nAT-VEC-WRONG .A; x/\n1nDA:rows\n2l e t ybe a new vector of length n\n3parallel for iD1ton\n4 yiD0\n5parallel for iD1ton\n6 parallel for jD1ton\n7 yiDyiCaijxj\n8return y\nThis procedure is, unfortunately, incorrect due to races on updating yiin line 7,\nwhich executes concurrently for all nvalues of j. Exercise 27.1-6 asks you to give\na correct implementation with \u201a.lgn/span.\nA multithreaded algorithm with races can sometimes be correct. As an exam-\nple, two parallel threads might store the same value into a shared variable, and itwouldn\u2019t matter which stored the value \ufb01rst. Generally, however, we shall considercode with races to be illegal.\nA chess lesson\nWe close this section with a true story that occurred during the development of\nthe world-class multithreaded chess-playing program ?Socrates [80], although the\ntimings below have been simpli\ufb01ed for exposition. The program was prototypedon a32-processor computer but was ultimately to run on a supercomputer with 512\nprocessors. At one point, the developers incorporated an optimization into the pro-\ngram that reduced its running time on an important benchmark on the 32-processor\nmachine from T\n32D65seconds to T0\n32D40seconds. Yet, the developers used\nthe work and span performance measures to conclude that the optimized version,which was faster on 32processors, would actually be slower than the original ver-\nsion on 512processsors. As a result, they abandoned the \u201coptimization.\u201d\nHere is their analysis. The original version of the program had work T\n1D2048\nseconds and span T1D1second. If we treat inequality (27.4) as an equation,\nTPDT1=PCT1, and use it as an approximation to the running time on Ppro-\ncessors, we see that indeed T32D2048=32C1D65. With the optimization, the\nwork became T0\n1D1024 seconds and the span became T0\n1D8seconds. Again\nusing our approximation, we get T0\n32D1024=32C8D40.\nThe relative speeds of the two versions switch when we calculate the running\ntimes on 512processors, however. In particular, we have T512D2048=512C1D5", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "811": {"page_number": 812, "page_information": "27.1 The basics of dynamic multithreading 791\nseconds, and T0\n512D1024=512C8D10seconds. The optimization that sped up\nthe program on 32processors would have made the program twice as slow on 512\nprocessors! The optimized version\u2019s span of 8, which was not the dominant term in\nthe running time on 32processors, became the dominant term on 512processors,\nnullifying the advantage from using more processors.\nThe moral of the story is that work and span can provide a better means of\nextrapolating performance than can measured running times.\nExercises\n27.1-1\nSuppose that we spawn P-F IB.n/NUL2/in line 4 of P-F IB, rather than calling it\nas is done in the code. What is the impact on the asymptotic work, span, andparallelism?\n27.1-2\nDraw the computation dag that results from executing P-F\nIB.5/. Assuming that\neach strand in the computation takes unit time, what are the work, span, and par-allelism of the computation? Show how to schedule the dag on 3processors using\ngreedy scheduling by labeling each strand with the time step in which it is executed.\n27.1-3\nProve that a greedy scheduler achieves the following time bound, which is slightlystronger than the bound proven in Theorem 27.1:\nT\nP/DC4T1/NULT1\nPCT1: (27.5)\n27.1-4\nConstruct a computation dag for which one execution of a greedy scheduler cantake nearly twice the time of another execution of a greedy scheduler on the samenumber of processors. Describe how the two executions would proceed.\n27.1-5\nProfessor Karan measures her deterministic multithreaded algorithm on 4,10,\nand64processors of an ideal parallel computer using a greedy scheduler. She\nclaims that the three runs yielded T\n4D80seconds, T10D42seconds, and\nT64D10seconds. Argue that the professor is either lying or incompetent. ( Hint:\nUse the work law (27.2), the span law (27.3), and inequality (27.5) from Exer-cise 27.1-3.)", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "812": {"page_number": 813, "page_information": "792 Chapter 27 Multithreaded Algorithms\n27.1-6\nGive a multithreaded algorithm to multiply an n/STXnmatrix by an n-vector that\nachieves \u201a.n2=lgn/parallelism while maintaining \u201a.n2/work.\n27.1-7\nConsider the following multithreaded pseudocode for transposing an n/STXnmatrix A\nin place:\nP-T RANSPOSE .A/\n1nDA:rows\n2parallel for jD2ton\n3 parallel for iD1toj/NUL1\n4 exchange aijwithaji\nAnalyze the work, span, and parallelism of this algorithm.\n27.1-8\nSuppose that we replace the parallel for loop in line 3 of P-T RANSPOSE (see Ex-\nercise 27.1-7) with an ordinary forloop. Analyze the work, span, and parallelism\nof the resulting algorithm.\n27.1-9\nFor how many processors do the two versions of the chess programs run equally\nfast, assuming that TPDT1=PCT1?\n27.2 Multithreaded matrix multiplication\nIn this section, we examine how to multithread matrix multiplication, a problem\nwhose serial running time we studied in Section 4.2. We\u2019ll look at multithreaded\nalgorithms based on the standard triply nested loop, as well as divide-and-conquer\nalgorithms.\nMultithreaded matrix multiplication\nThe \ufb01rst algorithm we study is the straighforward algorithm based on parallelizing\nthe loops in the procedure S QUARE -MATRIX -MULTIPLY on page 75:", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "813": {"page_number": 814, "page_information": "27.2 Multithreaded matrix multiplication 793\nP-S QUARE -MATRIX -MULTIPLY .A; B/\n1 nDA:rows\n2l e t Cb ean e w n/STXnmatrix\n3parallel for iD1ton\n4 parallel for jD1ton\n5 cijD0\n6 for kD1ton\n7 cijDcijCaik/SOHbkj\n8return C\nTo analyze this algorithm, observe that since the serialization of the algorithm is\njust S QUARE -MATRIX -MULTIPLY , the work is therefore simply T1.n/D\u201a.n3/,\nthe same as the running time of S QUARE -MATRIX -MULTIPLY . The span is\nT1.n/D \u201a.n/ , because it follows a path down the tree of recursion for the\nparallel for loop starting in line 3, then down the tree of recursion for the parallel\nforloop starting in line 4, and then executes all niterations of the ordinary forloop\nstarting in line 6, resulting in a total span of \u201a.lgn/C\u201a.lgn/C\u201a.n/ D\u201a.n/ .\nThus, the parallelism is \u201a.n3/=\u201a.n/ D\u201a.n2/. Exercise 27.2-3 asks you to par-\nallelize the inner loop to obtain a parallelism of \u201a.n3=lgn/, which you cannot do\nstraightforwardly using parallel for , because you would create races.\nA divide-and-conquer mu ltithreaded algorithm for matrix multiplication\nAs we learned in Section 4.2, we can multiply n/STXnmatrices serially in time\n\u201a.nlg7/DO.n2:81/using Strassen\u2019s divide-and-conquer strategy, which motivates\nus to look at multithreading such an algorithm. We begin, as we did in Section 4.2,\nwith multithreading a simpler divide-and-conquer algorithm.\nRecall from page 77 that the S QUARE -MATRIX -MULTIPLY -RECURSIVE proce-\ndure, which multiplies two n/STXnmatrices Aand Bto produce the n/STXnmatrix C,\nrelies on partitioning each of the three matrices into four n=2/STXn=2submatrices:\nAD/DC2A11 A12\nA21 A22/DC3\n;B D/DC2B11 B12\nB21 B22/DC3\n;C D/DC2C11 C12\nC21 C22/DC3\n:\nThen, we can write the matrix product as\n/DC2C11 C12\nC21 C22/DC3\nD/DC2A11 A12\nA21 A22/DC3/DC2B11 B12\nB21 B22/DC3\nD/DC2A11B11 A11B12\nA21B11 A21B12/DC3\nC/DC2A12B21 A12B22\nA22B21 A22B22/DC3\n: (27.6)\nThus, to multiply two n/STXnmatrices, we perform eight multiplications of n=2/STXn=2\nmatrices and one addition of n/STXnmatrices. The following pseudocode implements", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "814": {"page_number": 815, "page_information": "794 Chapter 27 Multithreaded Algorithms\nthis divide-and-conquer strategy using nested parallelism. Unlike the S QUARE -\nMATRIX -MULTIPLY -RECURSIVE procedure on which it is based, P-M ATRIX -\nMULTIPLY -RECURSIVE takes the output matrix as a parameter to avoid allocating\nmatrices unnecessarily.\nP-M ATRIX -MULTIPLY -RECURSIVE . C;A ;B/\n1nDA:rows\n2ifn==1\n3 c11Da11b11\n4elseletTb ean e w n/STXnmatrix\n5 partition A,B,C,a n d Tinton=2/STXn=2submatrices\nA11;A12;A21;A22;B11;B12;B21;B22;C11;C12;C21;C22;\nandT11;T12;T21;T22; respectively\n6 spawn P-M ATRIX -MULTIPLY -RECURSIVE .C11;A11;B11/\n7 spawn P-M ATRIX -MULTIPLY -RECURSIVE .C12;A11;B12/\n8 spawn P-M ATRIX -MULTIPLY -RECURSIVE .C21;A21;B11/\n9 spawn P-M ATRIX -MULTIPLY -RECURSIVE .C22;A21;B12/\n10 spawn P-M ATRIX -MULTIPLY -RECURSIVE .T11;A12;B21/\n11 spawn P-M ATRIX -MULTIPLY -RECURSIVE .T12;A12;B22/\n12 spawn P-M ATRIX -MULTIPLY -RECURSIVE .T21;A22;B21/\n13 P-M ATRIX -MULTIPLY -RECURSIVE .T22;A22;B22/\n14 sync\n15 parallel for iD1ton\n16 parallel for jD1ton\n17 cijDcijCtij\nLine 3 handles the base case, where we are multiplying 1/STX1matrices. We handle\nthe recursive case in lines 4\u201317. We allocate a temporary matrix Tin line 4, and\nline 5 partitions each of the matrices A,B,C,a n d Tinton=2/STXn=2submatrices.\n(As with S QUARE -MATRIX -MULTIPLY -RECURSIVE on page 77, we gloss over\nthe minor issue of how to use index calculations to represent submatrix sectionsof a matrix.) The recursive call in line 6 sets the submatrix C\n11to the submatrix\nproduct A11B11,s ot h a t C11equals the \ufb01rst of the two terms that form its sum in\nequation (27.6). Similarly, lines 7\u20139 set C12,C21,a n d C22to the \ufb01rst of the two\nterms that equal their sums in equation (27.6). Line 10 sets the submatrix T11to\nthe submatrix product A12B21,s ot h a t T11equals the second of the two terms that\nform C11\u2019s sum. Lines 11\u201313 set T12,T21,a n d T22to the second of the two terms\nthat form the sums of C12,C21,a n d C22, respectively. The \ufb01rst seven recursive\ncalls are spawned, and the last one runs in the main strand. The sync statement in\nline 14 ensures that all the submatrix products in lines 6\u201313 have been computed,", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "815": {"page_number": 816, "page_information": "27.2 Multithreaded matrix multiplication 795\nafter which we add the products from TintoCin using the doubly nested parallel\nforloops in lines 15\u201317.\nWe \ufb01rst analyze the work M1.n/of the P-M ATRIX -MULTIPLY -RECURSIVE\nprocedure, echoing the serial running-time analysis of its progenitor S QUARE -\nMATRIX -MULTIPLY -RECURSIVE . In the recursive case, we partition in \u201a.1/ time,\nperform eight recursive multiplications of n=2/STXn=2matrices, and \ufb01nish up with\nthe\u201a.n2/work from adding two n/STXnmatrices. Thus, the recurrence for the\nwork M1.n/is\nM1.n/D8M 1.n=2/C\u201a.n2/\nD\u201a.n3/\nby case 1 of the master theorem. In other words, the work of our multithreaded al-\ngorithm is asymptotically the same as the running time of the procedure S QUARE -\nMATRIX -MULTIPLY in Section 4.2, with its triply nested loops.\nTo determine the span M1.n/of P-M ATRIX -MULTIPLY -RECURSIVE ,w e\ufb01 r s t\nobserve that the span for partitioning is \u201a.1/ , which is dominated by the \u201a.lgn/\nspan of the doubly nested parallel for loops in lines 15\u201317. Because the eight\nparallel recursive calls all execute on matrices of the same size, the maximum span\nfor any recursive call is just the span of any one. Hence, the recurrence for the\nspanM1.n/of P-M ATRIX -MULTIPLY -RECURSIVE is\nM1.n/DM1.n=2/C\u201a.lgn/ : (27.7)\nThis recurrence does not fall under any of the cases of the master theorem, but\nit does meet the condition of Exercise 4.6-2. By Exercise 4.6-2, therefore, thesolution to recurrence (27.7) is M\n1.n/D\u201a.lg2n/.\nNow that we know the work and span of P-M ATRIX -MULTIPLY -RECURSIVE ,\nwe can compute its parallelism as M1.n/=M 1.n/D\u201a.n3=lg2n/, which is very\nhigh.\nMultithreading Strassen\u2019s method\nTo multithread Strassen\u2019s algorithm, we follow the same general outline as on\npage 79, only using nested parallelism:\n1. Divide the input matrices AandBand output matrix Cinton=2/STXn=2 sub-\nmatrices, as in equation (27.6). This step takes \u201a.1/ w o r ka n ds p a nb yi n d e x\ncalculation.\n2. Create 10matrices S1;S2;:::;S 10, each of which is n=2/STXn=2and is the sum\nor difference of two matrices created in step 1. We can create all 10matrices\nwith\u201a.n2/work and \u201a.lgn/span by using doubly nested parallel for loops.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "816": {"page_number": 817, "page_information": "796 Chapter 27 Multithreaded Algorithms\n3. Using the submatrices created in step 1 and the 10matrices created in\nstep 2, recursively spawn the computation of seven n=2/STXn=2matrix products\nP1;P2;:::;P 7.\n4. Compute the desired submatrices C11;C12;C21;C22of the result matrix Cby\nadding and subtracting various combinations of the Pimatrices, once again\nusing doubly nested parallel for loops. We can compute all four submatrices\nwith\u201a.n2/work and \u201a.lgn/span.\nTo analyze this algorithm, we \ufb01rst observe that since the serialization is the\nsame as the original serial algorithm, the work is just the running time of theserialization, namely, \u201a.n\nlg7/.A s f o r P - M ATRIX -MULTIPLY -RECURSIVE ,w e\ncan devise a recurrence for the span. In this case, seven recursive calls exe-cute in parallel, but since they all operate on matrices of the same size, we ob-tain the same recurrence (27.7) as we did for P-M\nATRIX -MULTIPLY -RECURSIVE ,\nwhich has solution \u201a.lg2n/. Thus, the parallelism of multithreaded Strassen\u2019s\nmethod is \u201a.nlg7=lg2n/, which is high, though slightly less than the parallelism\nof P-M ATRIX -MULTIPLY -RECURSIVE .\nExercises\n27.2-1\nDraw the computation dag for computing P-S QUARE -MATRIX -MULTIPLY on2/STX2\nmatrices, labeling how the vertices in your diagram correspond to strands in the\nexecution of the algorithm. Use the convention that spawn and call edges point\ndownward, continuation edges point horizontally to the right, and return edgespoint upward. Assuming that each strand takes unit time, analyze the work, span,and parallelism of this computation.\n27.2-2\nRepeat Exercise 27.2-1 for P-M\nATRIX -MULTIPLY -RECURSIVE .\n27.2-3\nGive pseudocode for a multithreaded algorithm that multiplies two n/STXnmatrices\nwith work \u201a.n3/but span only \u201a.lgn/. Analyze your algorithm.\n27.2-4\nGive pseudocode for an ef\ufb01cient multithreaded algorithm that multiplies a p/STXq\nmatrix by a q/STXrmatrix. Your algorithm should be highly parallel even if any of\np,q,a n d rare1. Analyze your algorithm.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "817": {"page_number": 818, "page_information": "27.3 Multithreaded merge sort 797\n27.2-5\nGive pseudocode for an ef\ufb01cient multithreaded algorithm that transposes an n/STXn\nmatrix in place by using divide-and-conquer to divide the matrix recursively intofourn=2/STXn=2submatrices. Analyze your algorithm.\n27.2-6\nGive pseudocode for an ef\ufb01cient multithreaded implementation of the Floyd-Warshall algorithm (see Section 25.2), which computes shortest paths between allpairs of vertices in an edge-weighted graph. Analyze your algorithm.\n27.3 Multithreaded merge sort\nWe \ufb01rst saw serial merge sort in Section 2.3.1, and in Section 2.3.2 we analyzed itsrunning time and showed it to be \u201a.n lgn/. Because merge sort already uses the\ndivide-and-conquer paradigm, it seems like a terri\ufb01c candidate for multithreadingusing nested parallelism. We can easily modify the pseudocode so that the \ufb01rstrecursive call is spawned:\nM\nERGE -SORT0. A ;p;r/\n1ifp<r\n2 qDb.pCr/=2c\n3 spawn MERGE -SORT0. A ;p;q/\n4M ERGE -SORT0.A; qC1; r/\n5 sync\n6M ERGE . A ;p;q;r/\nLike its serial counterpart, M ERGE -SORT0sorts the subarray A\u0152p : : r/c141 . After the\ntwo recursive subroutines in lines 3 and 4 have completed, which is ensured by thesync statement in line 5, M\nERGE -SORT0calls the same M ERGE procedure as on\npage 31.\nLet us analyze M ERGE -SORT0. To do so, we \ufb01rst need to analyze M ERGE .R e -\ncall that its serial running time to merge nelements is \u201a.n/ . Because M ERGE is\nserial, both its work and its span are \u201a.n/ . Thus, the following recurrence charac-\nterizes the work MS0\n1.n/of M ERGE -SORT0onnelements:\nMS0\n1.n/D2MS0\n1.n=2/C\u201a.n/\nD\u201a.n lgn/ ;", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "818": {"page_number": 819, "page_information": "798 Chapter 27 Multithreaded Algorithms\n\u2026\u2026 \u2026\n\u2026 \u2026merge merge copyp1 q1 r1 p2 q2r2\np3 q3 r3AT\nxx\n/DC4x/DC4x< x\n/NAKx/NAKx /NAKx\nFigure 27.6 The idea behind the multithreaded merging of two sorted subarrays T\u0152 p 1::r1/c141\nandT\u0152 p 2::r2/c141into the subarray A\u0152p3::r3/c141. Letting xDT\u0152 q1/c141be the median of T\u0152 p 1::r1/c141andq2\nbe the place in T\u0152 p 2::r2/c141such that xwould fall between T\u0152 q2/NUL1/c141andT\u0152 q2/c141, every element in\nsubarrays T\u0152 p 1::q1/NUL1/c141andT\u0152 p 2::q2/NUL1/c141(lightly shaded) is less than or equal to x,a n de v e r y\nelement in the subarrays T\u0152 q1C1::r 1/c141andT\u0152 q2C1::r 2/c141(heavily shaded) is at least x.T om e r g e ,\nwe compute the index q3where xbelongs in A\u0152p3::r3/c141,c o p y xintoA\u0152q3/c141, and then recursively\nmerge T\u0152 p 1::q1/NUL1/c141withT\u0152 p 2::q2/NUL1/c141intoA\u0152p3::q3/NUL1/c141andT\u0152 q1C1::r 1/c141withT\u0152 q2::r2/c141\nintoA\u0152q3C1::r 3/c141.\nwhich is the same as the serial running time of merge sort. Since the two recursive\ncalls of M ERGE -SORT0can run in parallel, the span MS0\n1is given by the recurrence\nMS0\n1.n/DMS0\n1.n=2/C\u201a.n/\nD\u201a.n/ :\nThus, the parallelism of M ERGE -SORT0comes to MS0\n1.n/=MS0\n1.n/D\u201a.lgn/,\nwhich is an unimpressive amount of parallelism. To sort 10 million elements, forexample, it might achieve linear speedup on a few processors, but it would notscale up effectively to hundreds of processors.\nYou probably have already \ufb01gured out where the parallelism bottleneck is in\nthis multithreaded merge sort: the serial M\nERGE procedure. Although merging\nmight initially seem to be inherently serial, we can, in fact, fashion a multithreaded\nversion of it by using nested parallelism.\nOur divide-and-conquer strategy for multithreaded merging, which is illus-\ntrated in Figure 27.6, operates on subarrays of an array T. Suppose that we\nare merging the two sorted subarrays T\u0152 p 1::r1/c141of length n1Dr1/NULp1C1\nandT\u0152 p 2::r2/c141of length n2Dr2/NULp2C1into another subarray A\u0152p 3::r3/c141,o f\nlength n3Dr3/NULp3C1Dn1Cn2. Without loss of generality, we make the sim-\nplifying assumption that n1/NAKn2.\nWe \ufb01rst \ufb01nd the middle element xDT\u0152 q 1/c141of the subarray T\u0152 p 1::r1/c141,\nwhere q1Db.p1Cr1/=2c. Because the subarray is sorted, xi sam e d i a n\nofT\u0152 p 1::r1/c141: every element in T\u0152 p 1::q 1/NUL1/c141is no more than x,a n de v e r ye l -\nement in T\u0152 q 1C1::r 1/c141is no less than x. We then use binary search to \ufb01nd the", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "819": {"page_number": 820, "page_information": "27.3 Multithreaded merge sort 799\nindex q2in the subarray T\u0152 p 2::r2/c141so that the subarray would still be sorted if we\ninserted xbetween T\u0152 q 2/NUL1/c141andT\u0152 q 2/c141.\nWe next merge the original subarrays T\u0152 p 1::r1/c141andT\u0152 p 2::r2/c141intoA\u0152p 3::r3/c141\nas follows:\n1. Set q3Dp3C.q1/NULp1/C.q2/NULp2/.\n2. Copy xintoA\u0152q 3/c141.\n3. Recursively merge T\u0152 p 1::q 1/NUL1/c141withT\u0152 p 2::q 2/NUL1/c141, and place the result into\nthe subarray A\u0152p 3::q 3/NUL1/c141.\n4. Recursively merge T\u0152 q 1C1::r 1/c141withT\u0152 q 2::r2/c141, and place the result into the\nsubarray A\u0152q 3C1::r 3/c141.\nWhen we compute q3, the quantity q1/NULp1is the number of elements in the subarray\nT\u0152 p 1::q 1/NUL1/c141, and the quantity q2/NULp2is the number of elements in the subarray\nT\u0152 p 2::q 2/NUL1/c141. Thus, their sum is the number of elements that end up before xin\nthe subarray A\u0152p 3::r3/c141.\nThe base case occurs when n1Dn2D0, in which case we have no work\nto do to merge the two empty subarrays. Since we have assumed that the sub-array T\u0152 p\n1::r1/c141is at least as long as T\u0152 p 2::r2/c141,t h a ti s , n1/NAKn2, we can check\nfor the base case by just checking whether n1D0. We must also ensure that the\nrecursion properly handles the case when only one of the two subarrays is empty,\nwhich, by our assumption that n1/NAKn2, must be the subarray T\u0152 p 2::r2/c141.\nNow, let\u2019s put these ideas into pseudocode. We start with the binary search,\nwhich we express serially. The procedure B INARY -SEARCH . x;T;p;r/ takes a\nkeyxand a subarray T\u0152 p::r/c141 , and it returns one of the following:\n/SIIfT\u0152 p::r/c141 is empty ( r<p ), then it returns the index p.\n/SIIfx/DC4T\u0152 p/c141 , and hence less than or equal to all the elements of T\u0152 p::r/c141 ,t h e n\nit returns the index p.\n/SIIfx>T\u0152 p /c141 , then it returns the largest index qin the range p<q/DC4rC1such\nthatT\u0152 q/NUL1/c141 < x .\nHere is the pseudocode:\nBINARY -SEARCH . x;T;p;r/\n1lowDp\n2highDmax.p; rC1/\n3while low<high\n4 midDb.lowChigh/=2c\n5 ifx/DC4T\u0152mid/c141\n6 highDmid\n7 elselowDmidC1\n8return high", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "820": {"page_number": 821, "page_information": "800 Chapter 27 Multithreaded Algorithms\nThe call B INARY -SEARCH . x;T;p;r/ takes \u201a.lgn/serial time in the worst case,\nwhere nDr/NULpC1is the size of the subarray on which it runs. (See Exer-\ncise 2.3-5.) Since B INARY -SEARCH is a serial procedure, its worst-case work and\nspan are both \u201a.lgn/.\nWe are now prepared to write pseudocode for the multithreaded merging pro-\ncedure itself. Like the M ERGE procedure on page 31, the P-M ERGE procedure\nassumes that the two subarrays to be merged lie within the same array. Un-like M\nERGE ,h o w e v e r ,P - M ERGE does not assume that the two subarrays to\nbe merged are adjacent within the array. (That is, P-M ERGE does not require\nthatp2Dr1C1.) Another difference between M ERGE and P-M ERGE is that\nP-M ERGE takes as an argument an output subarray Ainto which the merged val-\nues should be stored. The call P-M ERGE .T; p 1;r1;p2;r2;A ;p 3/merges the sorted\nsubarrays T\u0152 p 1::r1/c141andT\u0152 p 2::r2/c141into the subarray A\u0152p 3::r3/c141,w h e r e r3D\np3C.r1/NULp1C1/C.r2/NULp2C1//NUL1Dp3C.r1/NULp1/C.r2/NULp2/C1and\nis not provided as an input.\nP-M ERGE .T; p 1;r1;p2;r2;A ;p 3/\n1n1Dr1/NULp1C1\n2n2Dr2/NULp2C1\n3ifn1<n 2 //ensure that n1/NAKn2\n4 exchange p1withp2\n5 exchange r1withr2\n6 exchange n1withn2\n7ifn1==0 //both empty?\n8 return\n9elseq1Db.p1Cr1/=2c\n10 q2DBINARY -SEARCH .T \u0152q 1/c141; T; p 2;r2/\n11 q3Dp3C.q1/NULp1/C.q2/NULp2/\n12 A\u0152q 3/c141DT\u0152 q 1/c141\n13 spawn P-M ERGE .T; p 1;q1/NUL1; p 2;q2/NUL1; A; p 3/\n14 P-M ERGE .T; q 1C1; r1;q2;r2;A ;q 3C1/\n15 sync\nThe P-M ERGE procedure works as follows. Lines 1\u20132 compute the lengths n1\nandn2of the subarrays T\u0152 p 1::r1/c141andT\u0152 p 2::r2/c141, respectively. Lines 3\u20136 en-\nforce the assumption that n1/NAKn2. Line 7 tests for the base case, where the\nsubarray T\u0152 p 1::r1/c141is empty (and hence so is T\u0152 p 2::r2/c141), in which case we sim-\nply return. Lines 9\u201315 implement the divide-and-conquer strategy. Line 9 com-putes the midpoint of T\u0152 p\n1::r1/c141, and line 10 \ufb01nds the point q2inT\u0152 p 2::r2/c141such\nthat all elements in T\u0152 p 2::q 2/NUL1/c141are less than T\u0152 q 1/c141(which corresponds to x)\nand all the elements in T\u0152 q 2::p 2/c141are at least as large as T\u0152 q 1/c141.L i n e 1 1 c o m -", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "821": {"page_number": 822, "page_information": "27.3 Multithreaded merge sort 801\nputes the index q3of the element that divides the output subarray A\u0152p 3::r3/c141into\nA\u0152p 3::q 3/NUL1/c141andA\u0152q 3C1::r 3/c141, and then line 12 copies T\u0152 q 1/c141directly into A\u0152q 3/c141.\nThen, we recurse using nested parallelism. Line 13 spawns the \ufb01rst subproblem,\nwhile line 14 calls the second subproblem in parallel. The sync statement in line 15\nensures that the subproblems have completed before the procedure returns. (Sinceevery procedure implicitly executes a sync before returning, we could have omitted\nthesync statement in line 15, but including it is good coding practice.) There\nis some cleverness in the coding to ensure that when the subarray T\u0152 p\n2::r2/c141is\nempty, the code operates correctly. The way it works is that on each recursive call,\na median element of T\u0152 p 1::r1/c141is placed into the output subarray, until T\u0152 p 1::r1/c141\nitself \ufb01nally becomes empty, triggering the base case.\nAnalysis of multithreaded merging\nWe \ufb01rst derive a recurrence for the span PM 1.n/of P-M ERGE , where the two\nsubarrays contain a total of nDn1Cn2elements. Because the spawn in line 13 and\nthe call in line 14 operate logically in parallel, we need examine only the costlier ofthe two calls. The key is to understand that in the worst case, the maximum numberof elements in either of the recursive calls can be at most 3n=4 , which we see as\nfollows. Because lines 3\u20136 ensure that n\n2/DC4n1, it follows that n2D2n2=2/DC4\n.n1Cn2/=2Dn=2. In the worst case, one of the two recursive calls merges\nbn1=2celements of T\u0152 p 1::r1/c141with all n2elements of T\u0152 p 2::r2/c141, and hence the\nnumber of elements involved in the call is\nbn1=2cCn2/DC4n1=2Cn2=2Cn2=2\nD.n1Cn2/=2Cn2=2\n/DC4n=2Cn=4\nD3n=4 :\nAdding in the \u201a.lgn/cost of the call to B INARY -SEARCH in line 10, we obtain\nthe following recurrence for the worst-case span:\nPM 1.n/DPM 1.3n=4/C\u201a.lgn/ : (27.8)\n(For the base case, the span is \u201a.1/ , since lines 1\u20138 execute in constant time.)\nThis recurrence does not fall under any of the cases of the master theorem, but itmeets the condition of Exercise 4.6-2. Therefore, the solution to recurrence (27.8)isPM\n1.n/D\u201a.lg2n/.\nWe now analyze the work PM 1.n/of P-M ERGE onnelements, which turns out\nto be \u201a.n/ . Since each of the nelements must be copied from array Tto array A,\nwe have PM 1.n/D/DEL.n/ . Thus, it remains only to show that PM 1.n/DO.n/ .\nWe shall \ufb01rst derive a recurrence for the worst-case work. The binary search in\nline 10 costs \u201a.lgn/in the worst case, which dominates the other work outside", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "822": {"page_number": 823, "page_information": "802 Chapter 27 Multithreaded Algorithms\nof the recursive calls. For the recursive calls, observe that although the recursive\ncalls in lines 13 and 14 might merge different numbers of elements, together thetwo recursive calls merge at most nelements (actually n/NUL1elements, since T\u0152 q\n1/c141\ndoes not participate in either recursive call). Moreover, as we saw in analyzing thespan, a recursive call operates on at most 3n=4 elements. We therefore obtain the\nrecurrence\nPM\n1.n/DPM 1.\u02dbn/CPM 1..1/NUL\u02db/n/CO.lgn/ ; (27.9)\nwhere \u02dblies in the range 1=4/DC4\u02db/DC43=4, and where we understand that the actual\nvalue of \u02dbmay vary for each level of recursion.\nWe prove that recurrence (27.9) has solution PM 1DO.n/ via the substitution\nmethod. Assume that PM 1.n//DC4c1n/NULc2lgnfor some positive constants c1andc2.\nSubstituting gives us\nPM 1.n//DC4.c1\u02dbn/NULc2lg.\u02dbn//C.c1.1/NUL\u02db/n/NULc2lg..1/NUL\u02db/n//C\u201a.lgn/\nDc1.\u02dbC.1/NUL\u02db//n/NULc2.lg.\u02dbn/Clg..1/NUL\u02db/n//C\u201a.lgn/\nDc1n/NULc2.lg\u02dbClgnClg.1/NUL\u02db/Clgn/C\u201a.lgn/\nDc1n/NULc2lgn/NUL.c2.lgnClg.\u02db.1/NUL\u02db////NUL\u201a.lgn//\n/DC4c1n/NULc2lgn;\nsince we can choose c2large enough that c2.lgnClg.\u02db.1/NUL\u02db/// dominates the\n\u201a.lgn/term. Furthermore, we can choose c1large enough to satisfy the base\nconditions of the recurrence. Since the work PM 1.n/of P-M ERGE is both /DEL.n/\nandO.n/ ,w eh a v e PM 1.n/D\u201a.n/ .\nThe parallelism of P-M ERGE isPM 1.n/=PM 1.n/D\u201a.n= lg2n/.\nMultithreaded merge sort\nNow that we have a nicely parallelized multithreaded merging procedure, we can\nincorporate it into a multithreaded merge sort. This version of merge sort is similarto the M\nERGE -SORT0procedure we saw earlier, but unlike M ERGE -SORT0, it takes\nas an argument an output subarray B, which will hold the sorted result. In par-\nticular, the call P-M ERGE -SORT. A ;p;r ;B;s/ sorts the elements in A\u0152p : : r/c141 and\nstores them in B\u0152s::sCr/NULp/c141.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "823": {"page_number": 824, "page_information": "27.3 Multithreaded merge sort 803\nP-M ERGE -SORT. A ;p;r ;B;s/\n1nDr/NULpC1\n2ifn==1\n3 B\u0152s/c141DA\u0152p/c141\n4elseletT\u0152 1::n /c141 b ean e wa r r a y\n5 qDb.pCr/=2c\n6 q0Dq/NULpC1\n7 spawn P-M ERGE -SORT. A ;p;q;T;1 /\n8P - M ERGE -SORT.A; qC1; r; T; q0C1/\n9 sync\n10 P-M ERGE . T;1 ;q0;q0C1; n; B; s/\nAfter line 1 computes the number nof elements in the input subarray A\u0152p : : r/c141 ,\nlines 2\u20133 handle the base case when the array has only 1element. Lines 4\u20136 set\nup for the recursive spawn in line 7 and call in line 8, which operate in parallel. In\nparticular, line 4 allocates a temporary array Twithnelements to store the results\nof the recursive merge sorting. Line 5 calculates the index qofA\u0152p : : r/c141 to divide\nthe elements into the two subarrays A\u0152p : : q/c141 andA\u0152qC1::r/c141 that will be sorted\nrecursively, and line 6 goes on to compute the number q0of elements in the \ufb01rst\nsubarray A\u0152p : : q/c141 , which line 8 uses to determine the starting index in Tof where\nto store the sorted result of A\u0152qC1::r/c141 . At that point, the spawn and recursive\ncall are made, followed by the sync in line 9, which forces the procedure to wait\nuntil the spawned procedure is done. Finally, line 10 calls P-M ERGE to merge\nthe sorted subarrays, now in T\u0152 1::q0/c141andT\u0152 q0C1::n /c141 , into the output subarray\nB\u0152 s::sCr/NULp/c141.\nAnalysis of multithreaded merge sort\nWe start by analyzing the work PMS 1.n/of P-M ERGE -SORT, which is consider-\nably easier than analyzing the work of P-M ERGE . Indeed, the work is given by the\nrecurrence\nPMS 1.n/D2PMS 1.n=2/CPM 1.n/\nD2PMS 1.n=2/C\u201a.n/ :\nThis recurrence is the same as the recurrence (4.4) for ordinary M ERGE -SORT\nfrom Section 2.3.1 and has solution PMS 1.n/D\u201a.n lgn/by case 2 of the master\ntheorem.\nWe now derive and analyze a recurrence for the worst-case span PMS 1.n/.B e -\ncause the two recursive calls to P-M ERGE -SORT on lines 7 and 8 operate logically\nin parallel, we can ignore one of them, obtaining the recurrence", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "824": {"page_number": 825, "page_information": "804 Chapter 27 Multithreaded Algorithms\nPMS 1.n/DPMS 1.n=2/CPM 1.n/\nDPMS 1.n=2/C\u201a.lg2n/ : (27.10)\nAs for recurrence (27.8), the master theorem does not apply to recurrence (27.10),\nbut Exercise 4.6-2 does. The solution is PMS 1.n/D\u201a.lg3n/, and so the span of\nP-M ERGE -SORT is\u201a.lg3n/.\nParallel merging gives P-M ERGE -SORT a signi\ufb01cant parallelism advantage over\nMERGE -SORT0. Recall that the parallelism of M ERGE -SORT0, which calls the se-\nrial M ERGE procedure, is only \u201a.lgn/.F o rP - M ERGE -SORT, the parallelism is\nPMS 1.n/=PMS 1.n/D\u201a.n lgn/=\u201a. lg3n/\nD\u201a.n= lg2n/ ;\nwhich is much better both in theory and in practice. A good implementation in\npractice would sacri\ufb01ce some parallelism by coarsening the base case in order to\nreduce the constants hidden by the asymptotic notation. The straightforward way\nto coarsen the base case is to switch to an ordinary serial sort, perhaps quicksort,\nwhen the size of the array is suf\ufb01ciently small.\nExercises\n27.3-1\nExplain how to coarsen the base case of P-M ERGE .\n27.3-2\nInstead of \ufb01nding a median element in the larger subarray, as P-M ERGE does, con-\nsider a variant that \ufb01nds a median element of all the elements in the two sortedsubarrays using the result of Exercise 9.3-8. Give pseudocode for an ef\ufb01cientmultithreaded merging procedure that uses this median-\ufb01nding procedure. Ana-lyze your algorithm.\n27.3-3\nGive an ef\ufb01cient multithreaded algorithm for partitioning an array around a pivot,as is done by the P\nARTITION procedure on page 171. You need not partition the ar-\nray in place. Make your algorithm as parallel as possible. Analyze your algorithm.(Hint: You may need an auxiliary array and may need to make more than one pass\nover the input elements.)\n27.3-4\nGive a multithreaded version of R\nECURSIVE -FFT on page 911. Make your imple-\nmentation as parallel as possible. Analyze your algorithm.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "825": {"page_number": 826, "page_information": "Problems for Chapter 27 805\n27.3-5 ?\nGive a multithreaded version of R ANDOMIZED -SELECT on page 216. Make your\nimplementation as parallel as possible. Analyze your algorithm. ( Hint: Use the\npartitioning algorithm from Exercise 27.3-3.)\n27.3-6 ?\nShow how to multithread S ELECT from Section 9.3. Make your implementation as\nparallel as possible. Analyze your algorithm.\nProblems\n27-1 Implementing parallel loops using nested parallelismConsider the following multithreaded algorithm for performing pairwise additiononn-element arrays A\u01521 : : n/c141 andB\u0152 1::n /c141 , storing the sums in C\u0152 1::n /c141 :\nS\nUM-ARRAYS . A ;B;C/\n1parallel for iD1toA:length\n2 C\u0152 i/c141DA\u0152i/c141CB\u0152i/c141\na.Rewrite the parallel loop in S UM-ARRAYS using nested parallelism ( spawn\nandsync ) in the manner of M AT-VEC-MAIN-LOOP. Analyze the parallelism\nof your implementation.\nConsider the following alternative implementation of the parallel loop, which\ncontains a value grain -sizeto be speci\ufb01ed:\nSUM-ARRAYS0. A ;B;C/\n1nDA:length\n2grain -sizeD\u2039 //to be determined\n3rDdn=grain -sizee\n4forkD0tor/NUL1\n5 spawn ADD-SUBARRAY . A ;B;C;k/SOHgrain -sizeC1;\nmin..kC1//SOHgrain -size; n//\n6sync\nADD-SUBARRAY . A ;B;C;i;j/\n1forkDitoj\n2 C\u0152 k/c141DA\u0152k/c141CB\u0152k/c141", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "826": {"page_number": 827, "page_information": "806 Chapter 27 Multithreaded Algorithms\nb.Suppose that we set grain -sizeD1. What is the parallelism of this implemen-\ntation?\nc.Give a formula for the span of S UM-ARRAYS0in terms of nandgrain -size.\nDerive the best value for grain -sizeto maximize parallelism.\n27-2 Saving temporary space in matrix multiplication\nThe P-M ATRIX -MULTIPLY -RECURSIVE procedure has the disadvantage that it\nmust allocate a temporary matrix Tof size n/STXn, which can adversely affect the\nconstants hidden by the \u201a-notation. The P-M ATRIX -MULTIPLY -RECURSIVE pro-\ncedure does have high parallelism, however. For example, ignoring the constantsin the \u201a-notation, the parallelism for multiplying 1000/STX1000 matrices comes to\napproximately 1000\n3=102D107, since lg 1000/EM10. Most parallel computers\nhave far fewer than 10million processors.\na.Describe a recursive multithreaded algorithm that eliminates the need for the\ntemporary matrix Tat the cost of increasing the span to \u201a.n/ .(Hint: Com-\nputeCDCCABfollowing the general strategy of P-M ATRIX -MULTIPLY -\nRECURSIVE , but initialize Cin parallel and insert a sync in a judiciously cho-\nsen location.)\nb.Give and solve recurrences for the work and span of your implementation.\nc.Analyze the parallelism of your implementation. Ignoring the constants in the\n\u201a-notation, estimate the parallelism on 1000/STX1000 matrices. Compare with\nthe parallelism of P-M ATRIX -MULTIPLY -RECURSIVE .\n27-3 Multithreaded matrix algorithms\na.Parallelize the LU-D ECOMPOSITION procedure on page 821 by giving pseu-\ndocode for a multithreaded version of this algorithm. Make your implementa-tion as parallel as possible, and analyze its work, span, and parallelism.\nb.Do the same for LUP-D\nECOMPOSITION on page 824.\nc.Do the same for LUP-S OLVE on page 817.\nd.Do the same for a multithreaded algorithm based on equation (28.13) for in-\nverting a symmetric positive-de\ufb01nite matrix.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "827": {"page_number": 828, "page_information": "Problems for Chapter 27 807\n27-4 Multithreading reductions and pre\ufb01x computations\nA\u02dd-reduction of an array x\u01521::n/c141 ,w h e r e\u02ddis an associative operator, is the value\nyDx\u01521/c141\u02ddx\u01522/c141\u02dd/SOH/SOH/SOH\u02dd x\u0152n/c141 :\nThe following procedure computes the \u02dd-reduction of a subarray x\u0152 i::j/c141 serially.\nREDUCE . x;i;j/\n1yDx\u0152i/c141\n2forkDiC1toj\n3 yDy\u02ddx\u0152k/c141\n4return y\na.Use nested parallelism to implement a multithreaded algorithm P-R EDUCE ,\nwhich performs the same function with \u201a.n/ work and \u201a.lgn/span. Analyze\nyour algorithm.\nA related problem is that of computing a \u02dd-pre\ufb01x computation , sometimes\ncalled a \u02dd-scan , on an array x\u01521::n/c141 ,w h e r e\u02ddis once again an associative op-\nerator. The\u02dd-scan produces the array y\u0152 1::n /c141 given by\ny\u01521/c141Dx\u01521/c141 ;\ny\u01522/c141Dx\u01521/c141\u02ddx\u01522/c141 ;\ny\u01523/c141Dx\u01521/c141\u02ddx\u01522/c141\u02ddx\u01523/c141 ;\n:::\ny\u0152n/c141Dx\u01521/c141\u02ddx\u01522/c141\u02ddx\u01523/c141\u02dd/SOH/SOH/SOH\u02dd x\u0152n/c141 ;\nthat is, all pre\ufb01xes of the array x\u201csummed\u201d using the \u02ddoperator. The following\nserial procedure SCAN performs a\u02dd-pre\ufb01x computation:\nSCAN.x/\n1nDx:length\n2l e t y\u0152 1::n /c141 be a new array\n3y\u01521/c141Dx\u01521/c141\n4foriD2ton\n5 y\u0152i/c141Dy\u0152i/NUL1/c141\u02ddx\u0152i/c141\n6return y\nUnfortunately, multithreading S CAN is not straightforward. For example, changing\ntheforloop to a parallel for loop would create races, since each iteration of the\nloop body depends on the previous iteration. The following procedure P-S CAN-1\nperforms the\u02dd-pre\ufb01x computation in parallel, albeit inef\ufb01ciently:", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "828": {"page_number": 829, "page_information": "808 Chapter 27 Multithreaded Algorithms\nP-S CAN-1.x/\n1nDx:length\n2l e t y\u0152 1::n /c141 b ean e wa r r a y\n3P - S CAN-1-A UX. x;y;1 ;n /\n4return y\nP-S CAN-1-A UX. x;y;i;j/\n1parallel for lDitoj\n2 y\u0152l/c141DP-R EDUCE . x;1 ;l/\nb.Analyze the work, span, and parallelism of P-S CAN-1.\nBy using nested parallelism, we can obtain a more ef\ufb01cient \u02dd-pre\ufb01x computa-\ntion:\nP-S CAN-2.x/\n1nDx:length\n2l e t y\u0152 1::n /c141 b ean e wa r r a y\n3P - S CAN-2-A UX. x;y;1 ;n /\n4return y\nP-S CAN-2-A UX. x;y;i;j/\n1ifi==j\n2 y\u0152i/c141Dx\u0152i/c141\n3elsekDb.iCj/ =2c\n4 spawn P-S CAN-2-A UX. x;y;i;k/\n5P - S CAN-2-A UX. x;y;kC1; j /\n6 sync\n7 parallel for lDkC1toj\n8 y\u0152l/c141Dy\u0152k/c141\u02ddy\u0152l/c141\nc.Argue that P-S CAN-2 is correct, and analyze its work, span, and parallelism.\nWe can improve on both P-S CAN-1 and P-S CAN-2 by performing the \u02dd-pre\ufb01x\ncomputation in two distinct passes over the data. On the \ufb01rst pass, we gather the\nterms for various contiguous subarrays of xinto a temporary array t, and on the\nsecond pass we use the terms in tto compute the \ufb01nal result y. The following\npseudocode implements this strategy, but certain expressions have been omitted:", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "829": {"page_number": 830, "page_information": "Problems for Chapter 27 809\nP-S CAN-3.x/\n1nDx:length\n2l e t y\u0152 1::n /c141 andt\u01521::n/c141 be new arrays\n3y\u01521/c141Dx\u01521/c141\n4ifn>1\n5P - S CAN-UP. x;t;2;n /\n6P - S CAN-DOWN.x\u01521/c141; x; t; y; 2; n/\n7return y\nP-S CAN-UP. x;t;i;j/\n1ifi==j\n2 return x\u0152i/c141\n3else\n4 kDb.iCj/ =2c\n5 t\u0152k/c141Dspawn P-S CAN-UP. x;t;i;k/\n6 rightDP-S CAN-UP. x;t;kC1; j /\n7 sync\n8 return\n //\ufb01ll in the blank\nP-S CAN-DOWN. /ETB;x;t;y;i;j/\n1ifi==j\n2 y\u0152i/c141D/ETB\u02ddx\u0152i/c141\n3else\n4 kDb.iCj/ =2c\n5 spawn P-S CAN-DOWN.\n ;x;t;y;i;k/ //\ufb01ll in the blank\n6P - S CAN-DOWN.\n ;x;t;y;kC1; j / //\ufb01ll in the blank\n7 sync\nd.Fill in the three missing expressions in line 8 of P-S CAN-UPand lines 5 and 6\nof P-S CAN-DOWN . Argue that with expressions you supplied, P-S CAN-3 is\ncorrect. ( Hint: Prove that the value /ETBpassed to P-S CAN-DOWN. /ETB;x;t;y;i;j/\nsatis\ufb01es /ETBDx\u01521/c141\u02ddx\u01522/c141\u02dd/SOH/SOH/SOH\u02dd x\u0152i/NUL1/c141.)\ne.Analyze the work, span, and parallelism of P-S CAN-3.\n27-5 Multithreading a simple stencil calculation\nComputational science is replete with algorithms that require the entries of an arrayto be \ufb01lled in with values that depend on the values of certain already computedneighboring entries, along with other information that does not change over thecourse of the computation. The pattern of neighboring entries does not changeduring the computation and is called a stencil . For example, Section 15.4 presents", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "830": {"page_number": 831, "page_information": "810 Chapter 27 Multithreaded Algorithms\na stencil algorithm to compute a longest common subsequence, where the value in\nentry c\u0152i;j/c141 depends only on the values in c\u0152i/NUL1; j /c141,c\u0152i;j/NUL1/c141,a n d c\u0152i/NUL1; j/NUL1/c141,\nas well as the elements xiandyjwithin the two sequences given as inputs. The\ninput sequences are \ufb01xed, but the algorithm \ufb01lls in the two-dimensional array cso\nthat it computes entry c\u0152i;j/c141 after computing all three entries c\u0152i/NUL1; j /c141,c\u0152i;j/NUL1/c141,\nandc\u0152i/NUL1; j/NUL1/c141.\nIn this problem, we examine how to use nested parallelism to multithread a\nsimple stencil calculation on an n/STXnarray Ain which, of the values in A,t h e\nvalue placed into entry A\u0152i; j /c141 depends only on values in A\u0152i0;j0/c141,w h e r e i0/DC4i\nandj0/DC4j(and of course, i0\u00a4iorj0\u00a4j). In other words, the value in an\nentry depends only on values in entries that are above it and/or to its left, alongwith static information outside of the array. Furthermore, we assume throughoutthis problem that once we have \ufb01lled in the entries upon which A\u0152i; j /c141 depends, we\ncan \ufb01ll in A\u0152i; j /c141 in\u201a.1/ time (as in the LCS-L\nENGTH procedure of Section 15.4).\nWe can partition the n/STXnarray Ainto four n=2/STXn=2subarrays as follows:\nAD/DC2A11A12\nA21A22/DC3\n: (27.11)\nObserve now that we can \ufb01ll in subarray A11recursively, since it does not depend\non the entries of the other three subarrays. Once A11is complete, we can continue\nto \ufb01ll in A12andA21recursively in parallel, because although they both depend\nonA11, they do not depend on each other. Finally, we can \ufb01ll in A22recursively.\na.Give multithreaded pseudocode that performs this simple stencil calculation\nusing a divide-and-conquer algorithm S IMPLE -STENCIL based on the decom-\nposition (27.11) and the discussion above. (Don\u2019t worry about the details of the\nbase case, which depends on the speci\ufb01c stencil.) Give and solve recurrencesfor the work and span of this algorithm in terms of n. What is the parallelism?\nb.Modify your solution to part (a) to divide an n/STXnarray into nine n=3/STXn=3\nsubarrays, again recursing with as much parallelism as possible. Analyze this\nalgorithm. How much more or less parallelism does this algorithm have com-\npared with the algorithm from part (a)?\nc.Generalize your solutions to parts (a) and (b) as follows. Choose an integer\nb/NAK2.D i v i d ea n n/STXnarray into b\n2subarrays, each of size n=b/STXn=b, recursing\nwith as much parallelism as possible. In terms of nandb, what are the work,\nspan, and parallelism of your algorithm? Argue that, using this approach, theparallelism must be o.n/ for any choice of b/NAK2.(Hint: For this last argument,\nshow that the exponent of nin the parallelism is strictly less than 1for any\nchoice of b/NAK2.)", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "831": {"page_number": 832, "page_information": "Notes for Chapter 27 811\nd.Give pseudocode for a multithreaded algorithm for this simple stencil calcu-\nlation that achieves \u201a.n= lgn/parallelism. Argue using notions of work and\nspan that the problem, in fact, has \u201a.n/ inherent parallelism. As it turns out,\nthe divide-and-conquer nature of our multithreaded pseudocode does not let usachieve this maximal parallelism.\n27-6 Randomized multithreaded algorithms\nJust as with ordinary serial algorithms, we sometimes want to implement random-\nized multithreaded algorithms. This problem explores how to adapt the variousperformance measures in order to handle the expected behavior of such algorithms.It also asks you to design and analyze a multithreaded algorithm for randomizedquicksort.\na.Explain how to modify the work law (27.2), span law (27.3), and greedy sched-\nuler bound (27.4) to work with expectations when T\nP,T1,a n d T1are all ran-\ndom variables.\nb.Consider a randomized multithreaded algorithm for which 1% of the time we\nhave T1D104andT10;000D1,b u tf o r 99%o ft h et i m ew eh a v e T1D\nT10;000D109. Argue that the speedup of a randomized multithreaded algo-\nrithm should be de\ufb01ned as E \u0152T1/c141=E\u0152TP/c141, rather than E \u0152T1=TP/c141.\nc.Argue that the parallelism of a randomized multithreaded algorithm should be\nde\ufb01ned as the ratio E \u0152T1/c141=E\u0152T1/c141.\nd.Multithread the R ANDOMIZED -QUICKSORT algorithm on page 179 by using\nnested parallelism. (Do not parallelize R ANDOMIZED -PARTITION .) Give the\npseudocode for your P-R ANDOMIZED -QUICKSORT algorithm.\ne.Analyze your multithreaded algorithm for randomized quicksort. ( Hint: Re-\nview the analysis of R ANDOMIZED -SELECT on page 216.)\nChapter notes\nParallel computers, models for parallel computers, and algorithmic models for par-\nallel programming have been around in various forms for years. Prior editions ofthis book included material on sorting networks and the PRAM (Parallel Random-Access Machine) model. The data-parallel model [48, 168] is another popular al-gorithmic programming model, which features operations on vectors and matricesas primitives.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "832": {"page_number": 833, "page_information": "812 Chapter 27 Multithreaded Algorithms\nGraham [149] and Brent [55] showed that there exist schedulers achieving the\nbound of Theorem 27.1. Eager, Zahorjan, and Lazowska [98] showed that anygreedy scheduler achieves this bound and proposed the methodology of using workand span (although not by those names) to analyze parallel algorithms. Blelloch[47] developed an algorithmic programming model based on work and span (whichhe called the \u201cdepth\u201d of the computation) for data-parallel programming. Blumofeand Leiserson [52] gave a distributed scheduling algorithm for dynamic multi-threading based on randomized \u201cwork-stealing\u201d and showed that it achieves the\nbound E \u0152T\nP/c141/DC4T1=PCO.T 1/. Arora, Blumofe, and Plaxton [19] and Blelloch,\nGibbons, and Matias [49] also provided provably good algorithms for schedulingdynamic multithreaded computations.\nThe multithreaded pseudocode and programming model were heavily in\ufb02uenced\nby the Cilk [51, 118] project at MIT and the Cilk++ [71] extensions to C++ dis-tributed by Cilk Arts, Inc. Many of the multithreaded algorithms in this chapterappeared in unpublished lecture notes by C. E. Leiserson and H. Prokop and havebeen implemented in Cilk or Cilk++. The multithreaded merge-sorting algorithmwas inspired by an algorithm of Akl [12].\nThe notion of sequential consistency is due to Lamport [223].", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "833": {"page_number": 834, "page_information": "28 Matrix Operations\nBecause operations on matrices lie at the heart of scienti\ufb01c computing, ef\ufb01cient al-\ngorithms for working with matrices have many practical applications. This chapterfocuses on how to multiply matrices and solve sets of simultaneous linear equa-tions. Appendix D reviews the basics of matrices.\nSection 28.1 shows how to solve a set of linear equations using LUP decomposi-\ntions. Then, Section 28.2 explores the close relationship between multiplying andinverting matrices. Finally, Section 28.3 discusses the important class of symmetricpositive-de\ufb01nite matrices and shows how we can use them to \ufb01nd a least-squaressolution to an overdetermined set of linear equations.\nOne important issue that arises in practice is numerical stability . Due to the\nlimited precision of \ufb02oating-point representations in actual computers, round-off\nerrors in numerical computations may become ampli\ufb01ed over the course of a com-putation, leading to incorrect results; we call such computations numerically un-\nstable . Although we shall brie\ufb02y consider numerical stability on occasion, we do\nnot focus on it in this chapter. We refer you to the excellent book by Golub and\nVan Loan [144] for a thorough discussion of stability issues.\n28.1 Solving systems of linear equations\nNumerous applications need to solve sets of simultaneous linear equations. Wecan formulate a linear system as a matrix equation in which each matrix or vectorelement belongs to a \ufb01eld, typically the real numbers R. This section discusses how\nto solve a system of linear equations using a method called LUP decomposition.\nWe start with a set of linear equations in nunknowns x\n1;x2;:::;x n:", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "834": {"page_number": 835, "page_information": "814 Chapter 28 Matrix Operations\na11x1Ca12x2C/SOH/SOH/SOHC a1nxnDb1;\na21x1Ca22x2C/SOH/SOH/SOHC a2nxnDb2;\n:::\nan1x1Can2x2C/SOH/SOH/SOHC annxnDbn:(28.1)\nAsolution to the equations (28.1) is a set of values for x1;x2;:::;x nthat satisfy\nall of the equations simultaneously. In this section, we treat only the case in whichthere are exactly nequations in nunknowns.\nWe can conveniently rewrite equations (28.1) as the matrix-vector equation\n\u02d9\na11a12/SOH/SOH/SOHa1n\na21a22/SOH/SOH/SOHa2n\n::::::::::::\na\nn1an2/SOH/SOH/SOHann/BEL\u02d9\nx1\nx2\n:::\nxn/BEL\nD\u02d9\nb1\nb2\n:::\nbn/BEL\nor, equivalently, letting AD.aij/,xD.xi/,a n d bD.bi/,a s\nAxDb: (28.2)\nIfAis nonsingular, it possesses an inverse A/NUL1,a n d\nxDA/NUL1b (28.3)\nis the solution vector. We can prove that xis the unique solution to equation (28.2)\nas follows. If there are two solutions, xandx0,t h e n AxDAx0Dband, letting I\ndenote an identity matrix,\nxDIx\nD.A/NUL1A/x\nDA/NUL1.Ax/\nDA/NUL1.Ax0/\nD.A/NUL1A/x0\nDx0:\nIn this section, we shall be concerned predominantly with the case in which A\nis nonsingular or, equivalently (by Theorem D.1), the rank of Ais equal to the\nnumber nof unknowns. There are other possibilities, however, which merit a brief\ndiscussion. If the number of equations is less than the number nof unknowns\u2014or,\nmore generally, if the rank of Ais less than n\u2014then the system is underdeter-\nmined . An underdetermined system typically has in\ufb01nitely many solutions, al-\nthough it may have no solutions at all if the equations are inconsistent. If thenumber of equations exceeds the number nof unknowns, the system is overdeter-\nmined , and there may not exist any solutions. Section 28.3 addresses the important", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "835": {"page_number": 836, "page_information": "28.1 Solving systems of linear equations 815\nproblem of \ufb01nding good approximate solutions to overdetermined systems of linear\nequations.\nLet us return to our problem of solving the system AxDbofnequations in n\nunknowns. We could compute A/NUL1and then, using equation (28.3), multiply b\nbyA/NUL1, yielding xDA/NUL1b. This approach suffers in practice from numerical\ninstability. Fortunately, another approach\u2014LUP decomposition\u2014is numericallystable and has the further advantage of being faster in practice.\nOverview of LUP decomposition\nThe idea behind LUP decomposition is to \ufb01nd three n/STXnmatrices L,U,a n d P\nsuch that\nPADLU ; (28.4)\nwhere\n/SILis a unit lower-triangular matrix,\n/SIUis an upper-triangular matrix, and\n/SIPis a permutation matrix.\nWe call matrices L,U,a n d Psatisfying equation (28.4) an LUP decomposition\nof the matrix A. We shall show that every nonsingular matrix Apossesses such a\ndecomposition.\nComputing an LUP decomposition for the matrix Ahas the advantage that we\ncan more easily solve linear systems when they are triangular, as is the case for\nboth matrices LandU. Once we have found an LUP decomposition for A,w e\ncan solve equation (28.2), AxDb, by solving only triangular linear systems, as\nfollows. Multiplying both sides of AxDbbyPyields the equivalent equation\nPAxDPb, which, by Exercise D.1-4, amounts to permuting the equations (28.1).\nUsing our decomposition (28.4), we obtain\nLUxDPb :\nWe can now solve this equation by solving two triangular linear systems. Let us\nde\ufb01ne yDUx,w h e r e xis the desired solution vector. First, we solve the lower-\ntriangular system\nLyDPb (28.5)\nfor the unknown vector yby a method called \u201cforward substitution.\u201d Having solved\nfory, we then solve the upper-triangular system\nUxDy (28.6)", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "836": {"page_number": 837, "page_information": "816 Chapter 28 Matrix Operations\nfor the unknown xby a method called \u201cback substitution.\u201d Because the permu-\ntation matrix Pis invertible (Exercise D.2-3), multiplying both sides of equa-\ntion (28.4) by P/NUL1gives P/NUL1PADP/NUL1LU,s ot h a t\nADP/NUL1LU : (28.7)\nHence, the vector xis our solution to AxDb:\nAxDP/NUL1LUx (by equation (28.7))\nDP/NUL1Ly (by equation (28.6))\nDP/NUL1Pb (by equation (28.5))\nDb:\nOur next step is to show how forward and back substitution work and then attack\nthe problem of computing the LUP decomposition itself.\nForward and back substitution\nForward substitution can solve the lower-triangular system (28.5) in \u201a.n2/time,\ngiven L,P,a n d b. For convenience, we represent the permutation Pcompactly\nby an array /EM\u0152 1::n /c141 .F o r iD1 ;2;:::;n , the entry /EM\u0152i/c141 indicates that Pi;/EM\u0152i/c141D1\nandPijD0forj\u00a4/EM\u0152i/c141. Thus, PAhasa/EM\u0152i/c141;j in row iand column j,a n d Pb\nhasb/EM\u0152i/c141as its ith element. Since Lis unit lower-triangular, we can rewrite equa-\ntion (28.5) as\ny1 Db/EM\u01521/c141;\nl21y1C y2 Db/EM\u01522/c141;\nl31y1Cl32y2C y3Db/EM\u01523/c141;\n:::\nln1y1Cln2y2Cln3y3C/SOH/SOH/SOHC ynDb/EM\u0152n/c141:\nThe \ufb01rst equation tells us that y1Db/EM\u01521/c141. Knowing the value of y1, we can\nsubstitute it into the second equation, yielding\ny2Db/EM\u01522/c141/NULl21y1:\nNow, we can substitute both y1andy2into the third equation, obtaining\ny3Db/EM\u01523/c141/NUL.l31y1Cl32y2/:\nIn general, we substitute y1;y2;:::;y i/NUL1\u201cforward\u201d into the ith equation to solve\nforyi:", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "837": {"page_number": 838, "page_information": "28.1 Solving systems of linear equations 817\nyiDb/EM\u0152i/c141/NULi/NUL1X\njD1lijyj:\nHaving solved for y,w es o l v ef o r xin equation (28.6) using back substitution ,\nwhich is similar to forward substitution. Here, we solve the nth equation \ufb01rst and\nwork backward to the \ufb01rst equation. Like forward substitution, this process runsin\u201a.n\n2/time. Since Uis upper-triangular, we can rewrite the system (28.6) as\nu11x1Cu12x2C/SOH/SOH/SOHC u1;n/NUL2xn/NUL2Cu1;n/NUL1xn/NUL1C u1nxnDy1;\nu22x2C/SOH/SOH/SOHC u2;n/NUL2xn/NUL2Cu2;n/NUL1xn/NUL1C u2nxnDy2;\n:::\nun/NUL2;n/NUL2xn/NUL2Cun/NUL2;n/NUL1xn/NUL1Cun/NUL2;nxnDyn/NUL2;\nun/NUL1;n/NUL1xn/NUL1Cun/NUL1;nxnDyn/NUL1;\nun;nxnDyn:\nThus, we can solve for xn;xn/NUL1;:::;x 1successively as follows:\nxnDyn=un;n;\nxn/NUL1D.yn/NUL1/NULun/NUL1;nxn/=u n/NUL1;n/NUL1;\nxn/NUL2D.yn/NUL2/NUL.un/NUL2;n/NUL1xn/NUL1Cun/NUL2;nxn//=u n/NUL2;n/NUL2;\n:::\nor, in general,\nxiD \nyi/NULnX\njDiC1uijxj!\n=uii:\nGiven P,L,U,a n d b, the procedure LUP-S OLVE solves for xby combining\nforward and back substitution. The pseudocode assumes that the dimension nap-\npears in the attribute L:rows and that the permutation matrix Pis represented by\nthe array /EM.\nLUP-S OLVE . L;U;/EM ;b/\n1nDL:rows\n2l e t xbe a new vector of length n\n3foriD1ton\n4 yiDb/EM\u0152i/c141/NULPi/NUL1\njD1lijyj\n5foriDndownto 1\n6 xiD/NUL\nyi/NULPn\njDiC1uijxj/SOH\n=uii\n7return x", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "838": {"page_number": 839, "page_information": "818 Chapter 28 Matrix Operations\nProcedure LUP-S OLVE solves for yusing forward substitution in lines 3\u20134, and\nthen it solves for xusing backward substitution in lines 5\u20136. Since the summation\nwithin each of the forloops includes an implicit loop, the running time is \u201a.n2/.\nAs an example of these methods, consider the system of linear equations de\ufb01ned\nby/NUL\n120344563/SOH\nxD/NUL\n3\n78/SOH\n;\nwhere\nAD/NUL\n120\n344563/SOH\n;\nbD/NUL\n3\n7\n8/SOH\n;\nand we wish to solve for the unknown x. The LUP decomposition is\nLD/NUL\n10 0\n0:2 1 00:6 0:5 1/SOH\n;\nUD/NUL\n56 3\n00 : 8/NUL0:6\n002 : 5/SOH\n;\nPD/NUL\n001\n100010/SOH\n:\n(You might want to verify that PADLU.) Using forward substitution, we solve\nLyDPbfory:/NUL\n10 0\n0:2 1 00:6 0:5 1/SOH/NUL\ny1\ny2\ny3/SOH\nD/NUL\n837/SOH\n;\nobtaining\nyD/NUL\n8\n1:4\n1:5/SOH\nby computing \ufb01rst y1,t h e n y2, and \ufb01nally y3. Using back substitution, we solve\nUxDyforx:", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "839": {"page_number": 840, "page_information": "28.1 Solving systems of linear equations 819\n/NUL\n56 3\n00 : 8/NUL0:6\n002 : 5/SOH/NUL\nx1\nx2\nx3/SOH\nD/NUL\n8\n1:41:5/SOH\n;\nthereby obtaining the desired answer\nxD/NUL\n/NUL1:4\n2:2\n0:6/SOH\nby computing \ufb01rst x3,t h e n x2, and \ufb01nally x1.\nComputing an LU decomposition\nWe have now shown that if we can create an LUP decomposition for a nonsingular\nmatrix A, then forward and back substitution can solve the system AxDbof\nlinear equations. Now we show how to ef\ufb01ciently compute an LUP decompositionforA. We start with the case in which Ais an n/STXnnonsingular matrix and Pis\nabsent (or, equivalently, PDI\nn). In this case, we factor ADLU. We call the\ntwo matrices LandUanLU decomposition ofA.\nWe use a process known as Gaussian elimination to create an LU decomposi-\ntion. We start by subtracting multiples of the \ufb01rst equation from the other equationsin order to remove the \ufb01rst variable from those equations. Then, we subtract mul-tiples of the second equation from the third and subsequent equations so that nowthe \ufb01rst and second variables are removed from them. We continue this processuntil the system that remains has an upper-triangular form\u2014in fact, it is the ma-\ntrixU. The matrix Lis made up of the row multipliers that cause variables to be\neliminated.\nOur algorithm to implement this strategy is recursive. We wish to construct an\nLU decomposition for an n/STXnnonsingular matrix A.I fnD1, then we are done,\nsince we can choose LDI\n1andUDA.F o r n>1 , we break Ainto four parts:\nAD\u02d9\na11\na12/SOH/SOH/SOHa1n\na21\na22/SOH/SOH/SOHa2n\n:::\n:::::::::\na\nn1\nan2/SOH/SOH/SOHann/BEL\nD/DC2a11wT\n/ETBA0/DC3\n;\nwhere /ETBis a column .n/NUL1/-vector, wTi sar o w .n/NUL1/-vector, and A0is an\n.n/NUL1//STX.n/NUL1/matrix. Then, using matrix algebra (verify the equations by", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "840": {"page_number": 841, "page_information": "820 Chapter 28 Matrix Operations\nsimply multiplying through), we can factor Aas\nAD/DC2a11wT\n/ETBA0/DC3\nD/DC210\n/ETB=a 11In/NUL1/DC3/DC2a11 wT\n0A0/NUL/ETBwT=a11/DC3\n: (28.8)\nThe0s in the \ufb01rst and second matrices of equation (28.8) are row and col-\numn .n/NUL1/-vectors, respectively. The term /ETBwT=a11,f o r m e db yt a k i n gt h e\nouter product of /ETBandwand dividing each element of the result by a11,i sa n\n.n/NUL1//STX.n/NUL1/matrix, which conforms in size to the matrix A0from which it is\nsubtracted. The resulting .n/NUL1//STX.n/NUL1/matrix\nA0/NUL/ETBwT=a11 (28.9)\nis called the Schur complement ofAwith respect to a11.\nWe claim that if Ais nonsingular, then the Schur complement is nonsingular,\ntoo. Why? Suppose that the Schur complement, which is .n/NUL1//STX.n/NUL1/,i s\nsingular. Then by Theorem D.1, it has row rank strictly less than n/NUL1. Because\nthe bottom n/NUL1entries in the \ufb01rst column of the matrix/DC2a11 wT\n0A0/NUL/ETBwT=a11/DC3\nare all 0, the bottom n/NUL1rows of this matrix must have row rank strictly less\nthann/NUL1. The row rank of the entire matrix, therefore, is strictly less than n.\nApplying Exercise D.2-8 to equation (28.8), Ahas rank strictly less than n,a n d\nfrom Theorem D.1 we derive the contradiction that Ais singular.\nBecause the Schur complement is nonsingular, we can now recursively \ufb01nd an\nLU decomposition for it. Let us say that\nA0/NUL/ETBwT=a11DL0U0;\nwhere L0is unit lower-triangular and U0is upper-triangular. Then, using matrix\nalgebra, we have\nAD/DC210\n/ETB=a 11In/NUL1/DC3/DC2a11 wT\n0A0/NUL/ETBwT=a11/DC3\nD/DC210\n/ETB=a 11In/NUL1/DC3/DC2a11 wT\n0L0U0/DC3\nD/DC210\n/ETB=a 11L0/DC3/DC2a11wT\n0U0/DC3\nDLU ;\nthereby providing our LU decomposition. (Note that because L0is unit lower-\ntriangular, so is L, and because U0is upper-triangular, so is U.)", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "841": {"page_number": 842, "page_information": "28.1 Solving systems of linear equations 821\nOf course, if a11D0, this method doesn\u2019t work, because it divides by 0.I ta l s o\ndoesn\u2019t work if the upper leftmost entry of the Schur complement A0/NUL/ETBwT=a11\nis0, since we divide by it in the next step of the recursion. The elements by\nwhich we divide during LU decomposition are called pivots , and they occupy the\ndiagonal elements of the matrix U. The reason we include a permutation matrix P\nduring LUP decomposition is that it allows us to avoid dividing by 0.W h e nw eu s e\npermutations to avoid division by 0(or by small numbers, which would contribute\nto numerical instability), we are pivoting .\nAn important class of matrices for which LU decomposition always works cor-\nrectly is the class of symmetric positive-de\ufb01nite matrices. Such matrices requireno pivoting, and thus we can employ the recursive strategy outlined above with-out fear of dividing by 0. We shall prove this result, as well as several others, in\nSection 28.3.\nOur code for LU decomposition of a matrix Afollows the recursive strategy, ex-\ncept that an iteration loop replaces the recursion. (This transformation is a standardoptimization for a \u201ctail-recursive\u201d procedure\u2014one whose last operation is a recur-sive call to itself. See Problem 7-4.) It assumes that the attribute A:rows gives\nthe dimension of A. We initialize the matrix Uwith 0s below the diagonal and\nmatrix Lwith1s on its diagonal and 0s above the diagonal.\nLU-D\nECOMPOSITION .A/\n1nDA:rows\n2l e t LandUbe new n/STXnmatrices\n3 initialize Uwith0s below the diagonal\n4 initialize Lwith1s on the diagonal and 0s above the diagonal\n5forkD1ton\n6 ukkDakk\n7 foriDkC1ton\n8 likDaik=ukk //likholds /ETBi\n9 ukiDaki //ukiholds wT\ni\n10 foriDkC1ton\n11 forjDkC1ton\n12 aijDaij/NULlikukj\n13return LandU\nThe outer forloop beginning in line 5 iterates once for each recursive step. Within\nthis loop, line 6 determines the pivot to be ukkDakk.T h e forloop in lines 7\u20139\n(which does not execute when kDn), uses the /ETBandwTvectors to update L\nandU. Line 8 determines the elements of the /ETBvector, storing /ETBiinlik, and line 9\ncomputes the elements of the wTvector, storing wT\niinuki. Finally, lines 10\u201312\ncompute the elements of the Schur complement and store them back into the ma-", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "842": {"page_number": 843, "page_information": "822 Chapter 28 Matrix Operations\n2315\n61 351 92 1 91 02 34 1 01 13 1\n(a)315\n342411 691 8249 2 1\n(b)231532 41412217 1 7\n(c)2315342414 22173\n(d)\n(e)2\n4\n1\n/EOT\n2 315\n61 3 5 1 9\n21 91 02 3\n41 01 13 1\u02d8\nD/EOT\n1000\n3100\n1410\n2171\u02d8/EOT\n2315\n0424\n0012\n0003\u02d8\nAL U\nFigure 28.1 The operation of LU-D ECOMPOSITION .(a)The matrix A.(b)The element a11D2\nin the black circle is the pivot, the shaded column is /ETB=a11, and the shaded row is wT. The elements\nofUcomputed thus far are above the horizontal line, and the elements of Lare to the left of the\nvertical line. The Schur complement matrix A0/NUL/ETBwT=a11occupies the lower right. (c)We now\noperate on the Schur complement matrix produced from part (b). The element a22D4in the black\ncircle is the pivot, and the shaded column and row are /ETB=a22andwT(in the partitioning of the Schur\ncomplement), respectively. Lines divide the matrix into the elements of Ucomputed so far (above),\nthe elements of Lcomputed so far (left), and the new Schur complement (lower right). (d)After the\nnext step, the matrix Ais factored. (The element 3in the new Schur complement becomes part of U\nwhen the recursion terminates.) (e)The factorization ADLU.\ntrixA. (We don\u2019t need to divide by akkin line 12 because we already did so when\nwe computed likin line 8.) Because line 12 is triply nested, LU-D ECOMPOSITION\nruns in time \u201a.n3/.\nFigure 28.1 illustrates the operation of LU-D ECOMPOSITION . It shows a stan-\ndard optimization of the procedure in which we store the signi\ufb01cant elements of L\nandUin place in the matrix A. That is, we can set up a correspondence between\neach element aijand either lij(ifi>j )o ruij(ifi/DC4j) and update the ma-\ntrixAso that it holds both LandUwhen the procedure terminates. To obtain\nthe pseudocode for this optimization from the above pseudocode, just replace each\nreference to lorubya; you can easily verify that this transformation preserves\ncorrectness.\nComputing an LUP decomposition\nGenerally, in solving a system of linear equations AxDb, we must pivot on off-\ndiagonal elements of Ato avoid dividing by 0. Dividing by 0would, of course,\nbe disastrous. But we also want to avoid dividing by a small value\u2014even if Ais", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "843": {"page_number": 844, "page_information": "28.1 Solving systems of linear equations 823\nnonsingular\u2014because numerical instabilities can result. We therefore try to pivot\non a large value.\nThe mathematics behind LUP decomposition is similar to that of LU decom-\nposition. Recall that we are given an n/STXnnonsingular matrix A, and we wish\nto \ufb01nd a permutation matrix P, a unit lower-triangular matrix L, and an upper-\ntriangular matrix Usuch that PADLU. Before we partition the matrix A,a sw e\ndid for LU decomposition, we move a nonzero element, say ak1, from somewhere\nin the \ufb01rst column to the .1; 1/ position of the matrix. For numerical stability, we\nchoose ak1as the element in the \ufb01rst column with the greatest absolute value. (The\n\ufb01rst column cannot contain only 0s, for then Awould be singular, because its de-\nterminant would be 0, by Theorems D.4 and D.5.) In order to preserve the set of\nequations, we exchange row 1with row k, which is equivalent to multiplying Aby\na permutation matrix Qon the left (Exercise D.1-4). Thus, we can write QAas\nQAD/DC2ak1wT\n/ETBA0/DC3\n;\nwhere /ETBD.a21;a31;:::;a n1/T, except that a11replaces ak1;wTD.ak2;ak3;\n:::;a kn/;a n d A0is an.n/NUL1//STX.n/NUL1/matrix. Since ak1\u00a40, we can now perform\nmuch the same linear algebra as for LU decomposition, but now guaranteeing thatwe do not divide by 0:\nQAD/DC2a\nk1wT\n/ETBA0/DC3\nD/DC210\n/ETB=a k1In/NUL1/DC3/DC2ak1 wT\n0A0/NUL/ETBwT=ak1/DC3\n:\nAs we saw for LU decomposition, if Ais nonsingular, then the Schur comple-\nment A0/NUL/ETBwT=ak1is nonsingular, too. Therefore, we can recursively \ufb01nd an\nLUP decomposition for it, with unit lower-triangular matrix L0, upper-triangular\nmatrix U0, and permutation matrix P0, such that\nP0.A0/NUL/ETBwT=ak1/DL0U0:\nDe\ufb01ne\nPD/DC210\n0P0/DC3\nQ;\nwhich is a permutation matrix, since it is the product of two permutation matrices\n(Exercise D.1-4). We now have", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "844": {"page_number": 845, "page_information": "824 Chapter 28 Matrix Operations\nPAD/DC210\n0P0/DC3\nQA\nD/DC210\n0P0/DC3/DC210\n/ETB=a k1In/NUL1/DC3/DC2ak1 wT\n0A0/NUL/ETBwT=ak1/DC3\nD/DC210\nP0/ETB=a k1P0/DC3/DC2ak1 wT\n0A0/NUL/ETBwT=ak1/DC3\nD/DC210\nP0/ETB=a k1In/NUL1/DC3/DC2ak1 wT\n0P0.A0/NUL/ETBwT=ak1//DC3\nD/DC210\nP0/ETB=a k1In/NUL1/DC3/DC2ak1 wT\n0L0U0/DC3\nD/DC210\nP0/ETB=a k1L0/DC3/DC2ak1wT\n0U0/DC3\nDLU ;\nyielding the LUP decomposition. Because L0is unit lower-triangular, so is L,a n d\nbecause U0is upper-triangular, so is U.\nNotice that in this derivation, unlike the one for LU decomposition, we must\nmultiply both the column vector /ETB=a k1and the Schur complement A0/NUL/ETBwT=ak1\nby the permutation matrix P0. Here is the pseudocode for LUP decomposition:\nLUP-D ECOMPOSITION .A/\n1nDA:rows\n2l e t /EM\u0152 1::n /c141 be a new array\n3foriD1ton\n4 /EM\u0152i/c141Di\n5forkD1ton\n6 pD0\n7 foriDkton\n8 ifjaikj>p\n9 pDjaikj\n10 k0Di\n11 ifp==0\n12 error \u201csingular matrix\u201d\n13 exchange /EM\u0152k/c141 with/EM\u0152k0/c141\n14 foriD1ton\n15 exchange akiwithak0i\n16 foriDkC1ton\n17 aikDaik=akk\n18 forjDkC1ton\n19 aijDaij/NULaikakj", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "845": {"page_number": 846, "page_information": "28.1 Solving systems of linear equations 825\nLike LU-D ECOMPOSITION , our LUP-D ECOMPOSITION procedure replaces\nthe recursion with an iteration loop. As an improvement over a direct implemen-tation of the recursion, we dynamically maintain the permutation matrix Pas an\narray /EM,w h e r e /EM\u0152i/c141Djmeans that the ith row of Pcontains a 1in column j.\nWe also implement the code to compute LandU\u201cin place\u201d in the matrix A. Thus,\nwhen the procedure terminates,\na\nijD(\nlijifi>j;\nuijifi/DC4j:\nFigure 28.2 illustrates how LUP-D ECOMPOSITION factors a matrix. Lines 3\u20134\ninitialize the array /EMto represent the identity permutation. The outer forloop\nbeginning in line 5 implements the recursion. Each time through the outer loop,\nlines 6\u201310 determine the element ak0kwith largest absolute value of those in the\ncurrent \ufb01rst column (column k)o ft h e .n/NULkC1//STX.n/NULkC1/matrix whose\nLUP decomposition we are \ufb01nding. If all elements in the current \ufb01rst column arezero, lines 11\u201312 report that the matrix is singular. To pivot, we exchange /EM\u0152k\n0/c141\nwith /EM\u0152k/c141 in line 13 and exchange the kth and k0th rows of Ain lines 14\u201315,\nthereby making the pivot element akk. (The entire rows are swapped because in\nthe derivation of the method above, not only is A0/NUL/ETBwT=ak1multiplied by P0,b u t\nso is /ETB=a k1.) Finally, the Schur complement is computed by lines 16\u201319 in much\nthe same way as it is computed by lines 7\u201312 of LU-D ECOMPOSITION , except that\nhere the operation is written to work in place.\nBecause of its triply nested loop structure, LUP-D ECOMPOSITION has a run-\nning time of \u201a.n3/, which is the same as that of LU-D ECOMPOSITION . Thus,\npivoting costs us at most a constant factor in time.\nExercises\n28.1-1\nSolve the equation/NUL\n100410\n/NUL651/SOH/NUL\nx1\nx2\nx3/SOH\nD/NUL\n3\n14\n/NUL7/SOH\nby using forward substitution.\n28.1-2\nFind an LU decomposition of the matrix/NUL\n4/NUL56\n8/NUL67\n12/NUL71 2/SOH\n:", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "846": {"page_number": 847, "page_information": "826 Chapter 28 Matrix Operations\n2 0 2 0.6\n334 \u2013 2\n5 542\n\u20131 \u20132 3.4 \u20131\n(a)1\n234\n2 0 2 0.6334 \u2013 25 542\n\u20131 \u20132 3.4 \u20131\n(b)3\n214\n0.4 \u20132 0.4 \u2013.20.6 0 1.6 \u20133.25 542\n\u20130.2 \u20131 4.2 \u20130.6\n(c)3\n214\n0.4 \u20132 0.4 \u20130.20.6 0 1.6 \u20133.25542\n\u20130.2 \u20131 4.2 \u20130.6\n(d)3\n2140.4 \u20132 0.4 \u20130.2\n0.6 0 1.6 \u20133.25542\n\u20130.2 \u20131 4.2 \u20130.6\n(e)3\n21\n40.4 \u20132 0.4 \u20130.2\n0.6 0 1.6 \u20133.25542\n\u20130.2 0.5 4 \u20130.5\n(f)3\n21\n4\n0.4 \u20132 0.4 \u20130.2\n0.6 0 1.6 \u20133.25542\n\u20130.2 0.5 4\u20130.5\n(g)3\n21\n40.4 \u20132 0.4 \u20130.20.6 0 1.6 \u20133.25542\n\u20130.2 0.5\n4\u20130.5\n(h)3\n21\n40.4 \u20132 0.4 \u20130.2\n0.6 0 0.4 \u201335542\n\u20130.2 0.5 4\u20130.5\n(i)3\n21\n4\n(j)/EOT\n0010\n10000001\n0100\u02d8/EOT\n202 0 : 6\n334/NUL2\n5542\n/NUL1/NUL23 : 4/NUL1\u02d8\nD/EOT\n10 0 0\n0:4 1 0 0\n/NUL0:2 0:5 1 0\n0:6 0 0:4 1\u02d8/EOT\n55 4 2\n0/NUL20 : 4/NUL0:2\n00 4/NUL0:5\n00 0/NUL3\u02d8\nPA L U\nFigure 28.2 The operation of LUP-D ECOMPOSITION .(a)The input matrix Awith the identity\npermutation of the rows on the left. The \ufb01rst step of the algorithm determines that the element 5\nin the black circle in the third row is the pivot for the \ufb01rst column. (b)Rows 1and3are swapped\nand the permutation is updated. The shaded column and row represent /ETBandwT.(c)The vector /ETB\nis replaced by /ETB=5, and the lower right of the matrix is updated with the Schur complement. Lines\ndivide the matrix into three regions: elements of U(above), elements of L(left), and elements of the\nSchur complement (lower right). (d)\u2013(f) The second step. (g)\u2013(i) The third step. No further changes\noccur on the fourth (\ufb01nal) step. (j)The LUP decomposition PADLU.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "847": {"page_number": 848, "page_information": "28.2 Inverting matrices 827\n28.1-3\nSolve the equation/NUL\n154203\n582/SOH/NUL\nx1\nx2\nx3/SOH\nD/NUL\n12\n9\n5/SOH\nby using an LUP decomposition.\n28.1-4\nDescribe the LUP decomposition of a diagonal matrix.\n28.1-5\nDescribe the LUP decomposition of a permutation matrix A, and prove that it is\nunique.\n28.1-6\nShow that for all n/NAK1, there exists a singular n/STXnmatrix that has an LU decom-\nposition.\n28.1-7\nIn LU-D ECOMPOSITION , is it necessary to perform the outermost forloop itera-\ntion when kDn? How about in LUP-D ECOMPOSITION ?\n28.2 Inverting matrices\nAlthough in practice we do not generally use matrix inverses to solve systems of\nlinear equations, preferring instead to use more numerically stable techniques suchas LUP decomposition, sometimes we need to compute a matrix inverse. In thissection, we show how to use LUP decomposition to compute a matrix inverse.We also prove that matrix multiplication and computing the inverse of a matrix\nare equivalently hard problems, in that (subject to technical conditions) we can\nuse an algorithm for one to solve the other in the same asymptotic running time.Thus, we can use Strassen\u2019s algorithm (see Section 4.2) for matrix multiplicationto invert a matrix. Indeed, Strassen\u2019s original paper was motivated by the problemof showing that a set of a linear equations could be solved more quickly than bythe usual method.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "848": {"page_number": 849, "page_information": "828 Chapter 28 Matrix Operations\nComputing a matrix inverse from an LUP decomposition\nSuppose that we have an LUP decomposition of a matrix Ain the form of three\nmatrices L,U,a n d Psuch that PADLU. Using LUP-S OLVE , we can solve\nan equation of the form AxDbin time \u201a.n2/. Since the LUP decomposition\ndepends on Abut not b, we can run LUP-S OLVE on a second set of equations of\nthe form AxDb0in additional time \u201a.n2/. In general, once we have the LUP\ndecomposition of A, we can solve, in time \u201a.kn2/,kversions of the equation\nAxDbthat differ only in b.\nWe can think of the equation\nAXDIn; (28.10)\nwhich de\ufb01nes the matrix X, the inverse of A, as a set of ndistinct equations of the\nform AxDb. To be precise, let Xidenote the ith column of X, and recall that the\nunit vector eiis the ith column of In. We can then solve equation (28.10) for Xby\nusing the LUP decomposition for Ato solve each equation\nAX iDei\nseparately for Xi. Once we have the LUP decomposition, we can compute each of\nthencolumns Xiin time \u201a.n2/, and so we can compute Xfrom the LUP decom-\nposition of Ain time \u201a.n3/. Since we can determine the LUP decomposition of A\nin time \u201a.n3/, we can compute the inverse A/NUL1of a matrix Ain time \u201a.n3/.\nMatrix multiplication and matrix inversion\nWe now show that the theoretical speedups obtained for matrix multiplication\ntranslate to speedups for matrix inversion. In fact, we prove something stronger:matrix inversion is equivalent to matrix multiplication, in the following sense.IfM.n/ denotes the time to multiply two n/STXnmatrices, then we can invert a\nnonsingular n/STXnmatrix in time O.M.n// . Moreover, if I.n/ denotes the time\nto invert a nonsingular n/STXnmatrix, then we can multiply two n/STXnmatrices in\ntimeO.I.n// . We prove these results as two separate theorems.\nTheorem 28.1 (Multiplication is no harder than inversion)\nIf we can invert an n/STXnmatrix in time I.n/,w h e r e I.n/D/DEL.n\n2/andI.n/\nsatis\ufb01es the regularity condition I.3n/DO.I.n// , then we can multiply two n/STXn\nmatrices in time O.I.n// .\nProof LetAandBben/STXnmatrices whose matrix product Cwe wish to com-\npute. We de\ufb01ne the 3n/STX3nmatrix Dby", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "849": {"page_number": 850, "page_information": "28.2 Inverting matrices 829\nDD/NUL\nInA0\n0I nB\n00 I n/SOH\n:\nThe inverse of Dis\nD/NUL1D/NUL\nIn/NULAA B\n0I n/NULB\n00I n/SOH\n;\nand thus we can compute the product ABby taking the upper right n/STXnsubmatrix\nofD/NUL1.\nWe can construct matrix Din\u201a.n2/time, which is O.I.n// because we assume\nthatI.n/D/DEL.n2/, and we can invert DinO.I.3n//DO.I.n// time, by the\nregularity condition on I.n/. We thus have M.n/DO.I.n// .\nNote that I.n/ satis\ufb01es the regularity condition whenever I.n/D\u201a.nclgdn/\nfor any constants c>0 andd/NAK0.\nThe proof that matrix inversion is no harder than matrix multiplication relies\non some properties of symmetric positive-de\ufb01nite matrices that we will prove inSection 28.3.\nTheorem 28.2 (Inversion is no harder than multiplication)\nSuppose we can multiply two n/STXnreal matrices in time M.n/ ,w h e r e M.n/D\n/DEL.n\n2/andM.n/ satis\ufb01es the two regularity conditions M.nCk/DO.M.n// for\nanykin the range 0/DC4k/DC4nandM.n=2//DC4cM.n/ for some constant c<1 = 2 .\nThen we can compute the inverse of any real nonsingular n/STXnmatrix in time\nO.M.n// .\nProof We prove the theorem here for real matrices. Exercise 28.2-6 asks you to\ngeneralize the proof for matrices whose entries are complex numbers.\nWe can assume that nis an exact power of 2,s i n c ew eh a v e\n/DC2A0\n0I k/DC3/NUL1\nD/DC2A/NUL10\n0I k/DC3\nfor any k>0 . Thus, by choosing ksuch that nCkis a power of 2, we enlarge\nthe matrix to a size that is the next power of 2 and obtain the desired answer A/NUL1\nfrom the answer to the enlarged problem. The \ufb01rst regularity condition on M.n/\nensures that this enlargement does not cause the running time to increase by more\nthan a constant factor.\nFor the moment, let us assume that the n/STXnmatrix Ais symmetric and positive-\nde\ufb01nite. We partition each of Aand its inverse A/NUL1into four n=2/STXn=2submatri-\nces:", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "850": {"page_number": 851, "page_information": "830 Chapter 28 Matrix Operations\nAD/DC2BCT\nCD/DC3\nand A/NUL1D/DC2RT\nUV/DC3\n: (28.11)\nThen, if we let\nSDD/NULCB/NUL1CT(28.12)\nbe the Schur complement of Awith respect to B(we shall see more about this form\nof Schur complement in Section 28.3), we have\nA/NUL1D/DC2RT\nUV/DC3\nD/DC2B/NUL1CB/NUL1CTS/NUL1CB/NUL1/NULB/NUL1CTS/NUL1\n/NULS/NUL1CB/NUL1S/NUL1/DC3\n; (28.13)\nsince AA/NUL1DIn, as you can verify by performing the matrix multiplication. Be-\ncause Ais symmetric and positive-de\ufb01nite, Lemmas 28.4 and 28.5 in Section 28.3\nimply that BandSare both symmetric and positive-de\ufb01nite. By Lemma 28.3 in\nSection 28.3, therefore, the inverses B/NUL1andS/NUL1exist, and by Exercise D.2-6,\nB/NUL1andS/NUL1are symmetric, so that .B/NUL1/TDB/NUL1and.S/NUL1/TDS/NUL1.T h e r e -\nfore, we can compute the submatrices R,T,U,a n d VofA/NUL1as follows, where\nall matrices mentioned are n=2/STXn=2:\n1. Form the submatrices B,C,CT,a n d DofA.\n2. Recursively compute the inverse B/NUL1ofB.\n3. Compute the matrix product WDCB/NUL1, and then compute its transpose WT,\nwhich equals B/NUL1CT(by Exercise D.1-2 and .B/NUL1/TDB/NUL1).\n4. Compute the matrix product XDWCT, which equals CB/NUL1CT,a n dt h e n\ncompute the matrix SDD/NULXDD/NULCB/NUL1CT.\n5. Recursively compute the inverse S/NUL1ofS, and set VtoS/NUL1.\n6. Compute the matrix product YDS/NUL1W, which equals S/NUL1CB/NUL1,a n d\nthen compute its transpose YT, which equals B/NUL1CTS/NUL1(by Exercise D.1-2,\n.B/NUL1/TDB/NUL1,a n d .S/NUL1/TDS/NUL1). Set Tto/NULYTandUto/NULY.\n7. Compute the matrix product ZDWTY, which equals B/NUL1CTS/NUL1CB/NUL1,a n d\nsetRtoB/NUL1CZ.\nThus, we can invert an n/STXnsymmetric positive-de\ufb01nite matrix by inverting two\nn=2/STXn=2matrices in steps 2 and 5; performing four multiplications of n=2/STXn=2\nmatrices in steps 3, 4, 6, and 7; plus an additional cost of O.n2/for extracting\nsubmatrices from A, inserting submatrices into A/NUL1, and performing a constant\nnumber of additions, subtractions, and transposes on n=2/STXn=2matrices. We get\nthe recurrence\nI.n//DC42I.n=2/C4M.n=2/CO.n2/\nD2I.n=2/C\u201a.M.n//\nDO.M.n// :", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "851": {"page_number": 852, "page_information": "28.2 Inverting matrices 831\nThe second line holds because the second regularity condition in the statement\nof the theorem implies that 4M.n=2/ < 2M.n/ and because we assume that\nM.n/D/DEL.n2/. The third line follows because the second regularity condition\nallows us to apply case 3 of the master theorem (Theorem 4.1).\nIt remains to prove that we can obtain the same asymptotic running time for ma-\ntrix multiplication as for matrix inversion when Ais invertible but not symmetric\nand positive-de\ufb01nite. The basic idea is that for any nonsingular matrix A,t h em a -\ntrixATAis symmetric (by Exercise D.1-2) and positive-de\ufb01nite (by Theorem D.6).\nThe trick, then, is to reduce the problem of inverting Ato the problem of invert-\ningATA.\nThe reduction is based on the observation that when Ais an n/STXnnonsingular\nmatrix, we have\nA/NUL1D.ATA//NUL1AT;\nsince ..ATA//NUL1AT/AD.ATA//NUL1.ATA/DInand a matrix inverse is unique.\nTherefore, we can compute A/NUL1by \ufb01rst multiplying ATbyAto obtain ATA,t h e n\ninverting the symmetric positive-de\ufb01nite matrix ATAusing the above divide-and-\nconquer algorithm, and \ufb01nally multiplying the result by AT. Each of these three\nsteps takes O.M.n// time, and thus we can invert any nonsingular matrix with real\nentries in O.M.n// time.\nThe proof of Theorem 28.2 suggests a means of solving the equation AxDb\nby using LU decomposition without pivoting, so long as Ais nonsingular. We\nmultiply both sides of the equation by AT, yielding .ATA/xDATb. This trans-\nformation doesn\u2019t affect the solution x,s i n c e ATis invertible, and so we can fac-\ntor the symmetric positive-de\ufb01nite matrix ATAby computing an LU decomposi-\ntion. We then use forward and back substitution to solve for xwith the right-hand\nsideATb. Although this method is theoretically correct, in practice the procedure\nLUP-D ECOMPOSITION works much better. LUP decomposition requires fewer\narithmetic operations by a constant factor, and it has somewhat better numerical\nproperties.\nExercises\n28.2-1\nLetM.n/ be the time to multiply two n/STXnmatrices, and let S.n/ denote the time\nrequired to square an n/STXnmatrix. Show that multiplying and squaring matri-\nces have essentially the same dif\ufb01culty: an M.n/ -time matrix-multiplication al-\ngorithm implies an O.M.n// -time squaring algorithm, and an S.n/ -time squaring\nalgorithm implies an O.S.n// -time matrix-multiplication algorithm.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "852": {"page_number": 853, "page_information": "832 Chapter 28 Matrix Operations\n28.2-2\nLetM.n/ be the time to multiply two n/STXnmatrices, and let L.n/ be the time to\ncompute the LUP decomposition of an n/STXnmatrix. Show that multiplying matri-\nces and computing LUP decompositions of matrices have essentially the same dif-\ufb01culty: an M.n/ -time matrix-multiplication algorithm implies an O.M.n// -time\nLUP-decomposition algorithm, and an L.n/ -time LUP-decomposition algorithm\nimplies an O.L.n// -time matrix-multiplication algorithm.\n28.2-3\nLetM.n/ be the time to multiply two n/STXnmatrices, and let D.n/ denote the\ntime required to \ufb01nd the determinant of an n/STXnmatrix. Show that multiply-\ning matrices and computing the determinant have essentially the same dif\ufb01culty:anM.n/ -time matrix-multiplication algorithm implies an O.M.n// -time determi-\nnant algorithm, and a D.n/ -time determinant algorithm implies an O.D.n// -time\nmatrix-multiplication algorithm.\n28.2-4\nLetM.n/ be the time to multiply two n/STXnboolean matrices, and let T .n/ be the\ntime to \ufb01nd the transitive closure of an n/STXnboolean matrix. (See Section 25.2.)\nShow that an M.n/ -time boolean matrix-multiplication algorithm implies an\nO.M.n/ lgn/-time transitive-closure algorithm, and a T .n/ -time transitive-closure\nalgorithm implies an O.T .n// -time boolean matrix-multiplication algorithm.\n28.2-5\nDoes the matrix-inversion algorithm based on Theorem 28.2 work when matrixelements are drawn from the \ufb01eld of integers modulo 2? Explain.\n28.2-6 ?\nGeneralize the matrix-inversion algorithm of Theorem 28.2 to handle matrices ofcomplex numbers, and prove that your generalization works correctly. ( Hint: In-\nstead of the transpose of A,u s et h e conjugate transpose A\n/ETX, which you obtain from\nthe transpose of Aby replacing every entry with its complex conjugate. Instead of\nsymmetric matrices, consider Hermitian matrices, which are matrices Asuch that\nADA/ETX.)\n28.3 Symmetric positive-de\ufb01nite matrices and least-squares approximation\nSymmetric positive-de\ufb01nite matrices have many interesting and desirable proper-\nties. For example, they are nonsingular, and we can perform LU decompositionon them without having to worry about dividing by 0. In this section, we shall", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "853": {"page_number": 854, "page_information": "28.3 Symmetric positive-de\ufb01nite matrices and least-squares approximation 833\nprove several other important properties of symmetric positive-de\ufb01nite matrices\nand show an interesting application to curve \ufb01tting by a least-squares approxima-tion.\nThe \ufb01rst property we prove is perhaps the most basic.\nLemma 28.3\nAny positive-de\ufb01nite matrix is nonsingular.\nProof Suppose that a matrix Ais singular. Then by Corollary D.3, there exists a\nnonzero vector xsuch that AxD0. Hence, x\nTAxD0,a n d Acannot be positive-\nde\ufb01nite.\nThe proof that we can perform LU decomposition on a symmetric positive-\nde\ufb01nite matrix Awithout dividing by 0is more involved. We begin by proving\nproperties about certain submatrices of A.D e \ufb01 n et h e kthleading submatrix ofA\nto be the matrix Akconsisting of the intersection of the \ufb01rst krows and \ufb01rst k\ncolumns of A.\nLemma 28.4\nIfAis a symmetric positive-de\ufb01nite matrix, then every leading submatrix of Ais\nsymmetric and positive-de\ufb01nite.\nProof That each leading submatrix Akis symmetric is obvious. To prove that Ak\nis positive-de\ufb01nite, we assume that it is not and derive a contradiction. If Akis not\npositive-de\ufb01nite, then there exists a k-vector xk\u00a40such that xT\nkAkxk/DC40.L e t A\nben/STXn,a n d\nAD/DC2AkBT\nBC/DC3\n(28.14)\nfor submatrices B(which is .n/NULk//STXk)a n d C(which is .n/NULk//STX.n/NULk/). De\ufb01ne\nthen-vector xD.xT\nk0/T,w h e r e n/NULk0s follow xk.T h e nw eh a v e\nxTAxD.xT\nk0//DC2AkBT\nBC/DC3/DC2xk\n0/DC3\nD.xT\nk0//DC2Akxk\nBxk/DC3\nDxT\nkAkxk\n/DC40;\nwhich contradicts Abeing positive-de\ufb01nite.\n", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "854": {"page_number": 855, "page_information": "834 Chapter 28 Matrix Operations\nWe now turn to some essential properties of the Schur complement. Let Abe\na symmetric positive-de\ufb01nite matrix, and let Akb eal e a d i n g k/STXksubmatrix\nofA. Partition Aonce again according to equation (28.14). We generalize equa-\ntion (28.9) to de\ufb01ne the Schur complement SofAwith respect to Akas\nSDC/NULBA/NUL1\nkBT: (28.15)\n(By Lemma 28.4, Akis symmetric and positive-de\ufb01nite; therefore, A/NUL1\nkexists by\nLemma 28.3, and Sis well de\ufb01ned.) Note that our earlier de\ufb01nition (28.9) of the\nSchur complement is consistent with equation (28.15), by letting kD1.\nThe next lemma shows that the Schur-complement matrices of symmetric posi-\ntive-de\ufb01nite matrices are themselves symmetric and positive-de\ufb01nite. We used thisresult in Theorem 28.2, and we need its corollary to prove the correctness of LUdecomposition for symmetric positive-de\ufb01nite matrices.\nLemma 28.5 (Schur complement lemma)\nIfAis a symmetric positive-de\ufb01nite matrix and A\nkis a leading k/STXksubmatrix\nofA, then the Schur complement SofAwith respect to Akis symmetric and\npositive-de\ufb01nite.\nProof Because Ais symmetric, so is the submatrix C. By Exercise D.2-6, the\nproduct BA/NUL1\nkBTis symmetric, and by Exercise D.1-1, Sis symmetric.\nIt remains to show that Sis positive-de\ufb01nite. Consider the partition of Agiven in\nequation (28.14). For any nonzero vector x,w eh a v e xTAx > 0 by the assumption\nthatAis positive-de\ufb01nite. Let us break xinto two subvectors yand\u00b4compatible\nwithAkandC, respectively. Because A/NUL1\nkexists, we have\nxTAxD.yT\u00b4T//DC2AkBT\nBC/DC3/DC2y\n\u00b4/DC3\nD.yT\u00b4T//DC2AkyCBT\u00b4\nByCC\u00b4/DC3\nDyTAkyCyTBT\u00b4C\u00b4TByC\u00b4TC\u00b4\nD.yCA/NUL1\nkBT\u00b4/TAk.yCA/NUL1\nkBT\u00b4/C\u00b4T.C/NULBA/NUL1\nkBT/\u00b4 ; (28.16)\nby matrix magic. (Verify by multiplying through.) This last equation amounts to\n\u201ccompleting the square\u201d of the quadratic form. (See Exercise 28.3-2.)\nSince xTAx > 0 holds for any nonzero x, let us pick any nonzero \u00b4and then\nchoose yD/NULA/NUL1\nkBT\u00b4, which causes the \ufb01rst term in equation (28.16) to vanish,\nleaving\n\u00b4T.C/NULBA/NUL1\nkBT/\u00b4D\u00b4TS\u00b4\nas the value of the expression. For any \u00b4\u00a40, we therefore have \u00b4TS\u00b4D\nxTAx > 0 , and thus Sis positive-de\ufb01nite.\n", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "855": {"page_number": 856, "page_information": "28.3 Symmetric positive-de\ufb01nite matrices and least-squares approximation 835\nCorollary 28.6\nLU decomposition of a symmetric positive-de\ufb01nite matrix never causes a divisionby0.\nProof LetAbe a symmetric positive-de\ufb01nite matrix. We shall prove something\nstronger than the statement of the corollary: every pivot is strictly positive. The \ufb01rstpivot is a\n11.L e te1be the \ufb01rst unit vector, from which we obtain a11DeT\n1Ae1>0.\nSince the \ufb01rst step of LU decomposition produces the Schur complement of A\nwith respect to A1D.a11/, Lemma 28.5 implies by induction that all pivots are\npositive.\nLeast-squares approximation\nOne important application of symmetric positive-de\ufb01nite matrices arises in \ufb01tting\ncurves to given sets of data points. Suppose that we are given a set of mdata points\n.x1;y1/; .x 2;y2/ ;:::;. x m;ym/;\nwhere we know that the yiare subject to measurement errors. We would like to\ndetermine a function F.x/ such that the approximation errors\n/DC1iDF.x i//NULyi (28.17)\nare small for iD1 ;2;:::;m . The form of the function Fdepends on the problem\nat hand. Here, we assume that it has the form of a linearly weighted sum,\nF.x/DnX\njD1cjfj.x/ ;\nwhere the number of summands nand the speci\ufb01c basis functions fjare chosen\nbased on knowledge of the problem at hand. A common choice is fj.x/Dxj/NUL1,\nwhich means that\nF.x/Dc1Cc2xCc3x2C/SOH/SOH/SOHC cnxn/NUL1\nis a polynomial of degree n/NUL1inx. Thus, given mdata points .x1;y1/; .x 2;y2/;\n:::;. x m;ym/, we wish to calculate ncoef\ufb01cients c1;c2;:::;c nthat minimize the\napproximation errors /DC11;/DC12;:::;/DC1 m.\nBy choosing nDm, we can calculate each yiexactly in equation (28.17). Such\na high-degree F\u201c\ufb01ts the noise\u201d as well as the data, however, and generally gives\npoor results when used to predict yfor previously unseen values of x.I t i s u s u -\nally better to choose nsigni\ufb01cantly smaller than mand hope that by choosing the\ncoef\ufb01cients cjwell, we can obtain a function Fthat \ufb01nds the signi\ufb01cant patterns\nin the data points without paying undue attention to the noise. Some theoretical", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "856": {"page_number": 857, "page_information": "836 Chapter 28 Matrix Operations\nprinciples exist for choosing n, but they are beyond the scope of this text. In any\ncase, once we choose a value of nthat is less than m, we end up with an overde-\ntermined set of equations whose solution we wish to approximate. We now showhow to do so.\nLet\nAD\u02d9\nf1.x1/f 2.x1/ ::: f n.x1/\nf1.x2/f 2.x2/ ::: f n.x2/\n::::::::::::\nf\n1.xm/f 2.xm/ ::: f n.xm//BEL\ndenote the matrix of values of the basis functions at the given points; that is,a\nijDfj.xi/.L e t cD.ck/denote the desired n-vector of coef\ufb01cients. Then,\nAcD\u02d9\nf1.x1/f 2.x1/ ::: f n.x1/\nf1.x2/f 2.x2/ ::: f n.x2/\n::::::::::::\nf\n1.xm/f 2.xm/ ::: f n.xm//BEL\u02d9\nc1\nc2\n:::\ncn/BEL\nD\u02d9\nF.x 1/\nF.x 2/\n:::\nF.xm//BEL\nis the m-vector of \u201cpredicted values\u201d for y. Thus,\n/DC1DAc/NULy\nis the m-vector of approximation errors .\nTo minimize approximation errors, we choose to minimize the norm of the error\nvector /DC1, which gives us a least-squares solution ,s i n c e\nk/DC1kD mX\niD1/DC12\ni!1=2\n:\nBecause\nk/DC1k2DkAc/NULyk2DmX\niD1 nX\njD1aijcj/NULyi!2\n;\nwe can minimizek/DC1kby differentiatingk/DC1k2with respect to each ckand then\nsetting the result to 0:", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "857": {"page_number": 858, "page_information": "28.3 Symmetric positive-de\ufb01nite matrices and least-squares approximation 837\ndk/DC1k2\ndckDmX\niD12 nX\njD1aijcj/NULyi!\naikD0: (28.18)\nThenequations (28.18) for kD1 ;2;:::;n are equivalent to the single matrix\nequation\n.Ac/NULy/TAD0\nor, equivalently (using Exercise D.1-2), to\nAT.Ac/NULy/D0;\nwhich implies\nATAcDATy: (28.19)\nIn statistics, this is called the normal equation . The matrix ATAis symmetric\nby Exercise D.1-2, and if Ahas full column rank, then by Theorem D.6, ATA\nis positive-de\ufb01nite as well. Hence, .ATA//NUL1exists, and the solution to equa-\ntion (28.19) is\ncD/NUL\n.ATA//NUL1AT/SOH\ny\nDACy; (28.20)\nwhere the matrix ACD..ATA//NUL1AT/is the pseudoinverse of the matrix A.T h e\npseudoinverse naturally generalizes the notion of a matrix inverse to the case inwhich Ais not square. (Compare equation (28.20) as the approximate solution to\nAcDywith the solution A\n/NUL1bas the exact solution to AxDb.)\nAs an example of producing a least-squares \ufb01t, suppose that we have \ufb01ve data\npoints\n.x1;y1/D./NUL1; 2/ ;\n.x2;y2/D.1; 1/ ;\n.x3;y3/D.2; 1/ ;\n.x4;y4/D.3; 0/ ;\n.x5;y5/D.5; 3/ ;\nshown as black dots in Figure 28.3. We wish to \ufb01t these points with a quadratic\npolynomial\nF.x/Dc1Cc2xCc3x2:\nWe start with the matrix of basis-function values", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "858": {"page_number": 859, "page_information": "838 Chapter 28 Matrix Operations\n0.51.01.52.02.53.0\n0.0\n12345 0 \u20131 \u20132xy\nF(x) = 1.2 \u2013 0.757 x + 0.214 x2\nFigure 28.3 The least-squares \ufb01t of a quadratic polynomial to the set of \ufb01ve data points\nf./NUL1; 2/; .1; 1/; .2; 1/; .3; 0/; .5; 3/ g. The black dots are the data points, and the white dots are their\nestimated values predicted by the polynomial F.x/D1:2/NUL0:757xC0:214x2, the quadratic poly-\nnomial that minimizes the sum of the squared errors. Each shaded line shows the error for one data\npoint.\nAD/NUL\n1x 1x2\n1\n1x 2x2\n2\n1x 3x2\n3\n1x 4x2\n4\n1x 5x2\n5/SOH\nD/NUL\n1/NUL11\n11 1\n12 413 9\n15 2 5/SOH\n;\nwhose pseudoinverse is\nACD/NUL\n0:500 0:300 0:200 0:100 /NUL0:100\n/NUL0:388 0:093 0:190 0:193 /NUL0:088\n0:060/NUL0:036/NUL0:048/NUL0:036 0:060/SOH\n:\nMultiplying ybyAC, we obtain the coef\ufb01cient vector\ncD/NUL\n1:200\n/NUL0:757\n0:214/SOH\n;\nwhich corresponds to the quadratic polynomial", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "859": {"page_number": 860, "page_information": "28.3 Symmetric positive-de\ufb01nite matrices and least-squares approximation 839\nF.x/D1:200/NUL0:757xC0:214x2\nas the closest-\ufb01tting quadratic to the given data, in a least-squares sense.\nAs a practical matter, we solve the normal equation (28.19) by multiplying y\nbyATand then \ufb01nding an LU decomposition of ATA.I fAhas full rank, the\nmatrix ATAis guaranteed to be nonsingular, because it is symmetric and positive-\nde\ufb01nite. (See Exercise D.1-2 and Theorem D.6.)\nExercises\n28.3-1\nProve that every diagonal element of a symmetric positive-de\ufb01nite matrix is posi-tive.\n28.3-2\nLetAD/DC2ab\nbc/DC3\nbe a2/STX2symmetric positive-de\ufb01nite matrix. Prove that its\ndeterminant ac/NULb\n2is positive by \u201ccompleting the square\u201d in a manner similar to\nthat used in the proof of Lemma 28.5.\n28.3-3\nProve that the maximum element in a symmetric positive-de\ufb01nite matrix lies onthe diagonal.\n28.3-4\nProve that the determinant of each leading submatrix of a symmetric positive-\nde\ufb01nite matrix is positive.\n28.3-5\nLetA\nkdenote the kth leading submatrix of a symmetric positive-de\ufb01nite matrix A.\nProve that det .Ak/=det.Ak/NUL1/is the kth pivot during LU decomposition, where,\nby convention, det .A0/D1.\n28.3-6\nFind the function of the form\nF.x/Dc1Cc2xlgxCc3ex\nthat is the best least-squares \ufb01t to the data points\n.1; 1/; .2; 1/; .3; 3/; .4; 8/ :", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "860": {"page_number": 861, "page_information": "840 Chapter 28 Matrix Operations\n28.3-7\nShow that the pseudoinverse ACsatis\ufb01es the following four equations:\nAACADA;\nACAACDAC;\n.AAC/TDAAC;\n.ACA/TDACA:\nProblems\n28-1 Tridiagonal systems of linear equations\nConsider the tridiagonal matrix\nAD\u02c7\n1/NUL1000\n/NUL12/NUL100\n0/NUL12/NUL10\n00/NUL12/NUL1\n000/NUL12/CR\n:\na.Find an LU decomposition of A.\nb.Solve the equation AxD/NUL11111/SOHTby using forward and back sub-\nstitution.\nc.Find the inverse of A.\nd.Show how, for any n/STXnsymmetric positive-de\ufb01nite, tridiagonal matrix Aand\nanyn-vector b, to solve the equation AxDbinO.n/ time by performing an\nLU decomposition. Argue that any method based on forming A/NUL1is asymptot-\nically more expensive in the worst case.\ne.Show how, for any n/STXnnonsingular, tridiagonal matrix Aand any n-vector b,t o\nsolve the equation AxDbinO.n/ time by performing an LUP decomposition.\n28-2 Splines\nA practical method for interpolating a set of points with a curve is to use cu-\nbic splines . We are given a set f.xi;yi/WiD0; 1; : : : ; ngofnC1point-value\npairs, where x0<x 1</SOH/SOH/SOH<x n. We wish to \ufb01t a piecewise-cubic curve\n(spline) f. x/ to the points. That is, the curve f. x/ is made up of ncubic polyno-\nmials fi.x/DaiCbixCcix2Cdix3foriD0; 1; : : : ; n/NUL1, where if xfalls in", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "861": {"page_number": 862, "page_information": "Problems for Chapter 28 841\nthe range xi/DC4x/DC4xiC1, then the value of the curve is given by f. x/Dfi.x/NULxi/.\nThe points xiat which the cubic polynomials are \u201cpasted\u201d together are called knots .\nFor simplicity, we shall assume that xiDiforiD0; 1; : : : ; n .\nTo ensure continuity of f. x/ , we require that\nf. x i/Dfi.0/Dyi;\nf. x iC1/Dfi.1/DyiC1\nforiD0; 1; : : : ; n/NUL1. To ensure that f. x/ is suf\ufb01ciently smooth, we also insist\nthat the \ufb01rst derivative be continuous at each knot:\nf0.xiC1/Df0\ni.1/Df0\niC1.0/\nforiD0; 1; : : : ; n/NUL2.\na.Suppose that for iD0; 1; : : : ; n , we are given not only the point-value pairs\nf.xi;yi/gbut also the \ufb01rst derivatives DiDf0.xi/at each knot. Express each\ncoef\ufb01cient ai,bi,ci,a n d diin terms of the values yi,yiC1,Di,a n d DiC1.\n(Remember that xiDi.) How quickly can we compute the 4ncoef\ufb01cients\nfrom the point-value pairs and \ufb01rst derivatives?\nThe question remains of how to choose the \ufb01rst derivatives of f. x/ at the knots.\nOne method is to require the second derivatives to be continuous at the knots:\nf00.xiC1/Df00\ni.1/Df00\niC1.0/\nforiD0; 1; : : : ; n/NUL2. At the \ufb01rst and last knots, we assume that f00.x0/D\nf00\n0.0/D0andf00.xn/Df00\nn/NUL1.1/D0; these assumptions make f. x/ anatural\ncubic spline.\nb.Use the continuity constraints on the second derivative to show that for iD\n1 ;2;:::;n/NUL1,\nDi/NUL1C4DiCDiC1D3.y iC1/NULyi/NUL1/: (28.21)\nc.Show that\n2D0CD1D3.y 1/NULy0/; (28.22)\nDn/NUL1C2DnD3.y n/NULyn/NUL1/: (28.23)\nd.Rewrite equations (28.21)\u2013(28.23) as a matrix equation involving the vector\nDDhD0;D1;:::;D niof unknowns. What attributes does the matrix in your\nequation have?\ne.Argue that a natural cubic spline can interpolate a set of nC1point-value pairs\ninO.n/ time (see Problem 28-1).", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "862": {"page_number": 863, "page_information": "842 Chapter 28 Matrix Operations\nf.Show how to determine a natural cubic spline that interpolates a set of nC1\npoints .xi;yi/satisfying x0<x 1</SOH/SOH/SOH<x n,e v e nw h e n xiis not necessarily\nequal to i. What matrix equation must your method solve, and how quickly\ndoes your algorithm run?\nChapter notes\nMany excellent texts describe numerical and scienti\ufb01c computation in much greaterdetail than we have room for here. The following are especially readable: Georgeand Liu [132], Golub and Van Loan [144], Press, Teukolsky, Vetterling, and Flan-nery [283, 284], and Strang [323, 324].\nGolub and Van Loan [144] discuss numerical stability. They show why det .A/\nis not necessarily a good indicator of the stability of a matrix A, proposing instead\nto usekAk\n1kA/NUL1k1,w h e r ekAk1Dmax 1/DC4i/DC4nPn\njD1jaijj. They also address\nthe question of how to compute this value without actually computing A/NUL1.\nGaussian elimination, upon which the LU and LUP decompositions are based,\nwas the \ufb01rst systematic method for solving linear systems of equations. It was alsoone of the earliest numerical algorithms. Although it was known earlier, its dis-covery is commonly attributed to C. F. Gauss (1777\u20131855). In his famous paper\n[325], Strassen showed that an n/STXnmatrix can be inverted in O.n\nlg7/time. Wino-\ngrad [358] originally proved that matrix multiplication is no harder than matrixinversion, and the converse is due to Aho, Hopcroft, and Ullman [5].\nAnother important matrix decomposition is the singular value decomposition ,\norSVD . The SVD factors an m/STXnmatrix AintoADQ\n1\u2020QT\n2,w h e r e \u2020is an\nm/STXnmatrix with nonzero values only on the diagonal, Q1ism/STXmwith mutually\northonormal columns, and Q2isn/STXn, also with mutually orthonormal columns.\nTwo vectors are orthonormal if their inner product is 0and each vector has a norm\nof1. The books by Strang [323, 324] and Golub and Van Loan [144] contain good\ntreatments of the SVD.\nStrang [324] has an excellent presentation of symmetric positive-de\ufb01nite matri-\nces and of linear algebra in general.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "863": {"page_number": 864, "page_information": "29 Linear Programming\nMany problems take the form of maximizing or minimizing an objective, given\nlimited resources and competing constraints. If we can specify the objective asa linear function of certain variables, and if we can specify the constraints onresources as equalities or inequalities on those variables, then we have a linear-\nprogramming problem . Linear programs arise in a variety of practical applica-\ntions. We begin by studying an application in electoral politics.\nA political problem\nSuppose that you are a politician trying to win an election. Your district has three\ndifferent types of areas\u2014urban, suburban, and rural. These areas have, respec-tively, 100,000, 200,000, and 50,000 registered voters. Although not all the reg-istered voters actually go to the polls, you decide that to govern effectively, youwould like at least half the registered voters in each of the three regions to vote foryou. You are honorable and would never consider supporting policies in which youdo not believe. You realize, however, that certain issues may be more effective inwinning votes in certain places. Your primary issues are building more roads, gun\ncontrol, farm subsidies, and a gasoline tax dedicated to improved public transit.According to your campaign staff\u2019s research, you can estimate how many votes\nyou win or lose from each population segment by spending $1,000 on advertising\non each issue. This information appears in the table of Figure 29.1. In this table,each entry indicates the number of thousands of either urban, suburban, or ruralvoters who would be won over by spending $1,000 on advertising in support of aparticular issue. Negative entries denote votes that would be lost. Your task is to\ufb01gure out the minimum amount of money that you need to spend in order to win50,000 urban votes, 100,000 suburban votes, and 25,000 rural votes.\nYou could, by trial and error, devise a strategy that wins the required number\nof votes, but the strategy you come up with might not be the least expensive one.For example, you could devote $20,000 of advertising to building roads, $0 to guncontrol, $4,000 to farm subsidies, and $9,000 to a gasoline tax. In this case, you", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "864": {"page_number": 865, "page_information": "844 Chapter 29 Linear Programming\npolicy\n urban suburban rural\nbuild roads\n /NUL2 53\ngun control\n 82/NUL5\nfarm subsidies\n 00 1 0\ngasoline tax\n 10 0 /NUL2\nFigure 29.1 The effects of policies on voters. Each entry describes the number of thousands of\nurban, suburban, or rural voters who could be won over by spending $1,000 on advertising support\nof a policy on a particular issue. Negative entries denote votes that would be lost.\nwould win 20./NUL2/C0.8/C4.0/C9.10/D50thousand urban votes, 20.5/C0.2/C\n4.0/C9.0/D100thousand suburban votes, and 20.3/C0./NUL5/C4.10/C9./NUL2/D\n82thousand rural votes. You would win the exact number of votes desired in the\nurban and suburban areas and more than enough votes in the rural area. (In fact,in the rural area, you would receive more votes than there are voters.) In order togarner these votes, you would have paid for 20C0C4C9D33thousand dollars\nof advertising.\nNaturally, you may wonder whether this strategy is the best possible. That is,\ncould you achieve your goals while spending less on advertising? Additional trial\nand error might help you to answer this question, but wouldn\u2019t you rather have a\nsystematic method for answering such questions? In order to develop one, we shall\nformulate this question mathematically. We introduce 4variables:\n/SIx1is the number of thousands of dollars spent on advertising on building roads,\n/SIx2is the number of thousands of dollars spent on advertising on gun control,\n/SIx3is the number of thousands of dollars spent on advertising on farm subsidies,\nand\n/SIx4is the number of thousands of dollars spent on advertising on a gasoline tax.\nWe can write the requirement that we win at least 50,000 urban votes as\n/NUL2x1C8x2C0x3C10x 4/NAK50 : (29.1)\nSimilarly, we can write the requirements that we win at least 100,000 suburban\nvotes and 25,000 rural votes as\n5x1C2x2C0x3C0x4/NAK100 (29.2)\nand3x\n1/NUL5x2C10x 3/NUL2x4/NAK25 : (29.3)\nAny setting of the variables x1;x2;x3;x4that satis\ufb01es inequalities (29.1)\u2013(29.3)\nyields a strategy that wins a suf\ufb01cient number of each type of vote. In order to", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "865": {"page_number": 866, "page_information": "Chapter 29 Linear Programming 845\nkeep costs as small as possible, you would like to minimize the amount spent on\nadvertising. That is, you want to minimize the expression\nx1Cx2Cx3Cx4: (29.4)\nAlthough negative advertising often occurs in political campaigns, there is no such\nthing as negative-cost advertising. Consequently, we require that\nx1/NAK0; x 2/NAK0; x 3/NAK0;andx4/NAK0: (29.5)\nCombining inequalities (29.1)\u2013(29.3) and (29.5) with the objective of minimiz-\ning (29.4), we obtain what is known as a \u201clinear program.\u201d We format this problemas\nminimize x\n1C x2C x3C x4 (29.6)\nsubject to\n/NUL2x1C8x2C 0x3C10x 4/NAK 50 (29.7)\n5x1C2x2C 0x3C 0x4/NAK100 (29.8)\n3x1/NUL5x2C10x 3/NUL 2x4/NAK 25 (29.9)\nx1;x2;x3;x4 /NAK 0: (29.10)\nThe solution of this linear program yields your optimal strategy.\nGeneral linear programs\nIn the general linear-programming problem, we wish to optimize a linear function\nsubject to a set of linear inequalities. Given a set of real numbers a1;a2;:::;a nand\na set of variables x1;x2;:::;x n,w ed e \ufb01 n ea linear function fon those variables\nby\nf. x 1;x2;:::;x n/Da1x1Ca2x2C/SOH/SOH/SOHC anxnDnX\njD1ajxj:\nIfbis a real number and fis a linear function, then the equation\nf. x 1;x2;:::;x n/Db\nis alinear equality and the inequalities\nf. x 1;x2;:::;x n//DC4b\nand\nf. x 1;x2;:::;x n//NAKb", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "866": {"page_number": 867, "page_information": "846 Chapter 29 Linear Programming\narelinear inequalities . We use the general term linear constraints to denote either\nlinear equalities or linear inequalities. In linear programming, we do not allowstrict inequalities. Formally, a linear-programming problem is the problem of\neither minimizing or maximizing a linear function subject to a \ufb01nite set of linearconstraints. If we are to minimize, then we call the linear program a minimization\nlinear program , and if we are to maximize, then we call the linear program a\nmaximization linear program .\nThe remainder of this chapter covers how to formulate and solve linear pro-\ngrams. Although several polynomial-time algorithms for linear programming have\nbeen developed, we will not study them in this chapter. Instead, we shall study thesimplex algorithm, which is the oldest linear-programming algorithm. The simplexalgorithm does not run in polynomial time in the worst case, but it is fairly ef\ufb01cientand widely used in practice.\nAn overview of linear programming\nIn order to describe properties of and algorithms for linear programs, we \ufb01nd it\nconvenient to express them in canonical forms. We shall use two forms, standard\nandslack , in this chapter. We will de\ufb01ne them precisely in Section 29.1. Infor-\nmally, a linear program in standard form is the maximization of a linear function\nsubject to linear inequalities , whereas a linear program in slack form is the max-\nimization of a linear function subject to linear equalities . We shall typically use\nstandard form for expressing linear programs, but we \ufb01nd it more convenient touse slack form when we describe the details of the simplex algorithm. For now, werestrict our attention to maximizing a linear function on nvariables subject to a set\nofmlinear inequalities.\nLet us \ufb01rst consider the following linear program with two variables:\nmaximize x\n1C x2 (29.11)\nsubject to\n4x1/NUL x2/DC4 8 (29.12)\n2x1C x2/DC410 (29.13)\n5x1/NUL2x2/NAK/NUL 2 (29.14)\nx1;x2/NAK 0: (29.15)\nWe call any setting of the variables x1andx2that satis\ufb01es all the constraints\n(29.12)\u2013(29.15) a feasible solution to the linear program. If we graph the con-\nstraints in the .x1;x2/-Cartesian coordinate system, as in Figure 29.2(a), we see", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "867": {"page_number": 868, "page_information": "Chapter 29 Linear Programming 847\n4x1 \u2013 x2\u2264 8\n2x1 + \nx2\u2264 10x2\nx1x2\u2265 0x1\u2265 05x1 \u2013 2x2\u2265 \u20132\n(a)x2\nx1\n(b)x1 + x2 = 0x1 + x2 = 4x1 + x2 = 8\nFigure 29.2 (a) The linear program given in (29.12)\u2013(29.15). Each constraint is represented by\na line and a direction. The intersection of the constraints, which is the feasible region, is shaded.\n(b)The dotted lines show, respectively, the points for which the objective value is 0,4,a n d 8.T h e\noptimal solution to the linear program is x1D2andx2D6with objective value 8.\nthat the set of feasible solutions (shaded in the \ufb01gure) forms a convex region1in\nthe two-dimensional space. We call this convex region the feasible region and the\nfunction we wish to maximize the objective function . Conceptually, we could eval-\nuate the objective function x1Cx2at each point in the feasible region; we call the\nvalue of the objective function at a particular point the objective value . We could\nthen identify a point that has the maximum objective value as an optimal solution.For this example (and for most linear programs), the feasible region contains anin\ufb01nite number of points, and so we need to determine an ef\ufb01cient way to \ufb01nd apoint that achieves the maximum objective value without explicitly evaluating theobjective function at every point in the feasible region.\nIn two dimensions, we can optimize via a graphical procedure. The set of points\nfor which x\n1Cx2D\u00b4,f o ra n y \u00b4, is a line with a slope of /NUL1.I fw ep l o t x1Cx2D0,\nwe obtain the line with slope /NUL1through the origin, as in Figure 29.2(b). The\nintersection of this line and the feasible region is the set of feasible solutions thathave an objective value of 0. In this case, that intersection of the line with the\nfeasible region is the single point .0; 0/ . More generally, for any \u00b4, the intersection\n1An intuitive de\ufb01nition of a convex region is that it ful\ufb01lls the requirement that for any two points in\nthe region, all points on a line segment between them are also in the region.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "868": {"page_number": 869, "page_information": "848 Chapter 29 Linear Programming\nof the line x1Cx2D\u00b4and the feasible region is the set of feasible solutions that\nhave objective value \u00b4. Figure 29.2(b) shows the lines x1Cx2D0,x1Cx2D4,\nandx1Cx2D8. Because the feasible region in Figure 29.2 is bounded, there\nmust be some maximum value \u00b4for which the intersection of the line x1Cx2D\u00b4\nand the feasible region is nonempty. Any point at which this occurs is an optimalsolution to the linear program, which in this case is the point x\n1D2andx2D6\nwith objective value 8.\nIt is no accident that an optimal solution to the linear program occurs at a vertex\nof the feasible region. The maximum value of \u00b4for which the line x1Cx2D\u00b4\nintersects the feasible region must be on the boundary of the feasible region, andthus the intersection of this line with the boundary of the feasible region is either asingle vertex or a line segment. If the intersection is a single vertex, then there isjust one optimal solution, and it is that vertex. If the intersection is a line segment,every point on that line segment must have the same objective value; in particular,both endpoints of the line segment are optimal solutions. Since each endpoint of aline segment is a vertex, there is an optimal solution at a vertex in this case as well.\nAlthough we cannot easily graph linear programs with more than two variables,\nthe same intuition holds. If we have three variables, then each constraint corre-\nsponds to a half-space in three-dimensional space. The intersection of these half-spaces forms the feasible region. The set of points for which the objective functionobtains a given value \u00b4is now a plane (assuming no degenerate conditions). If all\ncoef\ufb01cients of the objective function are nonnegative, and if the origin is a feasible\nsolution to the linear program, then as we move this plane away from the origin, in\na direction normal to the objective function, we \ufb01nd points of increasing objectivevalue. (If the origin is not feasible or if some coef\ufb01cients in the objective functionare negative, the intuitive picture becomes slightly more complicated.) As in twodimensions, because the feasible region is convex, the set of points that achievethe optimal objective value must include a vertex of the feasible region. Simi-larly, if we have nvariables, each constraint de\ufb01nes a half-space in n-dimensional\nspace. We call the feasible region formed by the intersection of these half-spaces a\nsimplex . The objective function is now a hyperplane and, because of convexity, an\noptimal solution still occurs at a vertex of the simplex.\nThesimplex algorithm takes as input a linear program and returns an optimal\nsolution. It starts at some vertex of the simplex and performs a sequence of itera-tions. In each iteration, it moves along an edge of the simplex from a current vertexto a neighboring vertex whose objective value is no smaller than that of the current\nvertex (and usually is larger.) The simplex algorithm terminates when it reaches\na local maximum, which is a vertex from which all neighboring vertices have asmaller objective value. Because the feasible region is convex and the objectivefunction is linear, this local optimum is actually a global optimum. In Section 29.4,", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "869": {"page_number": 870, "page_information": "Chapter 29 Linear Programming 849\nwe shall use a concept called \u201cduality\u201d to show that the solution returned by the\nsimplex algorithm is indeed optimal.\nAlthough the geometric view gives a good intuitive view of the operations of the\nsimplex algorithm, we shall not refer to it explicitly when developing the detailsof the simplex algorithm in Section 29.3. Instead, we take an algebraic view. We\ufb01rst write the given linear program in slack form, which is a set of linear equalities.These linear equalities express some of the variables, called \u201cbasic variables,\u201d interms of other variables, called \u201cnonbasic variables.\u201d We move from one vertex\nto another by making a basic variable become nonbasic and making a nonbasic\nvariable become basic. We call this operation a \u201cpivot\u201d and, viewed algebraically,it is nothing more than rewriting the linear program in an equivalent slack form.\nThe two-variable example described above was particularly simple. We shall\nneed to address several more details in this chapter. These issues include iden-tifying linear programs that have no solutions, linear programs that have no \ufb01niteoptimal solution, and linear programs for which the origin is not a feasible solution.\nApplications of linear programming\nLinear programming has a large number of applications. Any textbook on opera-\ntions research is \ufb01lled with examples of linear programming, and linear program-\nming has become a standard tool taught to students in most business schools. The\nelection scenario is one typical example. Two more examples of linear program-\nming are the following:\n/SIAn airline wishes to schedule its \ufb02ight crews. The Federal Aviation Adminis-tration imposes many constraints, such as limiting the number of consecutivehours that each crew member can work and insisting that a particular crew workonly on one model of aircraft during each month. The airline wants to schedulecrews on all of its \ufb02ights using as few crew members as possible.\n/SIAn oil company wants to decide where to drill for oil. Siting a drill at a particu-lar location has an associated cost and, based on geological surveys, an expectedpayoff of some number of barrels of oil. The company has a limited budget forlocating new drills and wants to maximize the amount of oil it expects to \ufb01nd,given this budget.\nWith linear programs, we also model and solve graph and combinatorial prob-\nlems, such as those appearing in this textbook. We have already seen a specialcase of linear programming used to solve systems of difference constraints in Sec-tion 24.4. In Section 29.2, we shall study how to formulate several graph andnetwork-\ufb02ow problems as linear programs. In Section 35.4, we shall use linearprogramming as a tool to \ufb01nd an approximate solution to another graph problem.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "870": {"page_number": 871, "page_information": "850 Chapter 29 Linear Programming\nAlgorithms for linear programming\nThis chapter studies the simplex algorithm. This algorithm, when implemented\ncarefully, often solves general linear programs quickly in practice. With somecarefully contrived inputs, however, the simplex algorithm can require exponentialtime. The \ufb01rst polynomial-time algorithm for linear programming was the ellipsoid\nalgorithm , which runs slowly in practice. A second class of polynomial-time algo-\nrithms are known as interior-point methods . In contrast to the simplex algorithm,\nwhich moves along the exterior of the feasible region and maintains a feasible solu-tion that is a vertex of the simplex at each iteration, these algorithms move throughthe interior of the feasible region. The intermediate solutions, while feasible, arenot necessarily vertices of the simplex, but the \ufb01nal solution is a vertex. For largeinputs, interior-point algorithms can run as fast as, and sometimes faster than, thesimplex algorithm. The chapter notes point you to more information about thesealgorithms.\nIf we add to a linear program the additional requirement that all variables take\non integer values, we have an integer linear program . Exercise 34.5-3 asks you\nto show that just \ufb01nding a feasible solution to this problem is NP-hard; sinceno polynomial-time algorithms are known for any NP-hard problems, there is noknown polynomial-time algorithm for integer linear programming. In contrast, wecan solve a general linear-programming problem in polynomial time.\nIn this chapter, if we have a linear program with variables xD.x\n1;x2;:::;x n/\nand wish to refer to a particular setting of the variables, we shall use the notation\nNxD.Nx1;Nx2;:::;Nxn/.\n29.1 Standard and slack forms\nThis section describes two formats, standard form and slack form, that are use-\nful when we specify and work with linear programs. In standard form, all theconstraints are inequalities, whereas in slack form, all constraints are equalities(except for those that require the variables to be nonnegative).\nStandard form\nInstandard form ,w ea r eg i v e n nreal numbers c\n1;c2;:::;c n;mreal numbers\nb1;b2;:::;b m;a n d mnreal numbers aijforiD1 ;2;:::;m andjD1 ;2;:::;n .\nWe wish to \ufb01nd nreal numbers x1;x2;:::;x nthat", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "871": {"page_number": 872, "page_information": "29.1 Standard and slack forms 851\nmaximizenX\njD1cjxj (29.16)\nsubject to\nnX\njD1aijxj/DC4biforiD1 ;2;:::;m (29.17)\nxj/NAK0forjD1 ;2;:::;n: (29.18)\nGeneralizing the terminology we introduced for the two-variable linear program,\nwe call expression (29.16) the objective function and the nCminequalities in\nlines (29.17) and (29.18) the constraints .T h e nconstraints in line (29.18) are the\nnonnegativity constraints . An arbitrary linear program need not have nonnegativ-\nity constraints, but standard form requires them. Sometimes we \ufb01nd it convenient\nto express a linear program in a more compact form. If we create an m/STXnmatrix\nAD.aij/,a nm-vector bD.bi/,a nn-vector cD.cj/,a n da n n-vector xD.xj/,\nthen we can rewrite the linear program de\ufb01ned in (29.16)\u2013(29.18) as\nmaximize cTx (29.19)\nsubject to\nAx/DC4b (29.20)\nx/NAK0: (29.21)\nIn line (29.19), cTxis the inner product of two vectors. In inequality (29.20), Ax\nis a matrix-vector product, and in inequality (29.21), x/NAK0means that each entry\nof the vector xmust be nonnegative. We see that we can specify a linear program\nin standard form by a tuple . A ;b;c/ , and we shall adopt the convention that A,b,\nandcalways have the dimensions given above.\nWe now introduce terminology to describe solutions to linear programs. We used\nsome of this terminology in the earlier example of a two-variable linear program.\nWe call a setting of the variables Nxthat satis\ufb01es all the constraints a feasible solu-\ntion, whereas a setting of the variables Nxthat fails to satisfy at least one constraint\nis aninfeasible solution . We say that a solution Nxhasobjective value cTNx. A fea-\nsible solutionNxwhose objective value is maximum over all feasible solutions is an\noptimal solution , and we call its objective value cTNxtheoptimal objective value .\nIf a linear program has no feasible solutions, we say that the linear program is in-\nfeasible ; otherwise it is feasible . If a linear program has some feasible solutions\nbut does not have a \ufb01nite optimal objective value, we say that the linear program\nisunbounded . Exercise 29.1-9 asks you to show that a linear program can have a\n\ufb01nite optimal objective value even if the feasible region is not bounded.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "872": {"page_number": 873, "page_information": "852 Chapter 29 Linear Programming\nConverting linear programs into standard form\nIt is always possible to convert a linear program, given as minimizing or maxi-\nmizing a linear function subject to linear constraints, into standard form. A linearprogram might not be in standard form for any of four possible reasons:\n1. The objective function might be a minimization rather than a maximization.\n2. There might be variables without nonnegativity constraints.3. There might be equality constraints , which have an equal sign rather than a\nless-than-or-equal-to sign.\n4. There might be inequality constraints , but instead of having a less-than-or-\nequal-to sign, they have a greater-than-or-equal-to sign.\nWhen converting one linear program Linto another linear program L\n0, we would\nlike the property that an optimal solution to L0yields an optimal solution to L.T o\ncapture this idea, we say that two maximization linear programs LandL0are\nequivalent if for each feasible solution NxtoLwith objective value \u00b4, there is\na corresponding feasible solution Nx0toL0with objective value \u00b4, and for each\nfeasible solutionNx0toL0with objective value \u00b4, there is a corresponding feasible\nsolutionNxtoLwith objective value \u00b4. (This de\ufb01nition does not imply a one-to-\none correspondence between feasible solutions.) A minimization linear program L\nand a maximization linear program L0are equivalent if for each feasible solution Nx\ntoLwith objective value \u00b4, there is a corresponding feasible solution Nx0toL0with\nobjective value/NUL\u00b4, and for each feasible solution Nx0toL0with objective value \u00b4,\nthere is a corresponding feasible solution NxtoLwith objective value /NUL\u00b4.\nWe now show how to remove, one by one, each of the possible problems in the\nlist above. After removing each one, we shall argue that the new linear program isequivalent to the old one.\nTo convert a minimization linear program Linto an equivalent maximization lin-\near program L\n0, we simply negate the coef\ufb01cients in the objective function. Since\nLandL0have identical sets of feasible solutions and, for any feasible solution, the\nobjective value in Lis the negative of the objective value in L0, these two linear\nprograms are equivalent. For example, if we have the linear program\nminimize/NUL2x1C3x2\nsubject to\nx1C x2D7\nx1/NUL2x2/DC44\nx1/NAK0;\nand we negate the coef\ufb01cients of the objective function, we obtain", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "873": {"page_number": 874, "page_information": "29.1 Standard and slack forms 853\nmaximize 2x1/NUL3x2\nsubject to\nx1C x2D7\nx1/NUL2x2/DC44\nx1/NAK0:\nNext, we show how to convert a linear program in which some of the variables\ndo not have nonnegativity constraints into one in which each variable has a non-negativity constraint. Suppose that some variable x\njdoes not have a nonnegativity\nconstraint. Then, we replace each occurrence of xjbyx0\nj/NULx00\nj, and add the non-\nnegativity constraints x0\nj/NAK0andx00\nj/NAK0. Thus, if the objective function has a\nterm cjxj, we replace it by cjx0\nj/NULcjx00\nj, and if constraint ih a sat e r m aijxj,w e\nreplace it by aijx0\nj/NULaijx00\nj. Any feasible solution yxto the new linear program cor-\nresponds to a feasible solution Nxto the original linear program with NxjDyx0\nj/NULyx00\nj\nand with the same objective value. Also, any feasible solution Nxto the original\nlinear program corresponds to a feasible solution yxto the new linear program with\nyx0\njDNxjandyx00\njD0ifNxj/NAK0, or withyx00\njDNxjandyx0\njD0ifNxj<0.T h e t w o\nlinear programs have the same objective value regardless of the sign of Nxj. Thus,\nthe two linear programs are equivalent. We apply this conversion scheme to eachvariable that does not have a nonnegativity constraint to yield an equivalent linearprogram in which all variables have nonnegativity constraints.\nContinuing the example, we want to ensure that each variable has a correspond-\ning nonnegativity constraint. Variable x\n1has such a constraint, but variable x2does\nnot. Therefore, we replace x2by two variables x0\n2andx00\n2, and we modify the linear\nprogram to obtain\nmaximize 2x1/NUL3x0\n2C3x00\n2\nsubject to\nx1C x0\n2/NUL x00\n2D7 (29.22)\nx1/NUL2x0\n2C2x00\n2/DC44\nx1;x0\n2;x00\n2/NAK0:\nNext, we convert equality constraints into inequality constraints. Suppose that a\nlinear program has an equality constraint f. x 1;x2;:::;x n/Db.S i n c e xDyif\nand only if both x/NAKyandx/DC4y, we can replace this equality constraint by the\npair of inequality constraints f. x 1;x2;:::;x n//DC4bandf. x 1;x2;:::;x n//NAKb.\nRepeating this conversion for each equality constraint yields a linear program inwhich all constraints are inequalities.\nFinally, we can convert the greater-than-or-equal-to constraints to less-than-or-\nequal-to constraints by multiplying these constraints through by /NUL1. That is, any\ninequality of the form", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "874": {"page_number": 875, "page_information": "854 Chapter 29 Linear Programming\nnX\njD1aijxj/NAKbi\nis equivalent to\nnX\njD1/NULaijxj/DC4/NULbi:\nThus, by replacing each coef\ufb01cient aijby/NULaijand each value biby/NULbi, we obtain\nan equivalent less-than-or-equal-to constraint.\nFinishing our example, we replace the equality in constraint (29.22) by two in-\nequalities, obtaining\nmaximize 2x1/NUL3x0\n2C3x00\n2\nsubject to\nx1C x0\n2/NUL x00\n2/DC47\nx1C x0\n2/NUL x00\n2/NAK7 (29.23)\nx1/NUL2x0\n2C2x00\n2/DC44\nx1;x0\n2;x00\n2/NAK0:\nFinally, we negate constraint (29.23). For consistency in variable names, we re-\nname x0\n2tox2andx00\n2tox3, obtaining the standard form\nmaximize 2x1/NUL3x2C3x3 (29.24)\nsubject to\nx1C x2/NUL x3/DC4 7 (29.25)\n/NULx1/NUL x2C x3/DC4/NUL 7 (29.26)\nx1/NUL2x2C2x3/DC4 4 (29.27)\nx1;x2;x3/NAK 0: (29.28)\nConverting linear programs into slack form\nTo ef\ufb01ciently solve a linear program with the simplex algorithm, we prefer to ex-\npress it in a form in which some of the constraints are equality constraints. More\nprecisely, we shall convert it into a form in which the nonnegativity constraints arethe only inequality constraints, and the remaining constraints are equalities. Let\nnX\njD1aijxj/DC4bi (29.29)", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "875": {"page_number": 876, "page_information": "29.1 Standard and slack forms 855\nbe an inequality constraint. We introduce a new variable sand rewrite inequal-\nity (29.29) as the two constraints\nsDbi/NULnX\njD1aijxj; (29.30)\ns/NAK0: (29.31)\nWe call saslack variable because it measures the slack , or difference, between\nthe left-hand and right-hand sides of equation (29.29). (We shall soon see why we\ufb01nd it convenient to write the constraint with only the slack variable on the left-hand side.) Because inequality (29.29) is true if and only if both equation (29.30)and inequality (29.31) are true, we can convert each inequality constraint of a lin-ear program in this way to obtain an equivalent linear program in which the onlyinequality constraints are the nonnegativity constraints. When converting fromstandard to slack form, we shall use x\nnCi(instead of s) to denote the slack variable\nassociated with the ith inequality. The ith constraint is therefore\nxnCiDbi/NULnX\njD1aijxj; (29.32)\nalong with the nonnegativity constraint xnCi/NAK0.\nBy converting each constraint of a linear program in standard form, we obtain a\nlinear program in a different form. For example, for the linear program described\nin (29.24)\u2013(29.28), we introduce slack variables x4,x5,a n d x6, obtaining\nmaximize 2x1/NUL3x2C3x3 (29.33)\nsubject to\nx4D 7/NUL x1/NUL x2C x3 (29.34)\nx5D/NUL 7C x1C x2/NUL x3 (29.35)\nx6D 4/NUL x1C2x2/NUL2x3 (29.36)\nx1;x2;x3;x4;x5;x6/NAK 0: (29.37)\nIn this linear program, all the constraints except for the nonnegativity constraints\nare equalities, and each variable is subject to a nonnegativity constraint. We writeeach equality constraint with one of the variables on the left-hand side of the equal-ity and all others on the right-hand side. Furthermore, each equation has the sameset of variables on the right-hand side, and these variables are also the only onesthat appear in the objective function. We call the variables on the left-hand side ofthe equalities basic variables and those on the right-hand side nonbasic variables .\nFor linear programs that satisfy these conditions, we shall sometimes omit the\nwords \u201cmaximize\u201d and \u201csubject to,\u201d as well as the explicit nonnegativity con-straints. We shall also use the variable \u00b4to denote the value of the objective func-", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "876": {"page_number": 877, "page_information": "856 Chapter 29 Linear Programming\ntion. We call the resulting format slack form . If we write the linear program given\nin (29.33)\u2013(29.37) in slack form, we obtain\n\u00b4D 2x1/NUL3x2C3x3 (29.38)\nx4D 7/NUL x1/NUL x2C x3 (29.39)\nx5D/NUL 7C x1C x2/NUL x3 (29.40)\nx6D 4/NUL x1C2x2/NUL2x3: (29.41)\nAs with standard form, we \ufb01nd it convenient to have a more concise notation\nfor describing a slack form. As we shall see in Section 29.3, the sets of basic andnonbasic variables will change as the simplex algorithm runs. We use Nto denote\nthe set of indices of the nonbasic variables and Bto denote the set of indices of\nthe basic variables. We always have that jNjDn,jBjDm,a n d N[BD\nf1 ;2;:::;nCmg. The equations are indexed by the entries of B, and the variables\non the right-hand sides are indexed by the entries of N. As in standard form, we use\nb\ni,cj,a n d aijto denote constant terms and coef\ufb01cients. We also use /ETBto denote\nan optional constant term in the objective function. (We shall see a little later that\nincluding the constant term in the objective function makes it easy to determine the\nvalue of the objective function.) Thus we can concisely de\ufb01ne a slack form by a\ntuple . N;B;A ;b;c;/ETB/ , denoting the slack form\n\u00b4D/ETBCX\nj2Ncjxj (29.42)\nxiDbi/NULX\nj2Naijxjfori2B; (29.43)\nin which all variables xare constrained to be nonnegative. Because we subtract\nthe sumP\nj2Naijxjin (29.43), the values aijare actually the negatives of the\ncoef\ufb01cients as they \u201cappear\u201d in the slack form.\nFor example, in the slack form\n\u00b4D28/NULx3\n6/NULx5\n6/NUL2x6\n3\nx1D 8Cx3\n6Cx5\n6/NULx6\n3\nx2D 4/NUL8x3\n3/NUL2x5\n3Cx6\n3\nx4D18/NULx3\n2Cx5\n2;\nwe have BDf1; 2; 4g,NDf3; 5; 6g,", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "877": {"page_number": 878, "page_information": "29.1 Standard and slack forms 857\nAD/NUL\na13a15a16\na23a25a26\na43a45a46/SOH\nD/NUL\n/NUL1=6/NUL1=6 1=3\n8=3 2=3/NUL1=3\n1=2/NUL1=2 0/SOH\n;\nbD/NUL\nb1\nb2\nb4/SOH\nD/NUL\n8\n4\n18/SOH\n;\ncD/NULc3c5c6/SOHTD/NUL/NUL1=6/NUL1=6/NUL2=3/SOHT,a n d /ETBD28. Note that the\nindices into A,b,a n d care not necessarily sets of contiguous integers; they depend\non the index sets BandN. As an example of the entries of Abeing the negatives\nof the coef\ufb01cients as they appear in the slack form, observe that the equation for x1\nincludes the term x3=6, yet the coef\ufb01cient a13is actually/NUL1=6rather thanC1=6.\nExercises\n29.1-1\nIf we express the linear program in (29.24)\u2013(29.28) in the compact notation of(29.19)\u2013(29.21), what are n,m,A,b,a n d c?\n29.1-2\nGive three feasible solutions to the linear program in (29.24)\u2013(29.28). What is theobjective value of each one?\n29.1-3\nFor the slack form in (29.38)\u2013(29.41), what are N,B,A,b,c,a n d /ETB?\n29.1-4\nConvert the following linear program into standard form:\nminimize 2x\n1C7x2Cx3\nsubject to\nx1/NULx3D 7\n3x1C x2/NAK24\nx2 /NAK 0\nx3/DC4 0:", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "878": {"page_number": 879, "page_information": "858 Chapter 29 Linear Programming\n29.1-5\nConvert the following linear program into slack form:\nmaximize 2x1/NUL6x3\nsubject to\nx1C x2/NUL x3/DC47\n3x1/NUL x2/NAK8\n/NULx1C2x2C2x3/NAK0\nx1;x2;x3/NAK0:\nWhat are the basic and nonbasic variables?\n29.1-6\nShow that the following linear program is infeasible:\nmaximize 3x1/NUL2x2\nsubject to\nx1C x2/DC4 2\n/NUL2x1/NUL2x2/DC4/NUL 10\nx1;x2/NAK 0:\n29.1-7\nShow that the following linear program is unbounded:\nmaximize x1/NUL x2\nsubject to\n/NUL2x1C x2/DC4/NUL 1\n/NULx1/NUL2x2/DC4/NUL 2\nx1;x2/NAK 0:\n29.1-8\nSuppose that we have a general linear program with nvariables and mconstraints,\nand suppose that we convert it into standard form. Give an upper bound on thenumber of variables and constraints in the resulting linear program.\n29.1-9\nGive an example of a linear program for which the feasible region is not bounded,\nbut the optimal objective value is \ufb01nite.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "879": {"page_number": 880, "page_information": "29.2 Formulating problems as linear programs 859\n29.2 Formulating problems as linear programs\nAlthough we shall focus on the simplex algorithm in this chapter, it is also impor-\ntant to be able to recognize when we can formulate a problem as a linear program.Once we cast a problem as a polynomial-sized linear program, we can solve itin polynomial time by the ellipsoid algorithm or interior-point methods. Several\nlinear-programming software packages can solve problems ef\ufb01ciently, so that once\nthe problem is in the form of a linear program, such a package can solve it.\nWe shall look at several concrete examples of linear-programming problems. We\nstart with two problems that we have already studied: the single-source shortest-paths problem (see Chapter 24) and the maximum-\ufb02ow problem (see Chapter 26).We then describe the minimum-cost-\ufb02ow problem. Although the minimum-cost-\ufb02ow problem has a polynomial-time algorithm that is not based on linear program-ming, we won\u2019t describe the algorithm. Finally, we describe the multicommodity-\ufb02ow problem, for which the only known polynomial-time algorithm is based onlinear programming.\nWhen we solved graph problems in Part VI, we used attribute notation, such\nas/ETB:dand.u; /ETB/: f. Linear programs typically use subscripted variables rather\nthan objects with attached attributes, however. Therefore, when we express vari-\nables in linear programs, we shall indicate vertices and edges through subscripts.\nFor example, we denote the shortest-path weight for vertex /ETBnot by /ETB:dbut by d\n/ETB.\nSimilarly, we denote the \ufb02ow from vertex uto vertex /ETBnot by .u; /ETB/: fbut by fu/ETB.\nFor quantities that are given as inputs to problems, such as edge weights or capac-ities, we shall continue to use notations such as w.u;/ETB/ andc.u:/ETB/ .\nShortest paths\nWe can formulate the single-source shortest-paths problem as a linear program.\nIn this section, we shall focus on how to formulate the single-pair shortest-pathproblem, leaving the extension to the more general single-source shortest-pathsproblem as Exercise 29.2-3.\nIn the single-pair shortest-path problem, we are given a weighted, directed graph\nGD.V; E/ , with weight function wWE! Rmapping edges to real-valued\nweights, a source vertex s, and destination vertex t. We wish to compute the\nvalue d\nt, which is the weight of a shortest path from stot. To express this prob-\nlem as a linear program, we need to determine a set of variables and constraints thatde\ufb01ne when we have a shortest path from stot. Fortunately, the Bellman-Ford al-\ngorithm does exactly this. When the Bellman-Ford algorithm terminates, it hascomputed, for each vertex /ETB,av a l u e d\n/ETB(using subscript notation here rather than\nattribute notation) such that for each edge .u; /ETB/2E,w eh a v e d/ETB/DC4duCw.u;/ETB/ .", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "880": {"page_number": 881, "page_information": "860 Chapter 29 Linear Programming\nThe source vertex initially receives a value dsD0, which never changes. Thus\nwe obtain the following linear program to compute the shortest-path weight from s\ntot:\nmaximize dt (29.44)\nsubject to\nd/ETB/DC4duCw.u;/ETB/ for each edge .u; /ETB/2E; (29.45)\ndsD0: (29.46)\nYou might be surprised that this linear program maximizes an objective function\nwhen it is supposed to compute shortest paths. We do not want to minimize theobjective function, since then setting Nd\n/ETBD0for all /ETB2Vwould yield an optimal\nsolution to the linear program without solving the shortest-paths problem. We\nmaximize because an optimal solution to the shortest-paths problem sets each Nd/ETB\nto min uW.u;/ETB/ 2E\u02daNduCw.u;/ETB//TAB\n,s ot h a tNd/ETBis the largest value that is less than or\nequal to all of the values in the set\u02daNduCw.u;/ETB//TAB\n. We want to maximize d/ETB\nfor all vertices /ETBon a shortest path from stotsubject to these constraints on all\nvertices /ETB, and maximizing dtachieves this goal.\nThis linear program has jVjvariables d/ETB, one for each vertex /ETB2V.I t a l s o\nhasjEjC1constraints: one for each edge, plus the additional constraint that the\nsource vertex\u2019s shortest-path weight always has the value 0.\nMaximum \ufb02ow\nNext, we express the maximum-\ufb02ow problem as a linear program. Recall that we\nare given a directed graph GD.V; E/ in which each edge .u; /ETB/2Ehas a\nnonnegative capacity c.u;/ETB//NAK0, and two distinguished vertices: a source sand\nas i n k t. As de\ufb01ned in Section 26.1, a \ufb02ow is a nonnegative real-valued function\nfWV/STXV!Rthat satis\ufb01es the capacity constraint and \ufb02ow conservation. A\nmaximum \ufb02ow is a \ufb02ow that satis\ufb01es these constraints and maximizes the \ufb02owvalue, which is the total \ufb02ow coming out of the source minus the total \ufb02ow into thesource. A \ufb02ow, therefore, satis\ufb01es linear constraints, and the value of a \ufb02ow is alinear function. Recalling also that we assume that c.u;/ETB/D0if.u; /ETB/62Eand\nthat there are no antiparallel edges, we can express the maximum-\ufb02ow problem asa linear program:\nmaximizeX\n/ETB2Vfs/ETB/NULX\n/ETB2Vf/ETBs (29.47)\nsubject to\nfu/ETB/DC4c.u;/ETB/ for each u; /ETB2V; (29.48)X\n/ETB2Vf/ETBuDX\n/ETB2Vfu/ETBfor each u2V/NULfs; tg; (29.49)\nfu/ETB/NAK0 for each u; /ETB2V: (29.50)", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "881": {"page_number": 882, "page_information": "29.2 Formulating problems as linear programs 861\nThis linear program has jVj2variables, corresponding to the \ufb02ow between each\npair of vertices, and it has 2jVj2CjVj/NUL2constraints.\nIt is usually more ef\ufb01cient to solve a smaller-sized linear program. The linear\nprogram in (29.47)\u2013(29.50) has, for ease of notation, a \ufb02ow and capacity of 0for\neach pair of vertices u; /ETBwith.u; /ETB/62E. It would be more ef\ufb01cient to rewrite the\nlinear program so that it has O.VCE/constraints. Exercise 29.2-5 asks you to\ndo so.\nMinimum-cost \ufb02ow\nIn this section, we have used linear programming to solve problems for which we\nalready knew ef\ufb01cient algorithms. In fact, an ef\ufb01cient algorithm designed specif-ically for a problem, such as Dijkstra\u2019s algorithm for the single-source shortest-\npaths problem, or the push-relabel method for maximum \ufb02ow, will often be more\nef\ufb01cient than linear programming, both in theory and in practice.\nThe real power of linear programming comes from the ability to solve new prob-\nlems. Recall the problem faced by the politician in the beginning of this chapter.The problem of obtaining a suf\ufb01cient number of votes, while not spending toomuch money, is not solved by any of the algorithms that we have studied in thisbook, yet we can solve it by linear programming. Books abound with such real-world problems that linear programming can solve. Linear programming is alsoparticularly useful for solving variants of problems for which we may not alreadyknow of an ef\ufb01cient algorithm.\nConsider, for example, the following generalization of the maximum-\ufb02ow prob-\nlem. Suppose that, in addition to a capacity c.u;/ETB/ for each edge .u; /ETB/ ,w ea r e\ngiven a real-valued cost a.u;/ETB/ . As in the maximum-\ufb02ow problem, we assume that\nc.u;/ETB/D0if.u; /ETB/62E, and that there are no antiparallel edges. If we send f\nu/ETB\nunits of \ufb02ow over edge .u; /ETB/ , we incur a cost of a.u;/ETB/f u/ETB. We are also given a\n\ufb02ow demand d.W ew i s ht os e n d dunits of \ufb02ow from stotwhile minimizing the\ntotal costP\n.u;/ETB/ 2Ea.u;/ETB/f u/ETBincurred by the \ufb02ow. This problem is known as the\nminimum-cost-\ufb02ow problem .\nFigure 29.3(a) shows an example of the minimum-cost-\ufb02ow problem. We wish\nto send 4units of \ufb02ow from stotwhile incurring the minimum total cost. Any\nparticular legal \ufb02ow, that is, a function fsatisfying constraints (29.48)\u2013(29.49),\nincurs a total cost ofP\n.u;/ETB/ 2Ea.u;/ETB/f u/ETB. We wish to \ufb01nd the particular 4-unit\n\ufb02ow that minimizes this cost. Figure 29.3(b) shows an optimal solution, with totalcostP\n.u;/ETB/ 2Ea.u;/ETB/f u/ETBD.2/SOH2/C.5/SOH2/C.3/SOH1/C.7/SOH1/C.1/SOH3/D27:\nThere are polynomial-time algorithms speci\ufb01cally designed for the minimum-\ncost-\ufb02ow problem, but they are beyond the scope of this book. We can, however,express the minimum-cost-\ufb02ow problem as a linear program. The linear programlooks similar to the one for the maximum-\ufb02ow problem with the additional con-", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "882": {"page_number": 883, "page_information": "862 Chapter 29 Linear Programming\nsx\nt\ny\n(a)c = 1\na = 3c = 5\na = 2\nc = 4\na = 1c = 2a = 7\nc = 2a = 5sx\nt\ny\n(b)1/1\na = 32/5\na = 2\n3/4\na = 11/2\na = 7\n2/2\na = 5\nFigure 29.3 (a) An example of a minimum-cost-\ufb02ow problem. We denote the capacities by cand\nthe costs by a.V e r t e x sis the source and vertex tis the sink, and we wish to send 4units of \ufb02ow\nfrom stot.(b)A solution to the minimum-cost \ufb02ow problem in which 4units of \ufb02ow are sent from s\ntot. For each edge, the \ufb02ow and capacity are written as \ufb02ow/capacity.\nstraint that the value of the \ufb02ow be exactly dunits, and with the new objective\nfunction of minimizing the cost:\nminimizeX\n.u;/ETB/ 2Ea.u;/ETB/f u/ETB (29.51)\nsubject to\nfu/ETB/DC4c.u;/ETB/ for each u; /ETB2V;X\n/ETB2Vf/ETBu/NULX\n/ETB2Vfu/ETBD0 for each u2V/NULfs; tg;\nX\n/ETB2Vfs/ETB/NULX\n/ETB2Vf/ETBsDd;\nfu/ETB/NAK0 for each u; /ETB2V: (29.52)\nMulticommodity \ufb02ow\nAs a \ufb01nal example, we consider another \ufb02ow problem. Suppose that the Lucky\nPuck company from Section 26.1 decides to diversify its product line and shipnot only hockey pucks, but also hockey sticks and hockey helmets. Each piece ofequipment is manufactured in its own factory, has its own warehouse, and mustbe shipped, each day, from factory to warehouse. The sticks are manufactured inVancouver and must be shipped to Saskatoon, and the helmets are manufactured in\nEdmonton and must be shipped to Regina. The capacity of the shipping network\ndoes not change, however, and the different items, or commodities , must share the\nsame network.\nThis example is an instance of a multicommodity-\ufb02ow problem . In this problem,\nwe are again given a directed graph GD.V; E/ in which each edge .u; /ETB/2E\nhas a nonnegative capacity c.u;/ETB//NAK0. As in the maximum-\ufb02ow problem, we im-\nplicitly assume that c.u;/ETB/D0for.u; /ETB/62E, and that the graph has no antipar-", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "883": {"page_number": 884, "page_information": "29.2 Formulating problems as linear programs 863\nallel edges. In addition, we are given kdifferent commodities, K1;K2;:::;K k,\nwhere we specify commodity iby the triple KiD.si;ti;di/. Here, vertex siis\nthe source of commodity i, vertex tiis the sink of commodity i,a n d diis the de-\nmand for commodity i, which is the desired \ufb02ow value for the commodity from si\ntoti. We de\ufb01ne a \ufb02ow for commodity i, denoted by fi, (so that fiu/ETBis the \ufb02ow of\ncommodity ifrom vertex uto vertex /ETB) to be a real-valued function that satis\ufb01es\nthe \ufb02ow-conservation and capacity constraints. We now de\ufb01ne fu/ETB,t h eaggregate\n\ufb02ow, to be the sum of the various commodity \ufb02ows, so that fu/ETBDPk\niD1fiu/ETB.T h e\naggregate \ufb02ow on edge .u; /ETB/ must be no more than the capacity of edge .u; /ETB/ .\nWe are not trying to minimize any objective function in this problem; we needonly determine whether such a \ufb02ow exists. Thus, we write a linear program with a\u201cnull\u201d objective function:\nminimize 0\nsubject to\nkX\niD1fiu/ETB/DC4c.u;/ETB/ for each u; /ETB2V;\nX\n/ETB2Vfiu/ETB/NULX\n/ETB2Vfi/ETBuD0 for each iD1 ;2;:::;k and\nfor each u2V/NULfsi;tig;\nX\n/ETB2Vfi;si;/ETB/NULX\n/ETB2Vfi;/ETB;s iDdi for each iD1 ;2;:::;k;\nfiu/ETB/NAK0 for each u; /ETB2Vand\nfor each iD1 ;2;:::;k:\nThe only known polynomial-time algorithm for this problem expresses it as a linear\nprogram and then solves it with a polynomial-time linear-programming algorithm.\nExercises\n29.2-1\nPut the single-pair shortest-path linear program from (29.44)\u2013(29.46) into standard\nform.\n29.2-2\nWrite out explicitly the linear program corresponding to \ufb01nding the shortest pathfrom node sto node yin Figure 24.2(a).\n29.2-3\nIn the single-source shortest-paths problem, we want to \ufb01nd the shortest-pathweights from a source vertex sto all vertices /ETB2V.G i v e n a g r a p h G, write a", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "884": {"page_number": 885, "page_information": "864 Chapter 29 Linear Programming\nlinear program for which the solution has the property that d/ETBis the shortest-path\nweight from sto/ETBfor each vertex /ETB2V.\n29.2-4\nWrite out explicitly the linear program corresponding to \ufb01nding the maximum \ufb02owin Figure 26.1(a).\n29.2-5\nRewrite the linear program for maximum \ufb02ow (29.47)\u2013(29.50) so that it uses onlyO.VCE/constraints.\n29.2-6\nWrite a linear program that, given a bipartite graph GD.V; E/ , solves the maxi-\nmum-bipartite-matching problem.\n29.2-7\nIn the minimum-cost multicommodity-\ufb02ow problem , we are given directed graph\nGD.V; E/ in which each edge .u; /ETB/2Ehas a nonnegative capacity c.u;/ETB//NAK0\nand a cost a.u;/ETB/ . As in the multicommodity-\ufb02ow problem, we are given kdif-\nferent commodities, K\n1;K2;:::;K k, where we specify commodity iby the triple\nKiD.si;ti;di/.W ed e \ufb01 n et h e\ufb02 o w fifor commodity iand the aggregate \ufb02ow fu/ETB\non edge .u; /ETB/ as in the multicommodity-\ufb02ow problem. A feasible \ufb02ow is one\nin which the aggregate \ufb02ow on each edge .u; /ETB/ is no more than the capacity of\nedge .u; /ETB/ . The cost of a \ufb02ow isP\nu;/ETB2Va.u;/ETB/f u/ETB, and the goal is to \ufb01nd the\nfeasible \ufb02ow of minimum cost. Express this problem as a linear program.\n29.3 The simplex algorithm\nThe simplex algorithm is the classical method for solving linear programs. In con-trast to most of the other algorithms in this book, its running time is not polynomialin the worst case. It does yield insight into linear programs, however, and is oftenremarkably fast in practice.\nIn addition to having a geometric interpretation, described earlier in this chapter,\nthe simplex algorithm bears some similarity to Gaussian elimination, discussed inSection 28.1. Gaussian elimination begins with a system of linear equalities whose\nsolution is unknown. In each iteration, we rewrite this system in an equivalent\nform that has some additional structure. After some number of iterations, we haverewritten the system so that the solution is simple to obtain. The simplex algo-rithm proceeds in a similar manner, and we can view it as Gaussian elimination forinequalities.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "885": {"page_number": 886, "page_information": "29.3 The simplex algorithm 865\nWe now describe the main idea behind an iteration of the simplex algorithm.\nAssociated with each iteration will be a \u201cbasic solution\u201d that we can easily obtainfrom the slack form of the linear program: set each nonbasic variable to 0and\ncompute the values of the basic variables from the equality constraints. An iterationconverts one slack form into an equivalent slack form. The objective value of theassociated basic feasible solution will be no less than that at the previous iteration,and usually greater. To achieve this increase in the objective value, we choose anonbasic variable such that if we were to increase that variable\u2019s value from 0,t h e n\nthe objective value would increase, too. The amount by which we can increase\nthe variable is limited by the other constraints. In particular, we raise it until somebasic variable becomes 0. We then rewrite the slack form, exchanging the roles\nof that basic variable and the chosen nonbasic variable. Although we have used aparticular setting of the variables to guide the algorithm, and we shall use it in ourproofs, the algorithm does not explicitly maintain this solution. It simply rewritesthe linear program until an optimal solution becomes \u201cobvious.\u201d\nAn example of the simplex algorithm\nWe begin with an extended example. Consider the following linear program in\nstandard form:\nmaximize 3x\n1C x2C2x3 (29.53)\nsubject to\nx1C x2C3x3/DC430 (29.54)\n2x1C2x2C5x3/DC424 (29.55)\n4x1C x2C2x3/DC436 (29.56)\nx1;x2;x3/NAK 0: (29.57)\nIn order to use the simplex algorithm, we must convert the linear program into\nslack form; we saw how to do so in Section 29.1. In addition to being an algebraicmanipulation, slack is a useful algorithmic concept. Recalling from Section 29.1that each variable has a corresponding nonnegativity constraint, we say that anequality constraint is tight for a particular setting of its nonbasic variables if they\ncause the constraint\u2019s basic variable to become 0. Similarly, a setting of the non-\nbasic variables that would make a basic variable become negative violates that\nconstraint. Thus, the slack variables explicitly maintain how far each constraint is\nfrom being tight, and so they help to determine how much we can increase values\nof nonbasic variables without violating any constraints.\nAssociating the slack variables x\n4,x5,a n d x6with inequalities (29.54)\u2013(29.56),\nrespectively, and putting the linear program into slack form, we obtain", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "886": {"page_number": 887, "page_information": "866 Chapter 29 Linear Programming\n\u00b4D 3x1C x2C2x3 (29.58)\nx4D30/NUL x1/NUL x2/NUL3x3 (29.59)\nx5D24/NUL2x1/NUL2x2/NUL5x3 (29.60)\nx6D36/NUL4x1/NUL x2/NUL2x3: (29.61)\nThe system of constraints (29.59)\u2013(29.61) has 3 equations and 6 variables. Any\nsetting of the variables x1,x2,a n d x3de\ufb01nes values for x4,x5,a n d x6; therefore,\nwe have an in\ufb01nite number of solutions to this system of equations. A solution isfeasible if all of x\n1;x2;:::;x 6are nonnegative, and there can be an in\ufb01nite num-\nber of feasible solutions as well. The in\ufb01nite number of possible solutions to asystem such as this one will be useful in later proofs. We focus on the basic solu-\ntion: set all the (nonbasic) variables on the right-hand side to 0and then compute\nthe values of the (basic) variables on the left-hand side. In this example, the ba-sic solution is .Nx\n1;Nx2;:::;Nx6/D. 0 ;0 ;0 ;3 0 ;2 4;3 6 / and it has objective value\n\u00b4D.3/SOH0/C.1/SOH0/C.2/SOH0/D0. Observe that this basic solution sets NxiDbi\nfor each i2B. An iteration of the simplex algorithm rewrites the set of equations\nand the objective function so as to put a different set of variables on the right-\nhand side. Thus, a different basic solution is associated with the rewritten problem.\nWe emphasize that the rewrite does not in any way change the underlying linear-\nprogramming problem; the problem at one iteration has the identical set of feasible\nsolutions as the problem at the previous iteration. The problem does, however,have a different basic solution than that of the previous iteration.\nIf a basic solution is also feasible, we call it a basic feasible solution .A sw er u n\nthe simplex algorithm, the basic solution is almost always a basic feasible solution.We shall see in Section 29.5, however, that for the \ufb01rst few iterations of the simplexalgorithm, the basic solution might not be feasible.\nOur goal, in each iteration, is to reformulate the linear program so that the basic\nsolution has a greater objective value. We select a nonbasic variable x\newhose\ncoef\ufb01cient in the objective function is positive, and we increase the value of xeas\nmuch as possible without violating any of the constraints. The variable xebecomes\nbasic, and some other variable xlbecomes nonbasic. The values of other basic\nvariables and of the objective function may also change.\nTo continue the example, let\u2019s think about increasing the value of x1.A s w e\nincrease x1, the values of x4,x5,a n d x6all decrease. Because we have a nonnega-\ntivity constraint for each variable, we cannot allow any of them to become negative.Ifx\n1increases above 30,t h e n x4becomes negative, and x5andx6become nega-\ntive when x1increases above 12and9, respectively. The third constraint (29.61) is\nthe tightest constraint, and it limits how much we can increase x1. Therefore, we\nswitch the roles of x1andx6. We solve equation (29.61) for x1and obtain\nx1D9/NULx2\n4/NULx3\n2/NULx6\n4: (29.62)", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "887": {"page_number": 888, "page_information": "29.3 The simplex algorithm 867\nTo rewrite the other equations with x6on the right-hand side, we substitute for x1\nusing equation (29.62). Doing so for equation (29.59), we obtain\nx4D30/NULx1/NULx2/NUL3x3\nD30/NUL/DLE\n9/NULx2\n4/NULx3\n2/NULx6\n4/DC1\n/NULx2/NUL3x3\nD21/NUL3x2\n4/NUL5x3\n2Cx6\n4: (29.63)\nSimilarly, we combine equation (29.62) with constraint (29.60) and with objective\nfunction (29.58) to rewrite our linear program in the following form:\n\u00b4D27Cx2\n4Cx3\n2/NUL3x6\n4(29.64)\nx1D 9/NULx2\n4/NULx3\n2/NULx6\n4(29.65)\nx4D21/NUL3x2\n4/NUL5x3\n2Cx6\n4(29.66)\nx5D 6/NUL3x2\n2/NUL4x3Cx6\n2: (29.67)\nWe call this operation a pivot . As demonstrated above, a pivot chooses a nonbasic\nvariable xe, called the entering variable , and a basic variable xl, called the leaving\nvariable , and exchanges their roles.\nThe linear program described in equations (29.64)\u2013(29.67) is equivalent to the\nlinear program described in equations (29.58)\u2013(29.61). We perform two operations\nin the simplex algorithm: rewrite equations so that variables move between the left-\nhand side and the right-hand side, and substitute one equation into another. The \ufb01rstoperation trivially creates an equivalent problem, and the second, by elementarylinear algebra, also creates an equivalent problem. (See Exercise 29.3-3.)\nTo demonstrate this equivalence, observe that our original basic solution .0; 0;\n0; 30; 24; 36/ satis\ufb01es the new equations (29.65)\u2013(29.67) and has objective value\n27C.1=4//SOH0C.1=2//SOH0/NUL.3=4//SOH36D0. The basic solution associated with the\nnew linear program sets the nonbasic values to 0and is .9; 0; 0; 21; 6; 0/ , with ob-\njective value \u00b4D27. Simple arithmetic veri\ufb01es that this solution also satis\ufb01es\nequations (29.59)\u2013(29.61) and, when plugged into objective function (29.58), hasobjective value .3/SOH9/C.1/SOH0/C.2/SOH0/D27.\nContinuing the example, we wish to \ufb01nd a new variable whose value we wish to\nincrease. We do not want to increase x\n6, since as its value increases, the objective\nvalue decreases. We can attempt to increase either x2orx3; let us choose x3.H o w\nfar can we increase x3without violating any of the constraints? Constraint (29.65)\nlimits it to 18, constraint (29.66) limits it to 42=5 , and constraint (29.67) limits\nit to3=2. The third constraint is again the tightest one, and therefore we rewrite\nthe third constraint so that x3is on the left-hand side and x5is on the right-hand", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "888": {"page_number": 889, "page_information": "868 Chapter 29 Linear Programming\nside. We then substitute this new equation, x3D3=2/NUL3x2=8/NULx5=4Cx6=8,i n t o\nequations (29.64)\u2013(29.66) and obtain the new, but equivalent, system\n\u00b4D111\n4Cx2\n16/NULx5\n8/NUL11x 6\n16(29.68)\nx1D33\n4/NULx2\n16Cx5\n8/NUL5x6\n16(29.69)\nx3D3\n2/NUL3x2\n8/NULx5\n4Cx6\n8(29.70)\nx4D69\n4C3x2\n16C5x5\n8/NULx6\n16: (29.71)\nThis system has the associated basic solution .33=4; 0; 3=2; 69=4; 0; 0/ , with ob-\njective value 111=4 . Now the only way to increase the objective value is to in-\ncrease x2. The three constraints give upper bounds of 132,4,a n d1, respectively.\n(We get an upper bound of 1from constraint (29.71) because, as we increase x2,\nthe value of the basic variable x4increases also. This constraint, therefore, places\nno restriction on how much we can increase x2.) We increase x2to4, and it be-\ncomes nonbasic. Then we solve equation (29.70) for x2and substitute in the other\nequations to obtain\n\u00b4D28/NULx3\n6/NULx5\n6/NUL2x6\n3(29.72)\nx1D 8Cx3\n6Cx5\n6/NULx6\n3(29.73)\nx2D 4/NUL8x3\n3/NUL2x5\n3Cx6\n3(29.74)\nx4D18/NULx3\n2Cx5\n2: (29.75)\nAt this point, all coef\ufb01cients in the objective function are negative. As we shall see\nlater in this chapter, this situation occurs only when we have rewritten the linearprogram so that the basic solution is an optimal solution. Thus, for this problem,the solution .8; 4; 0; 18; 0; 0/ , with objective value 28, is optimal. We can now\nreturn to our original linear program given in (29.53)\u2013(29.57). The only variablesin the original linear program are x\n1,x2,a n d x3, and so our solution is x1D8,\nx2D4,a n d x3D0, with objective value .3/SOH8/C.1/SOH4/C.2/SOH0/D28.N o t e\nthat the values of the slack variables in the \ufb01nal solution measure how much slackremains in each inequality. Slack variable x\n4is18, and in inequality (29.54), the\nleft-hand side, with value 8C4C0D12,i s18less than the right-hand side of 30.\nSlack variables x5andx6are0and indeed, in inequalities (29.55) and (29.56),\nthe left-hand and right-hand sides are equal. Observe also that even though the\ncoef\ufb01cients in the original slack form are integral, the coef\ufb01cients in the other\nlinear programs are not necessarily integral, and the intermediate solutions are not", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "889": {"page_number": 890, "page_information": "29.3 The simplex algorithm 869\nnecessarily integral. Furthermore, the \ufb01nal solution to a linear program need not\nbe integral; it is purely coincidental that this example has an integral solution.\nPivoting\nWe now formalize the procedure for pivoting. The procedure P IVOT t a k e sa si n -\nput a slack form, given by the tuple . N;B;A ;b;c;/ETB/ , the index lof the leav-\ning variable xl, and the index eof the entering variable xe. It returns the tuple\n.yN;yB;yA;yb;yc;y/ETB/describing the new slack form. (Recall again that the entries of\nthem/STXnmatrices AandyAare actually the negatives of the coef\ufb01cients that appear\nin the slack form.)\nPIVOT. N;B;A ;b;c;/ETB;l;e/\n1//Compute the coef\ufb01cients of the equation for new basic variable xe.\n2l e tyAb ean e w m/STXnmatrix\n3ybeDbl=ale\n4foreachj2N/NULfeg\n5yaejDalj=ale\n6yaelD1=a le\n7//Compute the coef\ufb01cients of the remaining constraints.\n8foreachi2B/NULflg\n9ybiDbi/NULaieybe\n10 foreachj2N/NULfeg\n11yaijDaij/NULaieyaej\n12yailD/NULaieyael\n13//Compute the objective function.\n14y/ETBD/ETBCceybe\n15foreachj2N/NULfeg\n16ycjDcj/NULceyaej\n17yclD/NULceyael\n18//Compute new sets of basic and nonbasic variables.\n19yNDN/NULfeg[flg\n20yBDB/NULflg[feg\n21return .yN;yB;yA;yb;yc;y/ETB/\nPIVOT works as follows. Lines 3\u20136 compute the coef\ufb01cients in the new equation\nforxeby rewriting the equation that has xlon the left-hand side to instead have xe\non the left-hand side. Lines 8\u201312 update the remaining equations by substituting\nthe right-hand side of this new equation for each occurrence of xe. Lines 14\u201317\ndo the same substitution for the objective function, and lines 19 and 20 update the", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "890": {"page_number": 891, "page_information": "870 Chapter 29 Linear Programming\nsets of nonbasic and basic variables. Line 21 returns the new slack form. As given,\nifaleD0,PIVOT would cause an error by dividing by 0, but as we shall see in the\nproofs of Lemmas 29.2 and 29.12, we call P IVOT only when ale\u00a40.\nWe now summarize the effect that P IVOT has on the values of the variables in\nthe basic solution.\nLemma 29.1\nConsider a call to P IVOT. N;B;A ;b;c;/ETB;l;e/ in which ale\u00a40. Let the values\nreturned from the call be .yN;yB;yA;yb;yc;y/ETB/,a n dl e tNxdenote the basic solution after\nthe call. Then\n1.NxjD0for each j2yN.\n2.NxeDbl=ale.\n3.NxiDbi/NULaieybefor each i2yB/NULfeg.\nProof The \ufb01rst statement is true because the basic solution always sets all non-\nbasic variables to 0. When we set each nonbasic variable to 0in a constraint\nxiDybi/NULX\nj2yNyaijxj;\nwe have thatNxiDybifor each i2yB.S i n c e e2yB, line 3 of P IVOT gives\nNxeDybeDbl=ale;\nwhich proves the second statement. Similarly, using line 9 for each i2yB/NULfeg,\nwe have\nNxiDybiDbi/NULaieybe;\nwhich proves the third statement.\nThe formal simplex algorithm\nWe are now ready to formalize the simplex algorithm, which we demonstrated by\nexample. That example was a particularly nice one, and we could have had severalother issues to address:\n/SIHow do we determine whether a linear program is feasible?\n/SIWhat do we do if the linear program is feasible, but the initial basic solution isnot feasible?\n/SIHow do we determine whether a linear program is unbounded?\n/SIHow do we choose the entering and leaving variables?", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "891": {"page_number": 892, "page_information": "29.3 The simplex algorithm 871\nIn Section 29.5, we shall show how to determine whether a problem is feasible,\nand if so, how to \ufb01nd a slack form in which the initial basic solution is feasible.Therefore, let us assume that we have a procedure I\nNITIALIZE -SIMPLEX . A ;b;c/\nthat takes as input a linear program in standard form, that is, an m/STXnmatrix\nAD.aij/,a nm-vector bD.bi/,a n da n n-vector cD.cj/. If the problem is\ninfeasible, the procedure returns a message that the program is infeasible and thenterminates. Otherwise, the procedure returns a slack form for which the initialbasic solution is feasible.\nThe procedure S\nIMPLEX takes as input a linear program in standard form, as just\ndescribed. It returns an n-vectorNxD.Nxj/that is an optimal solution to the linear\nprogram described in (29.19)\u2013(29.21).\nSIMPLEX . A ;b;c/\n1. N;B;A ;b;c;/ETB/DINITIALIZE -SIMPLEX . A ;b;c/\n2l e t /c129be a new vector of length n\n3while some index j2Nhascj>0\n4 choose an index e2Nfor which ce>0\n5 foreach index i2B\n6 ifaie>0\n7 /c129iDbi=aie\n8 else/c129iD1\n9 choose an index l2Bthat minimizes /c129i\n10 if/c129l==1\n11 return \u201cunbounded\u201d\n12 else. N;B;A ;b;c;/ETB/DPIVOT. N;B;A ;b;c;/ETB;l;e/\n13foriD1ton\n14 ifi2B\n15NxiDbi\n16 elseNxiD0\n17return .Nx1;Nx2;:::;Nxn/\nThe S IMPLEX procedure works as follows. In line 1, it calls the procedure\nINITIALIZE -SIMPLEX . A ;b;c/ , described above, which either determines that the\nlinear program is infeasible or returns a slack form for which the basic solution isfeasible. The while loop of lines 3\u201312 forms the main part of the algorithm. If all\ncoef\ufb01cients in the objective function are negative, then the while loop terminates.\nOtherwise, line 4 selects a variable x\ne, whose coef\ufb01cient in the objective function\nis positive, as the entering variable. Although we may choose any such variable as\nthe entering variable, we assume that we use some prespeci\ufb01ed deterministic rule.\nNext, lines 5\u20139 check each constraint and pick the one that most severely limits\nthe amount by which we can increase xewithout violating any of the nonnegativ-", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "892": {"page_number": 893, "page_information": "872 Chapter 29 Linear Programming\nity constraints; the basic variable associated with this constraint is xl.A g a i n , w e\nare free to choose one of several variables as the leaving variable, but we assumethat we use some prespeci\ufb01ed deterministic rule. If none of the constraints lim-its the amount by which the entering variable can increase, the algorithm returns\u201cunbounded\u201d in line 11. Otherwise, line 12 exchanges the roles of the enteringand leaving variables by calling P\nIVOT. N;B;A ;b;c;/ETB;l;e/ , as described above.\nLines 13\u201316 compute a solution Nx1;Nx2;:::;Nxnfor the original linear-programming\nvariables by setting all the nonbasic variables to 0and each basic variable Nxitobi,\nand line 17 returns these values.\nTo show that S IMPLEX is correct, we \ufb01rst show that if S IMPLEX has an initial\nfeasible solution and eventually terminates, then it either returns a feasible solutionor determines that the linear program is unbounded. Then, we show that S\nIMPLEX\nterminates. Finally, in Section 29.4 (Theorem 29.10) we show that the solutionreturned is optimal.\nLemma 29.2\nGiven a linear program . A ;b;c/ , suppose that the call to I\nNITIALIZE -SIMPLEX in\nline 1 of S IMPLEX returns a slack form for which the basic solution is feasible.\nThen if S IMPLEX returns a solution in line 17, that solution is a feasible solution to\nthe linear program. If S IMPLEX returns \u201cunbounded\u201d in line 11, the linear program\nis unbounded.\nProof We use the following three-part loop invariant:\nAt the start of each iteration of the while loop of lines 3\u201312,\n1. the slack form is equivalent to the slack form returned by the call of\nINITIALIZE -SIMPLEX ,\n2. for each i2B,w eh a v e bi/NAK0,a n d\n3. the basic solution associated with the slack form is feasible.\nInitialization: The equivalence of the slack forms is trivial for the \ufb01rst itera-\ntion. We assume, in the statement of the lemma, that the call to I NITIALIZE -\nSIMPLEX in line 1 of S IMPLEX returns a slack form for which the basic solution\nis feasible. Thus, the third part of the invariant is true. Because the basic so-lution is feasible, each basic variable x\niis nonnegative. Furthermore, since the\nbasic solution sets each basic variable xitobi,w eh a v et h a t bi/NAK0for all\ni2B. Thus, the second part of the invariant holds.\nMaintenance: We shall show that each iteration of the while loop maintains the\nloop invariant, assuming that the return statement in line 11 does not execute.\nWe shall handle the case in which line 11 executes when we discuss termination.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "893": {"page_number": 894, "page_information": "29.3 The simplex algorithm 873\nAn iteration of the while loop exchanges the role of a basic and a nonbasic\nvariable by calling the P IVOT procedure. By Exercise 29.3-3, the slack form is\nequivalent to the one from the previous iteration which, by the loop invariant,is equivalent to the initial slack form.\nWe now demonstrate the second part of the loop invariant. We assume that at\nthe start of each iteration of the while loop, b\ni/NAK0for each i2B, and we shall\nshow that these inequalities remain true after the call to P IVOT in line 12. Since\nthe only changes to the variables biand the set Bof basic variables occur in this\nassignment, it suf\ufb01ces to show that line 12 maintains this part of the invariant.\nWe let bi,aij,a n d Brefer to values before the call of P IVOT ,a n dybirefer to\nvalues returned from P IVOT .\nFirst, we observe that ybe/NAK0because bl/NAK0by the loop invariant, ale>0by\nl i n e s6a n d9o fS IMPLEX ,a n dybeDbl=aleby line 3 of P IVOT .\nFor the remaining indices i2B/NULflg,w eh a v et h a t\nybiDbi/NULaieybe (by line 9 of P IVOT )\nDbi/NULaie.bl=ale/(by line 3 of P IVOT ) . (29.76)\nWe have two cases to consider, depending on whether aie>0 oraie/DC40.\nIfaie>0, then since we chose lsuch that\nbl=ale/DC4bi=aiefor all i2B; (29.77)\nwe have\nybiDbi/NULaie.bl=ale/(by equation (29.76))\n/NAKbi/NULaie.bi=aie/(by inequality (29.77))\nDbi/NULbi\nD0;\nand thusybi/NAK0.I faie/DC40, then because ale,bi,a n d blare all nonnegative,\nequation (29.76) implies that ybimust be nonnegative, too.\nWe now argue that the basic solution is feasible, i.e., that all variables have non-\nnegative values. The nonbasic variables are set to 0and thus are nonnegative.\nEach basic variable xiis de\ufb01ned by the equation\nxiDbi/NULX\nj2Naijxj:\nThe basic solution sets NxiDbi. Using the second part of the loop invariant, we\nconclude that each basic variable Nxiis nonnegative.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "894": {"page_number": 895, "page_information": "874 Chapter 29 Linear Programming\nTermination: Thewhile loop can terminate in one of two ways. If it terminates\nbecause of the condition in line 3, then the current basic solution is feasible andline 17 returns this solution. The other way it terminates is by returning \u201cun-bounded\u201d in line 11. In this case, for each iteration of the forloop in lines 5\u20138,\nwhen line 6 is executed, we \ufb01nd that a\nie/DC40. Consider the solution Nxde\ufb01ned as\nNxiD/c128\n1 ifiDe;\n0 ifi2N/NULfeg;\nbi/NULP\nj2NaijNxjifi2B:\nWe now show that this solution is feasible, i.e., that all variables are nonneg-\native. The nonbasic variables other than Nxeare0,a n dNxeD1 >0; thus all\nnonbasic variables are nonnegative. For each basic variable Nxi,w eh a v e\nNxiDbi/NULX\nj2NaijNxj\nDbi/NULaieNxe:\nThe loop invariant implies that bi/NAK0, and we have aie/DC40andNxeD1 >0.\nThus,Nxi/NAK0.\nNow we show that the objective value for the solution Nxis unbounded. From\nequation (29.42), the objective value is\n\u00b4D/ETBCX\nj2NcjNxj\nD/ETBCceNxe:\nSince ce>0 (by line 4 of S IMPLEX )a n dNxeD1 , the objective value is 1,\nand thus the linear program is unbounded.\nIt remains to show that S IMPLEX terminates, and when it does terminate, the\nsolution it returns is optimal. Section 29.4 will address optimality. We now discusstermination.\nTermination\nIn the example given in the beginning of this section, each iteration of the simplex\nalgorithm increased the objective value associated with the basic solution. As Ex-ercise 29.3-2 asks you to show, no iteration of S\nIMPLEX can decrease the objective\nvalue associated with the basic solution. Unfortunately, it is possible that an itera-tion leaves the objective value unchanged. This phenomenon is called degeneracy ,\nand we shall now study it in greater detail.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "895": {"page_number": 896, "page_information": "29.3 The simplex algorithm 875\nThe assignment in line 14 of P IVOT ,y/ETBD/ETBCceybe, changes the objective value.\nSince S IMPLEX calls P IVOT only when ce>0, the only way for the objective\nvalue to remain unchanged (i.e., y/ETBD/ETB)i sf o rybeto be 0. This value is assigned\nasybeDbl=alein line 3 of P IVOT . Since we always call P IVOT withale\u00a40,w e\nsee that forybeto equal 0, and hence the objective value to be unchanged, we must\nhave blD0.\nIndeed, this situation can occur. Consider the linear program\n\u00b4D x1Cx2Cx3\nx4D8/NULx1/NULx2\nx5D x2/NULx3:\nSuppose that we choose x1as the entering variable and x4as the leaving variable.\nAfter pivoting, we obtain\n\u00b4D8Cx3/NULx4\nx1D8/NULx2/NULx4\nx5D x2/NULx3:\nAt this point, our only choice is to pivot with x3entering and x5leaving. Since\nb5D0, the objective value of 8remains unchanged after pivoting:\n\u00b4D8Cx2/NULx4/NULx5\nx1D8/NULx2/NULx4\nx3D x2/NULx5:\nThe objective value has not changed, but our slack form has. Fortunately, if we\npivot again, with x2entering and x1leaving, the objective value increases (to 16),\nand the simplex algorithm can continue.\nDegeneracy can prevent the simplex algorithm from terminating, because it can\nlead to a phenomenon known as cycling : the slack forms at two different itera-\ntions of S IMPLEX are identical. Because of degeneracy, S IMPLEX could choose a\nsequence of pivot operations that leave the objective value unchanged but repeat\na slack form within the sequence. Since S IMPLEX is a deterministic algorithm, if\nit cycles, then it will cycle through the same series of slack forms forever, never\nterminating.\nCycling is the only reason that S IMPLEX might not terminate. To show this fact,\nwe must \ufb01rst develop some additional machinery.\nAt each iteration, S IMPLEX maintains A,b,c,a n d /ETBin addition to the sets\nNandB. Although we need to explicitly maintain A,b,c,a n d /ETBin order to\nimplement the simplex algorithm ef\ufb01ciently, we can get by without maintaining\nthem. In other words, the sets of basic and nonbasic variables suf\ufb01ce to uniquely\ndetermine the slack form. Before proving this fact, we prove a useful algebraiclemma.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "896": {"page_number": 897, "page_information": "876 Chapter 29 Linear Programming\nLemma 29.3\nLetIbe a set of indices. For each j2I,l e t\u02dbjand\u02c7jbe real numbers, and let xj\nbe a real-valued variable. Let /CRbe any real number. Suppose that for any settings\nof the xj,w eh a v e\nX\nj2I\u02dbjxjD/CRCX\nj2I\u02c7jxj: (29.78)\nThen \u02dbjD\u02c7jfor each j2I,a n d /CRD0.\nProof Since equation (29.78) holds for any values of the xj, we can use particular\nvalues to draw conclusions about \u02db,\u02c7,a n d /CR.I f w e l e t xjD0for each j2I,\nwe conclude that /CRD0. Now pick an arbitrary index j2I, and set xjD1and\nxkD0for all k\u00a4j. Then we must have \u02dbjD\u02c7j. Since we picked jas any\nindex in I, we conclude that \u02dbjD\u02c7jfor each j2I.\nA particular linear program has many different slack forms; recall that each slack\nform has the same set of feasible and optimal solutions as the original linear pro-gram. We now show that the slack form of a linear program is uniquely determinedby the set of basic variables. That is, given the set of basic variables, a unique slackform (unique set of coef\ufb01cients and right-hand sides) is associated with those basicvariables.\nLemma 29.4\nLet. A ;b;c/ be a linear program in standard form. Given a set Bof basic variables,\nthe associated slack form is uniquely determined.\nProof Assume for the purpose of contradiction that there are two different slack\nforms with the same set Bof basic variables. The slack forms must also have\nidentical sets NDf1 ;2;:::;nCmg/NULBof nonbasic variables. We write the \ufb01rst\nslack form as\n\u00b4D/ETBCX\nj2Ncjxj (29.79)\nxiDbi/NULX\nj2Naijxjfori2B; (29.80)\nand the second as\n\u00b4D/ETB0CX\nj2Nc0\njxj (29.81)\nxiDb0\ni/NULX\nj2Na0\nijxjfori2B: (29.82)", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "897": {"page_number": 898, "page_information": "29.3 The simplex algorithm 877\nConsider the system of equations formed by subtracting each equation in\nline (29.82) from the corresponding equation in line (29.80). The resulting sys-tem is\n0D.b\ni/NULb0\ni//NULX\nj2N.aij/NULa0\nij/xjfori2B\nor, equivalently,\nX\nj2NaijxjD.bi/NULb0\ni/CX\nj2Na0\nijxjfori2B:\nNow, for each i2B, apply Lemma 29.3 with \u02dbjDaij,\u02c7jDa0\nij,/CRDbi/NULb0\ni,a n d\nIDN.S i n c e \u02dbiD\u02c7i,w eh a v et h a t aijDa0\nijfor each j2N, and since /CRD0,\nwe have that biDb0\ni. Thus, for the two slack forms, Aandbare identical to A0\nandb0. Using a similar argument, Exercise 29.3-1 shows that it must also be the\ncase that cDc0and/ETBD/ETB0, and hence that the slack forms must be identical.\nWe can now show that cycling is the only possible reason that S IMPLEX might\nnot terminate.\nLemma 29.5\nIf S IMPLEX fails to terminate in at most/NULnCm\nm/SOH\niterations, then it cycles.\nProof By Lemma 29.4, the set Bof basic variables uniquely determines a slack\nform. There are nCmvariables andjBjDm, and therefore, there are at most/NULnCm\nm/SOH\nways to choose B. Thus, there are only at most/NULnCm\nm/SOH\nunique slack forms.\nTherefore, if S IMPLEX runs for more than/NULnCm\nm/SOH\niterations, it must cycle.\nCycling is theoretically possible, but extremely rare. We can prevent it by choos-\ning the entering and leaving variables somewhat more carefully. One option is toperturb the input slightly so that it is impossible to have two solutions with thesame objective value. Another option is to break ties by always choosing the vari-able with the smallest index, a strategy known as Bland\u2019s rule . We omit the proof\nthat these strategies avoid cycling.\nLemma 29.6\nIf lines 4 and 9 of S\nIMPLEX always break ties by choosing the variable with the\nsmallest index, then S IMPLEX must terminate.\nWe conclude this section with the following lemma.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "898": {"page_number": 899, "page_information": "878 Chapter 29 Linear Programming\nLemma 29.7\nAssuming that I NITIALIZE -SIMPLEX returns a slack form for which the basic so-\nlution is feasible, S IMPLEX either reports that a linear program is unbounded, or it\nterminates with a feasible solution in at most/NULnCm\nm/SOH\niterations.\nProof Lemmas 29.2 and 29.6 show that if I NITIALIZE -SIMPLEX returns a slack\nform for which the basic solution is feasible, S IMPLEX either reports that a linear\nprogram is unbounded, or it terminates with a feasible solution. By the contra-positive of Lemma 29.5, if S\nIMPLEX terminates with a feasible solution, then it\nterminates in at most/NULnCm\nm/SOH\niterations.\nExercises\n29.3-1\nComplete the proof of Lemma 29.4 by showing that it must be the case that cDc0\nand/ETBD/ETB0.\n29.3-2\nShow that the call to P IVOT in line 12 of S IMPLEX never decreases the value of /ETB.\n29.3-3\nProve that the slack form given to the P IVOT procedure and the slack form that the\nprocedure returns are equivalent.\n29.3-4\nSuppose we convert a linear program . A ;b;c/ in standard form to slack form.\nShow that the basic solution is feasible if and only if bi/NAK0foriD1 ;2;:::;m .\n29.3-5\nSolve the following linear program using S IMPLEX :\nmaximize 18x 1C12:5x 2\nsubject to\nx1C x2/DC420\nx1/DC412\nx2/DC416\nx1;x2/NAK 0:", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "899": {"page_number": 900, "page_information": "29.4 Duality 879\n29.3-6\nSolve the following linear program using S IMPLEX :\nmaximize 5x1/NUL3x2\nsubject to\nx1/NUL x2/DC41\n2x1C x2/DC42\nx1;x2/NAK0:\n29.3-7\nSolve the following linear program using S IMPLEX :\nminimize x1C x2C x3\nsubject to\n2x1C7:5x 2C 3x3/NAK10000\n20x 1C 5x2C10x 3/NAK30000\nx1;x2;x3/NAK 0:\n29.3-8\nIn the proof of Lemma 29.5, we argued that there are at most/NULmCn\nn/SOH\nways to choose\na setBof basic variables. Give an example of a linear program in which there are\nstrictly fewer than/NULmCn\nn/SOH\nways to choose the set B.\n29.4 Duality\nWe have proven that, under certain assumptions, S IMPLEX terminates. We have not\nyet shown that it actually \ufb01nds an optimal solution to a linear program, however.In order to do so, we introduce a powerful concept called linear-programming\nduality .\nDuality enables us to prove that a solution is indeed optimal. We saw an exam-\nple of duality in Chapter 26 with Theorem 26.6, the max-\ufb02ow min-cut theorem.Suppose that, given an instance of a maximum-\ufb02ow problem, we \ufb01nd a \ufb02ow f\nwith valuejfj. How do we know whether fis a maximum \ufb02ow? By the max-\ufb02ow\nmin-cut theorem, if we can \ufb01nd a cut whose value is also jfj,t h e nw eh a v ev e r -\ni\ufb01ed that fis indeed a maximum \ufb02ow. This relationship provides an example of\nduality: given a maximization problem, we de\ufb01ne a related minimization problemsuch that the two problems have the same optimal objective values.\nGiven a linear program in which the objective is to maximize, we shall describe\nhow to formulate a dual linear program in which the objective is to minimize and", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "900": {"page_number": 901, "page_information": "880 Chapter 29 Linear Programming\nwhose optimal value is identical to that of the original linear program. When refer-\nring to dual linear programs, we call the original linear program the primal .\nGiven a primal linear program in standard form, as in (29.16)\u2013(29.18), we de\ufb01ne\nthe dual linear program as\nminimizemX\niD1biyi (29.83)\nsubject to\nmX\niD1aijyi/NAKcjforjD1 ;2;:::;n; (29.84)\nyi/NAK0foriD1 ;2;:::;m: (29.85)\nTo form the dual, we change the maximization to a minimization, exchange the\nroles of coef\ufb01cients on the right-hand sides and the objective function, and replaceeach less-than-or-equal-to by a greater-than-or-equal-to. Each of the mconstraints\nin the primal has an associated variable y\niin the dual, and each of the nconstraints\nin the dual has an associated variable xjin the primal. For example, consider the\nlinear program given in (29.53)\u2013(29.57). The dual of this linear program is\nminimize 30y 1C24y 2C36y 3 (29.86)\nsubject to\ny1C 2y2C 4y3/NAK3 (29.87)\ny1C 2y2C y3/NAK1 (29.88)\n3y1C 5y2C 2y3/NAK2 (29.89)\ny1;y2;y3/NAK0: (29.90)\nWe shall show in Theorem 29.10 that the optimal value of the dual linear pro-\ngram is always equal to the optimal value of the primal linear program. Further-\nmore, the simplex algorithm actually implicitly solves both the primal and the dual\nlinear programs simultaneously, thereby providing a proof of optimality.\nWe begin by demonstrating weak duality , which states that any feasible solu-\ntion to the primal linear program has a value no greater than that of any feasible\nsolution to the dual linear program.\nLemma 29.8 (Weak linear-programming duality)\nLetNxbe any feasible solution to the primal linear program in (29.16)\u2013(29.18) and\nletNybe any feasible solution to the dual linear program in (29.83)\u2013(29.85). Then,\nwe have\nnX\njD1cjNxj/DC4mX\niD1biNyi:", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "901": {"page_number": 902, "page_information": "29.4 Duality 881\nProof We have\nnX\njD1cjNxj/DC4nX\njD1 mX\niD1aijNyi!\nNxj(by inequalities (29.84))\nDmX\niD1 nX\njD1aijNxj!\nNyi\n/DC4mX\niD1biNyi (by inequalities (29.17)) .\nCorollary 29.9\nLetNxbe a feasible solution to a primal linear program . A ;b;c/ ,a n dl e tNybe a\nfeasible solution to the corresponding dual linear program. If\nnX\njD1cjNxjDmX\niD1biNyi;\nthenNxandNyare optimal solutions to the primal and dual linear programs, respec-\ntively.\nProof By Lemma 29.8, the objective value of a feasible solution to the primal\ncannot exceed that of a feasible solution to the dual. The primal linear program isa maximization problem and the dual is a minimization problem. Thus, if feasiblesolutionsNxandNyhave the same objective value, neither can be improved.\nBefore proving that there always is a dual solution whose value is equal to that\nof an optimal primal solution, we describe how to \ufb01nd such a solution. Whenwe ran the simplex algorithm on the linear program in (29.53)\u2013(29.57), the \ufb01naliteration yielded the slack form (29.72)\u2013(29.75) with objective \u00b4D28/NULx\n3=6/NUL\nx5=6/NUL2x6=3,BDf1; 2; 4g,a n d NDf3; 5; 6g. As we shall show below, the basic\nsolution associated with the \ufb01nal slack form is indeed an optimal solution to thelinear program; an optimal solution to linear program (29.53)\u2013(29.57) is therefore.Nx\n1;Nx2;Nx3/D. 8 ;4;0 / , with objective value .3/SOH8/C.1/SOH4/C.2/SOH0/D28.A s\nwe also show below, we can read off an optimal dual solution: the negatives of thecoef\ufb01cients of the primal objective function are the values of the dual variables.\nMore precisely, suppose that the last slack form of the primal is\n\u00b4D/ETB\n0CX\nj2Nc0\njxj\nxiDb0\ni/NULX\nj2Na0\nijxjfori2B:", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "902": {"page_number": 903, "page_information": "882 Chapter 29 Linear Programming\nThen, to produce an optimal dual solution, we set\nNyiD(\n/NULc0\nnCiif.nCi/2N;\n0 otherwise :(29.91)\nThus, an optimal solution to the dual linear program de\ufb01ned in (29.86)\u2013(29.90)\nisNy1D0(since nC1D42B),Ny2D/NULc0\n5D1=6,a n dNy3D/NULc0\n6D2=3.\nEvaluating the dual objective function (29.86), we obtain an objective value of.30/SOH0/C.24/SOH.1=6//C.36/SOH.2=3//D28, which con\ufb01rms that the objective value\nof the primal is indeed equal to the objective value of the dual. Combining thesecalculations with Lemma 29.8 yields a proof that the optimal objective value of the\nprimal linear program is 28. We now show that this approach applies in general:\nwe can \ufb01nd an optimal solution to the dual and simultaneously prove that a solutionto the primal is optimal.\nTheorem 29.10 (Linear-programming duality)\nSuppose that S\nIMPLEX returns valuesNxD.Nx1;Nx2;:::;Nxn/for the primal lin-\near program . A ;b;c/ .L e t NandBdenote the nonbasic and basic variables for\nthe \ufb01nal slack form, let c0denote the coef\ufb01cients in the \ufb01nal slack form, and let\nNyD.Ny1;Ny2;:::;Nym/be de\ufb01ned by equation (29.91). Then Nxis an optimal so-\nlution to the primal linear program, Nyis an optimal solution to the dual linear\nprogram, and\nnX\njD1cjNxjDmX\niD1biNyi: (29.92)\nProof By Corollary 29.9, if we can \ufb01nd feasible solutions NxandNythat satisfy\nequation (29.92), then NxandNymust be optimal primal and dual solutions. We\nshall now show that the solutions NxandNydescribed in the statement of the theorem\nsatisfy equation (29.92).\nSuppose that we run S IMPLEX on a primal linear program, as given in lines\n(29.16)\u2013(29.18). The algorithm proceeds through a series of slack forms until itterminates with a \ufb01nal slack form with objective function\n\u00b4D/ETB\n0CX\nj2Nc0\njxj: (29.93)\nSince S IMPLEX terminated with a solution, by the condition in line 3 we know that\nc0\nj/DC40for all j2N: (29.94)", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "903": {"page_number": 904, "page_information": "29.4 Duality 883\nIf we de\ufb01ne\nc0\njD0for all j2B; (29.95)\nwe can rewrite equation (29.93) as\n\u00b4D/ETB0CX\nj2Nc0\njxj\nD/ETB0CX\nj2Nc0\njxjCX\nj2Bc0\njxj(because c0\njD0ifj2B)\nD/ETB0CnCmX\njD1c0\njxj (because N[BDf1 ;2;:::;nCmg) . (29.96)\nFor the basic solution Nxassociated with this \ufb01nal slack form, NxjD0for all j2N,\nand\u00b4D/ETB0. Since all slack forms are equivalent, if we evaluate the original objec-\ntive function onNx, we must obtain the same objective value:\nnX\njD1cjNxjD/ETB0CnCmX\njD1c0\njNxj (29.97)\nD/ETB0CX\nj2Nc0\njNxjCX\nj2Bc0\njNxj\nD/ETB0CX\nj2N.c0\nj/SOH0/CX\nj2B.0/SOHNxj/ (29.98)\nD/ETB0:\nWe shall now show that Ny, de\ufb01ned by equation (29.91), is feasible for the dual\nlinear program and that its objective valuePm\niD1biNyiequalsPn\njD1cjNxj. Equa-\ntion (29.97) says that the \ufb01rst and last slack forms, evaluated at Nx, are equal. More\ngenerally, the equivalence of all slack forms implies that for anyset of values\nxD.x1;x2;:::;x n/,w eh a v e\nnX\njD1cjxjD/ETB0CnCmX\njD1c0\njxj:\nTherefore, for any particular set of values NxD.Nx1;Nx2;:::;Nxn/,w eh a v e", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "904": {"page_number": 905, "page_information": "884 Chapter 29 Linear Programming\nnX\njD1cjNxj\nD/ETB0CnCmX\njD1c0\njNxj\nD/ETB0CnX\njD1c0\njNxjCnCmX\njDnC1c0\njNxj\nD/ETB0CnX\njD1c0\njNxjCmX\niD1c0\nnCiNxnCi\nD/ETB0CnX\njD1c0\njNxjCmX\niD1./NULNyi/NxnCi (by equations (29.91) and (29.95))\nD/ETB0CnX\njD1c0\njNxjCmX\niD1./NULNyi/ \nbi/NULnX\njD1aijNxj!\n(by equation (29.32))\nD/ETB0CnX\njD1c0\njNxj/NULmX\niD1biNyiCmX\niD1nX\njD1.aijNxj/Nyi\nD/ETB0CnX\njD1c0\njNxj/NULmX\niD1biNyiCnX\njD1mX\niD1.aijNyi/Nxj\nD \n/ETB0/NULmX\niD1biNyi!\nCnX\njD1 \nc0\njCmX\niD1aijNyi!\nNxj;\nso that\nnX\njD1cjNxjD \n/ETB0/NULmX\niD1biNyi!\nCnX\njD1 \nc0\njCmX\niD1aijNyi!\nNxj: (29.99)\nApplying Lemma 29.3 to equation (29.99), we obtain\n/ETB0/NULmX\niD1biNyiD0; (29.100)\nc0\njCmX\niD1aijNyiDcjforjD1 ;2;:::;n: (29.101)\nBy equation (29.100), we have thatPm\niD1biNyiD/ETB0, and hence the objective value\nof the dual/DLEPm\niD1biNyi/DC1\nis equal to that of the primal ( /ETB0). It remains to show", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "905": {"page_number": 906, "page_information": "29.4 Duality 885\nthat the solutionNyis feasible for the dual problem. From inequalities (29.94) and\nequations (29.95), we have that c0\nj/DC40for all jD1 ;2;:::;nCm. Hence, for any\njD1 ;2;:::;n , equations (29.101) imply that\ncjDc0\njCmX\niD1aijNyi\n/DC4mX\niD1aijNyi;\nwhich satis\ufb01es the constraints (29.84) of the dual. Finally, since c0\nj/DC40for each\nj2N[B, when we setNyaccording to equation (29.91), we have that each Nyi/NAK0,\nand so the nonnegativity constraints are satis\ufb01ed as well.\nWe have shown that, given a feasible linear program, if I NITIALIZE -SIMPLEX\nreturns a feasible solution, and if S IMPLEX terminates without returning \u201cun-\nbounded,\u201d then the solution returned is indeed an optimal solution. We have also\nshown how to construct an optimal solution to the dual linear program.\nExercises\n29.4-1\nFormulate the dual of the linear program given in Exercise 29.3-5.\n29.4-2\nSuppose that we have a linear program that is not in standard form. We couldproduce the dual by \ufb01rst converting it to standard form, and then taking the dual.\nIt would be more convenient, however, to be able to produce the dual directly.\nExplain how we can directly take the dual of an arbitrary linear program.\n29.4-3\nWrite down the dual of the maximum-\ufb02ow linear program, as given in lines(29.47)\u2013(29.50) on page 860. Explain how to interpret this formulation as aminimum-cut problem.\n29.4-4\nWrite down the dual of the minimum-cost-\ufb02ow linear program, as given in lines(29.51)\u2013(29.52) on page 862. Explain how to interpret this problem in terms ofgraphs and \ufb02ows.\n29.4-5\nShow that the dual of the dual of a linear program is the primal linear program.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "906": {"page_number": 907, "page_information": "886 Chapter 29 Linear Programming\n29.4-6\nWhich result from Chapter 26 can be interpreted as weak duality for the maximum-\ufb02ow problem?\n29.5 The initial basic feasible solution\nIn this section, we \ufb01rst describe how to test whether a linear program is feasible,and if it is, how to produce a slack form for which the basic solution is feasible.We conclude by proving the fundamental theorem of linear programming, whichsays that the S\nIMPLEX procedure always produces the correct result.\nFinding an initial solution\nIn Section 29.3, we assumed that we had a procedure I NITIALIZE -SIMPLEX that\ndetermines whether a linear program has any feasible solutions, and if it does, givesa slack form for which the basic solution is feasible. We describe this procedurehere.\nA linear program can be feasible, yet the initial basic solution might not be\nfeasible. Consider, for example, the following linear program:\nmaximize 2x\n1/NUL x2 (29.102)\nsubject to\n2x1/NUL x2/DC4 2 (29.103)\nx1/NUL5x2/DC4/NUL 4 (29.104)\nx1;x2/NAK 0: (29.105)\nIf we were to convert this linear program to slack form, the basic solution would\nsetx1D0andx2D0. This solution violates constraint (29.104), and so it is not a\nfeasible solution. Thus, I NITIALIZE -SIMPLEX cannot just return the obvious slack\nform. In order to determine whether a linear program has any feasible solutions,\nwe will formulate an auxiliary linear program . For this auxiliary linear program,\nwe can \ufb01nd (with a little work) a slack form for which the basic solution is feasible.\nFurthermore, the solution of this auxiliary linear program determines whether the\ninitial linear program is feasible and if so, it provides a feasible solution with whichwe can initialize S\nIMPLEX .\nLemma 29.11\nLetLbe a linear program in standard form, given as in (29.16)\u2013(29.18). Let x0be\na new variable, and let Lauxbe the following linear program with nC1variables:", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "907": {"page_number": 908, "page_information": "29.5 The initial basic feasible solution 887\nmaximize /NULx0 (29.106)\nsubject to\nnX\njD1aijxj/NULx0/DC4biforiD1 ;2;:::;m; (29.107)\nxj/NAK0forjD0; 1; : : : ; n : (29.108)\nThen Lis feasible if and only if the optimal objective value of Lauxis0.\nProof Suppose that Lhas a feasible solution NxD.Nx1;Nx2;:::;Nxn/. Then the\nsolutionNx0D0combined withNxis a feasible solution to Lauxwith objective\nvalue 0.S i n c e x0/NAK0is a constraint of Lauxand the objective function is to\nmaximize/NULx0, this solution must be optimal for Laux.\nConversely, suppose that the optimal objective value of Lauxis0.T h e nNx0D0,\nand the remaining solution values of Nxsatisfy the constraints of L.\nWe now describe our strategy to \ufb01nd an initial basic feasible solution for a linear\nprogram Lin standard form:\nINITIALIZE -SIMPLEX . A ;b;c/\n1l e t kbe the index of the minimum bi\n2ifbk/NAK0 //is the initial basic solution feasible?\n3 return .f1 ;2;:::;ng;fnC1; nC2;:::;nCmg;A ;b;c;0 /\n4f o r m Lauxby adding/NULx0to the left-hand side of each constraint\nand setting the objective function to /NULx0\n5l e t . N;B;A ;b;c;/ETB/ be the resulting slack form for Laux\n6lDnCk\n7//LauxhasnC1nonbasic variables and mbasic variables.\n8. N;B;A ;b;c;/ETB/DPIVOT. N;B;A ;b;c;/ETB;l;0 /\n9//The basic solution is now feasible for Laux.\n10 iterate the while loop of lines 3\u201312 of S IMPLEX until an optimal solution\ntoLauxis found\n11ifthe optimal solution to LauxsetsNx0to0\n12 ifNx0is basic\n13 perform one (degenerate) pivot to make it nonbasic14 from the \ufb01nal slack form of L\naux, remove x0from the constraints and\nrestore the original objective function of L, but replace each basic\nvariable in this objective function by the right-hand side of its\nassociated constraint\n15 return the modi\ufb01ed \ufb01nal slack form\n16else return \u201cinfeasible\u201d", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "908": {"page_number": 909, "page_information": "888 Chapter 29 Linear Programming\nINITIALIZE -SIMPLEX works as follows. In lines 1\u20133, we implicitly test the\nbasic solution to the initial slack form for Lgiven by NDf1 ;2;:::;ng,BD\nfnC1; nC2;:::;nCmg,NxiDbifor all i2B,a n dNxjD0for all j2N.\n(Creating the slack form requires no explicit effort, as the values of A,b,a n d care\nthe same in both slack and standard forms.) If line 2 \ufb01nds this basic solution to befeasible\u2014that is,Nx\ni/NAK0for all i2N[B\u2014then line 3 returns the slack form.\nOtherwise, in line 4, we form the auxiliary linear program Lauxas in Lemma 29.11.\nSince the initial basic solution to Lis not feasible, the initial basic solution to the\nslack form for Lauxcannot be feasible either. To \ufb01nd a basic feasible solution, we\nperform a single pivot operation. Line 6 selects lDnCkas the index of the\nbasic variable that will be the leaving variable in the upcoming pivot operation.Since the basic variables are x\nnC1;xnC2;:::;x nCm, the leaving variable xlwill be\nthe one with the most negative value. Line 8 performs that call of P IVOT , with\nx0entering and xlleaving. We shall see shortly that the basic solution resulting\nfrom this call of P IVOT will be feasible. Now that we have a slack form for which\nthe basic solution is feasible, we can, in line 10, repeatedly call P IVOT to fully\nsolve the auxiliary linear program. As the test in line 11 demonstrates, if we \ufb01ndan optimal solution to L\nauxwith objective value 0, then in lines 12\u201314, we create\na slack form for Lfor which the basic solution is feasible. To do so, we \ufb01rst,\nin lines 12\u201313, handle the degenerate case in which x0may still be basic with\nvalueNx0D0. In this case, we perform a pivot step to remove x0from the basis,\nusing any e2Nsuch that a0e\u00a40as the entering variable. The new basic\nsolution remains feasible; the degenerate pivot does not change the value of any\nvariable. Next we delete all x0terms from the constraints and restore the original\nobjective function for L. The original objective function may contain both basic\nand nonbasic variables. Therefore, in the objective function we replace each basicvariable by the right-hand side of its associated constraint. Line 15 then returnsthis modi\ufb01ed slack form. If, on the other hand, line 11 discovers that the originallinear program Lis infeasible, then line 16 returns this information.\nWe now demonstrate the operation of I\nNITIALIZE -SIMPLEX on the linear pro-\ngram (29.102)\u2013(29.105). This linear program is feasible if we can \ufb01nd nonneg-ative values for x\n1andx2that satisfy inequalities (29.103) and (29.104). Using\nLemma 29.11, we formulate the auxiliary linear program\nmaximize /NULx0 (29.109)\nsubject to\n2x1/NUL x2/NUL x0/DC4 2 (29.110)\nx1/NUL5x2/NUL x0/DC4/NUL 4 (29.111)\nx1;x2;x0/NAK 0:\nBy Lemma 29.11, if the optimal objective value of this auxiliary linear program\nis0, then the original linear program has a feasible solution. If the optimal objective", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "909": {"page_number": 910, "page_information": "29.5 The initial basic feasible solution 889\nvalue of this auxiliary linear program is negative, then the original linear program\ndoes not have a feasible solution.\nWe write this linear program in slack form, obtaining\n\u00b4D/NUL x0\nx3D 2/NUL2x1C x2Cx0\nx4D/NUL 4/NUL x1C5x2Cx0:\nWe are not out of the woods yet, because the basic solution, which would set\nx4D/NUL4, is not feasible for this auxiliary linear program. We can, however, with\none call to P IVOT , convert this slack form into one in which the basic solution is\nfeasible. As line 8 indicates, we choose x0to be the entering variable. In line 6, we\nchoose as the leaving variable x4, which is the basic variable whose value in the\nbasic solution is most negative. After pivoting, we have the slack form\n\u00b4D/NUL 4/NULx1C5x2/NULx4\nx0D 4Cx1/NUL5x2Cx4\nx3D 6/NULx1/NUL4x2Cx4:\nThe associated basic solution is .Nx0;Nx1;Nx2;Nx3;Nx4/D. 4;0 ;0 ;6 ;0 / , which is feasi-\nble. We now repeatedly call P IVOT until we obtain an optimal solution to Laux.I n\nthis case, one call to P IVOT withx2entering and x0leaving yields\n\u00b4D/NUL x0\nx2D4\n5/NULx0\n5Cx1\n5Cx4\n5\nx3D14\n5C4x0\n5/NUL9x1\n5Cx4\n5:\nThis slack form is the \ufb01nal solution to the auxiliary problem. Since this solution\nhasx0D0, we know that our initial problem was feasible. Furthermore, since\nx0D0, we can just remove it from the set of constraints. We then restore the\noriginal objective function, with appropriate substitutions made to include onlynonbasic variables. In our example, we get the objective function\n2x\n1/NULx2D2x1/NUL/DC24\n5/NULx0\n5Cx1\n5Cx4\n5/DC3\n:\nSetting x0D0and simplifying, we get the objective function\n/NUL4\n5C9x1\n5/NULx4\n5;\nand the slack form", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "910": {"page_number": 911, "page_information": "890 Chapter 29 Linear Programming\n\u00b4D/NUL4\n5C9x1\n5/NULx4\n5\nx2D4\n5Cx1\n5Cx4\n5\nx3D14\n5/NUL9x1\n5Cx4\n5:\nThis slack form has a feasible basic solution, and we can return it to procedure\nSIMPLEX .\nWe now formally show the correctness of I NITIALIZE -SIMPLEX .\nLemma 29.12\nIf a linear program Lhas no feasible solution, then I NITIALIZE -SIMPLEX returns\n\u201cinfeasible.\u201d Otherwise, it returns a valid slack form for which the basic solutionis feasible.\nProof First suppose that the linear program Lhas no feasible solution. Then by\nLemma 29.11, the optimal objective value of L\naux, de\ufb01ned in (29.106)\u2013(29.108),\nis nonzero, and by the nonnegativity constraint on x0, the optimal objective value\nmust be negative. Furthermore, this objective value must be \ufb01nite, since settingx\niD0,f o riD1 ;2;:::;n ,a n d x0Djminm\niD1fbigjis feasible, and this solution\nhas objective value /NULjminm\niD1fbigj. Therefore, line 10 of I NITIALIZE -SIMPLEX\n\ufb01nds a solution with a nonpositive objective value. Let Nxbe the basic solution\nassociated with the \ufb01nal slack form. We cannot have Nx0D0, because then Laux\nwould have objective value 0, which contradicts that the objective value is negative.\nThus the test in line 11 results in line 16 returning \u201cinfeasible.\u201d\nSuppose now that the linear program Ldoes have a feasible solution. From\nExercise 29.3-4, we know that if bi/NAK0foriD1 ;2;:::;m , then the basic solution\nassociated with the initial slack form is feasible. In this case, lines 2\u20133 return theslack form associated with the input. (Converting the standard form to slack formis easy, since A,b,a n d care the same in both.)\nIn the remainder of the proof, we handle the case in which the linear program is\nfeasible but we do not return in line 3. We argue that in this case, lines 4\u201310 \ufb01nd afeasible solution to L\nauxwith objective value 0. First, by lines 1\u20132, we must have\nbk<0;\nand\nbk/DC4bifor each i2B: (29.112)\nIn line 8, we perform one pivot operation in which the leaving variable xl(recall\nthatlDnCk,s ot h a t bl<0) is the left-hand side of the equation with mini-\nmum bi, and the entering variable is x0, the extra added variable. We now show", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "911": {"page_number": 912, "page_information": "29.5 The initial basic feasible solution 891\nthat after this pivot, all entries of bare nonnegative, and hence the basic solution\ntoLauxis feasible. Letting Nxbe the basic solution after the call to P IVOT ,a n d\nlettingybandyBbe values returned by P IVOT , Lemma 29.1 implies that\nNxiD(\nbi/NULaieybeifi2yB/NULfeg;\nbl=ale ifiDe:(29.113)\nThe call to P IVOT in line 8 has eD0. If we rewrite inequalities (29.107), to\ninclude coef\ufb01cients ai0,\nnX\njD0aijxj/DC4biforiD1 ;2;:::;m; (29.114)\nthen\nai0DaieD/NUL1for each i2B: (29.115)\n(Note that ai0is the coef\ufb01cient of x0as it appears in inequalities (29.114), not\nthe negation of the coef\ufb01cient, because Lauxis in standard rather than slack form.)\nSince l2B,w ea l s oh a v et h a t aleD/NUL1. Thus, bl=ale>0,a n ds oNxe>0.F o r\nthe remaining basic variables, we have\nNxiDbi/NULaieybe (by equation (29.113))\nDbi/NULaie.bl=ale/(by line 3 of P IVOT )\nDbi/NULbl (by equation (29.115) and aleD/NUL1)\n/NAK0 (by inequality (29.112)) ,\nwhich implies that each basic variable is now nonnegative. Hence the basic solu-\ntion after the call to P IVOT in line 8 is feasible. We next execute line 10, which\nsolves Laux. Since we have assumed that Lhas a feasible solution, Lemma 29.11\nimplies that Lauxhas an optimal solution with objective value 0. Since all the slack\nforms are equivalent, the \ufb01nal basic solution to Lauxmust haveNx0D0, and after\nremoving x0from the linear program, we obtain a slack form that is feasible for L.\nLine 15 then returns this slack form.\nFundamental theorem of linear programming\nWe conclude this chapter by showing that the S IMPLEX procedure works. In par-\nticular, any linear program either is infeasible, is unbounded, or has an optimalsolution with a \ufb01nite objective value. In each case, S\nIMPLEX acts appropriately.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "912": {"page_number": 913, "page_information": "892 Chapter 29 Linear Programming\nTheorem 29.13 (Fundamental theorem of linear programming)\nAny linear program L, given in standard form, either\n1. has an optimal solution with a \ufb01nite objective value,\n2. is infeasible, or\n3. is unbounded.\nIfLis infeasible, S IMPLEX returns \u201cinfeasible.\u201d If Lis unbounded, S IMPLEX\nreturns \u201cunbounded.\u201d Otherwise, S IMPLEX returns an optimal solution with a \ufb01nite\nobjective value.\nProof By Lemma 29.12, if linear program Lis infeasible, then S IMPLEX returns\n\u201cinfeasible.\u201d Now suppose that the linear program Lis feasible. By Lemma 29.12,\nINITIALIZE -SIMPLEX returns a slack form for which the basic solution is feasible.\nBy Lemma 29.7, therefore, S IMPLEX either returns \u201cunbounded\u201d or terminates\nwith a feasible solution. If it terminates with a \ufb01nite solution, then Theorem 29.10tells us that this solution is optimal. On the other hand, if S\nIMPLEX returns \u201cun-\nbounded,\u201d Lemma 29.2 tells us the linear program Lis indeed unbounded. Since\nSIMPLEX always terminates in one of these ways, the proof is complete.\nExercises\n29.5-1\nGive detailed pseudocode to implement lines 5 and 14 of I NITIALIZE -SIMPLEX .\n29.5-2\nShow that when the main loop of S IMPLEX is run by I NITIALIZE -SIMPLEX , it can\nnever return \u201cunbounded.\u201d\n29.5-3\nSuppose that we are given a linear program Lin standard form, and suppose that\nfor both Land the dual of L, the basic solutions associated with the initial slack\nforms are feasible. Show that the optimal objective value of Lis0.\n29.5-4\nSuppose that we allow strict inequalities in a linear program. Show that in this\ncase, the fundamental theorem of linear programming does not hold.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "913": {"page_number": 914, "page_information": "29.5 The initial basic feasible solution 893\n29.5-5\nSolve the following linear program using S IMPLEX :\nmaximize x1C3x2\nsubject to\nx1/NUL x2/DC4 8\n/NULx1/NUL x2/DC4/NUL 3\n/NULx1C4x2/DC4 2\nx1;x2/NAK 0:\n29.5-6\nSolve the following linear program using S IMPLEX :\nmaximize x1/NUL2x2\nsubject to\nx1C2x2/DC4 4\n/NUL2x1/NUL6x2/DC4/NUL 12\nx2/DC4 1\nx1;x2/NAK 0:\n29.5-7\nSolve the following linear program using S IMPLEX :\nmaximize x1C3x2\nsubject to\n/NULx1C x2/DC4/NUL 1\n/NULx1/NUL x2/DC4/NUL 3\n/NULx1C4x2/DC4 2\nx1;x2/NAK 0:\n29.5-8\nSolve the linear program given in (29.6)\u2013(29.10).\n29.5-9\nConsider the following 1-variable linear program, which we call P:\nmaximize tx\nsubject to\nrx/DC4s\nx/NAK0;\nwhere r,s,a n d tare arbitrary real numbers. Let Dbe the dual of P.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "914": {"page_number": 915, "page_information": "894 Chapter 29 Linear Programming\nState for which values of r,s,a n d tyou can assert that\n1. Both PandDhave optimal solutions with \ufb01nite objective values.\n2.Pis feasible, but Dis infeasible.\n3.Dis feasible, but Pis infeasible.\n4. Neither PnorDis feasible.\nProblems\n29-1 Linear-inequality feasibility\nGiven a set of mlinear inequalities on nvariables x1;x2;:::;x n,t h elinear-\ninequality feasibility problem asks whether there is a setting of the variables that\nsimultaneously satis\ufb01es each of the inequalities.\na.Show that if we have an algorithm for linear programming, we can use it to\nsolve a linear-inequality feasibility problem. The number of variables and con-straints that you use in the linear-programming problem should be polynomialinnandm.\nb.Show that if we have an algorithm for the linear-inequality feasibility problem,\nwe can use it to solve a linear-programming problem. The number of variables\nand linear inequalities that you use in the linear-inequality feasibility problemshould be polynomial in nandm, the number of variables and constraints in\nthe linear program.\n29-2 Complementary slackness\nComplementary slackness describes a relationship between the values of primal\nvariables and dual constraints and between the values of dual variables and pri-mal constraints. Let Nxbe a feasible solution to the primal linear program given\nin (29.16)\u2013(29.18), and let Nybe a feasible solution to the dual linear program given\nin (29.83)\u2013(29.85). Complementary slackness states that the following conditionsare necessary and suf\ufb01cient for NxandNyto be optimal:\nmX\niD1aijNyiDcjorNxjD0forjD1 ;2;:::;n\nand\nnX\njD1aijNxjDbiorNyiD0foriD1 ;2;:::;m:", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "915": {"page_number": 916, "page_information": "Problems for Chapter 29 895\na.Verify that complementary slackness holds for the linear program in lines\n(29.53)\u2013(29.57).\nb.Prove that complementary slackness holds for any primal linear program and\nits corresponding dual.\nc.Prove that a feasible solution Nxto a primal linear program given in lines\n(29.16)\u2013(29.18) is optimal if and only if there exist values NyD.Ny1;Ny2;:::;Nym/\nsuch that\n1.Nyis a feasible solution to the dual linear program given in (29.83)\u2013(29.85),\n2.Pm\niD1aijNyiDcjfor all jsuch thatNxj>0,a n d\n3.NyiD0for all isuch thatPn\njD1aijNxj<b i.\n29-3 Integer linear programming\nAninteger linear-programming problem is a linear-programming problem with\nthe additional constraint that the variables xmust take on integral values. Exer-\ncise 34.5-3 shows that just determining whether an integer linear program has afeasible solution is NP-hard, which means that there is no known polynomial-timealgorithm for this problem.\na.Show that weak duality (Lemma 29.8) holds for an integer linear program.\nb.Show that duality (Theorem 29.10) does not always hold for an integer linear\nprogram.\nc.Given a primal linear program in standard form, let us de\ufb01ne Pto be the opti-\nmal objective value for the primal linear program, Dto be the optimal objective\nvalue for its dual, IPto be the optimal objective value for the integer version of\nthe primal (that is, the primal with the added constraint that the variables takeon integer values), and IDto be the optimal objective value for the integer ver-\nsion of the dual. Assuming that both the primal integer program and the dualinteger program are feasible and bounded, show that\nIP/DC4PDD/DC4ID:\n29-4 Farkas\u2019s lemma\nLetAbe an m/STXnmatrix and cbe an n-vector. Then Farkas\u2019s lemma states that\nexactly one of the systems", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "916": {"page_number": 917, "page_information": "896 Chapter 29 Linear Programming\nAx/DC40;\ncTx>0\nand\nATyDc;\ny/NAK0\nis solvable, where xis an n-vector and yis an m-vector. Prove Farkas\u2019s lemma.\n29-5 Minimum-cost circulation\nIn this problem, we consider a variant of the minimum-cost-\ufb02ow problem from\nSection 29.2 in which we are not given a demand, a source, or a sink. Instead,\nwe are given, as before, a \ufb02ow network and edge costs a.u;/ETB/ . A \ufb02ow is feasible\nif it satis\ufb01es the capacity constraint on every edge and \ufb02ow conservation at every\nvertex. The goal is to \ufb01nd, among all feasible \ufb02ows, the one of minimum cost. Wecall this problem the minimum-cost-circulation problem.\na.Formulate the minimum-cost-circulation problem as a linear program.\nb.Suppose that for all edges .u; /ETB/2E,w eh a v e a.u;/ETB/ > 0 . Characterize an\noptimal solution to the minimum-cost-circulation problem.\nc.Formulate the maximum-\ufb02ow problem as a minimum-cost-circulation problem\nlinear program. That is given a maximum-\ufb02ow problem instance GD.V; E/\nwith source s,s i n k tand edge capacities c, create a minimum-cost-circulation\nproblem by giving a (possibly different) network G\n0D.V0;E0/with edge\ncapacities c0and edge costs a0such that you can discern a solution to the\nmaximum-\ufb02ow problem from a solution to the minimum-cost-circulation prob-lem.\nd.Formulate the single-source shortest-path problem as a minimum-cost-circu-\nlation problem linear program.\nChapter notes\nThis chapter only begins to study the wide \ufb01eld of linear programming. A num-ber of books are devoted exclusively to linear programming, including those byChv\u00b4atal [69], Gass [130], Karloff [197], Schrijver [303], and Vanderbei [344].\nMany other books give a good coverage of linear programming, including thoseby Papadimitriou and Steiglitz [271] and Ahuja, Magnanti, and Orlin [7]. Thecoverage in this chapter draws on the approach taken by Chv\u00b4 atal.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "917": {"page_number": 918, "page_information": "Notes for Chapter 29 897\nThe simplex algorithm for linear programming was invented by G. Dantzig\nin 1947. Shortly after, researchers discovered how to formulate a number of prob-lems in a variety of \ufb01elds as linear programs and solve them with the simplexalgorithm. As a result, applications of linear programming \ufb02ourished, along withseveral algorithms. Variants of the simplex algorithm remain the most popularmethods for solving linear-programming problems. This history appears in a num-ber of places, including the notes in [69] and [197].\nThe ellipsoid algorithm was the \ufb01rst polynomial-time algorithm for linear pro-\ngramming and is due to L. G. Khachian in 1979; it was based on earlier work by\nN. Z. Shor, D. B. Judin, and A. S. Nemirovskii. Gr\u00a8 otschel, Lov\u00b4 asz, and Schrijver\n[154] describe how to use the ellipsoid algorithm to solve a variety of problems incombinatorial optimization. To date, the ellipsoid algorithm does not appear to becompetitive with the simplex algorithm in practice.\nKarmarkar\u2019s paper [198] includes a description of the \ufb01rst interior-point algo-\nrithm. Many subsequent researchers designed interior-point algorithms. Good sur-\nveys appear in the article of Goldfarb and Todd [141] and the book by Ye [361].\nAnalysis of the simplex algorithm remains an active area of research. V. Klee\nand G. J. Minty constructed an example on which the simplex algorithm runs\nthrough 2\nn/NUL1iterations. The simplex algorithm usually performs very well in\npractice and many researchers have tried to give theoretical justi\ufb01cation for thisempirical observation. A line of research begun by K. H. Borgwardt, and carriedon by many others, shows that under certain probabilistic assumptions on the in-\nput, the simplex algorithm converges in expected polynomial time. Spielman and\nTeng [322] made progress in this area, introducing the \u201csmoothed analysis of algo-rithms\u201d and applying it to the simplex algorithm.\nThe simplex algorithm is known to run ef\ufb01ciently in certain special cases. Par-\nticularly noteworthy is the network-simplex algorithm, which is the simplex al-gorithm, specialized to network-\ufb02ow problems. For certain network problems,including the shortest-paths, maximum-\ufb02ow, and minimum-cost-\ufb02ow problems,variants of the network-simplex algorithm run in polynomial time. See, for exam-ple, the article by Orlin [268] and the citations therein.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "918": {"page_number": 919, "page_information": "30 Polynomials and the FFT\nThe straightforward method of adding two polynomials of degree ntakes \u201a.n/\ntime, but the straightforward method of multiplying them takes \u201a.n2/time. In this\nchapter, we shall show how the fast Fourier transform, or FFT, can reduce the timeto multiply polynomials to \u201a.n lgn/.\nThe most common use for Fourier transforms, and hence the FFT, is in signal\nprocessing. A signal is given in the time domain : as a function mapping time to\namplitude. Fourier analysis allows us to express the signal as a weighted sum ofphase-shifted sinusoids of varying frequencies. The weights and phases associatedwith the frequencies characterize the signal in the frequency domain . Among the\nmany everyday applications of FFT\u2019s are compression techniques used to encode\ndigital video and audio information, including MP3 \ufb01les. Several \ufb01ne books delve\ninto the rich area of signal processing; the chapter notes reference a few of them.\nPolynomials\nApolynomial in the variable xover an algebraic \ufb01eld Frepresents a function A.x/\nas a formal sum:\nA.x/D\nn/NUL1X\njD0ajxj:\nWe call the values a0;a1;:::;a n/NUL1thecoef\ufb01cients of the polynomial. The co-\nef\ufb01cients are drawn from a \ufb01eld F, typically the set Cof complex numbers. A\npolynomial A.x/ hasdegree kif its highest nonzero coef\ufb01cient is ak; we write\nthat degree .A/Dk. Any integer strictly greater than the degree of a polynomial\nis adegree-bound of that polynomial. Therefore, the degree of a polynomial of\ndegree-bound nmay be any integer between 0andn/NUL1,i n c l u s i v e .\nWe can de\ufb01ne a variety of operations on polynomials. For polynomial addi-\ntion,i fA.x/ andB.x/ are polynomials of degree-bound n,t h e i r sum is a polyno-", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "919": {"page_number": 920, "page_information": "Chapter 30 Polynomials and the FFT 899\nmialC.x/ , also of degree-bound n, such that C.x/DA.x/CB.x/ for all xin the\nunderlying \ufb01eld. That is, if\nA.x/Dn/NUL1X\njD0ajxj\nand\nB.x/Dn/NUL1X\njD0bjxj;\nthen\nC.x/Dn/NUL1X\njD0cjxj;\nwhere cjDajCbjforjD0; 1; : : : ; n/NUL1. For example, if we have the\npolynomials A.x/D6x3C7x2/NUL10xC9andB.x/D/NUL2x3C4x/NUL5,t h e n\nC.x/D4x3C7x2/NUL6xC4.\nForpolynomial multiplication ,i fA.x/ andB.x/ are polynomials of degree-\nbound n,t h e i r product C.x/ is a polynomial of degree-bound 2n/NUL1such that\nC.x/DA.x/B.x/ for all xin the underlying \ufb01eld. You probably have multi-\nplied polynomials before, by multiplying each term in A.x/ by each term in B.x/\nand then combining terms with equal powers. For example, we can multiplyA.x/D6x\n3C7x2/NUL10xC9andB.x/D/NUL2x3C4x/NUL5as follows:\n6x3C7x2/NUL10xC9\n/NUL2x3C4x/NUL5\n/NUL30x3/NUL35x2C50x/NUL45\n24x4C28x3/NUL40x2C36x\n/NUL12x6/NUL14x5C20x4/NUL18x3\n/NUL12x6/NUL14x5C44x4/NUL20x3/NUL75x2C86x/NUL45\nAnother way to express the product C.x/ is\nC.x/D2n/NUL2X\njD0cjxj; (30.1)\nwhere\ncjDjX\nkD0akbj/NULk: (30.2)", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "920": {"page_number": 921, "page_information": "900 Chapter 30 Polynomials and the FFT\nNote that degree .C /Ddegree .A/Cdegree .B/, implying that if Ais a polyno-\nmial of degree-bound naandBis a polynomial of degree-bound nb,t h e n Cis a\npolynomial of degree-bound naCnb/NUL1. Since a polynomial of degree-bound k\nis also a polynomial of degree-bound kC1, we will normally say that the product\npolynomial Cis a polynomial of degree-bound naCnb.\nChapter outline\nSection 30.1 presents two ways to represent polynomials: the coef\ufb01cient represen-\ntation and the point-value representation. The straightforward methods for multi-plying polynomials\u2014equations (30.1) and (30.2)\u2014take \u201a.n\n2/t i m ew h e nw er e p -\nresent polynomials in coef\ufb01cient form, but only \u201a.n/ time when we represent them\nin point-value form. We can, however, multiply polynomials using the coef\ufb01cient\nrepresentation in only \u201a.n lgn/time by converting between the two representa-\ntions. To see why this approach works, we must \ufb01rst study complex roots of unity,which we do in Section 30.2. Then, we use the FFT and its inverse, also describedin Section 30.2, to perform the conversions. Section 30.3 shows how to implementthe FFT quickly in both serial and parallel models.\nThis chapter uses complex numbers extensively, and within this chapter we use\nthe symbol iexclusively to denotep\n/NUL1.\n30.1 Representing polynomials\nThe coef\ufb01cient and point-value representations of polynomials are in a sense equiv-\nalent; that is, a polynomial in point-value form has a unique counterpart in co-\nef\ufb01cient form. In this section, we introduce the two representations and showhow to combine them so that we can multiply two degree-bound npolynomials\nin\u201a.n lgn/time.\nCoef\ufb01cient representation\nAcoef\ufb01cient representation of a polynomial A.x/DP\nn/NUL1\njD0ajxjof degree-\nbound nis a vector of coef\ufb01cients aD.a0;a1;:::;a n/NUL1/. In matrix equations\nin this chapter, we shall generally treat vectors as column vectors.\nThe coef\ufb01cient representation is convenient for certain operations on polyno-\nmials. For example, the operation of evaluating the polynomial A.x/ at a given\npoint x0consists of computing the value of A.x 0/. We can evaluate a polynomial\nin\u201a.n/ time using Horner\u2019s rule :\nA.x 0/Da0Cx0.a1Cx0.a2C/SOH/SOH/SOHC x0.an/NUL2Cx0.an/NUL1///SOH/SOH/SOH// :", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "921": {"page_number": 922, "page_information": "30.1 Representing polynomials 901\nSimilarly, adding two polynomials represented by the coef\ufb01cient vectors aD\n.a0;a1;:::;a n/NUL1/andbD.b0;b1;:::;b n/NUL1/takes \u201a.n/ time: we just produce\nthe coef\ufb01cient vector cD.c0;c1;:::;c n/NUL1/,w h e r e cjDajCbjforjD\n0; 1; : : : ; n/NUL1.\nNow, consider multiplying two degree-bound npolynomials A.x/ andB.x/ rep-\nresented in coef\ufb01cient form. If we use the method described by equations (30.1)and (30.2), multiplying polynomials takes time \u201a.n\n2/, since we must multiply\neach coef\ufb01cient in the vector aby each coef\ufb01cient in the vector b. The operation\nof multiplying polynomials in coef\ufb01cient form seems to be considerably more dif\ufb01-\ncult than that of evaluating a polynomial or adding two polynomials. The resultingcoef\ufb01cient vector c, given by equation (30.2), is also called the convolution of the\ninput vectors aandb, denoted cDa\u02ddb. Since multiplying polynomials and\ncomputing convolutions are fundamental computational problems of considerablepractical importance, this chapter concentrates on ef\ufb01cient algorithms for them.\nPoint-value representation\nApoint-value representation of a polynomial A.x/ of degree-bound nis a set of\nnpoint-value pairs\nf.x\n0;y0/; .x 1;y1/ ;:::;. x n/NUL1;yn/NUL1/g\nsuch that all of the xkare distinct and\nykDA.x k/ (30.3)\nforkD0; 1; : : : ; n/NUL1. A polynomial has many different point-value representa-\ntions, since we can use any set of ndistinct points x0;x1;:::;x n/NUL1as a basis for\nthe representation.\nComputing a point-value representation for a polynomial given in coef\ufb01cient\nform is in principle straightforward, since all we have to do is select ndistinct\npoints x0;x1;:::;x n/NUL1a n dt h e ne v a l u a t e A.x k/forkD0; 1; : : : ; n/NUL1. With\nHorner\u2019s method, evaluating a polynomial at npoints takes time \u201a.n2/.W es h a l l\nsee later that if we choose the points xkcleverly, we can accelerate this computation\nto run in time \u201a.n lgn/.\nThe inverse of evaluation\u2014determining the coef\ufb01cient form of a polynomial\nfrom a point-value representation\u2014is interpolation . The following theorem shows\nthat interpolation is well de\ufb01ned when the desired interpolating polynomial musthave a degree-bound equal to the given number of point-value pairs.\nTheorem 30.1 (Uniqueness of an interpolating polynomial)\nFor any setf.x\n0;y0/; .x 1;y1/ ;:::;. x n/NUL1;yn/NUL1/gofnpoint-value pairs such that\nall the xkvalues are distinct, there is a unique polynomial A.x/ of degree-bound n\nsuch that ykDA.x k/forkD0; 1; : : : ; n/NUL1.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "922": {"page_number": 923, "page_information": "902 Chapter 30 Polynomials and the FFT\nProof The proof relies on the existence of the inverse of a certain matrix. Equa-\ntion (30.3) is equivalent to the matrix equation\u02d91x 0 x2\n0/SOH/SOH/SOHxn/NUL1\n0\n1x 1 x2\n1/SOH/SOH/SOHxn/NUL1\n1:::::::::::::::\n1x\nn/NUL1x2\nn/NUL1/SOH/SOH/SOHxn/NUL1\nn/NUL1/BEL\u02d9a0\na1\n:::\nan/NUL1/BEL\nD\u02d9y0\ny1\n:::\nyn/NUL1/BEL\n: (30.4)\nThe matrix on the left is denoted V.x 0;x1;:::;x n/NUL1/and is known as a Vander-\nmonde matrix. By Problem D-1, this matrix has determinant\nY\n0/DC4j< k /DC4n/NUL1.xk/NULxj/;\nand therefore, by Theorem D.5, it is invertible (that is, nonsingular) if the xkare\ndistinct. Thus, we can solve for the coef\ufb01cients ajuniquely given the point-value\nrepresentation:\naDV.x 0;x1;:::;x n/NUL1//NUL1y:\nThe proof of Theorem 30.1 describes an algorithm for interpolation based on\nsolving the set (30.4) of linear equations. Using the LU decomposition algorithmsof Chapter 28, we can solve these equations in time O.n\n3/.\nA faster algorithm for n-point interpolation is based on Lagrange\u2019s formula :\nA.x/Dn/NUL1X\nkD0ykY\nj\u00a4k.x/NULxj/\nY\nj\u00a4k.xk/NULxj/: (30.5)\nYou may wish to verify that the right-hand side of equation (30.5) is a polynomial\nof degree-bound nthat satis\ufb01es A.x k/Dykfor all k. Exercise 30.1-5 asks you\nhow to compute the coef\ufb01cients of Ausing Lagrange\u2019s formula in time \u201a.n2/.\nThus, n-point evaluation and interpolation are well-de\ufb01ned inverse operations\nthat transform between the coef\ufb01cient representation of a polynomial and a point-\nvalue representation.1The algorithms described above for these problems take\ntime\u201a.n2/.\nThe point-value representation is quite convenient for many operations on poly-\nnomials. For addition, if C.x/DA.x/CB.x/ ,t h e n C.x k/DA.x k/CB.x k/for\nany point xk. More precisely, if we have a point-value representation for A,\n1Interpolation is a notoriously tricky problem from the point of view of numerical stability. Although\nthe approaches described here are mathematically co rrect, small differences in the inputs or round-off\nerrors during computation can cause large differences in the result.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "923": {"page_number": 924, "page_information": "30.1 Representing polynomials 903\nf.x0;y0/; .x 1;y1/ ;:::;. x n/NUL1;yn/NUL1/g;\nand for B,\nf.x0;y0\n0/; .x 1;y0\n1/ ;:::;. x n/NUL1;y0\nn/NUL1/g\n(note that AandBare evaluated at the same npoints), then a point-value repre-\nsentation for Cis\nf.x0;y0Cy0\n0/; .x 1;y1Cy0\n1/ ;:::;. x n/NUL1;yn/NUL1Cy0\nn/NUL1/g:\nThus, the time to add two polynomials of degree-bound nin point-value form\nis\u201a.n/ .\nSimilarly, the point-value representation is convenient for multiplying polyno-\nmials. If C.x/DA.x/B.x/ ,t h e n C.x k/DA.x k/B.x k/for any point xk,a n d\nwe can pointwise multiply a point-value representation for Aby a point-value rep-\nresentation for Bto obtain a point-value representation for C. We must face the\nproblem, however, that degree .C /Ddegree .A/Cdegree .B/;i fAandBare of\ndegree-bound n,t h e n Cis of degree-bound 2n. A standard point-value represen-\ntation for AandBconsists of npoint-value pairs for each polynomial. When we\nmultiply these together, we get npoint-value pairs, but we need 2npairs to interpo-\nlate a unique polynomial Cof degree-bound 2n. (See Exercise 30.1-4.) We must\ntherefore begin with \u201cextended\u201d point-value representations for Aand for Bcon-\nsisting of 2npoint-value pairs each. Given an extended point-value representation\nforA,\nf.x0;y0/; .x 1;y1/ ;:::;. x 2n/NUL1;y2n/NUL1/g;\nand a corresponding extended point-value representation for B,\nf.x0;y0\n0/; .x 1;y0\n1/ ;:::;. x 2n/NUL1;y0\n2n/NUL1/g;\nthen a point-value representation for Cis\nf.x0;y0y0\n0/; .x 1;y1y0\n1/ ;:::;. x 2n/NUL1;y2n/NUL1y0\n2n/NUL1/g:\nGiven two input polynomials in extended point-value form, we see that the time to\nmultiply them to obtain the point-value form of the result is \u201a.n/ , much less than\nthe time required to multiply polynomials in coef\ufb01cient form.\nFinally, we consider how to evaluate a polynomial given in point-value form at a\nnew point. For this problem, we know of no simpler approach than converting the\npolynomial to coef\ufb01cient form \ufb01rst, and then evaluating it at the new point.\nFast multiplication of polynomials in coef\ufb01cient form\nCan we use the linear-time multiplication method for polynomials in point-value\nform to expedite polynomial multiplication in coef\ufb01cient form? The answer hinges", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "924": {"page_number": 925, "page_information": "904 Chapter 30 Polynomials and the FFT\na0;a1;:::;a n/NUL1\nb0;b1;:::;b n/NUL1c0;c1;:::;c 2n/NUL2Ordinary multiplication\nTime \u201a.n2/\nEvaluation\nTime \u201a.n lgn/ Time \u201a.n lgn/Interpolation\nPointwise multiplication\nTime \u201a.n/A.!0\n2n/; B.!0\n2n/\nA.!1\n2n/; B.!1\n2n/\nA.!2n/NUL1\n2n/; B.!2n/NUL1\n2n/::::::C.!0\n2n/\nC.!1\n2n/\nC.!2n/NUL1\n2n/Coef\ufb01cient\nPoint-value\nrepresentationsrepresentations\nFigure 30.1 A graphical outline of an ef\ufb01cient polynomial-multiplication process. Representations\non the top are in coef\ufb01cient form, while those on the bottom are in point-value form. The arrows\nfrom left to right correspond to the multiplication operation. The !2nterms are complex .2n/th roots\nof unity.\non whether we can convert a polynomial quickly from coef\ufb01cient form to point-\nvalue form (evaluate) and vice versa (interpolate).\nWe can use any points we want as evaluation points, but by choosing the eval-\nuation points carefully, we can convert between representations in only \u201a.n lgn/\ntime. As we shall see in Section 30.2, if we choose \u201ccomplex roots of unity\u201d as\nthe evaluation points, we can produce a point-value representation by taking the\ndiscrete Fourier transform (or DFT) of a coef\ufb01cient vector. We can perform the\ninverse operation, interpolation, by taking the \u201cinverse DFT\u201d of point-value pairs,yielding a coef\ufb01cient vector. Section 30.2 will show how the FFT accomplishesthe DFT and inverse DFT operations in \u201a.n lgn/time.\nFigure 30.1 shows this strategy graphically. One minor detail concerns degree-\nbounds. The product of two polynomials of degree-bound nis a polynomial of\ndegree-bound 2n. Before evaluating the input polynomials AandB, therefore,\nwe \ufb01rst double their degree-bounds to 2nby adding nhigh-order coef\ufb01cients of 0.\nBecause the vectors have 2nelements, we use \u201ccomplex .2n/th roots of unity,\u201d\nwhich are denoted by the !\n2nterms in Figure 30.1.\nGiven the FFT, we have the following \u201a.n lgn/-time procedure for multiplying\ntwo polynomials A.x/ andB.x/ of degree-bound n, where the input and output\nrepresentations are in coef\ufb01cient form. We assume that ni sap o w e ro f 2; we can\nalways meet this requirement by adding high-order zero coef\ufb01cients.\n1.Double degree-bound: Create coef\ufb01cient representations of A.x/ andB.x/ as\ndegree-bound 2npolynomials by adding nhigh-order zero coef\ufb01cients to each.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "925": {"page_number": 926, "page_information": "30.1 Representing polynomials 905\n2.Evaluate: Compute point-value representations of A.x/ andB.x/ of length 2n\nby applying the FFT of order 2non each polynomial. These representations\ncontain the values of the two polynomials at the .2n/th roots of unity.\n3.Pointwise multiply: Compute a point-value representation for the polynomial\nC.x/DA.x/B.x/ by multiplying these values together pointwise. This repre-\nsentation contains the value of C.x/ at each .2n/th root of unity.\n4.Interpolate: Create the coef\ufb01cient representation of the polynomial C.x/ by\napplying the FFT on 2npoint-value pairs to compute the inverse DFT.\nSteps (1) and (3) take time \u201a.n/ , and steps (2) and (4) take time \u201a.n lgn/. Thus,\nonce we show how to use the FFT, we will have proven the following.\nTheorem 30.2\nWe can multiply two polynomials of degree-bound nin time \u201a.n lgn/, with both\nthe input and output representations in coef\ufb01cient form.\nExercises\n30.1-1\nMultiply the polynomials A.x/D7x3/NULx2Cx/NUL10andB.x/D8x3/NUL6xC3\nusing equations (30.1) and (30.2).\n30.1-2\nAnother way to evaluate a polynomial A.x/ of degree-bound nat a given point x0\nis to divide A.x/ by the polynomial .x/NULx0/, obtaining a quotient polynomial q.x/\nof degree-bound n/NUL1and a remainder r, such that\nA.x/Dq.x/.x/NULx0/Cr:\nClearly, A.x 0/Dr. Show how to compute the remainder rand the coef\ufb01cients\nofq.x/ in time \u201a.n/ from x0and the coef\ufb01cients of A.\n30.1-3\nDerive a point-value representation for Arev.x/DPn/NUL1\njD0an/NUL1/NULjxjfrom a point-\nvalue representation for A.x/DPn/NUL1\njD0ajxj, assuming that none of the points is 0.\n30.1-4\nProve that ndistinct point-value pairs are necessary to uniquely specify a polyno-\nmial of degree-bound n, that is, if fewer than ndistinct point-value pairs are given,\nthey fail to specify a unique polynomial of degree-bound n.(Hint: Using Theo-\nrem 30.1, what can you say about a set of n/NUL1point-value pairs to which you add\none more arbitraril ychosen point-value pair?)", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "926": {"page_number": 927, "page_information": "906 Chapter 30 Polynomials and the FFT\n30.1-5\nShow how to use equation (30.5) to interpolate in time \u201a.n2/.(Hint: First compute\nthe coef\ufb01cient representation of the polynomialQ\nj.x/NULxj/a n dt h e nd i v i d eb y\n.x/NULxk/as necessary for the numerator of each term; see Exercise 30.1-2. You can\ncompute each of the ndenominators in time O.n/ .)\n30.1-6\nExplain what is wrong with the \u201cobvious\u201d approach to polynomial division usinga point-value representation, i.e., dividing the corresponding yvalues. Discuss\nseparately the case in which the division comes out exactly and the case in which\nit doesn\u2019t.\n30.1-7\nConsider two sets AandB, each having nintegers in the range from 0to10n.W e\nwish to compute the Cartesian sum ofAandB,d e \ufb01 n e db y\nCDfxCyWx2Aandy2Bg:\nNote that the integers in Care in the range from 0to20n.W e w a n t t o \ufb01 n d t h e\nelements of Cand the number of times each element of Cis realized as a sum of\nelements in AandB. Show how to solve the problem in O.n lgn/time. ( Hint:\nRepresent AandBas polynomials of degree at most 10n.)\n30.2 The DFT and FFT\nIn Section 30.1, we claimed that if we use complex roots of unity, we can evaluate\nand interpolate polynomials in \u201a.n lgn/time. In this section, we de\ufb01ne complex\nroots of unity and study their properties, de\ufb01ne the DFT, and then show how theFFT computes the DFT and its inverse in \u201a.n lgn/time.\nComplex roots of unity\nAcomplex nth root of unity is a complex number !such that\n!\nnD1:\nThere are exactly ncomplex nth roots of unity: e2/EMik=nforkD0; 1; : : : ; n/NUL1.\nTo interpret this formula, we use the de\ufb01nition of the exponential of a complexnumber:\ne\niuDcos.u/Cisin.u/ :\nFigure 30.2 shows that the ncomplex roots of unity are equally spaced around the\ncircle of unit radius centered at the origin of the complex plane. The value", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "927": {"page_number": 928, "page_information": "30.2 The DFT and FFT 907\n1 /NUL1i\n/NULi!0\n8D!8\n8!1\n8!2\n8\n!3\n8\n!4\n8\n!5\n8\n!6\n8!7\n8\nFigure 30.2 The values of !0\n8;!1\n8;:::;!7\n8in the complex plane, where !8De2/EMi=8is the prin-\ncipal 8th root of unity.\n!nDe2/EMi=n(30.6)\nis theprincipal nth root of unity ;2all other complex nth roots of unity are powers\nof!n.\nThencomplex nth roots of unity,\n!0\nn;!1\nn;:::;!n/NUL1\nn;\nform a group under multiplication (see Section 31.3). This group has the same\nstructure as the additive group .Zn;C/modulo n,s i n c e !n\nnD!0\nnD1implies that\n!j\nn!k\nnD!jCk\nnD!.jCk/modn\nn . Similarly, !/NUL1\nnD!n/NUL1\nn. The following lemmas\nfurnish some essential properties of the complex nth roots of unity.\nLemma 30.3 (Cancellation lemma)\nFor any integers n/NAK0,k/NAK0,a n d d>0 ,\n!dk\ndnD!k\nn: (30.7)\nProof The lemma follows directly from equation (30.6), since\n!dk\ndnD/NUL\ne2/EMi=dn/SOHdk\nD/NUL\ne2/EMi=n/SOHk\nD!k\nn:\n2Many other authors de\ufb01ne !ndifferently: !nDe/NUL2/EMi=n. This alternative de\ufb01nition tends to be\nused for signal-processing applications. The underlying mathematics is substantially the same with\neither de\ufb01nition of !n.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "928": {"page_number": 929, "page_information": "908 Chapter 30 Polynomials and the FFT\nCorollary 30.4\nFor any even integer n>0 ,\n!n=2\nnD!2D/NUL1:\nProof The proof is left as Exercise 30.2-1.\nLemma 30.5 (Halving lemma)\nIfn>0 is even, then the squares of the ncomplex nth roots of unity are the n=2\ncomplex .n=2/ th roots of unity.\nProof By the cancellation lemma, we have .!k\nn/2D!k\nn=2, for any nonnegative\ninteger k. Note that if we square all of the complex nth roots of unity, then we\nobtain each .n=2/ th root of unity exactly twice, since\n.!kCn=2\nn /2D!2kCn\nn\nD!2k\nn!n\nn\nD!2k\nn\nD.!k\nn/2:\nThus, !k\nnand!kCn=2\nn have the same square. We could also have used Corol-\nlary 30.4 to prove this property, since !n=2\nnD/NUL1implies !kCn=2\nnD/NUL!k\nn,a n d\nthus.!kCn=2\nn /2D.!k\nn/2.\nAs we shall see, the halving lemma is essential to our divide-and-conquer ap-\nproach for converting between coef\ufb01cient and point-value representations of poly-nomials, since it guarantees that the recursive subproblems are only half as large.\nLemma 30.6 (Summation lemma)\nFor any integer n/NAK1and nonzero integer knot divisible by n,\nn/NUL1X\njD0/NUL\n!k\nn/SOHjD0:\nProof Equation (A.5) applies to complex values as well as to reals, and so we\nhave", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "929": {"page_number": 930, "page_information": "30.2 The DFT and FFT 909\nn/NUL1X\njD0/NUL\n!k\nn/SOHjD.!k\nn/n/NUL1\n!k\nn/NUL1\nD.!n\nn/k/NUL1\n!k\nn/NUL1\nD.1/k/NUL1\n!k\nn/NUL1\nD0:\nBecause we require that kis not divisible by n, and because !k\nnD1only when k\nis divisible by n, we ensure that the denominator is not 0.\nThe DFT\nRecall that we wish to evaluate a polynomial\nA.x/Dn/NUL1X\njD0ajxj\nof degree-bound nat!0\nn;!1\nn;!2\nn;:::;!n/NUL1\nn(that is, at the ncomplex nth roots of\nunity).3We assume that Ais given in coef\ufb01cient form: aD.a0;a1;:::;a n/NUL1/.L e t\nus de\ufb01ne the results yk,f o rkD0; 1; : : : ; n/NUL1,b y\nykDA.!k\nn/\nDn/NUL1X\njD0aj!kj\nn: (30.8)\nThe vector yD.y0;y1;:::;y n/NUL1/is thediscrete Fourier transform (DFT) of the\ncoef\ufb01cient vector aD.a0;a1;:::;a n/NUL1/. We also write yDDFT n.a/.\nThe FFT\nBy using a method known as the fast Fourier transform (FFT) , which takes ad-\nvantage of the special properties of the complex roots of unity, we can computeDFT\nn.a/in time \u201a.n lgn/, as opposed to the \u201a.n2/time of the straightforward\nmethod. We assume throughout that nis an exact power of 2. Although strategies\n3The length nis actually what we referred to as 2nin Section 30.1, since we double the degree-bound\nof the given polynomials prior to evaluation. In the context of polynomial multiplication, therefore,we are actually working with complex .2n/th roots of unity.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "930": {"page_number": 931, "page_information": "910 Chapter 30 Polynomials and the FFT\nfor dealing with non-power-of- 2sizes are known, they are beyond the scope of this\nbook.\nThe FFT method employs a divide-and-conquer strategy, using the even-indexed\nand odd-indexed coef\ufb01cients of A.x/ separately to de\ufb01ne the two new polynomials\nA\u01520/c141.x/andA\u01521/c141.x/of degree-bound n=2:\nA\u01520/c141.x/Da0Ca2xCa4x2C/SOH/SOH/SOHC an/NUL2xn=2/NUL1;\nA\u01521/c141.x/Da1Ca3xCa5x2C/SOH/SOH/SOHC an/NUL1xn=2/NUL1:\nNote that A\u01520/c141contains all the even-indexed coef\ufb01cients of A(the binary represen-\ntation of the index ends in 0)a n d A\u01521/c141contains all the odd-indexed coef\ufb01cients (the\nbinary representation of the index ends in 1). It follows that\nA.x/DA\u01520/c141.x2/CxA\u01521/c141.x2/; (30.9)\nso that the problem of evaluating A.x/ at!0\nn;!1\nn;:::;!n/NUL1\nnreduces to\n1. evaluating the degree-bound n=2polynomials A\u01520/c141.x/andA\u01521/c141.x/at the points\n.!0\nn/2;. !1\nn/2;:::;. !n/NUL1\nn/2; (30.10)\nand then\n2. combining the results according to equation (30.9).\nBy the halving lemma, the list of values (30.10) consists not of ndistinct val-\nues but only of the n=2 complex .n=2/ th roots of unity, with each root occurring\nexactly twice. Therefore, we recursively evaluate the polynomials A\u01520/c141andA\u01521/c141\nof degree-bound n=2 at the n=2 complex .n=2/ th roots of unity. These subprob-\nlems have exactly the same form as the original problem, but are half the size.\nWe have now successfully divided an n-element DFT ncomputation into two n=2-\nelement DFT n=2computations. This decomposition is the basis for the follow-\ning recursive FFT algorithm, which computes the DFT of an n-element vector\naD.a0;a1;:::;a n/NUL1/,w h e r e nis a power of 2.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "931": {"page_number": 932, "page_information": "30.2 The DFT and FFT 911\nRECURSIVE -FFT .a/\n1nDa:length //nis a power of 2\n2ifn==1\n3 return a\n4!nDe2/EMi=n\n5!D1\n6a\u01520/c141D.a0;a2;:::;a n/NUL2/\n7a\u01521/c141D.a1;a3;:::;a n/NUL1/\n8y\u01520/c141DRECURSIVE -FFT .a\u01520/c141/\n9y\u01521/c141DRECURSIVE -FFT .a\u01521/c141/\n10forkD0ton=2/NUL1\n11 ykDy\u01520/c141\nkC!y\u01521/c141\nk\n12 ykC.n=2/Dy\u01520/c141\nk/NUL!y\u01521/c141\nk\n13 !D!! n\n14return y //yis assumed to be a column vector\nThe R ECURSIVE -FFT procedure works as follows. Lines 2\u20133 represent the basis\nof the recursion; the DFT of one element is the element itself, since in this case\ny0Da0!0\n1\nDa0/SOH1\nDa0:\nLines 6\u20137 de\ufb01ne the coef\ufb01cient vectors for the polynomials A\u01520/c141andA\u01521/c141.L i n e s\n4, 5, and 13 guarantee that !is updated properly so that whenever lines 11\u201312\nare executed, we have !D!k\nn. (Keeping a running value of !from iteration\nto iteration saves time over computing !k\nnfrom scratch each time through the for\nloop.) Lines 8\u20139 perform the recursive DFT n=2computations, setting, for kD\n0; 1; : : : ; n=2/NUL1,\ny\u01520/c141\nkDA\u01520/c141.!k\nn=2/;\ny\u01521/c141\nkDA\u01521/c141.!k\nn=2/;\nor, since !k\nn=2D!2k\nnby the cancellation lemma,\ny\u01520/c141\nkDA\u01520/c141.!2k\nn/;\ny\u01521/c141\nkDA\u01521/c141.!2k\nn/:", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "932": {"page_number": 933, "page_information": "912 Chapter 30 Polynomials and the FFT\nLines 11\u201312 combine the results of the recursive DFT n=2calculations. For y0;y1;\n:::;y n=2/NUL1, line 11 yields\nykDy\u01520/c141\nkC!k\nny\u01521/c141\nk\nDA\u01520/c141.!2k\nn/C!k\nnA\u01521/c141.!2k\nn/\nDA.!k\nn/ (by equation (30.9)) .\nForyn=2;yn=2C1;:::;y n/NUL1, letting kD0; 1; : : : ; n=2/NUL1, line 12 yields\nykC.n=2/Dy\u01520/c141\nk/NUL!k\nny\u01521/c141\nk\nDy\u01520/c141\nkC!kC.n=2/\nn y\u01521/c141\nk(since !kC.n=2/\nnD/NUL!k\nn)\nDA\u01520/c141.!2k\nn/C!kC.n=2/\nn A\u01521/c141.!2k\nn/\nDA\u01520/c141.!2kCn\nn/C!kC.n=2/\nn A\u01521/c141.!2kCn\nn/(since !2kCn\nnD!2k\nn)\nDA.!kC.n=2/\nn / (by equation (30.9)) .\nThus, the vector yreturned by R ECURSIVE -FFT is indeed the DFT of the input\nvector a.\nLines 11 and 12 multiply each value y\u01521/c141\nkby!k\nn,f o r kD0; 1; : : : ; n=2/NUL1.\nLine 11 adds this product to y\u01520/c141\nk, and line 12 subtracts it. Because we use each\nfactor !k\nnin both its positive and negative forms, we call the factors !k\nntwiddle\nfactors .\nTo determine the running time of procedure R ECURSIVE -FFT, we note that\nexclusive of the recursive calls, each invocation takes time \u201a.n/ ,w h e r e nis the\nlength of the input vector. The recurrence for the running time is therefore\nT .n/D2T .n=2/C\u201a.n/\nD\u201a.n lgn/ :\nThus, we can evaluate a polynomial of degree-bound nat the complex nth roots of\nunity in time \u201a.n lgn/using the fast Fourier transform.\nInterpolation at the complex roots of unity\nWe now complete the polynomial multiplication scheme by showing how to in-\nterpolate the complex roots of unity by a polynomial, which enables us to convertfrom point-value form back to coef\ufb01cient form. We interpolate by writing the DFTas a matrix equation and then looking at the form of the matrix inverse.\nFrom equation (30.4), we can write the DFT as the matrix product yDV\nna,\nwhere Vnis a Vandermonde matrix containing the appropriate powers of !n:", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "933": {"page_number": 934, "page_information": "30.2 The DFT and FFT 913/STX\ny0\ny1\ny2\ny3\n:::\nyn/NUL1/ETX\nD/STX\n11 1 1 /SOH/SOH/SOH 1\n1! n !2\nn !3\nn/SOH/SOH/SOH !n/NUL1\nn\n1!2\nn !4\nn !6\nn/SOH/SOH/SOH !2.n/NUL1/\nn\n1!3\nn !6\nn !9\nn/SOH/SOH/SOH !3.n/NUL1/\nn::::::::::::::::::\n1!\nn/NUL1\nn!2.n/NUL1/\nn !3.n/NUL1/\nn/SOH/SOH/SOH!.n/NUL1/.n/NUL1/\nn/ETX/STX\na0\na1\na2\na3\n:::\nan/NUL1/ETX\n:\nThe.k; j / entry of Vnis!kj\nn,f o r j;kD0; 1; : : : ; n/NUL1. The exponents of the\nentries of Vnform a multiplication table.\nFor the inverse operation, which we write as aDDFT/NUL1\nn.y/, we proceed by\nmultiplying yby the matrix V/NUL1\nn, the inverse of Vn.\nTheorem 30.7\nForj;kD0; 1; : : : ; n/NUL1,t h e.j; k/ entry of V/NUL1\nnis!/NULkj\nn=n.\nProof We show that V/NUL1\nnVnDIn,t h en/STXnidentity matrix. Consider the .j; j0/\nentry of V/NUL1\nnVn:\n\u0152V/NUL1\nnVn/c141jj0Dn/NUL1X\nkD0.!/NULkj\nn=n/.!kj0\nn/\nDn/NUL1X\nkD0!k.j0/NULj/\nn =n :\nThis summation equals 1ifj0Dj, and it is 0otherwise by the summation lemma\n(Lemma 30.6). Note that we rely on /NUL.n/NUL1//DC4j0/NULj/DC4n/NUL1,s ot h a t j0/NULjis\nnot divisible by n, in order for the summation lemma to apply.\nGiven the inverse matrix V/NUL1\nn,w eh a v et h a tD F T/NUL1\nn.y/is given by\najD1\nnn/NUL1X\nkD0yk!/NULkj\nn (30.11)\nforjD0; 1; : : : ; n/NUL1. By comparing equations (30.8) and (30.11), we see that\nby modifying the FFT algorithm to switch the roles of aandy, replace !nby!/NUL1\nn,\nand divide each element of the result by n, we compute the inverse DFT (see Ex-\nercise 30.2-4). Thus, we can compute DFT/NUL1\nnin\u201a.n lgn/time as well.\nWe see that, by using the FFT and the inverse FFT, we can transform a poly-\nnomial of degree-bound nback and forth between its coef\ufb01cient representation\nand a point-value representation in time \u201a.n lgn/. In the context of polynomial\nmultiplication, we have shown the following.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "934": {"page_number": 935, "page_information": "914 Chapter 30 Polynomials and the FFT\nTheorem 30.8 (Convolution theorem)\nFor any two vectors aandbof length n,w h e r e ni sap o w e ro f 2,\na\u02ddbDDFT/NUL1\n2n.DFT 2n.a//SOHDFT 2n.b// ;\nwhere the vectors aandbare padded with 0s to length 2nand/SOHdenotes the com-\nponentwise product of two 2n-element vectors.\nExercises\n30.2-1\nProve Corollary 30.4.\n30.2-2\nCompute the DFT of the vector . 0 ;1 ;2;3 / .\n30.2-3\nDo Exercise 30.1-1 by using the \u201a.n lgn/-time scheme.\n30.2-4\nWrite pseudocode to compute DFT/NUL1\nnin\u201a.n lgn/time.\n30.2-5\nDescribe the generalization of the FFT procedure to the case in which ni sap o w e r\nof3. Give a recurrence for the running time, and solve the recurrence.\n30.2-6 ?\nSuppose that instead of performing an n-element FFT over the \ufb01eld of complex\nnumbers (where nis even), we use the ring Zmof integers modulo m,w h e r e\nmD2tn=2C1andtis an arbitrary positive integer. Use !D2tinstead of !n\nas a principal nth root of unity, modulo m. Prove that the DFT and the inverse DFT\nare well de\ufb01ned in this system.\n30.2-7\nG i v e nal i s to fv a l u e s \u00b40;\u00b41;:::;\u00b4 n/NUL1(possibly with repetitions), show how to \ufb01nd\nthe coef\ufb01cients of a polynomial P.x/ of degree-bound nC1that has zeros only\nat\u00b40;\u00b41;:::;\u00b4 n/NUL1(possibly with repetitions). Your procedure should run in time\nO.n lg2n/.(Hint: The polynomial P.x/ has a zero at \u00b4jif and only if P.x/ is a\nmultiple of .x/NUL\u00b4j/.)\n30.2-8 ?\nThechirp transform of a vector aD.a0;a1;:::;a n/NUL1/is the vector yD\n.y0;y1;:::;y n/NUL1/,w h e r e ykDPn/NUL1\njD0aj\u00b4kjand\u00b4is any complex number. The", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "935": {"page_number": 936, "page_information": "30.3 Ef\ufb01cient FFT implementations 915\nDFT is therefore a special case of the chirp transform, obtained by taking \u00b4D!n.\nShow how to evaluate the chirp transform in time O.n lgn/for any complex num-\nber\u00b4.(Hint: Use the equation\nykD\u00b4k2=2n/NUL1X\njD0/DLE\naj\u00b4j2=2/DC1/DLE\n\u00b4/NUL.k/NULj/2=2/DC1\nto view the chirp transform as a convolution.)\n30.3 Ef\ufb01cient FFT implementations\nSince the practical applications of the DFT, such as signal processing, demand the\nutmost speed, this section examines two ef\ufb01cient FFT implementations. First, we\nshall examine an iterative version of the FFT algorithm that runs in \u201a.n lgn/time\nbut can have a lower constant hidden in the \u201a-notation than the recursive version\nin Section 30.2. (Depending on the exact implementation, the recursive versionmay use the hardware cache more ef\ufb01ciently.) Then, we shall use the insights thatled us to the iterative implementation to design an ef\ufb01cient parallel FFT circuit.\nAn iterative FFT implementation\nWe \ufb01rst note that the forloop of lines 10\u201313 of R\nECURSIVE -FFT involves com-\nputing the value !k\nny\u01521/c141\nktwice. In compiler terminology, we call such a value a\ncommon subexpression . We can change the loop to compute it only once, storing\nit in a temporary variable t.\nforkD0ton=2/NUL1\ntD!y\u01521/c141\nk\nykDy\u01520/c141\nkCt\nykC.n=2/Dy\u01520/c141\nk/NULt\n!D!! n\nThe operation in this loop, multiplying the twiddle factor !D!k\nnbyy\u01521/c141\nk, storing\nthe product into t, and adding and subtracting tfrom y\u01520/c141\nk, is known as a butter\ufb02y\noperation and is shown schematically in Figure 30.3.\nWe now show how to make the FFT algorithm iterative rather than recursive\nin structure. In Figure 30.4, we have arranged the input vectors to the recursivecalls in an invocation of R\nECURSIVE -FFT in a tree structure, where the initial\ncall is for nD8. The tree has one node for each call of the procedure, labeled", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "936": {"page_number": 937, "page_information": "916 Chapter 30 Polynomials and the FFT\n+\n\u2013 \u2022\n(a) (b)y\u01520/c141\nky\u01520/c141\nk\ny\u01521/c141\nky\u01521/c141\nk!k\nn !k\nny\u01520/c141\nkC!k\nny\u01521/c141\nky\u01520/c141\nkC!k\nny\u01521/c141\nk\ny\u01520/c141\nk/NUL!k\nny\u01521/c141\nky\u01520/c141\nk/NUL!k\nny\u01521/c141\nk\nFigure 30.3 A butter\ufb02y operation. (a)The two input values enter from the left, the twiddle fac-\ntor!k\nnis multiplied by y\u01521/c141\nk, and the sum and difference are output on the right. (b)As i m p l i \ufb01 e d\ndrawing of a butter\ufb02y operation. We will use this representation in a parallel FFT circuit.\n(a0,a1,a2,a3,a4,a5,a6,a7)\n(a0,a2,a4,a6)\n(a0,a4)( a2,a6)\n(a0)( a4)( a2)( a6)(a1,a3,a5,a7)\n(a1,a5)\n(a1)( a5)(a3,a7)\n(a3)( a7)\nFigure 30.4 The tree of input vectors to the recursive calls of the R ECURSIVE -FFT procedure. The\ninitial invocation is for nD8.\nby the corresponding input vector. Each R ECURSIVE -FFT invocation makes two\nrecursive calls, unless it has received a 1-element vector. The \ufb01rst call appears in\nthe left child, and the second call appears in the right child.\nLooking at the tree, we observe that if we could arrange the elements of the\ninitial vector ainto the order in which they appear in the leaves, we could trace\nthe execution of the R ECURSIVE -FFT procedure, but bottom up instead of top\ndown. First, we take the elements in pairs, compute the DFT of each pair usingone butter\ufb02y operation, and replace the pair with its DFT. The vector then holdsn=2 2 -element DFTs. Next, we take these n=2 DFTs in pairs and compute the\nDFT of the four vector elements they come from by executing two butter\ufb02y oper-ations, replacing two 2-element DFTs with one 4-element DFT. The vector then\nholds n=4 4 -element DFTs. We continue in this manner until the vector holds two\n.n=2/ -element DFTs, which we combine using n=2 butter\ufb02y operations into the\n\ufb01naln-element DFT.\nTo turn this bottom-up approach into code, we use an array A\u01520 : : n/NUL1/c141that\ninitially holds the elements of the input vector ain the order in which they appear", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "937": {"page_number": 938, "page_information": "30.3 Ef\ufb01cient FFT implementations 917\nin the leaves of the tree of Figure 30.4. (We shall show later how to determine this\norder, which is known as a bit-reversal permutation.) Because we have to combineDFTs on each level of the tree, we introduce a variable sto count the levels, ranging\nfrom 1(at the bottom, when we are combining pairs to form 2-element DFTs)\nto lgn(at the top, when we are combining two .n=2/ -element DFTs to produce the\n\ufb01nal result). The algorithm therefore has the following structure:\n1forsD1tolgn\n2 forkD0ton/NUL1by2\ns\n3 combine the two 2s/NUL1-element DFTs in\nA\u0152k : : kC2s/NUL1/NUL1/c141andA\u0152kC2s/NUL1::kC2s/NUL1/c141\ninto one 2s-element DFT in A\u0152k : : kC2s/NUL1/c141\nWe can express the body of the loop (line 3) as more precise pseudocode. We\ncopy the forloop from the R ECURSIVE -FFT procedure, identifying y\u01520/c141with\nA\u0152k : : kC2s/NUL1/NUL1/c141andy\u01521/c141with A\u0152kC2s/NUL1::kC2s/NUL1/c141. The twiddle fac-\ntor used in each butter\ufb02y operation depends on the value of s;i ti sap o w e ro f !m,\nwhere mD2s. (We introduce the variable msolely for the sake of readability.)\nWe introduce another temporary variable uthat allows us to perform the butter\ufb02y\noperation in place. When we replace line 3 of the overall structure by the loop\nbody, we get the following pseudocode, which forms the basis of the parallel im-\nplementation we shall present later. The code \ufb01rst calls the auxiliary procedure\nBIT-REVERSE -COPY.a; A/ to copy vector ainto array Ain the initial order in\nwhich we need the values.\nITERATIVE -FFT .a/\n1B IT-REVERSE -COPY.a; A/\n2nDa:length //nis a power of 2\n3forsD1tolgn\n4 mD2s\n5 !mDe2/EMi=m\n6 forkD0ton/NUL1bym\n7 !D1\n8 forjD0tom=2/NUL1\n9 tD! A\u0152kCjCm=2/c141\n10 uDA\u0152kCj/c141\n11 A\u0152kCj/c141DuCt\n12 A\u0152kCjCm=2/c141Du/NULt\n13 !D!! m\n14return A\nHow does B IT-REVERSE -COPY get the elements of the input vector ainto the\ndesired order in the array A? The order in which the leaves appear in Figure 30.4", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "938": {"page_number": 939, "page_information": "918 Chapter 30 Polynomials and the FFT\nis abit-reversal permutation . That is, if we let rev .k/be the lg n-bit integer\nformed by reversing the bits of the binary representation of k,t h e nw ew a n tt o\nplace vector element akin array position A\u0152rev.k//c141. In Figure 30.4, for exam-\nple, the leaves appear in the order 0; 4; 2; 6; 1; 5; 3; 7 ; this sequence in binary is\n000; 100; 010; 110; 001; 101; 011; 111 , and when we reverse the bits of each value\nwe get the sequence 000; 001; 010; 011; 100; 101; 110; 111 . To see that we want a\nbit-reversal permutation in general, we note that at the top level of the tree, indiceswhose low-order bit is 0go into the left subtree and indices whose low-order bit\nis1go into the right subtree. Stripping off the low-order bit at each level, we con-\ntinue this process down the tree, until we get the order given by the bit-reversalpermutation at the leaves.\nSince we can easily compute the function rev .k/,t h eB\nIT-REVERSE -COPY pro-\ncedure is simple:\nBIT-REVERSE -COPY.a; A/\n1nDa:length\n2forkD0ton/NUL1\n3 A\u0152rev.k//c141Dak\nThe iterative FFT implementation runs in time \u201a.n lgn/. The call to B IT-\nREVERSE -COPY.a; A/ certainly runs in O.n lgn/time, since we iterate ntimes\nand can reverse an integer between 0 and n/NUL1, with lg nbits, in O.lgn/time.\n(In practice, because we usually know the initial value of nin advance, we would\nprobably code a table mapping kto rev .k/,m a k i n gB IT-REVERSE -COPY run in\n\u201a.n/ time with a low hidden constant. Alternatively, we could use the clever amor-\ntized reverse binary counter scheme described in Problem 17-1.) To complete the\nproof that I TERATIVE -FFT runs in time \u201a.n lgn/, we show that L.n/ , the number\nof times the body of the innermost loop (lines 8\u201313) executes, is \u201a.n lgn/.T h e\nforloop of lines 6\u201313 iterates n=mDn=2stimes for each value of s,a n dt h e\ninnermost loop of lines 8\u201313 iterates m=2D2s/NUL1times. Thus,\nL.n/DlgnX\nsD1n\n2s/SOH2s/NUL1\nDlgnX\nsD1n\n2\nD\u201a.n lgn/ :", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "939": {"page_number": 940, "page_information": "30.3 Ef\ufb01cient FFT implementations 919\na0\na1\na2\na3\na4\na5\na6\na7y0\ny1\ny2\ny3\ny4\ny5\ny6\ny7\nstage sD1 stage sD2 stage sD3!0\n2!0\n2!0\n2!0\n2\n!0\n4!0\n4\n!1\n4!1\n4\n!0\n8\n!1\n8\n!2\n8\n!3\n8\nFigure 30.5 A circuit that computes the FFT in parallel, here shown on nD8inputs. Each\nbutter\ufb02y operation takes as input the values on two wires, along with a twiddle factor, and it produces\nas outputs the values on two wires. The stages of butter\ufb02ies are labeled to correspond to iterations\nof the outermost loop of the I TERA TIVE -FFT procedure. Only the top and bottom wires passing\nthrough a butter\ufb02y interact with it; wires that pass through the middle of a butter\ufb02y do not affect\nthat butter\ufb02y, nor are their values changed by that butter\ufb02y. For example, the top butter\ufb02y in stage 2\nhas nothing to do with wire 1(the wire whose output is labeled y1); its inputs and outputs are only\non wires 0and2(labeled y0andy2, respectively). This circuit has depth \u201a.lgn/and performs\n\u201a.n lgn/butter\ufb02y operations altogether.\nA parallel FFT circuit\nWe can exploit many of the properties that allowed us to implement an ef\ufb01cient\niterative FFT algorithm to produce an ef\ufb01cient parallel algorithm for the FFT. We\nwill express the parallel FFT algorithm as a circuit. Figure 30.5 shows a parallelFFT circuit, which computes the FFT on ninputs, for nD8. The circuit begins\nwith a bit-reverse permutation of the inputs, followed by lg nstages, each stage\nconsisting of n=2 butter\ufb02ies executed in parallel. The depth of the circuit\u2014the\nmaximum number of computational elements between any output and any input\nthat can reach it\u2014is therefore \u201a.lgn/.\nThe leftmost part of the parallel FFT circuit performs the bit-reverse permuta-\ntion, and the remainder mimics the iterative I\nTERATIVE -FFT procedure. Because\neach iteration of the outermost forloop performs n=2independent butter\ufb02y opera-\ntions, the circuit performs them in parallel. The value of sin each iteration within", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "940": {"page_number": 941, "page_information": "920 Chapter 30 Polynomials and the FFT\nITERATIVE -FFT corresponds to a stage of butter\ufb02ies shown in Figure 30.5. For\nsD1 ;2;:::; lgn,s t a g e sconsists of n=2sgroups of butter\ufb02ies (corresponding to\neach value of kin ITERATIVE -FFT), with 2s/NUL1butter\ufb02ies per group (corresponding\nto each value of jin ITERATIVE -FFT). The butter\ufb02ies shown in Figure 30.5 corre-\nspond to the butter\ufb02y operations of the innermost loop (lines 9\u201312 of I TERATIVE -\nFFT). Note also that the twiddle factors used in the butter\ufb02ies correspond to those\nused in I TERATIVE -FFT: in stage s,w eu s e !0\nm;!1\nm;:::;!m=2/NUL1\nm ,w h e r e mD2s.\nExercises\n30.3-1\nShow how I TERATIVE -FFT computes the DFT of the input vector . 0 ;2;3 ;/NUL1; 4;\n5; 7; 9/ .\n30.3-2\nShow how to implement an FFT algorithm with the bit-reversal permutation occur-ring at the end, rather than at the beginning, of the computation. ( Hint: Consider\nthe inverse DFT.)\n30.3-3\nHow many times does I\nTERATIVE -FFT compute twiddle factors in each stage?\nRewrite I TERATIVE -FFT to compute twiddle factors only 2s/NUL1times in stage s.\n30.3-4 ?\nSuppose that the adders within the butter\ufb02y operations of the FFT circuit some-times fail in such a manner that they always produce a zero output, independentof their inputs. Suppose that exactly one adder has failed, but that you don\u2019t knowwhich one. Describe how you can identify the failed adder by supplying inputs tothe overall FFT circuit and observing the outputs. How ef\ufb01cient is your method?\nProblems\n30-1 Divide-and-conquer multiplicationa.Show how to multiply two linear polynomials axCbandcxCdusing only\nthree multiplications. ( Hint: One of the multiplications is .aCb//SOH.cCd/.)\nb.Give two divide-and-conquer algorithms for multiplying two polynomials of\ndegree-bound nin\u201a.n\nlg3/time. The \ufb01rst algorithm should divide the input\npolynomial coef\ufb01cients into a high half and a low half, and the second algorithmshould divide them according to whether their index is odd or even.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "941": {"page_number": 942, "page_information": "Problems for Chapter 30 921\nc.Show how to multiply two n-bit integers in O.nlg3/steps, where each step\noperates on at most a constant number of 1-bit values.\n30-2 Toeplitz matrices\nAToeplitz matrix is an n/STXnmatrix AD.aij/such that aijDai/NUL1;j/NUL1for\niD2;3 ;:::;n andjD2;3 ;:::;n .\na.Is the sum of two Toeplitz matrices necessarily Toeplitz? What about the prod-\nuct?\nb.Describe how to represent a Toeplitz matrix so that you can add two n/STXn\nToeplitz matrices in O.n/ time.\nc.Give an O.n lgn/-time algorithm for multiplying an n/STXnToeplitz matrix by a\nvector of length n. Use your representation from part (b).\nd.Give an ef\ufb01cient algorithm for multiplying two n/STXnToeplitz matrices. Analyze\nits running time.\n30-3 Multidimensional fast Fourier transform\nWe can generalize the 1-dimensional discrete Fourier transform de\ufb01ned by equa-\ntion (30.8) to ddimensions. The input is a d-dimensional array AD.aj1;j2;:::;j d/\nwhose dimensions are n1;n2;:::;n d,w h e r e n1n2/SOH/SOH/SOHndDn.W e d e \ufb01 n e t h e\nd-dimensional discrete Fourier transform by the equation\nyk1;k2;:::;k dDn1/NUL1X\nj1D0n2/NUL1X\nj2D0/SOH/SOH/SOHnd/NUL1X\njdD0aj1;j2;:::;j d!j1k1\nn1!j2k2\nn2/SOH/SOH/SOH!jdkd\nnd\nfor0/DC4k1<n 1,0/DC4k2<n 2,..., 0/DC4kd<n d.\na.Show that we can compute a d-dimensional DFT by computing 1-dimensional\nDFTs on each dimension in turn. That is, we \ufb01rst compute n=n 1separate\n1-dimensional DFTs along dimension 1. Then, using the result of the DFTs\nalong dimension 1as the input, we compute n=n 2separate 1-dimensional DFTs\nalong dimension 2. Using this result as the input, we compute n=n 3separate\n1-dimensional DFTs along dimension 3, and so on, through dimension d.\nb.Show that the ordering of dimensions does not matter, so that we can compute\nad-dimensional DFT by computing the 1-dimensional DFTs in any order of\ntheddimensions.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "942": {"page_number": 943, "page_information": "922 Chapter 30 Polynomials and the FFT\nc.Show that if we compute each 1-dimensional DFT by computing the fast Four-\nier transform, the total time to compute a d-dimensional DFT is O.n lgn/,\nindependent of d.\n30-4 Evaluating all derivatives of a polynomial at a point\nGiven a polynomial A.x/ of degree-bound n, we de\ufb01ne its tth derivative by\nA.t/.x/D\u201e\nA.x/ iftD0;\nd\ndxA.t/NUL1/.x/ if1/DC4t/DC4n/NUL1;\n0 ift/NAKn:\nFrom the coef\ufb01cient representation .a0;a1;:::;a n/NUL1/ofA.x/ and a given point x0,\nwe wish to determine A.t/.x0/fortD0; 1; : : : ; n/NUL1.\na.Given coef\ufb01cients b0;b1;:::;b n/NUL1such that\nA.x/Dn/NUL1X\njD0bj.x/NULx0/j;\nshow how to compute A.t/.x0/,f o rtD0; 1; : : : ; n/NUL1,i nO.n/ time.\nb.Explain how to \ufb01nd b0;b1;:::;b n/NUL1inO.n lgn/time, given A.x 0C!k\nn/for\nkD0; 1; : : : ; n/NUL1.\nc.Prove that\nA.x 0C!k\nn/Dn/NUL1X\nrD0 \n!kr\nn\nr\u0160n/NUL1X\njD0f. j/ g. r/NULj/!\n;\nwhere f. j/Daj/SOHj\u0160and\ng.l/D(\nx/NULl\n0=./NULl/\u0160 if/NUL.n/NUL1//DC4l/DC40;\n0 if1/DC4l/DC4n/NUL1:\nd.Explain how to evaluate A.x 0C!k\nn/forkD0; 1; : : : ; n/NUL1inO.n lgn/\ntime. Conclude that we can evaluate all nontrivial derivatives of A.x/ atx0in\nO.n lgn/time.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "943": {"page_number": 944, "page_information": "Problems for Chapter 30 923\n30-5 Polynomial evaluation at multiple points\nWe have seen how to evaluate a polynomial of degree-bound nat a single point in\nO.n/ time using Horner\u2019s rule. We have also discovered how to evaluate such a\npolynomial at all ncomplex roots of unity in O.n lgn/time using the FFT. We\nshall now show how to evaluate a polynomial of degree-bound natnarbitrary\npoints in O.n lg2n/time.\nTo do so, we shall assume that we can compute the polynomial remainder when\none such polynomial is divided by another in O.n lgn/time, a result that we state\nwithout proof. For example, the remainder of 3x3Cx2/NUL3xC1when divided by\nx2CxC2is\n.3x3Cx2/NUL3xC1/mod.x2CxC2/D/NUL7xC5:\nGiven the coef\ufb01cient representation of a polynomial A.x/DPn/NUL1\nkD0akxkand\nnpoints x0;x1;:::;x n/NUL1, we wish to compute the nvalues A.x 0/; A.x 1/ ;:::;\nA.x n/NUL1/.F o r 0/DC4i/DC4j/DC4n/NUL1, de\ufb01ne the polynomials Pij.x/DQj\nkDi.x/NULxk/\nandQij.x/DA.x/ modPij.x/. Note that Qij.x/has degree at most j/NULi.\na.Prove that A.x/ mod.x/NUL\u00b4/DA.\u00b4/ for any point \u00b4.\nb.Prove that Qkk.x/DA.x k/and that Q0;n/NUL1.x/DA.x/ .\nc.Prove that for i/DC4k/DC4j,w eh a v e Qik.x/DQij.x/modPik.x/and\nQkj.x/DQij.x/modPkj.x/.\nd.Give an O.n lg2n/-time algorithm to evaluate A.x 0/; A.x 1/ ;:::;A . x n/NUL1/.\n30-6 FFT using modular arithmetic\nAs de\ufb01ned, the discrete Fourier transform requires us to compute with complexnumbers, which can result in a loss of precision due to round-off errors. For someproblems, the answer is known to contain only integers, and by using a variant ofthe FFT based on modular arithmetic, we can guarantee that the answer is calcu-lated exactly. An example of such a problem is that of multiplying two polynomialswith integer coef\ufb01cients. Exercise 30.2-6 gives one approach, using a modulus oflength /DEL.n/ bits to handle a DFT on npoints. This problem gives another ap-\nproach, which uses a modulus of the more reasonable length O.lgn/; it requires\nthat you understand the material of Chapter 31. Let nbe a power of 2.\na.Suppose that we search for the smallest ksuch that pDknC1is prime. Give\na simple heuristic argument why we might expect kto be approximately ln n.\n(The value of kmight be much larger or smaller, but we can reasonably expect\nto examine O.lgn/candidate values of kon average.) How does the expected\nlength of pcompare to the length of n?", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "944": {"page_number": 945, "page_information": "924 Chapter 30 Polynomials and the FFT\nLetgbe a generator of Z/ETX\np,a n dl e t wDgkmodp.\nb.Argue that the DFT and the inverse DFT are well-de\ufb01ned inverse operations\nmodulo p,w h e r e wis used as a principal nth root of unity.\nc.Show how to make the FFT and its inverse work modulo pin time O.n lgn/,\nwhere operations on words of O.lgn/bits take unit time. Assume that the\nalgorithm is given pandw.\nd.Compute the DFT modulo pD17of the vector . 0 ;5 ;3 ;7 ;7 ;2;1 ;6 / . Note that\ngD3is a generator of Z/ETX\n17.\nChapter notes\nVan Loan\u2019s book [343] provides an outstanding treatment of the fast Fourier trans-\nform. Press, Teukolsky, Vetterling, and Flannery [283, 284] have a good descrip-tion of the fast Fourier transform and its applications. For an excellent introduction\nto signal processing, a popular FFT application area, see the texts by Oppenheim\nand Schafer [266] and Oppenheim and Willsky [267]. The Oppenheim and Schaferbook also shows how to handle cases in which nis not an integer power of 2.\nFourier analysis is not limited to 1-dimensional data. It is widely used in image\nprocessing to analyze data in 2or more dimensions. The books by Gonzalez and\nWoods [146] and Pratt [281] discuss multidimensional Fourier transforms and their\nuse in image processing, and books by Tolimieri, An, and Lu [338] and Van Loan[343] discuss the mathematics of multidimensional fast Fourier transforms.\nCooley and Tukey [76] are widely credited with devising the FFT in the 1960s.\nThe FFT had in fact been discovered many times previously, but its importance wasnot fully realized before the advent of modern digital computers. Although Press,Teukolsky, Vetterling, and Flannery attribute the origins of the method to Rungeand K\u00a8 onig in 1924, an article by Heideman, Johnson, and Burrus [163] traces the\nhistory of the FFT as far back as C. F. Gauss in 1805.\nFrigo and Johnson [117] developed a fast and \ufb02exible implementation of the\nFFT, called FFTW (\u201cfastest Fourier transform in the West\u201d). FFTW is designed forsituations requiring multiple DFT computations on the same problem size. Beforeactually computing the DFTs, FFTW executes a \u201cplanner,\u201d which, by a series oftrial runs, determines how best to decompose the FFT computation for the givenproblem size on the host machine. FFTW adapts to use the hardware cache ef-\ufb01ciently, and once subproblems are small enough, FFTW solves them with opti-mized, straight-line code. Furthermore, FFTW has the unusual advantage of taking\u201a.n lgn/time for any problem size n,e v e nw h e n nis a large prime.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "945": {"page_number": 946, "page_information": "Notes for Chapter 30 925\nAlthough the standard Fourier transform assumes that the input represents points\nthat are uniformly spaced in the time domain, other techniques can approximate theFFT on \u201cnonequispaced\u201d data. The article by Ware [348] provides an overview.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "946": {"page_number": 947, "page_information": "31 Number-Theoretic Algorithms\nNumber theory was once viewed as a beautiful but largely useless subject in pure\nmathematics. Today number-theoretic algorithms are used widely, due in large partto the invention of cryptographic schemes based on large prime numbers. Theseschemes are feasible because we can \ufb01nd large primes easily, and they are securebecause we do not know how to factor the product of large primes (or solve relatedproblems, such as computing discrete logarithms) ef\ufb01ciently. This chapter presentssome of the number theory and related algorithms that underlie such applications.\nSection 31.1 introduces basic concepts of number theory, such as divisibility,\nmodular equivalence, and unique factorization. Section 31.2 studies one of theworld\u2019s oldest algorithms: Euclid\u2019s algorithm for computing the greatest commondivisor of two integers. Section 31.3 reviews concepts of modular arithmetic. Sec-tion 31.4 then studies the set of multiples of a given number a, modulo n,a n ds h o w s\nhow to \ufb01nd all solutions to the equation ax/DC1b.mod n/by using Euclid\u2019s algo-\nrithm. The Chinese remainder theorem is presented in Section 31.5. Section 31.6\nconsiders powers of a given number a, modulo n, and presents a repeated-squaring\nalgorithm for ef\ufb01ciently computing a\nbmodn,g i v e n a,b,a n d n. This operation is\nat the heart of ef\ufb01cient primality testing and of much modern cryptography. Sec-tion 31.7 then describes the RSA public-key cryptosystem. Section 31.8 examinesa randomized primality test. We can use this test to \ufb01nd large primes ef\ufb01ciently,which we need to do in order to create keys for the RSA cryptosystem. Finally,Section 31.9 reviews a simple but effective heuristic for factoring small integers. Itis a curious fact that factoring is one problem people may wish to be intractable,since the security of RSA depends on the dif\ufb01culty of factoring large integers.\nSize of inputs and cost of arithmetic computations\nBecause we shall be working with large integers, we need to adjust how we think\nabout the size of an input and about the cost of elementary arithmetic operations.\nIn this chapter, a \u201clarge input\u201d typically means an input containing \u201clarge in-\ntegers\u201d rather than an input containing \u201cmany integers\u201d (as for sorting). Thus,", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "947": {"page_number": 948, "page_information": "31.1 Elementary number-theoretic notions 927\nwe shall measure the size of an input in terms of the number of bits required to\nrepresent that input, not just the number of integers in the input. An algorithmwith integer inputs a\n1;a2;:::;a kis apolynomial-time algorithm if it runs in time\npolynomial in lg a1;lga2;:::; lgak, that is, polynomial in the lengths of its binary-\nencoded inputs.\nIn most of this book, we have found it convenient to think of the elemen-\ntary arithmetic operations (multiplications, divisions, or computing remainders)as primitive operations that take one unit of time. By counting the number of such\narithmetic operations that an algorithm performs, we have a basis for making a\nreasonable estimate of the algorithm\u2019s actual running time on a computer. Elemen-tary operations can be time-consuming, however, when their inputs are large. Itthus becomes convenient to measure how many bit operations a number-theoretic\nalgorithm requires. In this model, multiplying two \u02c7-bit integers by the ordinary\nmethod uses \u201a.\u02c7\n2/bit operations. Similarly, we can divide a \u02c7-bit integer by a\nshorter integer or take the remainder of a \u02c7-bit integer when divided by a shorter in-\nteger in time \u201a.\u02c72/by simple algorithms. (See Exercise 31.1-12.) Faster methods\nare known. For example, a simple divide-and-conquer method for multiplying two\n\u02c7-bit integers has a running time of \u201a.\u02c7lg3/, and the fastest known method has\na running time of \u201a.\u02c7 lg\u02c7lg lg\u02c7/. For practical purposes, however, the \u201a.\u02c72/\nalgorithm is often best, and we shall use this bound as a basis for our analyses.\nWe shall generally analyze algorithms in this chapter in terms of both the number\nof arithmetic operations and the number of bit operations they require.\n31.1 Elementary number-theoretic notions\nThis section provides a brief review of notions from elementary number theoryconcerning the set ZDf:::;/NUL2;/NUL1; 0; 1; 2; : : :gof integers and the set ND\nf0; 1; 2; : : :gof natural numbers.\nDivisibility and divisors\nThe notion of one integer being divisible by another is key to the theory of numbers.\nThe notation dja(read \u201c ddivides a\u201d) means that aDkdfor some integer k.\nEvery integer divides 0.I fa>0 anddja,t h e njdj/DC4jaj.I fdja,t h e nw ea l s o\nsay that ais amultiple ofd.I fddoes not divide a, we write d\u2212a.\nIfdjaandd/NAK0, we say that dis adivisor ofa. Note that djaif and only\nif/NULdja, so that no generality is lost by de\ufb01ning the divisors to be nonnegative,\nwith the understanding that the negative of any divisor of aalso divides a.A", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "948": {"page_number": 949, "page_information": "928 Chapter 31 Number-Theoretic Algorithms\ndivisor of a nonzero integer ais at least 1but not greater than jaj. For example, the\ndivisors of 24are1,2,3,4,6,8,12,a n d 24.\nEvery positive integer ais divisible by the trivial divisors 1anda. The nontrivial\ndivisors of aare the factors ofa. For example, the factors of 20are2,4,5,a n d 10.\nPrime and composite numbers\nAn integer a>1 whose only divisors are the trivial divisors 1andais aprime\nnumber or, more simply, a prime . Primes have many special properties and play a\ncritical role in number theory. The \ufb01rst 20 primes, in order, are\n2; 3; 5; 7; 11; 13; 17; 19; 23; 29; 31; 37; 41; 43; 47; 53; 59; 61; 67; 71 :Exercise 31.1-2 asks you to prove that there are in\ufb01nitely many primes. An integer\na>1 that is not prime is a composite number or, more simply, a composite .F o r\nexample, 39is composite because 3j39. We call the integer 1aunit, and it is\nneither prime nor composite. Similarly, the integer 0and all negative integers are\nneither prime nor composite.\nThe division theorem, remainders, and modular equivalence\nG i v e na ni n t e g e r n, we can partition the integers into those that are multiples of n\nand those that are not multiples of n. Much number theory is based upon re\ufb01ning\nthis partition by classifying the nonmultiples of naccording to their remainders\nwhen divided by\nn. The following theorem provides the basis for this re\ufb01nement.\nWe omit the proof (but see, for example, Niven and Zuckerman [265]).\nTheorem 31.1 (Division theorem)\nFor any integer aand any positive integer n, there exist unique integers qandr\nsuch that 0/DC4r<n andaDqnCr.\nThe value qDba=ncis the quotient of the division. The value rDamodn\nis the remainder (orresidue ) of the division. We have that njaif and only if\namodnD0.\nWe can partition the integers into nequivalence classes according to their re-\nmainders modulo n.T h eequivalence class modulo ncontaining an integer ais\n\u0152a/c141nDfaCknWk2Zg:\nFor example, \u01523/c1417Df:::;/NUL11;/NUL4; 3; 10; 17; : : :g; we can also denote this set by\n\u0152/NUL4/c1417and\u015210/c141 7. Using the notation de\ufb01ned on page 54, we can say that writing\na2\u0152b/c141nis the same as writing a/DC1b.mod n/. The set of all such equivalence\nclasses is", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "949": {"page_number": 950, "page_information": "31.1 Elementary number-theoretic notions 929\nZnDf\u0152a/c141nW0/DC4a/DC4n/NUL1g: (31.1)\nWhen you see the de\ufb01nition\nZnDf0; 1; : : : ; n/NUL1g; (31.2)\nyou should read it as equivalent to equation (31.1) with the understanding that 0\nrepresents \u01520/c141n,1represents \u01521/c141n, and so on; each class is represented by its smallest\nnonnegative element. You should keep the underlying equivalence classes in mind,however. For example, if we refer to /NUL1a sam e m b e ro f Z\nn, we are really referring\nto\u0152n/NUL1/c141n,s i n c e/NUL1/DC1n/NUL1.mod n/.\nCommon divisors and greatest common divisors\nIfdis a divisor of aanddis also a divisor of b,t h e n dis acommon divisor ofa\nandb. For example, the divisors of 30are1,2,3,5,6,10,15,a n d 30,a n ds ot h e\ncommon divisors of 24and30are1,2,3,a n d 6. Note that 1is a common divisor\nof any two integers.\nAn important property of common divisors is that\ndjaanddjbimplies dj.aCb/anddj.a/NULb/ : (31.3)\nMore generally, we have that\ndjaanddjbimplies dj.axCby/ (31.4)\nfor any integers xandy. Also, if ajb, then eitherjaj/DC4jbjorbD0,w h i c h\nimplies that\najbandbjaimplies aD\u02d9b: (31.5)\nThegreatest common divisor of two integers aandb, not both zero, is the\nlargest of the common divisors of aandb;w ed e n o t ei tb yg c d .a; b/ . For example,\ngcd.24; 30/D6,g c d.5; 7/D1, and gcd .0; 9/D9.I faandbare both nonzero,\nthen gcd .a; b/ is an integer between 1and min .jaj;jbj/. We de\ufb01ne gcd .0; 0/ to\nbe0; this de\ufb01nition is necessary to make standard properties of the gcd function\n(such as equation (31.9) below) universally valid.\nThe following are elementary properties of the gcd function:\ngcd.a; b/Dgcd.b; a/ ; (31.6)\ngcd.a; b/Dgcd./NULa;b/ ; (31.7)\ngcd.a; b/Dgcd.jaj;jbj/; (31.8)\ngcd.a; 0/Djaj; (31.9)\ngcd.a; ka/Djaj for any k2Z: (31.10)\nThe following theorem provides an alternative and useful characterization of\ngcd.a; b/ .", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "950": {"page_number": 951, "page_information": "930 Chapter 31 Number-Theoretic Algorithms\nTheorem 31.2\nIfaandbare any integers, not both zero, then gcd .a; b/ is the smallest positive\nelement of the setfaxCbyWx;y2Zgof linear combinations of aandb.\nProof Letsbe the smallest positive such linear combination of aandb,a n dl e t\nsDaxCbyfor some x;y2Z.L e t qDba=sc. Equation (3.8) then implies\namodsDa/NULqs\nDa/NULq.axCby/\nDa. 1/NULqx/Cb./NULqy/ ;\nand so amodsis a linear combination of aandbas well. But, since 0/DC4\namods<s ,w eh a v et h a t amodsD0, because sis the smallest positive such lin-\near combination. Therefore, we have that sjaand, by analogous reasoning, sjb.\nThus, sis a common divisor of aandb, and so gcd .a; b//NAKs. Equation (31.4)\nimplies that gcd .a; b/js,s i n c eg c d .a; b/ divides both aandbandsis a linear\ncombination of aandb. But gcd .a; b/jsands>0 imply that gcd .a; b//DC4s.\nCombining gcd .a; b//NAKsand gcd .a; b//DC4syields gcd .a; b/Ds. We conclude\nthatsis the greatest common divisor of aandb.\nCorollary 31.3\nFor any integers aandb,i fdjaanddjb,t h e n djgcd.a; b/ .\nProof This corollary follows from equation (31.4), because gcd .a; b/ is a linear\ncombination of aandbby Theorem 31.2.\nCorollary 31.4\nFor all integers aandband any nonnegative integer n,\ngcd.an; bn/Dngcd.a; b/ :\nProof IfnD0, the corollary is trivial. If n>0 ,t h e ng c d .an; bn/ is the smallest\npositive element of the set fanxCbn yWx;y2Zg,w h i c hi s ntimes the smallest\npositive element of the set faxCbyWx;y2Zg.\nCorollary 31.5\nFor all positive integers n,a,a n d b,i fnjaband gcd .a; n/D1,t h e n njb.\nProof We leave the proof as Exercise 31.1-5.\n", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "951": {"page_number": 952, "page_information": "31.1 Elementary number-theoretic notions 931\nRelatively prime integers\nTwo integers aandbarerelatively prime if their only common divisor is 1,t h a t\nis, if gcd .a; b/D1. For example, 8and15are relatively prime, since the divisors\nof8are1,2,4,a n d 8, and the divisors of 15are1,3,5,a n d 15. The following\ntheorem states that if two integers are each relatively prime to an integer p,t h e n\ntheir product is relatively prime to p.\nTheorem 31.6\nFor any integers a,b,a n d p, if both gcd .a; p/D1and gcd .b; p/D1,t h e n\ngcd.ab;p/D1.\nProof It follows from Theorem 31.2 that there exist integers x,y,x0,a n d y0such\nthat\naxCpyD1;\nbx0Cpy0D1:\nMultiplying these equations and rearranging, we have\nab.xx0/Cp.ybx0Cy0axCpyy0/D1:\nSince 1is thus a positive linear combination of abandp, an appeal to Theo-\nrem 31.2 completes the proof.\nIntegers n1,n2, ..., nkarepairwise relatively prime if, whenever i\u00a4j,w e\nhave gcd .ni;nj/D1.\nUnique factorization\nAn elementary but important fact about divisibility by primes is the following.\nTheorem 31.7\nFor all primes pand all integers aandb,i fpjab,t h e n pjaorpjb(or both).\nProof Assume for the purpose of contradiction that pjab,b u tt h a t p\u2212aand\np\u2212b. Thus, gcd .a; p/D1and gcd .b; p/D1, since the only divisors of pare1\nandp, and we assume that pdivides neither anorb. Theorem 31.6 then implies\nthat gcd .ab;p/D1, contradicting our assumption that pjab,s i n c e pjab\nimplies gcd .ab;p/Dp. This contradiction completes the proof.\nA consequence of Theorem 31.7 is that we can uniquely factor any composite\ninteger into a product of primes.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "952": {"page_number": 953, "page_information": "932 Chapter 31 Number-Theoretic Algorithms\nTheorem 31.8 (Unique factorization)\nThere is exactly one way to write any composite integer aas a product of the form\naDpe1\n1pe2\n2/SOH/SOH/SOHper\nr;\nwhere the piare prime, p1<p 2</SOH/SOH/SOH<p r,a n dt h e eiare positive integers.\nProof We leave the proof as Exercise 31.1-11.\nAs an example, the number 6000 is uniquely factored into primes as 24/SOH3/SOH53.\nExercises\n31.1-1\nProve that if a>b>0 andcDaCb,t h e n cmodaDb.\n31.1-2\nProve that there are in\ufb01nitely many primes. ( Hint: Show that none of the primes\np1;p2;:::;p kdivide .p1p2/SOH/SOH/SOHpk/C1.)\n31.1-3\nProve that if ajbandbjc,t h e n ajc.\n31.1-4\nProve that if pis prime and 0<k<p ,t h e ng c d .k; p/D1.\n31.1-5\nProve Corollary 31.5.\n31.1-6\nProve that if pis prime and 0<k<p ,t h e n pj/NULp\nk/SOH\n. Conclude that for all integers\naandband all primes p,\n.aCb/p/DC1apCbp.mod p/ :\n31.1-7\nProve that if aandbare any positive integers such that ajb,t h e n\n.xmodb/modaDxmoda\nfor any x. Prove, under the same assumptions, that\nx/DC1y.mod b/implies x/DC1y.mod a/\nfor any integers xandy.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "953": {"page_number": 954, "page_information": "31.2 Greatest common divisor 933\n31.1-8\nFor any integer k>0 ,a ni n t e g e r nis akth power if there exists an integer asuch\nthatakDn. Furthermore, n>1 is anontrivial power if it is a kth power for\nsome integer k>1 . Show how to determine whether a given \u02c7-bit integer nis a\nnontrivial power in time polynomial in \u02c7.\n31.1-9\nProve equations (31.6)\u2013(31.10).\n31.1-10\nShow that the gcd operator is associative. That is, prove that for all integers a,b,\nandc,\ngcd.a;gcd.b; c//Dgcd.gcd.a; b/; c/ :\n31.1-11 ?\nProve Theorem 31.8.\n31.1-12\nGive ef\ufb01cient algorithms for the operations of dividing a \u02c7-bit integer by a shorter\ninteger and of taking the remainder of a \u02c7-bit integer when divided by a shorter\ninteger. Your algorithms should run in time \u201a.\u02c72/.\n31.1-13\nGive an ef\ufb01cient algorithm to convert a given \u02c7-bit (binary) integer to a decimal\nrepresentation. Argue that if multiplication or division of integers whose lengthis at most \u02c7takes time M.\u02c7/ , then we can convert binary to decimal in time\n\u201a.M.\u02c7/ lg\u02c7/.(Hint: Use a divide-and-conquer approach, obtaining the top and\nbottom halves of the result with separate recursions.)\n31.2 Greatest common divisor\nIn this section, we describe Euclid\u2019s algorithm for ef\ufb01ciently computing the great-est common divisor of two integers. When we analyze the running time, we shallsee a surprising connection with the Fibonacci numbers, which yield a worst-case\ninput for Euclid\u2019s algorithm.\nWe restrict ourselves in this section to nonnegative integers. This restriction is\njusti\ufb01ed by equation (31.8), which states that gcd .a; b/Dgcd.jaj;jbj/.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "954": {"page_number": 955, "page_information": "934 Chapter 31 Number-Theoretic Algorithms\nIn principle, we can compute gcd .a; b/ for positive integers aandbfrom the\nprime factorizations of aandb. Indeed, if\naDpe1\n1pe2\n2/SOH/SOH/SOHper\nr; (31.11)\nbDpf1\n1pf2\n2/SOH/SOH/SOHpfr\nr; (31.12)\nwith zero exponents being used to make the set of primes p1;p2;:::;p rthe same\nfor both aandb, then, as Exercise 31.2-1 asks you to show,\ngcd.a; b/Dpmin.e1;f1/\n1 pmin.e2;f2/\n2/SOH/SOH/SOHpmin.er;fr/\nr : (31.13)\nAs we shall show in Section 31.9, however, the best algorithms to date for factoring\ndo not run in polynomial time. Thus, this approach to computing greatest common\ndivisors seems unlikely to yield an ef\ufb01cient algorithm.\nEuclid\u2019s algorithm for computing greatest common divisors relies on the follow-\ning theorem.\nTheorem 31.9 (GCD recursion theorem)\nFor any nonnegative integer aand any positive integer b,\ngcd.a; b/Dgcd.b; a modb/ :\nProof We shall show that gcd .a; b/ and gcd .b; a modb/divide each other, so\nthat by equation (31.5) they must be equal (since they are both nonnegative).\nWe \ufb01rst show that gcd .a; b/jgcd.b; a modb/.I f w e l e t dDgcd.a; b/ ,t h e n\ndjaanddjb. By equation (3.8), amodbDa/NULqb,w h e r e qDba=bc.\nSince amodbis thus a linear combination of aandb, equation (31.4) implies that\ndj.amodb/. Therefore, since djbanddj.amodb/, Corollary 31.3 implies\nthatdjgcd.b; a modb/or, equivalently, that\ngcd.a; b/jgcd.b; a modb/: (31.14)\nShowing that gcd .b; a modb/jgcd.a; b/ is almost the same. If we now let\ndDgcd.b; a modb/,t h e n djbanddj.amodb/.S i n c e aDqbC.amodb/,\nwhere qDba=bc,w eh a v et h a t ais a linear combination of band.amodb/.B y\nequation (31.4), we conclude that dja.S i n c e djbanddja,w eh a v et h a t\ndjgcd.a; b/ by Corollary 31.3 or, equivalently, that\ngcd.b; a modb/jgcd.a; b/: (31.15)\nUsing equation (31.5) to combine equations (31.14) and (31.15) completes the\nproof.\n", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "955": {"page_number": 956, "page_information": "31.2 Greatest common divisor 935\nEuclid\u2019s algorithm\nThe Elements of Euclid (circa 300 B.C.) describes the following gcd algorithm,\nalthough it may be of even earlier origin. We express Euclid\u2019s algorithm as arecursive program based directly on Theorem 31.9. The inputs aandbare arbitrary\nnonnegative integers.\nE\nUCLID .a; b/\n1ifb==0\n2 return a\n3else return EUCLID .b; a modb/\nAs an example of the running of E UCLID , consider the computation of gcd .30; 21/ :\nEUCLID .30; 21/DEUCLID .21; 9/\nDEUCLID .9; 3/\nDEUCLID .3; 0/\nD3:\nThis computation calls E UCLID recursively three times.\nThe correctness of E UCLID follows from Theorem 31.9 and the property that if\nthe algorithm returns ain line 2, then bD0, so that equation (31.9) implies that\ngcd.a; b/Dgcd.a; 0/Da. The algorithm cannot recurse inde\ufb01nitely, since the\nsecond argument strictly decreases in each recursive call and is always nonnegative.Therefore, E\nUCLID always terminates with the correct answer.\nThe running time of Euclid\u2019s algorithm\nWe analyze the worst-case running time of E UCLID as a function of the size of\naandb. We assume with no loss of generality that a>b/NAK0. To justify this\nassumption, observe that if b>a/NAK0,t h e nE UCLID .a; b/ immediately makes the\nrecursive call E UCLID .b; a/ . That is, if the \ufb01rst argument is less than the second\nargument, E UCLID spends one recursive call swapping its arguments and then pro-\nceeds. Similarly, if bDa>0 , the procedure terminates after one recursive call,\nsince amodbD0.\nThe overall running time of E UCLID is proportional to the number of recursive\ncalls it makes. Our analysis makes use of the Fibonacci numbers Fk,d e \ufb01 n e db y\nthe recurrence (3.22).\nLemma 31.10\nIfa>b/NAK1and the call E UCLID .a; b/ performs k/NAK1recursive calls, then\na/NAKFkC2andb/NAKFkC1.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "956": {"page_number": 957, "page_information": "936 Chapter 31 Number-Theoretic Algorithms\nProof The proof proceeds by induction on k. For the basis of the induction, let\nkD1. Then, b/NAK1DF2, and since a>b ,w em u s th a v e a/NAK2DF3.S i n c e\nb>. a modb/, in each recursive call the \ufb01rst argument is strictly larger than the\nsecond; the assumption that a>b therefore holds for each recursive call.\nAssume inductively that the lemma holds if k/NUL1recursive calls are made; we\nshall then prove that the lemma holds for krecursive calls. Since k>0 ,w eh a v e\nb>0 ,a n dE UCLID .a; b/ calls E UCLID .b; a modb/recursively, which in turn\nmakes k/NUL1recursive calls. The inductive hypothesis then implies that b/NAKFkC1\n(thus proving part of the lemma), and amodb/NAKFk.W eh a v e\nbC.amodb/DbC.a/NULbba=bc/\n/DC4a;\nsince a>b>0 impliesba=bc/NAK1. Thus,\na/NAKbC.amodb/\n/NAKFkC1CFk\nDFkC2:\nThe following theorem is an immediate corollary of this lemma.\nTheorem 31.11 (Lam \u00b4e\u2019s theorem)\nFor any integer k/NAK1,i fa>b/NAK1andb<F kC1, then the call E UCLID .a; b/\nmakes fewer than krecursive calls.\nWe can show that the upper bound of Theorem 31.11 is the best possible by\nshowing that the call E UCLID .FkC1;Fk/makes exactly k/NUL1recursive calls\nwhen k/NAK2. We use induction on k. For the base case, kD2, and the call\nEUCLID .F3;F2/makes exactly one recursive call, to E UCLID .1; 0/ .( W e h a v e t o\nstart at kD2, because when kD1we do not have F2>F 1.) For the induc-\ntive step, assume that E UCLID .Fk;Fk/NUL1/makes exactly k/NUL2recursive calls. For\nk>2 ,w eh a v e Fk>F k/NUL1>0andFkC1DFkCFk/NUL1, and so by Exercise 31.1-1,\nwe have FkC1modFkDFk/NUL1. Thus, we have\ngcd.FkC1;Fk/Dgcd.Fk;FkC1modFk/\nDgcd.Fk;Fk/NUL1/:\nTherefore, the call E UCLID .FkC1;Fk/recurses one time more than the call\nEUCLID .Fk;Fk/NUL1/, or exactly k/NUL1times, meeting the upper bound of Theo-\nrem 31.11.\nSince Fkis approximately /RSk=p\n5,w h e r e /RSis the golden ratio .1Cp\n5/=2 de-\n\ufb01ned by equation (3.24), the number of recursive calls in E UCLID isO.lgb/.( S e e", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "957": {"page_number": 958, "page_information": "31.2 Greatest common divisor 937\nabba=bcdx y\n99 78 1 3 /NUL11 14\n78 21 3 3 3 /NUL11\n21 15 1 3 /NUL23\n15 6 2 3 1 /NUL2\n63 2 3 0 1\n30 \u2014 3 1 0\nFigure 31.1 How E XTENDED -EUCLID computes gcd .99; 78/ . Each line shows one level of the\nrecursion: the values of the inputs aandb, the computed value ba=bc, and the values d,x,a n d y\nreturned. The triple .d; x; y/ returned becomes the triple .d0;x0;y0/used at the next higher level\nof recursion. The call E XTENDED -EUCLID .99; 78/ returns .3;/NUL11; 14/ ,s ot h a tg c d .99; 78/D3D\n99/SOH./NUL11/C78/SOH14.\nExercise 31.2-5 for a tighter bound.) Therefore, if we call E UCLID on two \u02c7-bit\nnumbers, then it performs O.\u02c7/ arithmetic operations and O.\u02c73/bit operations\n(assuming that multiplication and division of \u02c7-bit numbers take O.\u02c72/bit oper-\nations). Problem 31-2 asks you to show an O.\u02c72/bound on the number of bit\noperations.\nThe extended form of Euclid\u2019s algorithm\nWe now rewrite Euclid\u2019s algorithm to compute additional useful information.\nSpeci\ufb01cally, we extend the algorithm to compute the integer coef\ufb01cients xandy\nsuch that\ndDgcd.a; b/DaxCby : (31.16)\nNote that xandymay be zero or negative. We shall \ufb01nd these coef\ufb01cients useful\nlater for computing modular multiplicative inverses. The procedure E XTENDED -\nEUCLID takes as input a pair of nonnegative integers and returns a triple of the\nform . d;x;y/ that satis\ufb01es equation (31.16).\nEXTENDED -EUCLID .a; b/\n1ifb==0\n2 return . a;1 ;0 /\n3else.d0;x0;y0/DEXTENDED -EUCLID .b; a modb/\n4 . d;x;y/D.d0;y0;x0/NULba=bcy0/\n5 return . d;x;y/\nFigure 31.1 illustrates how E XTENDED -EUCLID computes gcd .99; 78/ .\nThe E XTENDED -EUCLID procedure is a variation of the E UCLID procedure.\nLine 1 is equivalent to the test \u201c b==0\u201d in line 1 of E UCLID .I fbD0,t h e n", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "958": {"page_number": 959, "page_information": "938 Chapter 31 Number-Theoretic Algorithms\nEXTENDED -EUCLID returns not only dDain line 2, but also the coef\ufb01cients\nxD1andyD0,s ot h a t aDaxCby.I fb\u00a40,EXTENDED -EUCLID \ufb01rst\ncomputes .d0;x0;y0/such that d0Dgcd.b; a modb/and\nd0Dbx0C.amodb/y0: (31.17)\nAs for E UCLID , we have in this case dDgcd.a; b/Dd0Dgcd.b; a modb/.\nTo obtain xandysuch that dDaxCby, we start by rewriting equation (31.17)\nusing the equation dDd0and equation (3.8):\ndDbx0C.a/NULbba=bc/y0\nDay0Cb.x0/NULba=bcy0/:\nThus, choosing xDy0andyDx0/NULba=bcy0satis\ufb01es the equation dDaxCby,\nproving the correctness of E XTENDED -EUCLID .\nSince the number of recursive calls made in E UCLID is equal to the number\nof recursive calls made in E XTENDED -EUCLID , the running times of E UCLID\nand E XTENDED -EUCLID are the same, to within a constant factor. That is, for\na>b>0 , the number of recursive calls is O.lgb/.\nExercises\n31.2-1\nProve that equations (31.11) and (31.12) imply equation (31.13).\n31.2-2\nCompute the values . d;x;y/ that the call E XTENDED -EUCLID .899; 493/ returns.\n31.2-3\nProve that for all integers a,k,a n d n,\ngcd.a; n/Dgcd.aCkn;n/ :\n31.2-4\nRewrite E UCLID in an iterative form that uses only a constant amount of memory\n(that is, stores only a constant number of integer values).\n31.2-5\nIfa>b/NAK0, show that the call E UCLID .a; b/ makes at most 1Clog/RSbrecursive\ncalls. Improve this bound to 1Clog/RS.b=gcd.a; b// .\n31.2-6\nWhat does E XTENDED -EUCLID .FkC1;Fk/return? Prove your answer correct.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "959": {"page_number": 960, "page_information": "31.3 Modular arithmetic 939\n31.2-7\nDe\ufb01ne the gcd function for more than two arguments by the recursive equationgcd.a\n0;a1;:::;a n/Dgcd.a0;gcd.a1;a2;:::;a n//. Show that the gcd function\nreturns the same answer independent of the order in which its arguments are speci-\ufb01ed. Also show how to \ufb01nd integers x\n0;x1;:::;x nsuch that gcd .a0;a1;:::;a n/D\na0x0Ca1x1C/SOH/SOH/SOHC anxn. Show that the number of divisions performed by your\nalgorithm is O.nClg.maxfa0;a1;:::;a ng//.\n31.2-8\nDe\ufb01ne lcm .a1;a2;:::;a n/to be the least common multiple of the nintegers\na1;a2;:::;a n, that is, the smallest nonnegative integer that is a multiple of each ai.\nShow how to compute lcm .a1;a2;:::;a n/ef\ufb01ciently using the (two-argument) gcd\noperation as a subroutine.\n31.2-9\nProve that n1,n2,n3,a n d n4are pairwise relatively prime if and only if\ngcd.n1n2;n3n4/Dgcd.n1n3;n2n4/D1:\nMore generally, show that n1;n2;:::;n kare pairwise relatively prime if and only\nif a set ofdlgkepairs of numbers derived from the niare relatively prime.\n31.3 Modular arithmetic\nInformally, we can think of modular arithmetic as arithmetic as usual over the\nintegers, except that if we are working modulo n, then every result xis replaced\nby the element off0; 1; : : : ; n/NUL1gthat is equivalent to x, modulo n(that is, xis\nreplaced by xmodn). This informal model suf\ufb01ces if we stick to the operations\nof addition, subtraction, and multiplication. A more formal model for modulararithmetic, which we now give, is best described within the framework of grouptheory.\nFinite groups\nAgroup .S;\u02da/is a set Stogether with a binary operation \u02dade\ufb01ned on Sfor\nwhich the following properties hold:\n1.Closure: For all a,b2S,w eh a v e a\u02dab2S.\n2.Identity: There exists an element e2S, called the identity of the group, such\nthate\u02daaDa\u02daeDafor all a2S.\n3.Associativity: For all a,b,c2S,w eh a v e .a\u02dab/\u02dacDa\u02da.b\u02dac/.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "960": {"page_number": 961, "page_information": "940 Chapter 31 Number-Theoretic Algorithms\n4.Inverses: For each a2S, there exists a unique element b2S, called the\ninverse ofa, such that a\u02dabDb\u02daaDe.\nAs an example, consider the familiar group .Z;C/of the integers Zunder the\noperation of addition: 0is the identity, and the inverse of ais/NULa. If a group .S;\u02da/\nsatis\ufb01es the commutative law a\u02dabDb\u02daafor all a;b2S,t h e ni ti sa n abelian\ngroup . If a group .S;\u02da/satis\ufb01esjSj<1,t h e ni ti sa \ufb01nite group .\nThe groups de\ufb01ned by modular addition and multiplication\nWe can form two \ufb01nite abelian groups by using addition and multiplication mod-\nulon,w h e r e nis a positive integer. These groups are based on the equivalence\nclasses of the integers modulo n, de\ufb01ned in Section 31.1.\nTo de\ufb01ne a group on Zn, we need to have suitable binary operations, which\nwe obtain by rede\ufb01ning the ordinary operations of addition and multiplication.We can easily de\ufb01ne addition and multiplication operations for Z\nn, because the\nequivalence class of two integers uniquely determines the equivalence class of their\nsum or product. That is, if a/DC1a0.mod n/andb/DC1b0.mod n/,t h e n\naCb/DC1a0Cb0.mod n/ ;\nab/DC1a0b0.mod n/ :\nThus, we de\ufb01ne addition and multiplication modulo n, denotedCnand/SOHn,b y\n\u0152a/c141nCn\u0152b/c141nD\u0152aCb/c141n; (31.18)\n\u0152a/c141n/SOHn\u0152b/c141nD\u0152ab/c141 n:\n(We can de\ufb01ne subtraction similarly on Znby\u0152a/c141n/NULn\u0152b/c141nD\u0152a/NULb/c141n, but divi-\nsion is more complicated, as we shall see.) These facts justify the common andconvenient practice of using the smallest nonnegative element of each equivalenceclass as its representative when performing computations in Z\nn. We add, subtract,\nand multiply as usual on the representatives, but we replace each result xby the\nrepresentative of its class, that is, by xmodn.\nUsing this de\ufb01nition of addition modulo n,w ed e \ufb01 n et h e additive group\nmodulo nas.Zn;Cn/. The size of the additive group modulo nisjZnjDn.\nFigure 31.2(a) gives the operation table for the group .Z6;C6/.\nTheorem 31.12\nThe system .Zn;Cn/is a \ufb01nite abelian group.\nProof Equation (31.18) shows that .Zn;Cn/is closed. Associativity and com-\nmutativity ofCnfollow from the associativity and commutativity of C:", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "961": {"page_number": 962, "page_information": "31.3 Modular arithmetic 941\n012345\n0\n123450 12345\n01 2345012345\n012 345\n0123 45\n012345\n(a)1 2 4 7 8 11 13 14\n1\n2478\n1113141 2 4 7 8 11 13 14\n2 4 8 14 1 7 11 13481 1 3 2 1 4 7 1 171 4 1 341 12 1 88 1 21 141 3 1 47\n1 171 421 31 8 413 11 7 1 14 8 4 21 4 1 3 1 1 87421\n(b)+6 \u00b715\nFigure 31.2 Two \ufb01nite groups. Equivalence classes are denoted by their representative elements.\n(a)The group .Z6;C6/.(b)The group .Z/ETX\n15;/SOH15/.\n.\u0152a/c141 nCn\u0152b/c141n/Cn\u0152c/c141nD\u0152aCb/c141nCn\u0152c/c141n\nD\u0152.aCb/Cc/c141n\nD\u0152aC.bCc//c141n\nD\u0152a/c141nCn\u0152bCc/c141n\nD\u0152a/c141nCn.\u0152b/c141 nCn\u0152c/c141n/;\n\u0152a/c141nCn\u0152b/c141nD\u0152aCb/c141n\nD\u0152bCa/c141n\nD\u0152b/c141nCn\u0152a/c141n:\nThe identity element of .Zn;Cn/is0(that is, \u01520/c141n). The (additive) inverse of\nan element a(that is, of \u0152a/c141n) is the element/NULa(that is, \u0152/NULa/c141nor\u0152n/NULa/c141n), since\n\u0152a/c141nCn\u0152/NULa/c141nD\u0152a/NULa/c141nD\u01520/c141n.\nUsing the de\ufb01nition of multiplication modulo n,w ed e \ufb01 n et h e multiplicative\ngroup modulo nas.Z/ETX\nn;/SOHn/. The elements of this group are the set Z/ETX\nnof elements\ninZnthat are relatively prime to n, so that each one has a unique inverse, modulo n:\nZ/ETX\nnDf\u0152a/c141n2ZnWgcd.a; n/D1g:\nTo see that Z/ETX\nnis well de\ufb01ned, note that for 0/DC4a<n ,w eh a v e a/DC1.aCkn/\n.mod n/for all integers k. By Exercise 31.2-3, therefore, gcd .a; n/D1implies\ngcd.aCkn;n/D1for all integers k.S i n c e \u0152a/c141nDfaCknWk2Zg, the set Z/ETX\nn\nis well de\ufb01ned. An example of such a group is\nZ/ETX\n15Df1; 2; 4; 7; 8; 11; 13; 14 g;", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "962": {"page_number": 963, "page_information": "942 Chapter 31 Number-Theoretic Algorithms\nwhere the group operation is multiplication modulo 15. (Here we denote an el-\nement \u0152a/c14115asa; for example, we denote \u01527/c14115as7.) Figure 31.2(b) shows the\ngroup .Z/ETX\n15;/SOH15/. For example, 8/SOH11/DC113 . mod 15/, working in Z/ETX\n15.T h ei d e n -\ntity for this group is 1.\nTheorem 31.13\nThe system .Z/ETX\nn;/SOHn/is a \ufb01nite abelian group.\nProof Theorem 31.6 implies that .Z/ETX\nn;/SOHn/is closed. Associativity and commu-\ntativity can be proved for /SOHnas they were forCnin the proof of Theorem 31.12.\nThe identity element is \u01521/c141n. To show the existence of inverses, let abe an element\nofZ/ETX\nnand let . d;x;y/ be returned by E XTENDED -EUCLID .a; n/ . Then, dD1,\nsince a2Z/ETX\nn,a n d\naxCnyD1 (31.19)\nor, equivalently,ax/DC11.mod n/ :\nThus, \u0152x/c141\nnis a multiplicative inverse of \u0152a/c141n, modulo n. Furthermore, we claim\nthat\u0152x/c141n2Z/ETX\nn. To see why, equation (31.19) demonstrates that the smallest pos-\nitive linear combination of xandnmust be 1. Therefore, Theorem 31.2 implies\nthat gcd .x; n/D1. We defer the proof that inverses are uniquely de\ufb01ned until\nCorollary 31.26.\nAs an example of computing multiplicative inverses, suppose that aD5and\nnD11.T h e n E XTENDED -EUCLID .a; n/ returns . d;x;y/D.1;/NUL2;1/,s ot h a t\n1D5/SOH./NUL2/C11/SOH1. Thus, \u0152/NUL2/c14111(i.e.,\u01529/c14111) is the multiplicative inverse of \u01525/c14111.\nWhen working with the groups .Zn;Cn/and.Z/ETX\nn;/SOHn/in the remainder of this\nchapter, we follow the convenient practice of denoting equivalence classes by theirrepresentative elements and denoting the operations C\nnand/SOHnby the usual arith-\nmetic notationsCand/SOH(or juxtaposition, so that abDa/SOHb) respectively. Also,\nequivalences modulo nmay also be interpreted as equations in Zn. For example,\nthe following two statements are equivalent:\nax/DC1b.mod n/ ;\n\u0152a/c141n/SOHn\u0152x/c141nD\u0152b/c141n:\nAs a further convenience, we sometimes refer to a group .S;\u02da/merely as S\nwhen the operation \u02dais understood from context. We may thus refer to the groups\n.Zn;Cn/and.Z/ETX\nn;/SOHn/asZnand Z/ETX\nn, respectively.\nWe denote the (multiplicative) inverse of an element aby.a/NUL1modn/. Division\ninZ/ETX\nnis de\ufb01ned by the equation a=b/DC1ab/NUL1.mod n/. For example, in Z/ETX\n15", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "963": {"page_number": 964, "page_information": "31.3 Modular arithmetic 943\nwe have that 7/NUL1/DC113 . mod 15/,s i n c e 7/SOH13D91/DC11.mod 15/,s ot h a t\n4=7/DC14/SOH13/DC17.mod 15/.\nThe size of Z/ETX\nnis denoted /RS.n/ . This function, known as Euler\u2019s phi function ,\nsatis\ufb01es the equation\n/RS.n/DnY\npWpis prime and pjn/DC2\n1/NUL1\np/DC3\n; (31.20)\nso that pruns over all the primes dividing n(including nitself, if nis prime).\nWe shall not prove this formula here. Intuitively, we begin with a list of the n\nremaindersf0; 1; : : : ; n/NUL1gand then, for each prime pthat divides n, cross out\nevery multiple of pin the list. For example, since the prime divisors of 45 are 3\nand 5,\n/RS.45/D45/DC2\n1/NUL1\n3/DC3/DC2\n1/NUL1\n5/DC3\nD45/DC22\n3/DC3/DC24\n5/DC3\nD24 :\nIfpis prime, then Z/ETX\npDf1 ;2;:::;p/NUL1g,a n d\n/RS.p/Dp/DC2\n1/NUL1\np/DC3\nDp/NUL1: (31.21)\nIfnis composite, then /RS.n/ < n/NUL1, although it can be shown that\n/RS.n/ >n\ne/CRln lnnC3\nln lnn(31.22)\nforn/NAK3,w h e r e /CRD0:5772156649 : : : isEuler\u2019s constant . A somewhat simpler\n(but looser) lower bound for n>5 is\n/RS.n/ >n\n6ln lnn: (31.23)\nThe lower bound (31.22) is essentially the best possible, since\nlim inf\nn!1/RS.n/\nn=ln lnnDe/NUL/CR: (31.24)\nSubgroups\nIf.S;\u02da/is a group, S0/DC2S,a n d .S0;\u02da/is also a group, then .S0;\u02da/is asubgroup\nof.S;\u02da/. For example, the even integers form a subgroup of the integers under the\noperation of addition. The following theorem provides a useful tool for recognizingsubgroups.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "964": {"page_number": 965, "page_information": "944 Chapter 31 Number-Theoretic Algorithms\nTheorem 31.14 (A nonempty closed subset of a \ufb01nite group is a subgroup)\nIf.S;\u02da/is a \ufb01nite group and S0is any nonempty subset of Ssuch that a\u02dab2S0\nfor all a;b2S0,t h e n .S0;\u02da/is a subgroup of .S;\u02da/.\nProof We leave the proof as Exercise 31.3-3.\nFor example, the set f0;2;4;6gforms a subgroup of Z8, since it is nonempty\nand closed under the operation C(that is, it is closed under C8).\nThe following theorem provides an extremely useful constraint on the size of a\nsubgroup; we omit the proof.\nTheorem 31.15 (Lagrange\u2019s theorem)\nIf.S;\u02da/is a \ufb01nite group and .S0;\u02da/is a subgroup of .S;\u02da/,t h e njS0jis a divisor\nofjSj.\nA subgroup S0of a group Sis aproper subgroup if S0\u00a4S. We shall use the\nfollowing corollary in our analysis in Section 31.8 of the Miller-Rabin primalitytest procedure.\nCorollary 31.16\nIfS\n0is a proper subgroup of a \ufb01nite group S,t h e njS0j/DC4jSj=2.\nSubgroups generated by an element\nTheorem 31.14 gives us an easy way to produce a subgroup of a \ufb01nite group .S;\u02da/:\nchoose an element aand take all elements that can be generated from ausing the\ngroup operation. Speci\ufb01cally, de\ufb01ne a.k/fork/NAK1by\na.k/DkM\niD1aDa\u02daa\u02da/SOH/SOH/SOH\u02da a \u0153\nk:\nF o re x a m p l e ,i fw et a k e aD2in the group Z6, the sequence a.1/;a.2/;a.3/;:::is\n2;4;0;2;4;0;2;4;0;::: :\nIn the group Zn,w eh a v e a.k/Dkamodn, and in the group Z/ETX\nn,w eh a v e a.k/D\nakmodn.W ed e \ufb01 n et h e subgroup generated by a, denotedhaior.hai;\u02da/,b y\nhaiDf a.k/Wk/NAK1g:\nWe say that agenerates the subgrouphaior that ais agenerator ofhai.S i n c e Sis\n\ufb01nite,haiis a \ufb01nite subset of S, possibly including all of S. Since the associativity\nof\u02daimplies", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "965": {"page_number": 966, "page_information": "31.3 Modular arithmetic 945\na.i/\u02daa.j /Da.iCj/;\nhaiis closed and therefore, by Theorem 31.14, haiis a subgroup of S. For example,\ninZ6,w eh a v e\nh0iDf0g;\nh1iDf0; 1; 2; 3; 4; 5g;\nh2iDf0; 2; 4g:\nSimilarly, in Z/ETX\n7,w eh a v e\nh1iDf1g;\nh2iDf1; 2; 4g;\nh3iDf1; 2; 3; 4; 5; 6g:\nTheorder ofa(in the group S), denoted ord .a/, is de\ufb01ned as the smallest posi-\ntive integer tsuch that a.t/De.\nTheorem 31.17\nFor any \ufb01nite group .S;\u02da/and any a2S, the order of ais equal to the size of the\nsubgroup it generates, or ord .a/Djhaij.\nProof LettDord.a/.S i n c e a.t/Deanda.tCk/Da.t/\u02daa.k/Da.k/for\nk/NAK1,i fi>t ,t h e n a.i/Da.j /for some j< i . Thus, as we generate ele-\nments by a, we see no new elements after a.t/. Thus,haiDf a.1/;a.2/;:::;a.t/g,\nand sojhaij/DC4t. To show thatjhaij/NAKt, we show that each element of the se-\nquence a.1/;a.2/;:::;a.t/is distinct. Suppose for the purpose of contradiction that\na.i/Da.j /for some iandjsatisfying 1/DC4i<j/DC4t. Then, a.iCk/Da.jCk/\nfork/NAK0. But this equality implies that a.iC.t/NULj/ /Da.jC.t/NULj/ /De, a contradic-\ntion, since iC.t/NULj/<t buttis the least positive value such that a.t/De.T h e r e -\nfore, each element of the sequence a.1/;a.2/;:::;a.t/is distinct, andjhaij/NAKt.W e\nconclude that ord .a/Djhaij.\nCorollary 31.18\nThe sequence a.1/;a.2/;:::is periodic with period tDord.a/;t h a ti s , a.i/Da.j /\nif and only if i/DC1j.mod t/.\nConsistent with the above corollary, we de\ufb01ne a.0/aseanda.i/asa.imodt/,\nwhere tDord.a/, for all integers i.\nCorollary 31.19\nIf.S;\u02da/is a \ufb01nite group with identity e, then for all a2S,\na.jSj/De:", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "966": {"page_number": 967, "page_information": "946 Chapter 31 Number-Theoretic Algorithms\nProof Lagrange\u2019s theorem (Theorem 31.15) implies that ord .a/jjSj,a n ds o\njSj/DC10.mod t/,w h e r e tDord.a/. Therefore, a.jSj/Da.0/De.\nExercises\n31.3-1\nDraw the group operation tables for the groups .Z4;C4/and.Z/ETX\n5;/SOH5/. Show that\nthese groups are isomorphic by exhibiting a one-to-one correspondence \u02dbbetween\ntheir elements such that aCb/DC1c.mod 4/if and only if \u02db.a//SOH\u02db.b//DC1\u02db.c/\n.mod 5/.\n31.3-2\nList all subgroups of Z9and of Z/ETX\n13.\n31.3-3\nProve Theorem 31.14.\n31.3-4\nShow that if pis prime and eis a positive integer, then\n/RS.pe/Dpe/NUL1.p/NUL1/ :\n31.3-5\nShow that for any integer n>1 and for any a2Z/ETX\nn, the function faWZ/ETX\nn! Z/ETX\nn\nde\ufb01ned by fa.x/Daxmodnis a permutation of Z/ETX\nn.\n31.4 Solving modular linear equations\nWe now consider the problem of \ufb01nding solutions to the equation\nax/DC1b.mod n/ ; (31.25)\nwhere a>0 andn>0 . This problem has several applications; for example,\nwe shall use it as part of the procedure for \ufb01nding keys in the RSA public-key\ncryptosystem in Section 31.7. We assume that a,b,a n d nare given, and we wish\nto \ufb01nd all values of x, modulo n, that satisfy equation (31.25). The equation may\nhave zero, one, or more than one such solution.\nLethaidenote the subgroup of Zngenerated by a.S i n c ehaiDf a.x/Wx>0gD\nfaxmodnWx>0g, equation (31.25) has a solution if and only if \u0152b/c1412hai.L a -\ngrange\u2019s theorem (Theorem 31.15) tells us that jhaijmust be a divisor of n.T h e\nfollowing theorem gives us a precise characterization of hai.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "967": {"page_number": 968, "page_information": "31.4 Solving modular linear equations 947\nTheorem 31.20\nFor any positive integers aandn,i fdDgcd.a; n/ ,t h e n\nhaiDh diDf0; d; 2d; : : : ; ..n=d/ /NUL1/dg (31.26)\ninZn, and thus\njhaijDn=d :\nProof We begin by showing that d2hai. Recall that E XTENDED -EUCLID .a; n/\nproduces integers x0andy0such that ax0Cny0Dd. Thus, ax0/DC1d.mod n/,s o\nthatd2hai. In other words, dis a multiple of ainZn.\nSince d2hai, it follows that every multiple of dbelongs tohai, because any\nmultiple of a multiple of ais itself a multiple of a. Thus,haicontains every element\ninf0; d; 2d; : : : ; ..n=d/ /NUL1/dg.T h a ti s ,hdi/DC2hai.\nWe now show that hai/DC2h di.I fm2hai,t h e n mDaxmodnfor some\ninteger x,a n ds o mDaxCnyfor some integer y.H o w e v e r , djaanddjn,a n d\nsodjmby equation (31.4). Therefore, m2hdi.\nCombining these results, we have that haiDh di. To see thatjhaijDn=d,\nobserve that there are exactly n=d multiples of dbetween 0andn/NUL1,i n c l u s i v e .\nCorollary 31.21\nThe equation ax/DC1b.mod n/is solvable for the unknown xif and only if djb,\nwhere dDgcd.a; n/ .\nProof The equation ax/DC1b.mod n/is solvable if and only if \u0152b/c1412hai,w h i c h\nis the same as saying\n.bmodn/2f0; d; 2d; : : : ; ..n=d/ /NUL1/dg;\nby Theorem 31.20. If 0/DC4b<n ,t h e n b2haiif and only if djb, since the\nmembers ofhaiare precisely the multiples of d.I fb<0 orb/NAKn, the corollary\nthen follows from the observation that djbif and only if dj.bmodn/,s i n c e b\nandbmodndiffer by a multiple of n, which is itself a multiple of d.\nCorollary 31.22\nThe equation ax/DC1b.mod n/either has ddistinct solutions modulo n,w h e r e\ndDgcd.a; n/ , or it has no solutions.\nProof Ifax/DC1b.mod n/has a solution, then b2hai. By Theorem 31.17,\nord.a/Djhaij, and so Corollary 31.18 and Theorem 31.20 imply that the sequence\naimodn,f o riD0; 1; : : : , is periodic with period jhaijDn=d.I fb2hai,t h e n b\nappears exactly dtimes in the sequence aimodn,f o riD0; 1; : : : ; n/NUL1,s i n c e", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "968": {"page_number": 969, "page_information": "948 Chapter 31 Number-Theoretic Algorithms\nthe length- .n=d/ block of valueshairepeats exactly dtimes as iincreases from 0\nton/NUL1. The indices xof the dpositions for which axmodnDbare the solutions\nof the equation ax/DC1b.mod n/.\nTheorem 31.23\nLetdDgcd.a; n/ , and suppose that dDax0Cny0for some integers x0andy0\n(for example, as computed by E XTENDED -EUCLID ). If djb, then the equation\nax/DC1b.mod n/has as one of its solutions the value x0,w h e r e\nx0Dx0.b=d/ modn:\nProof We have\nax0/DC1ax0.b=d/ . mod n/\n/DC1d.b=d/ . mod n/ (because ax0/DC1d.mod n/)\n/DC1b. mod n/ ;\nand thus x0is a solution to ax/DC1b.mod n/.\nTheorem 31.24\nSuppose that the equation ax/DC1b.mod n/is solvable (that is, djb,w h e r e\ndDgcd.a; n/ )a n dt h a t x0is any solution to this equation. Then, this equa-\ntion has exactly ddistinct solutions, modulo n,g i v e nb y xiDx0Ci.n=d/ for\niD0; 1; : : : ; d/NUL1.\nProof Because n=d > 0 and0/DC4i.n=d/ < n foriD0; 1; : : : ; d/NUL1,t h e\nvalues x0;x1;:::;x d/NUL1are all distinct, modulo n.S i n c e x0is a solution of ax/DC1b\n.mod n/,w eh a v e ax0modn/DC1b.mod n/. Thus, for iD0; 1; : : : ; d/NUL1,w e\nhave\naximodnDa.x 0Cin=d/ modn\nD.ax 0Cain=d/ modn\nDax0modn(because djaimplies that ain=d is a multiple of n)\n/DC1b.mod n/ ;\nand hence axi/DC1b.mod n/,m a k i n g xia solution, too. By Corollary 31.22, the\nequation ax/DC1b.mod n/has exactly dsolutions, so that x0;x1;:::;x d/NUL1must\nbe all of them.\nWe have now developed the mathematics needed to solve the equation ax/DC1b\n.mod n/; the following algorithm prints all solutions to this equation. The inputs\naandnare arbitrary positive integers, and bis an arbitrary integer.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "969": {"page_number": 970, "page_information": "31.4 Solving modular linear equations 949\nMODULAR -LINEAR -EQUATION -SOLVER . a;b;n /\n1.d; x0;y0/DEXTENDED -EUCLID .a; n/\n2ifdjb\n3 x0Dx0.b=d/ modn\n4 foriD0tod/NUL1\n5 print .x0Ci.n=d// modn\n6elseprint \u201cno solutions\u201d\nAs an example of the operation of this procedure, consider the equation 14x/DC1\n30 . mod 100/ (here, aD14,bD30,a n d nD100). Calling E XTENDED -\nEUCLID in line 1, we obtain .d; x0;y0/D.2;/NUL7; 1/.S i n c e 2j30, lines 3\u20135\nexecute. Line 3 computes x0D./NUL7/.15/ mod100D95. The loop on lines 4\u20135\nprints the two solutions 95 and 45.\nThe procedure M ODULAR -LINEAR -EQUATION -SOLVER works as follows.\nLine 1 computes dDgcd.a; n/ , along with two values x0andy0such that dD\nax0Cny0, demonstrating that x0is a solution to the equation ax0/DC1d.mod n/.\nIfddoes not divide b, then the equation ax/DC1b.mod n/has no solution, by\nCorollary 31.21. Line 2 checks to see whether djb; if not, line 6 reports that there\nare no solutions. Otherwise, line 3 computes a solution x0toax/DC1b.mod n/,\nin accordance with Theorem 31.23. Given one solution, Theorem 31.24 states thatadding multiples of .n=d/ , modulo n, yields the other d/NUL1solutions. The for\nloop of lines 4\u20135 prints out all dsolutions, beginning with x\n0and spaced n=d\napart, modulo n.\nMODULAR -LINEAR -EQUATION -SOLVER performs O.lgnCgcd.a; n// arith-\nmetic operations, since E XTENDED -EUCLID performs O.lgn/arithmetic opera-\ntions, and each iteration of the forloop of lines 4\u20135 performs a constant number of\narithmetic operations.\nThe following corollaries of Theorem 31.24 give specializations of particular\ninterest.\nCorollary 31.25\nFor any n>1 ,i fg c d .a; n/D1, then the equation ax/DC1b.mod n/has a unique\nsolution, modulo n.\nIfbD1, a common case of considerable interest, the xwe are looking for is a\nmultiplicative inverse ofa, modulo n.\nCorollary 31.26\nFor any n>1 ,i fg c d .a; n/D1, then the equation ax/DC11.mod n/has a unique\nsolution, modulo n. Otherwise, it has no solution.\n", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "970": {"page_number": 971, "page_information": "950 Chapter 31 Number-Theoretic Algorithms\nThanks to Corollary 31.26, we can use the notation a/NUL1modnto refer to the\nmultiplicative inverse of a, modulo n,w h e n aandnare relatively prime. If\ngcd.a; n/D1, then the unique solution to the equation ax/DC11.mod n/is the\ninteger xreturned by E XTENDED -EUCLID , since the equation\ngcd.a; n/D1DaxCny\nimplies ax/DC11.mod n/. Thus, we can compute a/NUL1modnef\ufb01ciently using\nEXTENDED -EUCLID .\nExercises\n31.4-1\nFind all solutions to the equation 35x/DC110 . mod 50/.\n31.4-2\nProve that the equation ax/DC1ay . mod n/implies x/DC1y.mod n/whenever\ngcd.a; n/D1. Show that the condition gcd .a; n/D1is necessary by supplying a\ncounterexample with gcd .a; n/ > 1 .\n31.4-3\nConsider the following change to line 3 of the procedure M ODULAR -LINEAR -\nEQUATION -SOLVER :\n3 x0Dx0.b=d/ mod.n=d/\nWill this work? Explain why or why not.\n31.4-4 ?\nLetpbe prime and f. x//DC1f0Cf1xC/SOH/SOH/SOHC ftxt.mod p/be a polyno-\nmial of degree t, with coef\ufb01cients fidrawn from Zp. We say that a2Zp\nis azero offiff. a //DC10.mod p/. Prove that if ais a zero of f,t h e n\nf. x//DC1.x/NULa/g.x/ . mod p/for some polynomial g.x/ of degree t/NUL1. Prove\nby induction on tthat if pis prime, then a polynomial f. x/ of degree tcan have\nat most tdistinct zeros modulo p.\n31.5 The Chinese remainder theorem\nAround A.D. 100, the Chinese mathematician Sun-Ts\u02d8 u solved the problem of \ufb01nd-\ning those integers xthat leave remainders 2, 3, and 2 when divided by 3, 5, and 7\nrespectively. One such solution is xD23; all solutions are of the form 23C105k", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "971": {"page_number": 972, "page_information": "31.5 The Chinese remainder theorem 951\nfor arbitrary integers k. The \u201cChinese remainder theorem\u201d provides a correspon-\ndence between a system of equations modulo a set of pairwise relatively primemoduli (for example, 3, 5, and 7) and an equation modulo their product (for exam-ple, 105).\nThe Chinese remainder theorem has two major applications. Let the inte-\ngernbe factored as nDn\n1n2/SOH/SOH/SOHnk, where the factors niare pairwise relatively\nprime. First, the Chinese remainder theorem is a descriptive \u201cstructure theorem\u201dthat describes the structure of Z\nnas identical to that of the Cartesian product\nZn1/STXZn2/STX/SOH/SOH/SOH/STX Znkwith componentwise addition and multiplication modulo ni\nin the ith component. Second, this description helps us to design ef\ufb01cient algo-\nrithms, since working in each of the systems Znican be more ef\ufb01cient (in terms of\nbit operations) than working modulo n.\nTheorem 31.27 (Chinese remainder theorem)\nLetnDn1n2/SOH/SOH/SOHnk, where the niare pairwise relatively prime. Consider the\ncorrespondence\na$.a1;a2;:::;a k/; (31.27)\nwhere a2Zn,ai2Zni,a n d\naiDamodni\nforiD1 ;2;:::;k . Then, mapping (31.27) is a one-to-one correspondence (bijec-\ntion) between Znand the Cartesian product Zn1/STXZn2/STX/SOH/SOH/SOH/STX Znk. Operations per-\nformed on the elements of Zncan be equivalently performed on the corresponding\nk-tuples by performing the operations independently in each coordinate position in\nthe appropriate system. That is, if\na$.a1;a2;:::;a k/;\nb$.b1;b2;:::;b k/;\nthen.aCb/modn$..a\n1Cb1/modn1;:::;. a kCbk/modnk/; (31.28)\n.a/NULb/modn$..a1/NULb1/modn1;:::;. a k/NULbk/modnk/; (31.29)\n.ab/ modn$.a1b1modn1;:::;a kbkmodnk/: (31.30)\nProof Transforming between the two representations is fairly straightforward.\nGoing from ato.a1;a2;:::;a k/is quite easy and requires only k\u201cmod\u201d opera-\ntions.\nComputing afrom inputs .a1;a2;:::;a k/is a bit more complicated. We begin\nby de\ufb01ning miDn=n iforiD1 ;2;:::;k ; thus miis the product of all of the nj\u2019s\nother than ni:miDn1n2/SOH/SOH/SOHni/NUL1niC1/SOH/SOH/SOHnk.W en e x td e \ufb01 n e", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "972": {"page_number": 973, "page_information": "952 Chapter 31 Number-Theoretic Algorithms\nciDmi.m/NUL1\nimodni/ (31.31)\nforiD1 ;2;:::;k . Equation (31.31) is always well de\ufb01ned: since miandniare\nrelatively prime (by Theorem 31.6), Corollary 31.26 guarantees that m/NUL1\nimodni\nexists. Finally, we can compute aa saf u n c t i o no f a1,a2,..., akas follows:\na/DC1.a1c1Ca2c2C/SOH/SOH/SOHC akck/.mod n/ : (31.32)\nWe now show that equation (31.32) ensures that a/DC1ai.mod ni/foriD\n1 ;2;:::;k . Note that if j\u00a4i,t h e n mj/DC10.mod ni/, which implies that cj/DC1\nmj/DC10.mod ni/. Note also that ci/DC11.mod ni/, from equation (31.31). We\nthus have the appealing and useful correspondence\nci$. 0 ;0 ;:::;0 ;1 ;0 ;:::;0 /;\na vector that has 0s everywhere except in the ith coordinate, where it has a 1;t h eci\nthus form a \u201cbasis\u201d for the representation, in a certain sense. For each i, therefore,\nwe have\na/DC1aici .mod ni/\n/DC1aimi.m/NUL1\nimodni/.mod ni/\n/DC1ai .mod ni/;\nwhich is what we wished to show: our method of computing afrom the ai\u2019s pro-\nduces a result athat satis\ufb01es the constraints a/DC1ai.mod ni/foriD1 ;2;:::;k .\nThe correspondence is one-to-one, since we can transform in both directions.Finally, equations (31.28)\u2013(31.30) follow directly from Exercise 31.1-7, sincexmodn\niD.xmodn/modnifor any xandiD1 ;2;:::;k .\nWe shall use the following corollaries later in this chapter.\nCorollary 31.28\nIfn1;n2;:::;n kare pairwise relatively prime and nDn1n2/SOH/SOH/SOHnk, then for any\nintegers a1;a2;:::;a k, the set of simultaneous equations\nx/DC1ai.mod ni/;\nforiD1 ;2;:::;k , has a unique solution modulo nfor the unknown x.\nCorollary 31.29\nIfn1;n2;:::;n kare pairwise relatively prime and nDn1n2/SOH/SOH/SOHnk, then for all\nintegers xanda,\nx/DC1a.mod ni/\nforiD1 ;2;:::;k if and only if\nx/DC1a.mod n/ :\n", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "973": {"page_number": 974, "page_information": "31.5 The Chinese remainder theorem 953\n0123456789 1 0 1 1 1 2\n0\n 0 4 01 55 53 0 5 4 52 06 03 51 05 02 5\n1\n2 6 1 4 11 65 63 1 6 4 62 16 13 61 15 1\n2\n52 27 2 42 17 57 32 7 47 22 62 37 12\n3\n1 35 32 8 3 4 31 85 83 3 8 4 82 36 33 8\n4\n39 14 54 29 4 44 19 59 34 9 49 24 64\nFigure 31.3 An illustration of the Chinese remainder theorem for n1D5andn2D13. For this\nexample, c1D26andc2D40.I n r o w i, column jis shown the value of a, modulo 65, such\nthatamod5Diandamod13Dj. Note that row 0, column 0 contains a 0. Similarly, row 4,\ncolumn 12 contains a 64 (equivalent to /NUL1). Since c1D26, moving down a row increases aby26.\nSimilarly, c2D40means that moving right by a column increases aby40. Increasing aby1\ncorresponds to moving diagonally downward and to the right, wrapping around from the bottom to\nthe top and from the right to the left.\nAs an example of the application of the Chinese remainder theorem, suppose we\nare given the two equations\na/DC12.mod 5/ ;\na/DC13.mod 13/ ;\nso that a1D2,n1Dm2D5,a2D3,a n d n2Dm1D13, and we wish\nto compute amod65,s i n c e nDn1n2D65. Because 13/NUL1/DC12.mod 5/and\n5/NUL1/DC18.mod 13/,w eh a v e\nc1D13.2 mod5/D26 ;\nc2D5.8mod13/D40 ;\nand\na/DC12/SOH26C3/SOH40 . mod 65/\n/DC152C120 . mod 65/\n/DC142 . mod 65/ :\nSee Figure 31.3 for an illustration of the Chinese remainder theorem, modulo 65.\nThus, we can work modulo nby working modulo ndirectly or by working in the\ntransformed representation using separate modulo nicomputations, as convenient.\nThe computations are entirely equivalent.\nExercises\n31.5-1\nFind all solutions to the e quations x/DC14.mod 5/andx/DC15.mod 11/.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "974": {"page_number": 975, "page_information": "954 Chapter 31 Number-Theoretic Algorithms\n31.5-2\nFind all integers xthat leave remainders 1, 2, 3 when divided by 9, 8, 7 respectively.\n31.5-3\nArgue that, under the de\ufb01nitions of Theorem 31.27, if gcd .a; n/D1,t h e n\n.a/NUL1modn/$..a/NUL1\n1modn1/; .a/NUL1\n2modn2/ ;:::;. a/NUL1\nkmodnk// :\n31.5-4\nUnder the de\ufb01nitions of Theorem 31.27, prove that for any polynomial f, the num-\nber of roots of the equation f. x//DC10.mod n/equals the product of the number\nof roots of each of the equations f. x//DC10.mod n1/,f. x//DC10.mod n2/, ...,\nf. x//DC10.mod nk/.\n31.6 Powers of an element\nJust as we often consider the multiples of a given element a, modulo n, we consider\nthe sequence of powers of a, modulo n,w h e r e a2Z/ETX\nn:\na0;a1;a2;a3;:::; (31.33)\nmodulo n. Indexing from 0,t h e0th value in this sequence is a0modnD1,a n d\ntheith value is aimodn. For example, the powers of 3modulo 7are\ni 01234567891 01 1 /SOH/SOH/SOH\n3imod71326451326 4 5 /SOH/SOH/SOH\nwhereas the powers of 2modulo 7are\ni 01234567891 01 1 /SOH/SOH/SOH\n2imod71241241241 2 4 /SOH/SOH/SOH\nIn this section, lethaidenote the subgroup of Z/ETX\nngenerated by aby repeated\nmultiplication, and let ord n.a/(the \u201corder of a, modulo n\u201d) denote the order of a\ninZ/ETX\nn. For example,h2iDf1; 2; 4ginZ/ETX\n7, and ord 7.2/D3. Using the de\ufb01nition of\nthe Euler phi function /RS.n/ as the size of Z/ETX\nn(see Section 31.3), we now translate\nCorollary 31.19 into the notation of Z/ETX\nnto obtain Euler\u2019s theorem and specialize it\ntoZ/ETX\np,w h e r e pis prime, to obtain Fermat\u2019s theorem.\nTheorem 31.30 (Euler\u2019s theorem)\nFor any integer n>1 ,\na/RS.n//DC11.mod n/for all a2Z/ETX\nn:\n", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "975": {"page_number": 976, "page_information": "31.6 Powers of an element 955\nTheorem 31.31 (Fermat\u2019s theorem)\nIfpis prime, then\nap/NUL1/DC11.mod p/for all a2Z/ETX\np:\nProof By equation (31.21), /RS.p/Dp/NUL1ifpis prime.\nFermat\u2019s theorem applies to every element in Zpexcept 0,s i n c e 062Z/ETX\np.F o ra l l\na2Zp, however, we have ap/DC1a.mod p/ifpis prime.\nIf ord n.g/DjZ/ETX\nnj, then every element in Z/ETX\nni sap o w e ro f g, modulo n,a n d\ngis aprimitive root or agenerator ofZ/ETX\nn. For example, 3is a primitive root,\nmodulo 7,b u t 2is not a primitive root, modulo 7.I f Z/ETX\nnpossesses a primitive\nroot, the group Z/ETX\nniscyclic . We omit the proof of the following theorem, which is\nproven by Niven and Zuckerman [265].\nTheorem 31.32\nThe values of n>1 for which Z/ETX\nnis cyclic are 2,4,pe,a n d 2pe, for all primes\np>2 and all positive integers e.\nIfgis a primitive root of Z/ETX\nnandais any element of Z/ETX\nn, then there exists a \u00b4such\nthatg\u00b4/DC1a.mod n/.T h i s \u00b4is adiscrete logarithm or anindex ofa, modulo n,\nto the base g; we denote this value as ind n;g.a/.\nTheorem 31.33 (Discrete logarithm theorem)\nIfgis a primitive root of Z/ETX\nn, then the equation gx/DC1gy.mod n/holds if and\nonly if the equation x/DC1y.mod /RS.n// holds.\nProof Suppose \ufb01rst that x/DC1y.mod /RS.n// . Then, xDyCk/RS.n/ for some\ninteger k. Therefore,\ngx/DC1gyCk/RS.n/.mod n/\n/DC1gy/SOH.g/RS.n//k.mod n/\n/DC1gy/SOH1k.mod n/ (by Euler\u2019s theorem)\n/DC1gy.mod n/ :\nConversely, suppose that gx/DC1gy.mod n/. Because the sequence of powers of g\ngenerates every element of hgiandjhgijD/RS.n/ , Corollary 31.18 implies that\nthe sequence of powers of gis periodic with period /RS.n/ . Therefore, if gx/DC1gy\n.mod n/, then we must have x/DC1y.mod /RS.n// .\nWe now turn our attention to the square roots of 1, modulo a prime power. The\nfollowing theorem will be useful in our development of a primality-testing algo-\nrithm in Section 31.8.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "976": {"page_number": 977, "page_information": "956 Chapter 31 Number-Theoretic Algorithms\nTheorem 31.34\nIfpis an odd prime and e/NAK1, then the equation\nx2/DC11.mod pe/ (31.34)\nhas only two solutions, namely xD1andxD/NUL1.\nProof Equation (31.34) is equivalent to\npej.x/NUL1/.xC1/ :\nSince p>2 , we can have pj.x/NUL1/orpj.xC1/, but not both. (Otherwise,\nby property (31.3), pwould also divide their difference .xC1//NUL.x/NUL1/D2.)\nIfp\u2212.x/NUL1/,t h e ng c d .pe;x/NUL1/D1, and by Corollary 31.5, we would have\npej.xC1/.T h a t i s , x/DC1/NUL 1.mod pe/. Symmetrically, if p \u2212.xC1/,\nthen gcd .pe;xC1/D1, and Corollary 31.5 implies that pej.x/NUL1/,s ot h a t\nx/DC11.mod pe/. Therefore, either x/DC1/NUL1.mod pe/orx/DC11.mod pe/.\nA number xis anontrivial square root of 1, modulo n, if it satis\ufb01es the equation\nx2/DC11.mod n/butxis equivalent to neither of the two \u201ctrivial\u201d square roots:\n1or/NUL1, modulo n. For example, 6is a nontrivial square root of 1, modulo 35.\nWe shall use the following corollary to Theorem 31.34 in the correctness proof inSection 31.8 for the Miller-Rabin primality-testing procedure.\nCorollary 31.35\nIf there exists a nontrivial square root of 1, modulo n,t h e n nis composite.\nProof By the contrapositive of Theorem 31.34, if there exists a nontrivial square\nroot of 1, modulo n,t h e n ncannot be an odd prime or a power of an odd prime.\nIfx\n2/DC11.mod 2/,t h e n x/DC11.mod 2/, and so all square roots of 1, modulo 2,\nare trivial. Thus, ncannot be prime. Finally, we must have n>1 for a nontrivial\nsquare root of 1to exist. Therefore, nmust be composite.\nRaising to powers with repeated squaring\nA frequently occurring operation in number-theoretic computations is raising one\nnumber to a power modulo another number, also known as modular exponentia-\ntion. More precisely, we would like an ef\ufb01cient way to compute abmodn,w h e r e\naandbare nonnegative integers and nis a positive integer. Modular exponenti-\nation is an essential operation in many primality-testing routines and in the RSApublic-key cryptosystem. The method of repeated squaring solves this problem\nef\ufb01ciently using the binary representation of b.\nLethb\nk;bk/NUL1;:::;b 1;b0ibe the binary representation of b. (That is, the binary\nrepresentation is kC1bits long, bkis the most signi\ufb01cant bit, and b0is the least", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "977": {"page_number": 978, "page_information": "31.6 Powers of an element 957\ni\n 9 8 76543210\nbi\n1 0 00110000\nc\n 1 2 4 8 17 35 70 140 280 560\nd\n 7 49 157 526 160 241 298 166 67 1\nFigure 31.4 The results of M ODULAR -EXPONENTIATION when computing ab.mod n/,w h e r e\naD7,bD560Dh1000110000i,a n d nD561. The values are shown after each execution of the\nforloop. The \ufb01nal result is 1.\nsigni\ufb01cant bit.) The following procedure computes acmodnascis increased by\ndoublings and incrementations from 0tob.\nMODULAR -EXPONENTIATION . a;b;n /\n1cD0\n2dD1\n3l e thbk;bk/NUL1;:::;b 0ibe the binary representation of b\n4foriDkdownto 0\n5 cD2c\n6 dD.d/SOHd/modn\n7 ifbi==1\n8 cDcC1\n9 dD.d/SOHa/modn\n10return d\nThe essential use of squaring in line 6 of each iteration explains the name \u201crepeated\nsquaring.\u201d As an example, for aD7,bD560,a n d nD561, the algorithm\ncomputes the sequence of values modulo 561 shown in Figure 31.4; the sequenceof exponents used appears in the row of the table labeled by c.\nThe variable cis not really needed by the algorithm but is included for the fol-\nlowing two-part loop invariant:\nJust prior to each iteration of the forloop of lines 4\u20139,\n1. The value of cis the same as the pre\ufb01x hb\nk;bk/NUL1;:::;b iC1iof the binary\nrepresentation of b,a n d\n2.dDacmodn.\nWe use this loop invariant as follows:\nInitialization: Initially, iDk, so that the pre\ufb01x hbk;bk/NUL1;:::;b iC1iis empty,\nwhich corresponds to cD0. Moreover, dD1Da0modn.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "978": {"page_number": 979, "page_information": "958 Chapter 31 Number-Theoretic Algorithms\nMaintenance: Letc0andd0denote the values of canddat the end of an iteration\nof the forloop, and thus the values prior to the next iteration. Each iteration\nupdates c0D2c(ifbiD0)o rc0D2cC1(ifbiD1), so that cwill be correct\nprior to the next iteration. If biD0,t h e n d0Dd2modnD.ac/2modnD\na2cmodnDac0modn.I fbiD1,t h e n d0Dd2amodnD.ac/2amodnD\na2cC1modnDac0modn. In either case, dDacmodnprior to the next\niteration.\nTermination: At termination, iD/NUL1. Thus, cDb,s i n c e chas the value of the\npre\ufb01xhbk;bk/NUL1;:::;b 0iofb\u2019s binary representation. Hence dDacmodnD\nabmodn.\nIf the inputs a,b,a n d nare\u02c7-bit numbers, then the total number of arith-\nmetic operations required is O.\u02c7/ and the total number of bit operations required\nisO.\u02c73/.\nExercises\n31.6-1\nDraw a table showing the order of every element in Z/ETX\n11. Pick the smallest primitive\nrootgand compute a table giving ind 11;g.x/for all x2Z/ETX\n11.\n31.6-2\nGive a modular exponentiation algorithm that examines the bits of bfrom right to\nleft instead of left to right.\n31.6-3\nAssuming that you know /RS.n/ , explain how to compute a/NUL1modnfor any a2Z/ETX\nn\nusing the procedure M ODULAR -EXPONENTIATION .\n31.7 The RSA public-key cryptosystem\nWith a public-key cryptosystem, we can encrypt messages sent between two com-\nmunicating parties so that an eavesdropper who overhears the encrypted messageswill not be able to decode them. A public-key cryptosystem also enables a partyto append an unforgeable \u201cdigital signature\u201d to the end of an electronic message.Such a signature is the electronic version of a handwritten signature on a paper doc-ument. It can be easily checked by anyone, forged by no one, yet loses its validityif any bit of the message is altered. It therefore provides authentication of both theidentity of the signer and the contents of the signed message. It is the perfect tool", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "979": {"page_number": 980, "page_information": "31.7 The RSA public-key cryptosystem 959\nfor electronically signed business contracts, electronic checks, electronic purchase\norders, and other electronic communications that parties wish to authenticate.\nThe RSA public-key cryptosystem relies on the dramatic difference between the\nease of \ufb01nding large prime numbers and the dif\ufb01culty of factoring the product oftwo large prime numbers. Section 31.8 describes an ef\ufb01cient procedure for \ufb01ndinglarge prime numbers, and Section 31.9 discusses the problem of factoring largeintegers.\nPublic-key cryptosystems\nIn a public-key cryptosystem, each participant has both a public key and a secret\nkey. Each key is a piece of information. For example, in the RSA cryptosystem,\neach key consists of a pair of integers. The participants \u201cAlice\u201d and \u201cBob\u201d are\ntraditionally used in cryptography examples; we denote their public and secret\nkeys as P\nA,SAfor Alice and PB,SBfor Bob.\nEach participant creates his or her own public and secret keys. Secret keys are\nkept secret, but public keys can be revealed to anyone or even published. In fact,it is often convenient to assume that everyone\u2019s public key is available in a pub-lic directory, so that any participant can easily obtain the public key of any otherparticipant.\nThe public and secret keys specify functions that can be applied to any message.\nLetDdenote the set of permissible messages. For example, Dmight be the set of\nall \ufb01nite-length bit sequences. In the simplest, and original, formulation of public-key cryptography, we require that the public and secret keys specify one-to-onefunctions from Dto itself. We denote the function corresponding to Alice\u2019s public\nkeyP\nAbyPA./and the function corresponding to her secret key SAbySA./.T h e\nfunctions PA./andSA./are thus permutations of D. We assume that the functions\nPA./andSA./are ef\ufb01ciently computable given the corresponding key PAorSA.\nThe public and secret keys for any participant are a \u201cmatched pair\u201d in that they\nspecify functions that are inverses of each other. That is,\nMDSA.PA.M // ; (31.35)\nMDPA.SA.M // (31.36)\nfor any message M2D. Transforming Mwith the two keys PAandSAsucces-\nsively, in either order, yields the message Mback.\nIn a public-key cryptosystem, we require that no one but Alice be able to com-\npute the function SA./in any practical amount of time. This assumption is crucial\nto keeping encrypted mail sent to Alice private and to knowing that Alice\u2019s digi-tal signatures are authentic. Alice must keep S\nAsecret; if she does not, she loses\nher uniqueness and the cryptosystem cannot provide her with unique capabilities.The assumption that only Alice can compute S\nA./must hold even though everyone", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "980": {"page_number": 981, "page_information": "960 Chapter 31 Number-Theoretic Algorithms\ndecryptcommunication channel\nencryptBob Alice\neavesdropperM M PA SA\nCCDPA.M /\nFigure 31.5 Encryption in a public key system. Bob encrypts the message Musing Alice\u2019s public\nkeyPAand transmits the resulting ciphertext CDPA.M/ over a communication channel to Al-\nice. An eavesdropper who captures the transmitted ciphertext gains no information about M. Alice\nreceives Cand decrypts it using her secret key to obtain the original message MDSA.C /.\nknows PAand can compute PA./, the inverse function to SA./, ef\ufb01ciently. In order\nto design a workable public-key cryptosystem, we must \ufb01gure out how to create\na system in which we can reveal a transformation PA./without thereby revealing\nhow to compute the corresponding inverse transformation SA./. This task appears\nformidable, but we shall see how to accomplish it.\nIn a public-key cryptosystem, encryption works as shown in Figure 31.5. Sup-\npose Bob wishes to send Alice a message Mencrypted so that it will look like\nunintelligible gibberish to an eavesdropper. The scenario for sending the messagegoes as follows.\n/SIBob obtains Alice\u2019s public key PA(from a public directory or directly from\nAlice).\n/SIBob computes the ciphertext CDPA.M / corresponding to the message M\nand sends Cto Alice.\n/SIWhen Alice receives the ciphertext C, she applies her secret key SAto retrieve\nthe original message: SA.C /DSA.PA.M //DM.\nBecause SA./andPA./are inverse functions, Alice can compute Mfrom C.B e -\ncause only Alice is able to compute SA./, Alice is the only one who can compute M\nfrom C. Because Bob encrypts Musing PA./, only Alice can understand the trans-\nmitted message.\nWe can just as easily implement digital signatures within our formulation of a\npublic-key cryptosystem. (There are other ways of approaching the problem of\nconstructing digital signatures, but we shall not go into them here.) Suppose now\nthat Alice wishes to send Bob a digitally signed response M0. Figure 31.6 shows\nhow the digital-signature scenario proceeds.\n/SIAlice computes her digital signature /ESCfor the message M0using her secret\nkeySAand the equation /ESCDSA.M0/.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "981": {"page_number": 982, "page_information": "31.7 The RSA public-key cryptosystem 961\nsign\ncommunication channelverify\n=? acceptBob Alice\nM0\nM0PA SA/ESC\n.M0;/ESC//ESCDSA.M0/\nFigure 31.6 Digital signatures in a public-key system. Alice signs the message M0by appending\nher digital signature /ESCDSA.M0/to it. She transmits the message/signature pair .M0;/ESC/to Bob,\nwho veri\ufb01es it by checking the equation M0DPA./ESC/. If the equation holds, he accepts .M0;/ESC/as\na message that Alice has signed.\n/SIAlice sends the message/signature pair .M0;/ESC/to Bob.\n/SIWhen Bob receives .M0;/ESC/, he can verify that it originated from Alice by us-\ning Alice\u2019s public key to verify the equation M0DPA./ESC/. (Presumably, M0\ncontains Alice\u2019s name, so Bob knows whose public key to use.) If the equation\nholds, then Bob concludes that the message M0was actually signed by Alice.\nIf the equation fails to hold, Bob concludes either that the message M0or the\ndigital signature /ESCwas corrupted by transmission errors or that the pair .M0;/ESC/\nis an attempted forgery.\nBecause a digital signature provides both authentication of the signer\u2019s identity and\nauthentication of the contents of the signed message, it is analogous to a handwrit-\nten signature at the end of a written document.\nA digital signature must be veri\ufb01able by anyone who has access to the signer\u2019s\npublic key. A signed message can be veri\ufb01ed by one party and then passed on toother parties who can also verify the signature. For example, the message mightbe an electronic check from Alice to Bob. After Bob veri\ufb01es Alice\u2019s signature onthe check, he can give the check to his bank, who can then also verify the signatureand effect the appropriate funds transfer.\nA signed message is not necessarily encrypted; the message can be \u201cin the clear\u201d\nand not protected from disclosure. By composing the above protocols for encryp-\ntion and for signatures, we can create messages that are both signed and encrypted.\nThe signer \ufb01rst appends his or her digital signature to the message and then en-\ncrypts the resulting message/signature pair with the public key of the intended re-\ncipient. The recipient decrypts the received message with his or her secret key toobtain both the original message and its digital signature. The recipient can then\nverify the signature using the public key of the signer. The corresponding com-\nbined process using paper-based systems would be to sign the paper document and", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "982": {"page_number": 983, "page_information": "962 Chapter 31 Number-Theoretic Algorithms\nthen seal the document inside a paper envelope that is opened only by the intended\nrecipient.\nThe RSA cryptosystem\nIn the RSA public-key cryptosystem , a participant creates his or her public and\nsecret keys with the following procedure:\n1. Select at random two large prime numbers pandqsuch that p\u00a4q. The primes\npandqmight be, say, 1024 bits each.\n2. Compute nDpq.\n3. Select a small odd integer ethat is relatively prime to /RS.n/ , which, by equa-\ntion (31.20), equals .p/NUL1/.q/NUL1/.\n4. Compute das the multiplicative inverse of e, modulo /RS.n/ . (Corollary 31.26\nguarantees that dexists and is uniquely de\ufb01ned. We can use the technique of\nSection 31.4 to compute d,g i v e n eand/RS.n/ .)\n5. Publish the pair PD.e; n/ as the participant\u2019s RSA public key .\n6. Keep secret the pair SD.d; n/ as the participant\u2019s RSA secret key .\nFor this scheme, the domain Dis the set Zn. To transform a message Masso-\nciated with a public key PD.e; n/ , compute\nP.M/DMemodn: (31.37)\nTo transform a ciphertext Cassociated with a secret key SD.d; n/ , compute\nS.C/DCdmodn: (31.38)\nThese equations apply to both encryption and signatures. To create a signature, the\nsigner applies his or her secret key to the message to be signed, rather than to aciphertext. To verify a signature, the public key of the signer is applied to it, ratherthan to a message to be encrypted.\nWe can implement the public-key and secret-key operations using the procedure\nM\nODULAR -EXPONENTIATION described in Section 31.6. To analyze the running\ntime of these operations, assume that the public key .e; n/ and secret key .d; n/\nsatisfy lg eDO.1/ ,l gd/DC4\u02c7,a n dl g n/DC4\u02c7. Then, applying a public key requires\nO.1/ modular multiplications and uses O.\u02c72/bit operations. Applying a secret\nkey requires O.\u02c7/ modular multiplications, using O.\u02c73/bit operations.\nTheorem 31.36 (Correctness of RSA)\nThe RSA equations (31.37) and (31.38) de\ufb01ne inverse transformations of Znsatis-\nfying equations (31.35) and (31.36).", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "983": {"page_number": 984, "page_information": "31.7 The RSA public-key cryptosystem 963\nProof From equations (31.37) and (31.38), we have that for any M2Zn,\nP.S.M//DS.P.M//DMed.mod n/ :\nSince eanddare multiplicative inverses modulo /RS.n/D.p/NUL1/.q/NUL1/,\nedD1Ck.p/NUL1/.q/NUL1/\nfor some integer k.B u tt h e n ,i f M6/DC10.mod p/,w eh a v e\nMed/DC1M.Mp/NUL1/k.q/NUL1/.mod p/\n/DC1M..M modp/p/NUL1/k.q/NUL1/.mod p/\n/DC1M.1/k.q/NUL1/.mod p/ (by Theorem 31.31)\n/DC1M. mod p/ :\nAlso, Med/DC1M. mod p/ifM/DC10.mod p/. Thus,\nMed/DC1M. mod p/\nfor all M. Similarly,\nMed/DC1M. mod q/\nfor all M. Thus, by Corollary 31.29 to the Chinese remainder theorem,\nMed/DC1M. mod n/\nfor all M.\nThe security of the RSA cryptosystem rests in large part on the dif\ufb01culty of fac-\ntoring large integers. If an adversary can factor the modulus nin a public key, then\nthe adversary can derive the secret key from the public key, using the knowledge\nof the factors pandqin the same way that the creator of the public key used them.\nTherefore, if factoring large integers is easy, then breaking the RSA cryptosystemis easy. The converse statement, that if factoring large integers is hard, then break-ing RSA is hard, is unproven. After two decades of research, however, no easiermethod has been found to break the RSA public-key cryptosystem than to factorthe modulus n. And as we shall see in Section 31.9, factoring large integers is sur-\nprisingly dif\ufb01cult. By randomly selecting and multiplying together two 1024 -bit\nprimes, we can create a public key that cannot be \u201cbroken\u201d in any feasible amountof time with current technology. In the absence of a fundamental breakthrough inthe design of number-theoretic algorithms, and when implemented with care fol-lowing recommended standards, the RSA cryptosystem is capable of providing ahigh degree of security in applications.\nIn order to achieve security with the RSA cryptosystem, however, we should\nuse integers that are quite long\u2014hundreds or even more than one thousand bits", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "984": {"page_number": 985, "page_information": "964 Chapter 31 Number-Theoretic Algorithms\nlong\u2014to resist possible advances in the art of factoring. At the time of this\nwriting (2009), RSA moduli were commonly in the range of 768 to 2048 bits.To create moduli of such sizes, we must be able to \ufb01nd large primes ef\ufb01ciently.Section 31.8 addresses this problem.\nFor ef\ufb01ciency, RSA is often used in a \u201chybrid\u201d or \u201ckey-management\u201d mode\nwith fast non-public-key cryptosystems. With such a system, the encryption anddecryption keys are identical. If Alice wishes to send a long message Mto Bob\nprivately, she selects a random key Kfor the fast non-public-key cryptosystem and\nencrypts Musing K, obtaining ciphertext C. Here, Cis as long as M,b u t K\nis quite short. Then, she encrypts Kusing Bob\u2019s public RSA key. Since Kis\nshort, computing P\nB.K/ is fast (much faster than computing PB.M /). She then\ntransmits .C; P B.K// to Bob, who decrypts PB.K/ to obtain Kand then uses K\nto decrypt C, obtaining M.\nWe can use a similar hybrid approach to make digital signatures ef\ufb01ciently.\nThis approach combines RSA with a public collision-resistant hash function h\u2014a\nfunction that is easy to compute but for which it is computationally infeasible to\n\ufb01nd two messages MandM0such that h.M /Dh.M0/.T h e v a l u e h.M / is\na short (say, 256-bit) \u201c\ufb01ngerprint\u201d of the message M. If Alice wishes to sign a\nmessage M, she \ufb01rst applies htoMto obtain the \ufb01ngerprint h.M / , which she\nthen encrypts with her secret key. She sends .M; S A.h.M /// to Bob as her signed\nversion of M. Bob can verify the signature by computing h.M / and verifying\nthatPAapplied to SA.h.M // as received equals h.M / . Because no one can create\ntwo messages with the same \ufb01ngerprint, it is computationally infeasible to alter a\nsigned message and preserve the validity of the signature.\nFinally, we note that the use of certi\ufb01cates makes distributing public keys much\neasier. For example, assume there is a \u201ctrusted authority\u201d Twhose public key\nis known by everyone. Alice can obtain from Ta signed message (her certi\ufb01cate)\nstating that \u201cAlice\u2019s public key is PA.\u201d This certi\ufb01cate is \u201cself-authenticating\u201d since\neveryone knows PT. Alice can include her certi\ufb01cate with her signed messages,\nso that the recipient has Alice\u2019s public key immediately available in order to verifyher signature. Because her key was signed by T, the recipient knows that Alice\u2019s\nkey is really Alice\u2019s.\nExercises\n31.7-1\nConsider an RSA key set with pD11,qD29,nD319,a n d eD3.W h a t\nvalue of dshould be used in the secret key? What is the encryption of the message\nMD100?", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "985": {"page_number": 986, "page_information": "31.8 Primality testing 965\n31.7-2\nProve that if Alice\u2019s public exponent eis3and an adversary obtains Alice\u2019s secret\nexponent d,w h e r e 0 < d < /RS.n/ , then the adversary can factor Alice\u2019s modulus n\nin time polynomial in the number of bits in n. (Although you are not asked to prove\nit, you may be interested to know that this result remains true even if the conditioneD3is removed. See Miller [255].)\n31.7-3 ?\nProve that RSA is multiplicative in the sense that\nP\nA.M1/PA.M2//DC1PA.M1M2/.mod n/ :\nUse this fact to prove that if an adversary had a procedure that could ef\ufb01ciently\ndecrypt 1 percent of messages from Znencrypted with PA, then he could employ\na probabilistic algorithm to decrypt every message encrypted with PAwith high\nprobability.\n?31.8 Primality testing\nIn this section, we consider the problem of \ufb01nding large primes. We begin with adiscussion of the density of primes, proceed to examine a plausible, but incomplete,approach to primality testing, and then present an effective randomized primality\ntest due to Miller and Rabin.\nThe density of prime numbers\nFor many applications, such as cryptography, we need to \ufb01nd large \u201crandom\u201d\nprimes. Fortunately, large primes are not too rare, so that it is feasible to test\nrandom integers of the appropriate size until we \ufb01nd a prime. The prime distribu-\ntion function /EM.n/ speci\ufb01es the number of primes that are less than or equal to n.\nFor example, /EM.10/D4, since there are 4 prime numbers less than or equal to 10,\nnamely, 2, 3, 5, and 7. The prime number theorem gives a useful approximationto/EM.n/ .\nTheorem 31.37 (Prime number theorem)\nlim\nn!1/EM.n/\nn=lnnD1:\nThe approximation n=lnngives reasonably accurate estimates of /EM.n/ even\nfor small n. For example, it is off by less than 6%a t nD109,w h e r e /EM.n/D", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "986": {"page_number": 987, "page_information": "966 Chapter 31 Number-Theoretic Algorithms\n50,847,534 and n=lnn/EM48,254,942. (To a number theorist, 109i sas m a l ln u m -\nber.)\nWe can view the process of randomly selecting an integer nand determining\nwhether it is prime as a Bernoulli trial (see Section C.4). By the prime numbertheorem, the probability of a success\u2014that is, the probability that nis prime\u2014is\napproximately 1=lnn. The geometric distribution tells us how many trials we need\nto obtain a success, and by equation (C.32), the expected number of trials is ap-proximately ln n. Thus, we would expect to examine approximately ln nintegers\nchosen randomly near nin order to \ufb01nd a prime that is of the same length as n.\nFor example, we expect that \ufb01nding a 1024 -bit prime would require testing ap-\nproximately ln 2\n1024/EM710randomly chosen 1024 -bit numbers for primality. (Of\ncourse, we can cut this \ufb01gure in half by choosing only odd integers.)\nIn the remainder of this section, we consider the problem of determining whether\nor not a large odd integer nis prime. For notational convenience, we assume that n\nhas the prime factorization\nnDpe1\n1pe2\n2/SOH/SOH/SOHper\nr; (31.39)\nwhere r/NAK1,p1;p2;:::;p rare the prime factors of n,a n d e1;e2;:::;e rare posi-\ntive integers. The integer nis prime if and only if rD1ande1D1.\nOne simple approach to the problem of testing for primality is trial division .W e\ntry dividing nby each integer 2;3 ;:::;bp\nnc. (Again, we may skip even integers\ngreater than 2.) It is easy to see that nis prime if and only if none of the trial divi-\nsors divides n. Assuming that each trial division takes constant time, the worst-case\nrunning time is \u201a.p\nn/, which is exponential in the length of n. (Recall that if n\nis encoded in binary using \u02c7bits, then \u02c7Ddlg.nC1/e,a n ds op\nnD\u201a.2\u02c7=2/.)\nThus, trial division works well only if nis very small or happens to have a small\nprime factor. When it works, trial division has the advantage that it not only de-termines whether nis prime or composite, but also determines one of n\u2019s prime\nfactors if nis composite.\nIn this section, we are interested only in \ufb01nding out whether a given number n\nis prime; if nis composite, we are not concerned with \ufb01nding its prime factor-\nization. As we shall see in Section 31.9, computing the prime factorization of a\nnumber is computationally expensive. It is perhaps surprising that it is much easier\nto tell whether or not a given number is prime than it is to determine the prime\nfactorization of the number if it is not prime.\nPseudoprimality testing\nWe now consider a method for primality testing that \u201calmost works\u201d and in fact\nis good enough for many practical applications. Later on, we shall present a re-", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "987": {"page_number": 988, "page_information": "31.8 Primality testing 967\n\ufb01nement of this method that removes the small defect. Let ZC\nndenote the nonzero\nelements of Zn:\nZC\nnDf1 ;2;:::;n/NUL1g:\nIfnis prime, then ZC\nnDZ/ETX\nn.\nWe say that nis abase- apseudoprime ifnis composite and\nan/NUL1/DC11.mod n/ : (31.40)\nFermat\u2019s theorem (Theorem 31.31) implies that if nis prime, then nsatis\ufb01es equa-\ntion (31.40) for every ainZC\nn. Thus, if we can \ufb01nd any a2ZC\nnsuch that ndoes\nnotsatisfy equation (31.40), then nis certainly composite. Surprisingly, the con-\nverse almost holds, so that this criterion forms an almost perfect test for primality.\nWe test to see whether nsatis\ufb01es equation (31.40) for aD2. If not, we declare n\nto be composite by returning COMPOSITE . Otherwise, we return PRIME , guessing\nthatnis prime (when, in fact, all we know is that nis either prime or a base- 2\npseudoprime).\nThe following procedure pretends in this manner to be checking the primality\nofn. It uses the procedure M ODULAR -EXPONENTIATION from Section 31.6. We\nassume that the input nis an odd integer greater than 2.\nPSEUDOPRIME .n/\n1ifMODULAR -EXPONENTIATION .2; n/NUL1; n/6/DC11.mod n/\n2 return COMPOSITE //de\ufb01nitely\n3else return PRIME //we hope!\nThis procedure can make errors, but only of one type. That is, if it says that n\nis composite, then it is always correct. If it says that nis prime, however, then it\nmakes an error only if nis a base- 2pseudoprime.\nHow often does this procedure err? Surprisingly rarely. There are only 22 values\nofnless than 10,000 for which it errs; the \ufb01rst four such values are 341, 561,\n645, and 1105. We won\u2019t prove it, but the probability that this program makes anerror on a randomly chosen \u02c7-bit number goes to zero as \u02c7!1 .U s i n g m o r e\nprecise estimates due to Pomerance [279] of the number of base- 2pseudoprimes of\na given size, we may estimate that a randomly chosen 512-bit number that is calledprime by the above procedure has less than one chance in 10\n20of being a base- 2\npseudoprime, and a randomly chosen 1024-bit number that is called prime has lessthan one chance in 10\n41of being a base- 2pseudoprime. So if you are merely\ntrying to \ufb01nd a large prime for some application, for all practical purposes youalmost never go wrong by choosing large numbers at random until one of themcauses P\nSEUDOPRIME to return PRIME . But when the numbers being tested for\nprimality are not randomly chosen, we need a better approach for testing primality.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "988": {"page_number": 989, "page_information": "968 Chapter 31 Number-Theoretic Algorithms\nAs we shall see, a little more cleverness, and some randomization, will yield a\nprimality-testing routine that works well on all inputs.\nUnfortunately, we cannot entirely eliminate all the errors by simply checking\nequation (31.40) for a second base number, say aD3, because there exist com-\nposite integers n, known as Carmichael numbers , that satisfy equation (31.40) for\nalla2Z/ETX\nn. (We note that equation (31.40) does fail when gcd .a; n/ > 1 \u2014that\nis, when a62Z/ETX\nn\u2014but hoping to demonstrate that nis composite by \ufb01nding such\nanacan be dif\ufb01cult if nhas only large prime factors.) The \ufb01rst three Carmichael\nnumbers are 561, 1105, and 1729. Carmichael numbers are extremely rare; there\nare, for example, only 255 of them less than 100,000,000. Exercise 31.8-2 helpsexplain why they are so rare.\nWe next show how to improve our primality test so that it won\u2019t be fooled by\nCarmichael numbers.\nThe Miller-Rabin randomized primality test\nThe Miller-Rabin primality test overcomes the problems of the simple test P\nSEU-\nDOPRIME with two modi\ufb01cations:\n/SIIt tries several randomly chosen base values ainstead of just one base value.\n/SIWhile computing each modular exponentiation, it looks for a nontrivial square\nroot of 1, modulo n, during the \ufb01nal set of squarings. If it \ufb01nds one, it stops\nand returns COMPOSITE . Corollary 31.35 from Section 31.6 justi\ufb01es detecting\ncomposites in this manner.\nThe pseudocode for the Miller-Rabin primality test follows. The input n>2 is\nthe odd number to be tested for primality, and sis the number of randomly cho-\nsen base values from ZC\nnto be tried. The code uses the random-number generator\nRANDOM described on page 117: R ANDOM .1; n/NUL1/returns a randomly chosen\ninteger asatisfying 1/DC4a/DC4n/NUL1. The code uses an auxiliary procedure W ITNESS\nsuch that W ITNESS .a; n/ isTRUE if and only if ais a \u201cwitness\u201d to the composite-\nness of n\u2014that is, if it is possible using ato prove (in a manner that we shall see)\nthatnis composite. The test W ITNESS .a; n/ is an extension of, but more effective\nthan, the test\nan/NUL16/DC11.mod n/\nthat formed the basis (using aD2)f o rP SEUDOPRIME . We \ufb01rst present and\njustify the construction of W ITNESS , and then we shall show how we use it in the\nMiller-Rabin primality test. Let n/NUL1D2tuwhere t/NAK1anduis odd; i.e.,\nthe binary representation of n/NUL1is the binary representation of the odd integer u\nfollowed by exactly tzeros. Therefore, an/NUL1/DC1.au/2t.mod n/, so that we can", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "989": {"page_number": 990, "page_information": "31.8 Primality testing 969\ncompute an/NUL1modnby \ufb01rst computing aumodnand then squaring the result t\ntimes successively.\nWITNESS .a; n/\n1l e t tandube such that t/NAK1,uis odd, and n/NUL1D2tu\n2x0DMODULAR -EXPONENTIATION . a;u ;n /\n3foriD1tot\n4 xiDx2\ni/NUL1modn\n5 ifxi==1andxi/NUL1\u00a41andxi/NUL1\u00a4n/NUL1\n6 return TRUE\n7ifxt\u00a41\n8 return TRUE\n9return FALSE\nThis pseudocode for W ITNESS computes an/NUL1modnby \ufb01rst computing the\nvalue x0Daumodnin line 2 and then squaring the result ttimes in a row in the\nforloop of lines 3\u20136. By induction on i, the sequence x0,x1, ..., xtof values\ncomputed satis\ufb01es the equation xi/DC1a2iu.mod n/foriD0; 1; : : : ; t ,s ot h a ti n\nparticular xt/DC1an/NUL1.mod n/. After line 4 performs a squaring step, however,\nthe loop may terminate early if lines 5\u20136 detect that a nontrivial square root of 1\nhas just been discovered. (We shall explain these tests shortly.) If so, the algo-rithm stops and returns\nTRUE . Lines 7\u20138 return TRUE if the value computed for\nxt/DC1an/NUL1.mod n/is not equal to 1, just as the P SEUDOPRIME procedure returns\nCOMPOSITE in this case. Line 9 returns FALSE if we haven\u2019t returned TRUE in\nlines 6 or 8.\nWe now argue that if W ITNESS .a; n/ returns TRUE , then we can construct a\nproof that nis composite using aas a witness.\nIf W ITNESS returns TRUE from line 8, then it has discovered that xtD\nan/NUL1modn\u00a41.I fnis prime, however, we have by Fermat\u2019s theorem (Theo-\nrem 31.31) that an/NUL1/DC11.mod n/for all a2ZC\nn. Therefore, ncannot be prime,\nand the equation an/NUL1modn\u00a41proves this fact.\nIf W ITNESS returns TRUE from line 6, then it has discovered that xi/NUL1is a non-\ntrivial square root of 1, modulo n, since we have that xi/NUL16/DC1\u02d9 1.mod n/yet\nxi/DC1x2\ni/NUL1/DC11.mod n/. Corollary 31.35 states that only if nis composite can\nthere exist a nontrivial square root of 1modulo n, so that demonstrating that xi/NUL1\nis a nontrivial square root of 1modulo nproves that nis composite.\nThis completes our proof of the correctness of W ITNESS . If we \ufb01nd that the call\nWITNESS .a; n/ returns TRUE ,t h e n nis surely composite, and the witness a, along\nwith the reason that the procedure returns TRUE (did it return from line 6 or from\nline 8?), provides a proof that nis composite.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "990": {"page_number": 991, "page_information": "970 Chapter 31 Number-Theoretic Algorithms\nAt this point, we brie\ufb02y present an alternative description of the behavior of\nWITNESS as a function of the sequence XDhx0;x1;:::;x ti, which we shall \ufb01nd\nuseful later on, when we analyze the ef\ufb01ciency of the Miller-Rabin primality test.Note that if x\niD1for some 0/DC4i<t ,W ITNESS might not compute the rest\nof the sequence. If it were to do so, however, each value xiC1;xiC2;:::;x twould\nbe1, and we consider these positions in the sequence Xas being all 1s. We have\nfour cases:\n1.XDh:::;di,w h e r e d\u00a41: the sequence Xdoes not end in 1.R e t u r n TRUE\nin line 8; ais a witness to the compositeness of n(by Fermat\u2019s Theorem).\n2.XDh1; 1; : : : ; 1i: the sequence Xis all 1s. Return FALSE ;ais not a witness\nto the compositeness of n.\n3.XDh:::;/NUL1; 1; : : : ; 1i: the sequence Xends in 1, and the last non- 1is equal\nto/NUL1.R e t u r n FALSE ;ais not a witness to the compositeness of n.\n4.XDh:::;d;1 ;:::;1i,w h e r e d\u00a4\u02d91: the sequence Xends in 1, but the last\nnon-1is not/NUL1.R e t u r n TRUE in line 6; ais a witness to the compositeness\nofn,s i n c e dis a nontrivial square root of 1.\nWe now examine the Miller-Rabin primality test based on the use of W ITNESS .\nAgain, we assume that nis an odd integer greater than 2.\nMILLER -RABIN .n; s/\n1forjD1tos\n2 aDRANDOM .1; n/NUL1/\n3 ifWITNESS .a; n/\n4 return COMPOSITE //de\ufb01nitely\n5return PRIME //almost surely\nThe procedure M ILLER -RABIN is a probabilistic search for a proof that nis\ncomposite. The main loop (beginning on line 1) picks up to srandom values of a\nfrom ZC\nn(line 2). If one of the a\u2019s picked is a witness to the compositeness of n,\nthen M ILLER -RABIN returns COMPOSITE on line 4. Such a result is always cor-\nrect, by the correctness of W ITNESS .I f M ILLER -RABIN \ufb01nds no witness in s\ntrials, then the procedure assumes that this is because no witnesses exist, and there-fore it assumes that nis prime. We shall see that this result is likely to be correct\nifsis large enough, but that there is still a tiny chance that the procedure may be\nunlucky in its choice of a\u2019s and that witnesses do exist even though none has been\nfound.\nTo illustrate the operation of M\nILLER -RABIN ,l e tnbe the Carmichael num-\nber561,s ot h a t n/NUL1D560D24/SOH35,tD4,a n d uD35. If the pro-\ncedure chooses aD7as a base, Figure 31.4 in Section 31.6 shows that W IT-\nNESS computes x0/DC1a35/DC1241 . mod 561/ and thus computes the sequence", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "991": {"page_number": 992, "page_information": "31.8 Primality testing 971\nXDh241; 298; 166; 67; 1 i. Thus, W ITNESS discovers a nontrivial square root\nof1in the last squaring step, since a280/DC167 . mod n/anda560/DC11.mod n/.\nTherefore, aD7is a witness to the compositeness of n,W ITNESS .7; n/ returns\nTRUE ,a n dM ILLER -RABIN returns COMPOSITE .\nIfnis a\u02c7-bit number, M ILLER -RABIN requires O.s\u02c7/ arithmetic operations\nandO.s\u02c73/bit operations, since it requires asymptotically no more work than s\nmodular exponentiations.\nError rate of the Miller-Rabin primality test\nIf M ILLER -RABIN returns PRIME , then there is a very slim chance that it has made\nan error. Unlike P SEUDOPRIME , however, the chance of error does not depend\nonn; there are no bad inputs for this procedure. Rather, it depends on the size of s\nand the \u201cluck of the draw\u201d in choosing base values a. Moreover, since each test is\nmore stringent than a simple check of equation (31.40), we can expect on generalprinciples that the error rate should be small for randomly chosen integers n.T h e\nfollowing theorem presents a more precise argument.\nTheorem 31.38\nIfnis an odd composite number, then the number of witnesses to the composite-\nness of nis at least .n/NUL1/=2 .\nProof The proof shows that the number of nonwitnesses is at most .n/NUL1/=2 ,\nwhich implies the theorem.\nWe start by claiming that any nonwitness must be a member of Z\n/ETX\nn. Why?\nConsider any nonwitness a. It must satisfy an/NUL1/DC11.mod n/or, equivalently,\na/SOHan/NUL2/DC11.mod n/. Thus, the equation ax/DC11.mod n/has a solution,\nnamely an/NUL2. By Corollary 31.21, gcd .a; n/j1, which in turn implies that\ngcd.a; n/D1. Therefore, ai sam e m b e ro f Z/ETX\nn; all nonwitnesses belong to Z/ETX\nn.\nTo complete the proof, we show that not only are all nonwitnesses contained\ninZ/ETX\nn, they are all contained in a proper subgroup BofZ/ETX\nn(recall that we say B\nis aproper subgroup of Z/ETX\nnwhen Bis subgroup of Z/ETX\nnbutBis not equal to Z/ETX\nn).\nBy Corollary 31.16, we then have jBj/DC4jZ/ETX\nnj=2.S i n c ejZ/ETX\nnj/DC4n/NUL1, we obtain\njBj/DC4.n/NUL1/=2 . Therefore, the number of nonwitnesses is at most .n/NUL1/=2 ,s o\nthat the number of witnesses must be at least .n/NUL1/=2 .\nWe now show how to \ufb01nd a proper subgroup BofZ/ETX\nncontaining all of the\nnonwitnesses. We break the proof into two cases.\nCase 1: There exists an x2Z/ETX\nnsuch that\nxn/NUL16/DC11.mod n/ :", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "992": {"page_number": 993, "page_information": "972 Chapter 31 Number-Theoretic Algorithms\nIn other words, nis not a Carmichael number. Because, as we noted earlier,\nCarmichael numbers are extremely rare, case 1 is the main case that arises \u201cinpractice\u201d (e.g., when nhas been chosen randomly and is being tested for primal-\nity).\nLetBDfb2Z\n/ETX\nnWbn/NUL1/DC11.mod n/g. Clearly, Bis nonempty, since 12B.\nSince Bis closed under multiplication modulo n,w eh a v et h a t Bis a subgroup\nofZ/ETX\nnby Theorem 31.14. Note that every nonwitness belongs to B, since a non-\nwitness asatis\ufb01es an/NUL1/DC11.mod n/.S i n c e x2Z/ETX\nn/NULB,w eh a v et h a t Bis a\nproper subgroup of Z/ETX\nn.\nCase 2: For all x2Z/ETX\nn,\nxn/NUL1/DC11.mod n/ : (31.41)\nIn other words, nis a Carmichael number. This case is extremely rare in prac-\ntice. However, the Miller-Rabin test (unlike a pseudo-primality test) can ef\ufb01cientlydetermine that Carmichael numbers are composite, as we now show.\nIn this case, ncannot be a prime power. To see why, let us suppose to the\ncontrary that nDp\ne,w h e r e pis a prime and e>1 . We derive a contradiction\nas follows. Since we assume that nis odd, pmust also be odd. Theorem 31.32\nimplies that Z/ETX\nnis a cyclic group: it contains a generator gsuch that ord n.g/D\njZ/ETX\nnjD/RS.n/Dpe.1/NUL1=p/D.p/NUL1/pe/NUL1. (The formula for /RS.n/ comes from\nequation (31.20).) By equation (31.41), we have gn/NUL1/DC11.mod n/. Then the\ndiscrete logarithm theorem (Theorem 31.33, taking yD0) implies that n/NUL1/DC10\n.mod /RS.n// ,o r\n.p/NUL1/pe/NUL1jpe/NUL1:\nThis is a contradiction for e>1 ,s i n c e .p/NUL1/pe/NUL1is divisible by the prime p\nbutpe/NUL1is not. Thus, nis not a prime power.\nSince the odd composite number nis not a prime power, we decompose it into\na product n1n2,w h e r e n1andn2are odd numbers greater than 1 that are relatively\nprime to each other. (There may be several ways to decompose n, and it does not\nmatter which one we choose. For example, if nDpe1\n1pe2\n2/SOH/SOH/SOHper\nr, then we can\nchoose n1Dpe1\n1andn2Dpe2\n2pe3\n3/SOH/SOH/SOHper\nr.)\nRecall that we de\ufb01ne tanduso that n/NUL1D2tu,w h e r e t/NAK1anduis odd, and\nthat for an input a, the procedure W ITNESS computes the sequence\nXDhau;a2u;a22u;:::;a2tui\n(all computations are performed modulo n).\nLet us call a pair ./ETB; j / of integers acceptable if/ETB2Z/ETX\nn,j2f0; 1; : : : ; tg,a n d\n/ETB2ju/DC1/NUL1.mod n/ :", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "993": {"page_number": 994, "page_information": "31.8 Primality testing 973\nAcceptable pairs certainly exist since uis odd; we can choose /ETBDn/NUL1and\njD0,s ot h a t .n/NUL1; 0/ is an acceptable pair. Now pick the largest possible jsuch\nthat there exists an acceptable pair ./ETB; j / ,a n d\ufb01 x /ETBso that ./ETB; j / is an acceptable\npair. Let\nBDfx2Z/ETX\nnWx2ju/DC1\u02d91.mod n/g:\nSince Bis closed under multiplication modulo n, it is a subgroup of Z/ETX\nn. By Theo-\nrem 31.15, therefore, jBjdividesjZ/ETX\nnj. Every nonwitness must be a member of B,\nsince the sequence Xproduced by a nonwitness must either be all 1s or else contain\na/NUL1no later than the jth position, by the maximality of j. (If.a; j0/is acceptable,\nwhere ais a nonwitness, we must have j0/DC4jby how we chose j.)\nWe now use the existence of /ETBto demonstrate that there exists a w2Z/ETX\nn/NULB,\nand hence that Bis a proper subgroup of Z/ETX\nn.S i n c e /ETB2ju/DC1/NUL1.mod n/,w eh a v e\n/ETB2ju/DC1/NUL1.mod n1/by Corollary 31.29 to the Chinese remainder theorem. By\nCorollary 31.28, there exists a wsimultaneously satisfying the equations\nw/DC1/ETB.mod n1/;\nw/DC11.mod n2/:\nTherefore,\nw2ju/DC1/NUL 1.mod n1/;\nw2ju/DC1 1.mod n2/:\nBy Corollary 31.29, w2ju6/DC11.mod n1/implies w2ju6/DC11.mod n/,a n d\nw2ju6/DC1/NUL1.mod n2/implies w2ju6/DC1/NUL1.mod n/. Hence, we conclude that\nw2ju6/DC1\u02d91.mod n/,a n ds o w62B.\nIt remains to show that w2Z/ETX\nn, which we do by \ufb01rst working separately mod-\nulon1and modulo n2. Working modulo n1, we observe that since /ETB2Z/ETX\nn,w e\nhave that gcd ./ETB; n/D1, and so also gcd ./ETB; n 1/D1;i f/ETBdoes not have any com-\nmon divisors with n, then it certainly does not have any common divisors with n1.\nSince w/DC1/ETB.mod n1/, we see that gcd .w; n 1/D1. Working modulo n2,w e\nobserve that w/DC11.mod n2/implies gcd .w; n 2/D1. To combine these results,\nwe use Theorem 31.6, which implies that gcd .w; n 1n2/Dgcd.w; n/D1.T h a ti s ,\nw2Z/ETX\nn.\nTherefore w2Z/ETX\nn/NULB, and we \ufb01nish case 2 with the conclusion that Bis a\nproper subgroup of Z/ETX\nn.\nIn either case, we see that the number of witnesses to the compositeness of nis\nat least .n/NUL1/=2 .\nTheorem 31.39\nFor any odd integer n>2 and positive integer s, the probability that M ILLER -\nRABIN .n; s/ errs is at most 2/NULs.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "994": {"page_number": 995, "page_information": "974 Chapter 31 Number-Theoretic Algorithms\nProof Using Theorem 31.38, we see that if nis composite, then each execution of\ntheforloop of lines 1\u20134 has a probability of at least 1=2of discovering a witness x\nto the compositeness of n.M ILLER -RABIN makes an error only if it is so unlucky\nas to miss discovering a witness to the compositeness of non each of the siterations\nof the main loop. The probability of such a sequence of misses is at most 2/NULs.\nIfnis prime, M ILLER -RABIN always reports P RIME ,a n di f nis composite, the\nchance that M ILLER -RABIN reports P RIME is at most 2/NULs.\nWhen applying M ILLER -RABIN to a large randomly chosen integer n,h o w e v e r ,\nwe need to consider as well the prior probability that nis prime, in order to cor-\nrectly interpret M ILLER -RABIN \u2019s result. Suppose that we \ufb01x a bit length \u02c7and\nchoose at random an integer nof length \u02c7bits to be tested for primality. Let A\ndenote the event that nis prime. By the prime number theorem (Theorem 31.37),\nthe probability that nis prime is approximately\nPrfAg/EM1=lnn\n/EM1:443=\u02c7 :\nNow let Bdenote the event that M ILLER -RABIN returns P RIME .W e h a v e t h a t\nPr\u02da\nBjA/TAB\nD0(or equivalently, that Pr fBjAgD1)a n dP r\u02da\nBj\nA/TAB\n/DC42/NULs(or\nequivalently, that Pr\u02da\nBj\nA/TAB\n>1/NUL2/NULs).\nBut what is PrfAjBg, the probability that nis prime, given that M ILLER -\nRABIN has returned P RIME ? By the alternate form of Bayes\u2019s theorem (equa-\ntion (C.18)) we have\nPrfAjBgDPrfAgPrfBjAg\nPrfAgPrfBjAgCPr\u02da\nA/TAB\nPr\u02da\nBj\nA/TAB\n/EM1\n1C2/NULs.lnn/NUL1/:\nThis probability does not exceed 1=2until sexceeds lg .lnn/NUL1/. Intuitively, that\nmany initial trials are needed just for the con\ufb01dence derived from failing to \ufb01nd awitness to the compositeness of nto overcome the prior bias in favor of nbeing\ncomposite. For a number with \u02c7D1024 bits, this initial testing requires about\nlg.lnn/NUL1//EMlg.\u02c7=1:443/\n/EM9\ntrials. In any case, choosing sD50should suf\ufb01ce for almost any imaginable\napplication.\nIn fact, the situation is much better. If we are trying to \ufb01nd large primes by\napplying M\nILLER -RABIN to large randomly chosen odd integers, then choosing\na small value of s(say3) is very unlikely to lead to erroneous results, though", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "995": {"page_number": 996, "page_information": "31.9 Integer factorization 975\nwe won\u2019t prove it here. The reason is that for a randomly chosen odd composite\ninteger n, the expected number of nonwitnesses to the compositeness of nis likely\nto be very much smaller than .n/NUL1/=2 .\nIf the integer nis not chosen randomly, however, the best that can be proven is\nthat the number of nonwitnesses is at most .n/NUL1/=4, using an improved version\nof Theorem 31.38. Furthermore, there do exist integers nfor which the number of\nnonwitnesses is .n/NUL1/=4.\nExercises\n31.8-1\nProve that if an odd integer n>1 is not a prime or a prime power, then there exists\na nontrivial square root of 1modulo n.\n31.8-2 ?\nIt is possible to strengthen Euler\u2019s theorem slightly to the form\na/NAK.n//DC11.mod n/for all a2Z/ETX\nn;\nwhere nDpe1\n1/SOH/SOH/SOHper\nrand/NAK.n/ is de\ufb01ned by\n/NAK.n/Dlcm./RS.pe1\n1/ ;:::;/RS. per\nr// : (31.42)\nProve that /NAK.n/j/RS.n/ . A composite number nis a Carmichael number if\n/NAK.n/jn/NUL1. The smallest Carmichael number is 561D3/SOH11/SOH17; here,\n/NAK.n/Dlcm.2; 10; 16/D80, which divides 560. Prove that Carmichael num-\nbers must be both \u201csquare-free\u201d (not divisible by the square of any prime) and theproduct of at least three primes. (For this reason, they are not very common.)\n31.8-3\nProve that if xis a nontrivial square root of 1, modulo n,t h e ng c d .x/NUL1; n/ and\ngcd.xC1; n/ are both nontrivial divisors of n.\n?31.9 Integer factorization\nSuppose we have an integer nthat we wish to factor , that is, to decompose into a\nproduct of primes. The primality test of the preceding section may tell us that nis\ncomposite, but it does not tell us the prime factors of n. Factoring a large integer n\nseems to be much more dif\ufb01cult than simply determining whether nis prime or\ncomposite. Even with today\u2019s supercomputers and the best algorithms to date, wecannot feasibly factor an arbitrary 1024 -bit number.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "996": {"page_number": 997, "page_information": "976 Chapter 31 Number-Theoretic Algorithms\nPollard\u2019s rho heuristic\nTrial division by all integers up to Ris guaranteed to factor completely any number\nup to R2. For the same amount of work, the following procedure, P OLLARD -RHO,\nfactors any number up to R4(unless we are unlucky). Since the procedure is only\na heuristic, neither its running time nor its success is guaranteed, although theprocedure is highly effective in practice. Another advantage of the P\nOLLARD -\nRHOprocedure is that it uses only a constant number of memory locations. (If you\nwanted to, you could easily implement P OLLARD -RHOon a programmable pocket\ncalculator to \ufb01nd factors of small numbers.)\nPOLLARD -RHO.n/\n1iD1\n2x1DRANDOM .0; n/NUL1/\n3yDx1\n4kD2\n5while TRUE\n6 iDiC1\n7 xiD.x2\ni/NUL1/NUL1/modn\n8 dDgcd.y/NULxi;n /\n9 ifd\u00a41andd\u00a4n\n10 print d\n11 ifi==k\n12 yDxi\n13 kD2k\nThe procedure works as follows. Lines 1\u20132 initialize ito1andx1to a randomly\nchosen value in Zn.T h e while loop beginning on line 5 iterates forever, searching\nfor factors of n. During each iteration of the while loop, line 7 uses the recurrence\nxiD.x2\ni/NUL1/NUL1/modn (31.43)\nto produce the next value of xiin the in\ufb01nite sequence\nx1;x2;x3;x4;::: ; (31.44)\nwith line 6 correspondingly incrementing i. The pseudocode is written using sub-\nscripted variables xifor clarity, but the program works the same if all of the sub-\nscripts are dropped, since only the most recent value of xineeds to be maintained.\nWith this modi\ufb01cation, the procedure uses only a constant number of memory lo-\ncations.\nEvery so often, the program saves the most recently generated xivalue in the\nvariable y. Speci\ufb01cally, the values that are saved are the ones whose subscripts are\npowers of 2:", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "997": {"page_number": 998, "page_information": "31.9 Integer factorization 977\nx1;x2;x4;x8;x16;::: :\nLine 3 saves the value x1, and line 12 saves xkwhenever iis equal to k.T h e\nvariable kis initialized to 2 in line 4, and line 13 doubles it whenever line 12\nupdates y. Therefore, kfollows the sequence 1;2;4;8;::: and always gives the\nsubscript of the next value xkto be saved in y.\nLines 8\u201310 try to \ufb01nd a factor of n, using the saved value of yand the cur-\nrent value of xi. Speci\ufb01cally, line 8 computes the greatest common divisor\ndDgcd.y/NULxi;n /. If line 9 \ufb01nds dto be a nontrivial divisor of n, then line 10\nprints d.\nThis procedure for \ufb01nding a factor may seem somewhat mysterious at \ufb01rst.\nNote, however, that P OLLARD -RHOnever prints an incorrect answer; any num-\nber it prints is a nontrivial divisor of n.POLLARD -RHOmight not print anything\nat all, though; it comes with no guarantee that it will print any divisors. We shallsee, however, that we have good reason to expect P\nOLLARD -RHOto print a fac-\ntorpofnafter \u201a.p\np/iterations of the while loop. Thus, if nis composite, we\ncan expect this procedure to discover enough divisors to factor ncompletely after\napproximately n1=4updates, since every prime factor pofnexcept possibly the\nlargest one is less thanp\nn.\nWe begin our analysis of how this procedure behaves by studying how long\nit takes a random sequence modulo nto repeat a value. Since Znis \ufb01nite, and\nsince each value in the sequence (31.44) depends only on the previous value, thesequence (31.44) eventually repeats itself. Once we reach an x\nisuch that xiDxj\nfor some j< i , we are in a cycle, since xiC1DxjC1,xiC2DxjC2, and so on.\nThe reason for the name \u201crho heuristic\u201d is that, as Figure 31.7 shows, we can draw\nthe sequence x1;x2;:::;x j/NUL1as the \u201ctail\u201d of the rho and the cycle xj;xjC1;:::;x i\nas the \u201cbody\u201d of the rho.\nLet us consider the question of how long it takes for the sequence of xito repeat.\nThis information is not exactly what we need, but we shall see later how to modify\nthe argument. For the purpose of this estimation, let us assume that the function\nfn.x/D.x2/NUL1/modn\nbehaves like a \u201crandom\u201d function. Of course, it is not really random, but this as-\nsumption yields results consistent with the observed behavior of P OLLARD -RHO.\nWe can then consider each xito have been independently drawn from Znaccording\nto a uniform distribution on Zn. By the birthday-paradox analysis of Section 5.4.1,\nwe expect \u201a.p\nn/steps to be taken before the sequence cycles.\nNow for the required modi\ufb01cation. Let pbe a nontrivial factor of nsuch that\ngcd.p; n=p/D1. For example, if nhas the factorization nDpe1\n1pe2\n2/SOH/SOH/SOHper\nr,t h e n\nwe may take pto be pe1\n1. (Ife1D1,t h e n pis just the smallest prime factor of n,\na good example to keep in mind.)", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "998": {"page_number": 999, "page_information": "978 Chapter 31 Number-Theoretic Algorithms\n996 310\n396\n84\n120\n529\n1053 595339814\n1194\n63\n8\n3\n2\n(b) (c) (a)3\n218\n26\n831\n11\n47177\n1186\nmod 1387 mod 19 mod 7386\n1663\n3\n2 x1x2x3x4x5x6x7\nx0\n1x0\n2x0\n3x0\n4\nx0\n5x0\n6x0\n7\nx00\n1x00\n2x00\n3x00\n4x00\n5x00\n6x00\n7\nFigure 31.7 Pollard\u2019s rho heuristic. (a)The values produced by the recurrence xiC1D\n.x2\ni/NUL1/mod1387 , starting with x1D2. The prime factorization of 1387 is19/SOH73. The heavy\narrows indicate the iteration steps that are executed before the factor 19 is discovered. The light\narrows point to unreached values in the iteration, to illustrate the \u201crho\u201d shape. The shaded values are\ntheyvalues stored by P OLLARD -RHO. The factor 19 is discovered upon reaching x7D177,w h e n\ngcd.63/NUL177; 1387/D19is computed. The \ufb01rst xvalue that would be repeated is 1186, but the\nfactor 19 is discovered before this value is repeated. (b)The values produced by the same recurrence,\nmodulo 19. Every value xigiven in part (a) is equivalent, modulo 19, to the value x0\nishown here.\nFor example, both x4D63andx7D177are equivalent to 6, modulo 19. (c)The values produced\nby the same recurrence, modulo 73. Every value xigiven in part (a) is equivalent, modulo 73, to the\nvalue x00\nishown here. By the Chinese remainder theorem, each node in part (a) corresponds to a pair\nof nodes, one from part (b) and one from part (c).\nThe sequencehxiiinduces a corresponding sequence hx0\niimodulo p,w h e r e\nx0\niDximodp\nfor all i.\nFurthermore, because fnis de\ufb01ned using only arithmetic operations (squaring\nand subtraction) modulo n, we can compute x0\niC1from x0\ni; the \u201cmodulo p\u201dv i e wo f", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "999": {"page_number": 1000, "page_information": "31.9 Integer factorization 979\nthe sequence is a smaller version of what is happening modulo n:\nx0\niC1DxiC1modp\nDfn.xi/modp\nD..x2\ni/NUL1/modn/modp\nD.x2\ni/NUL1/modp (by Exercise 31.1-7)\nD..ximodp/2/NUL1/modp\nD..x0\ni/2/NUL1/modp\nDfp.x0\ni/:\nThus, although we are not explicitly computing the sequence hx0\nii, this sequence is\nwell de\ufb01ned and obeys the same recurrence as the sequence hxii.\nReasoning as before, we \ufb01nd that the expected number of steps before the se-\nquencehx0\niirepeats is \u201a.p\np/.I fpis small compared to n, the sequencehx0\niimight\nrepeat much more quickly than the sequence hxii. Indeed, as parts (b) and (c) of\nFigure 31.7 show, the hx0\niisequence repeats as soon as two elements of the se-\nquencehxiiare merely equivalent modulo p, rather than equivalent modulo n.\nLettdenote the index of the \ufb01rst repeated value in the hx0\niisequence, and let\nu>0 denote the length of the cycle that has been thereby produced. That is, t\nandu>0 are the smallest values such that x0\ntCiDx0\ntCuCifor all i/NAK0.B y t h e\nabove arguments, the expected values of tanduare both \u201a.p\np/. Note that if\nx0\ntCiDx0\ntCuCi,t h e n pj.xtCuCi/NULxtCi/. Thus, gcd .xtCuCi/NULxtCi;n />1 .\nTherefore, once P OLLARD -RHOhas saved as yany value xksuch that k/NAKt,\nthenymodpis always on the cycle modulo p. (If a new value is saved as y,\nthat value is also on the cycle modulo p.) Eventually, kis set to a value that\nis greater than u, and the procedure then makes an entire loop around the cycle\nmodulo pwithout changing the value of y. The procedure then discovers a factor\nofnwhen xi\u201cruns into\u201d the previously stored value of y, modulo p, that is, when\nxi/DC1y.mod p/.\nPresumably, the factor found is the factor p, although it may occasionally hap-\npen that a multiple of pis discovered. Since the expected values of both tanduare\n\u201a.p\np/, the expected number of steps required to produce the factor pis\u201a.p\np/.\nThis algorithm might not perform quite as expected, for two reasons. First, the\nheuristic analysis of the running time is not rigorous, and it is possible that the cycleof values, modulo p, could be much larger thanp\np. In this case, the algorithm\nperforms correctly but much more slowly than desired. In practice, this issue seemsto be moot. Second, the divisors of nproduced by this algorithm might always be\none of the trivial factors 1orn. For example, suppose that nDpq,w h e r e p\nandqare prime. It can happen that the values of tanduforpare identical with\nthe values of tanduforq, and thus the factor pis always revealed in the same\ngcd operation that reveals the factor q. Since both factors are revealed at the same", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "1000": {"page_number": 1001, "page_information": "980 Chapter 31 Number-Theoretic Algorithms\ntime, the trivial factor pqDnis revealed, which is useless. Again, this problem\nseems to be insigni\ufb01cant in practice. If necessary, we can restart the heuristic witha different recurrence of the form x\niC1D.x2\ni/NULc/modn. (We should avoid the\nvalues cD0andcD2for reasons we will not go into here, but other values are\n\ufb01ne.)\nOf course, this analysis is heuristic and not rigorous, since the recurrence is\nnot really \u201crandom.\u201d Nonetheless, the procedure performs well in practice, andit seems to be as ef\ufb01cient as this heuristic analysis indicates. It is the method of\nchoice for \ufb01nding small prime factors of a large number. To factor a \u02c7-bit compos-\nite number ncompletely, we only need to \ufb01nd all prime factors less than bn\n1=2c,\nand so we expect P OLLARD -RHOto require at most n1=4D2\u02c7=4arithmetic opera-\ntions and at most n1=4\u02c72D2\u02c7=4\u02c72bit operations. P OLLARD -RHO\u2019s ability to \ufb01nd\na small factor pofnwith an expected number \u201a.p\np/of arithmetic operations is\noften its most appealing feature.\nExercises\n31.9-1\nReferring to the execution history shown in Figure 31.7(a), when does P OLLARD -\nRHOprint the factor 73 of 1387?\n31.9-2\nSuppose that we are given a function fWZn! Znand an initial value x02Zn.\nDe\ufb01ne xiDf. x i/NUL1/foriD1 ;2;::: .L e t tandu>0 be the smallest values such\nthatxtCiDxtCuCiforiD0; 1; : : : . In the terminology of Pollard\u2019s rho algorithm,\ntis the length of the tail and uis the length of the cycle of the rho. Give an ef\ufb01cient\nalgorithm to determine tanduexactly, and analyze its running time.\n31.9-3\nHow many steps would you expect P OLLARD -RHOto require to discover a factor\nof the form pe,w h e r e pis prime and e>1 ?\n31.9-4 ?\nOne disadvantage of P OLLARD -RHOas written is that it requires one gcd compu-\ntation for each step of the recurrence. Instead, we could batch the gcd computa-\ntions by accumulating the product of several xivalues in a row and then using this\nproduct instead of xiin the gcd computation. Describe carefully how you would\nimplement this idea, why it works, and what batch size you would pick as the most\neffective when working on a \u02c7-bit number n.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "1001": {"page_number": 1002, "page_information": "Problems for Chapter 31 981\nProblems\n31-1 Binary gcd algorithm\nMost computers can perform the operations of subtraction, testing the parity (oddor even) of a binary integer, and halving more quickly than computing remainders.This problem investigates the binary gcd algorithm , which avoids the remainder\ncomputations used in Euclid\u2019s algorithm.\na.Prove that if aandbare both even, then gcd .a; b/D2/SOHgcd.a=2; b=2/ .\nb.Prove that if ais odd and bis even, then gcd .a; b/Dgcd.a; b=2/ .\nc.Prove that if aandbare both odd, then gcd .a; b/Dgcd..a/NULb/=2;b/ .\nd.Design an ef\ufb01cient binary gcd algorithm for input integers aandb,w h e r e\na/NAKb, that runs in O.lga/time. Assume that each subtraction, parity test,\nand halving takes unit time.\n31-2 Analysis of bit operations in Euclid\u2019s algorithm\na.Consider the ordinary \u201cpaper and pencil\u201d algorithm for long division: dividing\nabyb, which yields a quotient qand remainder r. Show that this method\nrequires O..1Clgq/lgb/bit operations.\nb.De\ufb01ne /SYN.a; b/D.1Clga/.1Clgb/. Show that the number of bit operations\nperformed by E\nUCLID in reducing the problem of computing gcd .a; b/ to that\nof computing gcd .b; a modb/is at most c./SYN.a;b//NUL/SYN.b; a modb//for some\nsuf\ufb01ciently large constant c>0 .\nc.Show that E UCLID .a; b/ requires O./SYN.a;b// bit operations in general and\nO.\u02c72/bit operations when applied to two \u02c7-bit inputs.\n31-3 Three algorithms for Fibonacci numbers\nThis problem compares the ef\ufb01ciency of three methods for computing the nth Fi-\nbonacci number Fn,g i v e n n. Assume that the cost of adding, subtracting, or mul-\ntiplying two numbers is O.1/ , independent of the size of the numbers.\na.Show that the running time of the straightforward recursive method for com-\nputing Fnbased on recurrence (3.22) is exponential in n. (See, for example, the\nFIBprocedure on page 775.)\nb.Show how to compute FninO.n/ time using memoization.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "1002": {"page_number": 1003, "page_information": "982 Chapter 31 Number-Theoretic Algorithms\nc.Show how to compute FninO.lgn/time using only integer addition and mul-\ntiplication. ( Hint: Consider the matrix\n/DC201\n11/DC3\nand its powers.)\nd.Assume now that adding two \u02c7-bit numbers takes \u201a.\u02c7/ time and that multi-\nplying two \u02c7-bit numbers takes \u201a.\u02c72/time. What is the running time of these\nthree methods under this more reasonable cost measure for the elementary arith-\nmetic operations?\n31-4 Quadratic residues\nLetpbe an odd prime. A number a2Z/ETX\npis aquadratic residue if the equation\nx2Da.mod p/has a solution for the unknown x.\na.Show that there are exactly .p/NUL1/=2 quadratic residues, modulo p.\nb.Ifpis prime, we de\ufb01ne the Legendre symbol .a\np/,f o ra2Z/ETX\np,t ob e 1ifais a\nquadratic residue modulo pand/NUL1otherwise. Prove that if a2Z/ETX\np,t h e n\n/DLEa\np/DC1\n/DC1a.p/NUL1/=2.mod p/ :\nGive an ef\ufb01cient algorithm that determines whether a given number ais a qua-\ndratic residue modulo p. Analyze the ef\ufb01ciency of your algorithm.\nc.Prove that if pis a prime of the form 4kC3andais a quadratic residue in Z/ETX\np,\nthenakC1modpis a square root of a, modulo p. How much time is required\nto \ufb01nd the square root of a quadratic residue amodulo p?\nd.Describe an ef\ufb01cient randomized algorithm for \ufb01nding a nonquadratic residue,\nmodulo an arbitrary prime p, that is, a member of Z/ETX\npthat is not a quadratic\nresidue. How many arithmetic operations does your algorithm require on aver-age?\nChapter notes\nNiven and Zuckerman [265] provide an excellent introduction to elementary num-ber theory. Knuth [210] contains a good discussion of algorithms for \ufb01nding the", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "1003": {"page_number": 1004, "page_information": "Notes for Chapter 31 983\ngreatest common divisor, as well as other basic number-theoretic algorithms. Bach\n[30] and Riesel [295] provide more recent surveys of computational number the-ory. Dixon [91] gives an overview of factorization and primality testing. Theconference proceedings edited by Pomerance [280] contains several excellent sur-vey articles. More recently, Bach and Shallit [31] have provided an exceptionaloverview of the basics of computational number theory.\nKnuth [210] discusses the origin of Euclid\u2019s algorithm. It appears in Book 7,\nPropositions 1 and 2, of the Greek mathematician Euclid\u2019s Elements ,w h i c hw a s\nwritten around 300\nB.C. Euclid\u2019s description may have been derived from an al-\ngorithm due to Eudoxus around 375 B.C. Euclid\u2019s algorithm may hold the honor\nof being the oldest nontrivial algorithm; it is rivaled only by an algorithm for mul-tiplication known to the ancient Egyptians. Shallit [312] chronicles the history ofthe analysis of Euclid\u2019s algorithm.\nKnuth attributes a special case of the Chinese remainder theorem (Theo-\nrem 31.27) to the Chinese mathematician Sun-Ts\u02d8 u, who lived sometime between\n200\nB.C.a n d A.D. 200\u2014the date is quite uncertain. The same special case was\ngiven by the Greek mathematician Nichomachus around A.D. 100. It was gener-\nalized by Chhin Chiu-Shao in 1247. The Chinese remainder theorem was \ufb01nallystated and proved in its full generality by L. Euler in 1734.\nThe randomized primality-testing algorithm presented here is due to Miller [255]\nand Rabin [289]; it is the fastest randomized primality-testing algorithm known,to within constant factors. The proof of Theorem 31.39 is a slight adaptation of\none suggested by Bach [29]. A proof of a stronger result for M\nILLER -RABIN\nwas given by Monier [258, 259]. For many years primality-testing was the classic\nexample of a problem where randomization appeared to be necessary to obtainan ef\ufb01cient (polynomial-time) algorithm. In 2002, however, Agrawal, Kayal, andSaxema [4] surprised everyone with their deterministic polynomial-time primality-testing algorithm. Until then, the fastest deterministic primality testing algorithmknown, due to Cohen and Lenstra [73], ran in time .lgn/\nO.lg lg lg n/on input n,w h i c h\nis just slightly superpolynomial. Nonetheless, for practical purposes randomizedprimality-testing algorithms remain more ef\ufb01cient and are preferred.\nThe problem of \ufb01nding large \u201crandom\u201d primes is nicely discussed in an article\nby Beauchemin, Brassard, Cr\u00b4 epeau, Goutier, and Pomerance [36].\nThe concept of a public-key cryptosystem is due to Dif\ufb01e and Hellman [87].\nThe RSA cryptosystem was proposed in 1977 by Rivest, Shamir, and Adleman[296]. Since then, the \ufb01eld of cryptography has blossomed. Our understanding\nof the RSA cryptosystem has deepened, and modern implementations use signif-\nicant re\ufb01nements of the basic techniques presented here. In addition, many newtechniques have been developed for proving cryptosystems to be secure. For ex-ample, Goldwasser and Micali [142] show that randomization can be an effectivetool in the design of secure public-key encryption schemes. For signature schemes,", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "1004": {"page_number": 1005, "page_information": "984 Chapter 31 Number-Theoretic Algorithms\nGoldwasser, Micali, and Rivest [143] present a digital-signature scheme for which\nevery conceivable type of forgery is provably as dif\ufb01cult as factoring. Menezes,van Oorschot, and Vanstone [254] provide an overview of applied cryptography.\nThe rho heuristic for integer factorization was invented by Pollard [277]. The\nversion presented here is a variant proposed by Brent [56].\nThe best algorithms for factoring large numbers have a running time that grows\nroughly exponentially with the cube root of the length of the number nto be fac-\ntored. The general number-\ufb01eld sieve factoring algorithm (as developed by Buh-\nler, Lenstra, and Pomerance [57] as an extension of the ideas in the number-\ufb01eld\nsieve factoring algorithm by Pollard [278] and Lenstra et al. [232] and re\ufb01ned byCoppersmith [77] and others) is perhaps the most ef\ufb01cient such algorithm in gen-eral for large inputs. Although it is dif\ufb01cult to give a rigorous analysis of thisalgorithm, under reasonable assumptions we can derive a running-time estimate ofL.1=3; n/\n1:902 Co.1/,w h e r e L.\u02db; n/De.lnn/\u02db.ln lnn/1/NUL\u02db.\nThe elliptic-curve method due to Lenstra [233] may be more effective for some\ninputs than the number-\ufb01eld sieve method, since, like Pollard\u2019s rho method, it can\ufb01nd a small prime factor pquite quickly. With this method, the time to \ufb01nd pis\nestimated to be L.1=2; p/ p\n2Co.1/.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "1005": {"page_number": 1006, "page_information": "32 String Matching\nText-editing programs frequently need to \ufb01nd all occurrences of a pattern in the\ntext. Typically, the text is a document being edited, and the pattern searched for is aparticular word supplied by the user. Ef\ufb01cient algorithms for this problem\u2014called\u201cstring matching\u201d\u2014can greatly aid the responsiveness of the text-editing program.Among their many other applications, string-matching algorithms search for par-ticular patterns in DNA sequences. Internet search engines also use them to \ufb01ndWeb pages relevant to queries.\nWe formalize the string-matching problem as follows. We assume that the\ntext is an array T\u0152 1::n /c141 of length nand that the pattern is an array P\u0152 1::m /c141\nof length m/DC4n. We further assume that the elements of PandTare char-\nacters drawn from a \ufb01nite alphabet \u2020. For example, we may have \u2020Df0,1g\nor\u2020Dfa;b;:::;zg. The character arrays PandTare often called strings of\ncharacters.\nReferring to Figure 32.1, we say that pattern Poccurs with shift sin text T\n(or, equivalently, that pattern Poccurs beginning at position sC1in text T)i f\n0/DC4s/DC4n/NULmandT\u0152 sC1::sCm/c141DP\u0152 1::m /c141 (that is, if T\u0152 sCj/c141DP\u0152 j/c141 ,f o r\n1/DC4j/DC4m). IfPoccurs with shift sinT, then we call savalid shift ; otherwise,\nwe call saninvalid shift\n.T h estring-matching problem is the problem of \ufb01nding\nall valid shifts with which a given pattern Poccurs in a given text T.\nabcabaabcabac\nabaa pattern Ptext T\ns = 3\nFigure 32.1 An example of the string-matching problem, where we want to \ufb01nd all occurrences of\nthe pattern PDabaa in the text TDabcabaabcabac . The pattern occurs only once in the text,\nat shift sD3, which we call a valid shift. A vertical line connects each character of the pattern to its\nmatching character in the text, and all matched characters are shaded.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "1006": {"page_number": 1007, "page_information": "986 Chapter 32 String Matching\nAlgorithm Preprocessing time Matching time\nNaive 0 O..n/NULmC1/m/\nRabin-Karp \u201a.m/ O..n /NULmC1/m/\nFinite automaton O.mj\u2020j/\u201a . n /\nKnuth-Morris-Pratt \u201a.m/ \u201a.n/\nFigure 32.2 The string-matching algorithms in this chapter and their preprocessing and matching\ntimes.\nExcept for the naive brute-force algorithm, which we review in Section 32.1,\neach string-matching algorithm in this chapter performs some preprocessing basedon the pattern and then \ufb01nds all valid shifts; we call this latter phase \u201cmatching.\u201dFigure 32.2 shows the preprocessing and matching times for each of the algorithmsin this chapter. The total running time of each algorithm is the sum of the prepro-\ncessing and matching times. Section 32.2 presents an interesting string-matching\nalgorithm, due to Rabin and Karp. Although the \u201a..n/NULmC1/m/ worst-case\nrunning time of this algorithm is no better than that of the naive method, it worksmuch better on average and in practice. It also generalizes nicely to other pattern-matching problems. Section 32.3 then describes a string-matching algorithm thatbegins by constructing a \ufb01nite automaton speci\ufb01cally designed to search for occur-rences of the given pattern Pin a text. This algorithm takes O.mj\u2020j/preprocess-\ning time, but only \u201a.n/ matching time. Section 32.4 presents the similar, but much\ncleverer, Knuth-Morris-Pratt (or KMP) algorithm; it has the same \u201a.n/ matching\ntime, and it reduces the preprocessing time to only \u201a.m/ .\nNotation and terminology\nWe denote by \u2020\n/ETX(read \u201csigma-star\u201d) the set of all \ufb01nite-length strings formed\nusing characters from the alphabet \u2020. In this chapter, we consider only \ufb01nite-\nlength strings. The zero-length empty string , denoted \", also belongs to \u2020/ETX.T h e\nlength of a string xis denotedjxj.T h e concatenation of two strings xandy,\ndenoted xy, has lengthjxjCjyjand consists of the characters from xfollowed by\nthe characters from y.\nWe say that a string wis apre\ufb01x of a string x, denoted w<x,i fxDwyfor\nsome string y2\u2020/ETX. Note that if w<x,t h e njwj/DC4jxj. Similarly, we say that a\nstring wis asuf\ufb01x of a string x, denoted w=x,i fxDywfor some y2\u2020/ETX.A s\nwith a pre\ufb01x, w=ximpliesjwj/DC4jxj. For example, we have ab<abcca and\ncca=abcca . The empty string \"is both a suf\ufb01x and a pre\ufb01x of every string. For\nany strings xandyand any character a,w eh a v e x=yif and only if xa=ya.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "1007": {"page_number": 1008, "page_information": "Chapter 32 String Matching 987\nx\nz\nxy\ny\n(a)x\nz\nxy\ny\n(b)x\nz\nxy\ny\n(c)\nFigure 32.3 A graphical proof of Lemma 32.1. We suppose that x=\u00b4andy=\u00b4. The three parts\nof the \ufb01gure illustrate the three cases of the lemma. Vertical lines connect matching regions (shownshaded) of the strings. (a)Ifjxj/DC4jyj,t h e n x=y.(b)Ifjxj/NAKjyj,t h e n y=x.(c)IfjxjDjyj,\nthenxDy.\nAlso note that <and=are transitive relations. The following lemma will be useful\nlater.\nLemma 32.1 (Overlapping-suf\ufb01x lemma)\nSuppose that x,y,a n d \u00b4are strings such that x=\u00b4andy=\u00b4.I fjxj/DC4jyj,\nthenx=y.I fjxj/NAKjyj,t h e n y=x.I fjxjDjyj,t h e n xDy.\nProof See Figure 32.3 for a graphical proof.\nFor brevity of notation, we denote the k-character pre\ufb01x P\u0152 1::k/c141 of the pattern\nP\u0152 1::m /c141 byPk. Thus, P0D\"andPmDPDP\u0152 1::m /c141 . Similarly, we denote\nthek-character pre\ufb01x of the text TbyTk. Using this notation, we can state the\nstring-matching problem as that of \ufb01nding all shifts sin the range 0/DC4s/DC4n/NULm\nsuch that P=TsCm.\nIn our pseudocode, we allow two equal-length strings to be compared for equal-\nity as a primitive operation. If the strings are compared from left to right and thecomparison stops when a mismatch is discovered, we assume that the time takenby such a test is a linear function of the number of matching characters discovered.To be precise, the test \u201c x\n==y\u201d is assumed to take time \u201a.tC1/,w h e r e tis the\nlength of the longest string \u00b4such that \u00b4<xand\u00b4<y. (We write \u201a.tC1/\nrather than \u201a.t/ to handle the case in which tD0; the \ufb01rst characters compared\ndo not match, but it takes a positive amount of time to perform this comparison.)", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "1008": {"page_number": 1009, "page_information": "988 Chapter 32 String Matching\n32.1 The naive string-matching algorithm\nThe naive algorithm \ufb01nds all valid shifts using a loop that checks the condition\nP\u0152 1::m /c141DT\u0152 sC1::sCm/c141for each of the n/NULmC1possible values of s.\nNAIVE -STRING -MATCHER .T; P /\n1nDT:length\n2mDP:length\n3forsD0ton/NULm\n4 ifP\u0152 1::m /c141 ==T\u0152 sC1::sCm/c141\n5 print \u201cPattern occurs with shift\u201d s\nFigure 32.4 portrays the naive string-matching procedure as sliding a \u201ctemplate\u201d\ncontaining the pattern over the text, noting for which shifts all of the characterson the template equal the corresponding characters in the text. The forloop of\nlines 3\u20135 considers each possible shift explicitly. The test in line 4 determineswhether the current shift is valid; this test implicitly loops to check correspondingcharacter positions until all positions match successfully or a mismatch is found.\nLine 5 prints out each valid shift s.\nProcedure N\nAIVE -STRING -MATCHER takes time O..n/NULmC1/m/ , and this\nbound is tight in the worst case. For example, consider the text string an(a string\nofna\u2019s) and the pattern am. For each of the n/NULmC1possible values of the shift s,\nthe implicit loop on line 4 to compare corresponding characters must execute m\ntimes to validate the shift. The worst-case running time is thus \u201a..n/NULmC1/m/ ,\nwhich is \u201a.n2/ifmDbn=2c. Because it requires no preprocessing, N AIVE -\nSTRING -MATCHER \u2019s running time equals its matching time.\nacaabc\naabs = 0\n(a)acaabc\naabs = 1\n(b)acaabc\naabs = 2\n(c)acaabc\naabs = 3\n(d)\nFigure 32.4 The operation of the naive string matcher for the pattern PDaab and the text\nTDacaabc . We can imagine the pattern Pas a template that we slide next to the text. (a)\u2013(d) The\nfour successive alignments tried by the naive string matcher. In each part, vertical lines connect cor-\nresponding regions found to match (shown shaded), and a jagged line connects the \ufb01rst mismatched\ncharacter found, if any. The algorithm \ufb01nds one occurrence of the pattern, at shift sD2,s h o w ni n\npart (c).", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "1009": {"page_number": 1010, "page_information": "32.1 The naive string-matching algorithm 989\nAs we shall see, N AIVE -STRING -MATCHER is not an optimal procedure for this\nproblem. Indeed, in this chapter we shall see that the Knuth-Morris-Pratt algorithmis much better in the worst case. The naive string-matcher is inef\ufb01cient becauseit entirely ignores information gained about the text for one value of swhen it\nconsiders other values of s. Such information can be quite valuable, however. For\nexample, if PDaaab and we \ufb01nd that sD0is valid, then none of the shifts 1,2,\nor3are valid, since T\u0152 4 /c141Db. In the following sections, we examine several ways\nto make effective use of this sort of information.\nExercises\n32.1-1\nShow the comparisons the naive string matcher makes for the pattern PD0001\nin the text TD000010001010001 .\n32.1-2\nSuppose that all characters in the pattern Pare different. Show how to accelerate\nN\nAIVE -STRING -MATCHER to run in time O.n/ on an n-character text T.\n32.1-3\nSuppose that pattern Pand text Tarerandomly chosen strings of length mandn,\nrespectively, from the d-ary alphabet \u2020dDf0; 1; : : : ; d/NUL1g,w h e r e d/NAK2.S h o w\nthat the expected number of character-to-character comparisons made by the im-\nplicit loop in line 4 of the naive algorithm is\n.n/NULmC1/1/NULd/NULm\n1/NULd/NUL1/DC42.n/NULmC1/\nover all executions of this loop. (Assume that the naive algorithm stops comparing\ncharacters for a given shift once it \ufb01nds a mismatch or matches the entire pattern.)Thus, for randomly chosen strings, the naive algorithm is quite ef\ufb01cient.\n32.1-4\nSuppose we allow the pattern Pto contain occurrences of a gap character}that\ncan match an arbitrary string of characters (even one of zero length). For example,\nthe pattern ab}ba}coccurs in the text cabccbacbacab as\nca b\u2019\nabcc\u2019\n}ba\u2019\nbacba\u201c\n}c\u2019\ncab\nand as\nca b\u2019\nabccbac\u2014\n}ba\u2019\nba\u2019\n}c\u2019\ncab:", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "1010": {"page_number": 1011, "page_information": "990 Chapter 32 String Matching\nNote that the gap character may occur an arbitrary number of times in the pattern\nbut not at all in the text. Give a polynomial-time algorithm to determine whethersuch a pattern Poccurs in a given text T, and analyze the running time of your\nalgorithm.\n32.2 The Rabin-Karp algorithm\nRabin and Karp proposed a string-matching algorithm that performs well in prac-tice and that also generalizes to other algorithms for related problems, such astwo-dimensional pattern matching. The Rabin-Karp algorithm uses \u201a.m/ prepro-\ncessing time, and its worst-case running time is \u201a..n/NULmC1/m/ . Based on certain\nassumptions, however, its average-case running time is better.\nThis algorithm makes use of elementary number-theoretic notions such as the\nequivalence of two numbers modulo a third number. You might want to refer toSection 31.1 for the relevant de\ufb01nitions.\nFor expository purposes, let us assume that \u2020Df0;1;2;:::;9g, so that each\ncharacter is a decimal digit. (In the general case, we can assume that each charac-\nter is a digit in radix- dnotation, where dDj\u2020j.) We can then view a string of k\nconsecutive characters as representing a length- kdecimal number. The character\nstring 31415 thus corresponds to the decimal number 31,415. Because we inter-\npret the input characters as both graphical symbols and digits, we \ufb01nd it convenient\nin this section to denote them as we would digits, in our standard text font.\nGiven a pattern P\u0152 1::m /c141 ,l e tpdenote its corresponding decimal value. In a sim-\nilar manner, given a text T\u0152 1::n /c141 ,l e tt\nsdenote the decimal value of the length- m\nsubstring T\u0152 sC1::sCm/c141,f o rsD0; 1; : : : ; n/NULm. Certainly, tsDpif and only\nifT\u0152 sC1::sCm/c141DP\u0152 1::m /c141 ; thus, sis a valid shift if and only if tsDp.I fw e\ncould compute pin time \u201a.m/ and all the tsvalues in a total of \u201a.n/NULmC1/time,1\nthen we could determine all valid shifts sin time \u201a.m/C\u201a.n/NULmC1/D\u201a.n/\nby comparing pwith each of the tsvalues. (For the moment, let\u2019s not worry about\nthe possibility that pand the tsvalues might be very large numbers.)\nWe can compute pin time \u201a.m/ using Horner\u2019s rule (see Section 30.1):\npDP\u0152 m /c141C10 .P \u0152m/NUL1/c141C10.P \u0152m/NUL2/c141C/SOH/SOH/SOHC 10.P \u01522/c141C10P \u01521/c141//SOH/SOH/SOH// :\nSimilarly, we can compute t0from T\u0152 1::m /c141 in time \u201a.m/ .\n1We write \u201a.n/NULmC1/instead of \u201a.n/NULm/because stakes on n/NULmC1different values. The\n\u201cC1\u201d is signi\ufb01cant in an asymptotic sense because when mDn, computing the lone tsvalue takes\n\u201a.1/ time, not \u201a.0/ time.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "1011": {"page_number": 1012, "page_information": "32.2 The Rabin-Karp algorithm 991\nTo compute the remaining values t1;t2;:::;t n/NULmin time \u201a.n/NULm/, we observe\nthat we can compute tsC1from tsin constant time, since\ntsC1D10.t s/NUL10m/NUL1T\u0152 sC1/c141/CT\u0152 sCmC1/c141 : (32.1)\nSubtracting 10m/NUL1T\u0152 sC1/c141removes the high-order digit from ts, multiplying the\nresult by 10shifts the number left by one digit position, and adding T\u0152 sCmC1/c141\nbrings in the appropriate low-order digit. For example, if mD5andtsD31415 ,\nthen we wish to remove the high-order digit T\u0152 sC1/c141D3a n db r i n gi nt h en e w\nlow-order digit (suppose it is T\u0152 sC5C1/c141D2) to obtain\ntsC1D10.31415/NUL10000/SOH3/C2\nD14152 :\nIf we precompute the constant 10m/NUL1(which we can do in time O.lgm/using the\ntechniques of Section 31.6, although for this application a straightforward O.m/ -\ntime method suf\ufb01ces), then each execution of equation (32.1) takes a constant num-ber of arithmetic operations. Thus, we can compute pin time \u201a.m/ , and we can\ncompute all of t\n0;t1;:::;t n/NULmin time \u201a.n/NULmC1/. Therefore, we can \ufb01nd all\noccurrences of the pattern P\u0152 1::m /c141 in the text T\u0152 1::n /c141 with\u201a.m/ preprocessing\ntime and \u201a.n/NULmC1/matching time.\nUntil now, we have intentionally overlooked one problem: pandtsmay be\ntoo large to work with conveniently. If Pcontains mcharacters, then we cannot\nreasonably assume that each arithmetic operation on p(which is mdigits long)\ntakes \u201cconstant time.\u201d Fortunately, we can solve this problem easily, as Figure 32.5\nshows: compute pand the tsvalues modulo a suitable modulus q. We can compute\npmodulo qin\u201a.m/ time and all the tsvalues modulo qin\u201a.n/NULmC1/time.\nIf we choose the modulus qas a prime such that 10qjust \ufb01ts within one computer\nword, then we can perform all the necessary computations with single-precisionarithmetic. In general, with a d-ary alphabetf0; 1; : : : ; d/NUL1g, we choose qso\nthatdq\ufb01ts within a computer word and adjust the recurrence equation (32.1) to\nwork modulo q,s ot h a ti tb e c o m e s\nt\nsC1D.d.t s/NULT\u0152 sC1/c141h/CT\u0152 sCmC1/c141/modq; (32.2)\nwhere h/DC1dm/NUL1.mod q/is the value of the digit \u201c 1\u201d in the high-order position\nof an m-digit text window.\nThe solution of working modulo qis not perfect, however: ts/DC1p.mod q/\ndoes not imply that tsDp. On the other hand, if ts6/DC1p.mod q/,t h e nw e\nde\ufb01nitely have that ts\u00a4p, so that shift sis invalid. We can thus use the test\nts/DC1p.mod q/as a fast heuristic test to rule out invalid shifts s. Any shift sfor\nwhich ts/DC1p.mod q/must be tested further to see whether sis really valid or\nwe just have a spurious hit . This additional test explicitly checks the condition", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "1012": {"page_number": 1013, "page_information": "992 Chapter 32 String Matching\n2359023141526739921\n7\n(a)mod 13\n2359023141526739921\n7\n(b)mod 13123456789 1 0 1 1 1 2 1 3 1 4 1 5 1 6 1 7 1 8 1 9\n8931101 8 5 11 911 7 10 4\nvalid\nmatchspurious\nhit\u2026\u2026 \u2026\n314152\n78old\nhigh-order\ndigitnew\nlow-order\ndigit\n\u2261(31415 \u2013 3\u00b710000)\u00b710 + 2  (mod 13) old\nhigh-order\ndigitnew\nlow-order\ndigit shift\n\u2261(7 \u2013 3\u00b73)\u00b710 + 2  (mod 13) \n\u22618  (mod 13) \n(c)14152\nFigure 32.5 The Rabin-Karp algorithm. Each character is a decimal digit, and we compute values\nmodulo 13.(a)A text string. A window of length 5 is shown shaded. The numerical value of the\nshaded number, computed modulo 13, yields the value 7.(b)The same text string with values com-\nputed modulo 13for each possible position of a length-5 window. Assuming the pattern PD31415 ,\nwe look for windows whose value modulo 13is7,s i n c e 31415/DC17.mod 13/. The algorithm \ufb01nds\ntwo such windows, shown shaded in the \ufb01gure. The \ufb01rst, beginning at text position 7, is indeed an\noccurrence of the pattern, while the second, beginning at text position 13, is a spurious hit. (c)How\nto compute the value for a window in constant time, given the value for the previous window. The\n\ufb01rst window has value 31415. Dropping the high-order digit 3, shifting left (multiplying by 10), and\nthen adding in the low-order digit 2gives us the new value 14152 . Because all computations are\nperformed modulo 13, the value for the \ufb01rst window is 7, and the value for the new window is 8.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "1013": {"page_number": 1014, "page_information": "32.2 The Rabin-Karp algorithm 993\nP\u0152 1::m /c141DT\u0152 sC1::sCm/c141.I fqis large enough, then we hope that spurious\nhits occur infrequently enough that the cost of the extra checking is low.\nThe following procedure makes these ideas precise. The inputs to the procedure\nare the text T, the pattern P, the radix dto use (which is typically taken to be j\u2020j),\nand the prime qto use.\nRABIN -KARP-MATCHER . T;P;d;q/\n1nDT:length\n2mDP:length\n3hDdm/NUL1modq\n4pD0\n5t0D0\n6foriD1tom //preprocessing\n7 pD.dpCP\u0152 i/c141 / modq\n8 t0D.dt0CT\u0152 i/c141 / modq\n9forsD0ton/NULm //matching\n10 ifp==ts\n11 ifP\u0152 1::m /c141 ==T\u0152 sC1::sCm/c141\n12 print \u201cPattern occurs with shift\u201d s\n13 ifs<n/NULm\n14 tsC1D.d.t s/NULT\u0152 sC1/c141h/CT\u0152 sCmC1/c141/modq\nThe procedure R ABIN -KARP-MATCHER works as follows. All characters are\ninterpreted as radix- ddigits. The subscripts on tare provided only for clarity; the\nprogram works correctly if all the subscripts are dropped. Line 3 initializes hto the\nvalue of the high-order digit position of an m-digit window. Lines 4\u20138 compute p\nas the value of P\u0152 1::m /c141 modqandt0as the value of T\u0152 1::m /c141 modq.T h e for\nloop of lines 9\u201314 iterates through all possible shifts s, maintaining the following\ninvariant:\nWhenever line 10 is executed, tsDT\u0152 sC1::sCm/c141modq.\nIfpDtsin line 10 (a \u201chit\u201d), then line 11 checks to see whether P\u0152 1::m /c141D\nT\u0152 sC1::sCm/c141in order to rule out the possibility of a spurious hit. Line 12 prints\nout any valid shifts that are found. If s<n/NULm(checked in line 13), then the for\nloop will execute at least one more time, and so line 14 \ufb01rst executes to ensure that\nthe loop invariant holds when we get back to line 10. Line 14 computes the value\noftsC1modqfrom the value of tsmodqin constant time using equation (32.2)\ndirectly.\nRABIN -KARP-MATCHER takes \u201a.m/ preprocessing time, and its matching time\nis\u201a..n/NULmC1/m/ in the worst case, since (like the naive string-matching algo-\nrithm) the Rabin-Karp algorithm explicitly veri\ufb01es every valid shift. If PDam", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "1014": {"page_number": 1015, "page_information": "994 Chapter 32 String Matching\nandTDan, then verifying takes time \u201a..n/NULmC1/m/ , since each of the n/NULmC1\npossible shifts is valid.\nIn many applications, we expect few valid shifts\u2014perhaps some constant cof\nthem. In such applications, the expected matching time of the algorithm is onlyO..n/NULmC1/Ccm/DO.nCm/, plus the time required to process spurious\nhits. We can base a heuristic analysis on the assumption that reducing values mod-uloqacts like a random mapping from \u2020\n/ETXtoZq. (See the discussion on the use of\ndivision for hashing in Section 11.3.1. It is dif\ufb01cult to formalize and prove such an\nassumption, although one viable approach is to assume that qis chosen randomly\nfrom integers of the appropriate size. We shall not pursue this formalization here.)We can then expect that the number of spurious hits is O.n=q/ , since we can es-\ntimate the chance that an arbitrary t\nswill be equivalent to p, modulo q,a s1=q.\nSince there are O.n/ positions at which the test of line 10 fails and we spend O.m/\ntime for each hit, the expected matching time taken by the Rabin-Karp algorithmis\nO.n/CO.m./ETBCn=q// ;\nwhere /ETBis the number of valid shifts. This running time is O.n/ if/ETBDO.1/ and\nwe choose q/NAKm. That is, if the expected number of valid shifts is small ( O.1/ )\nand we choose the prime qto be larger than the length of the pattern, then we\ncan expect the Rabin-Karp procedure to use only O.nCm/matching time. Since\nm/DC4n, this expected matching time is O.n/ .\nExercises\n32.2-1\nWorking modulo qD11, how many spurious hits does the Rabin-Karp matcher en-\ncounter in the text TD3141592653589793 when looking for the pattern PD26?\n32.2-2\nHow would you extend the Rabin-Karp method to the problem of searching a textstring for an occurrence of any one of a given set of kpatterns? Start by assuming\nthat all kpatterns have the same length. Then generalize your solution to allow the\npatterns to have different lengths.\n32.2-3\nShow how to extend the Rabin-Karp method to handle the problem of looking forag i v e n m/STXmpattern in an n/STXnarray of characters. (The pattern may be shifted\nvertically and horizontally, but it may not be rotated.)", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "1015": {"page_number": 1016, "page_information": "32.3 String matching with \ufb01nite automata 995\n32.2-4\nAlice has a copy of a long n-bit \ufb01le ADhan/NUL1;an/NUL2;:::;a 0i, and Bob similarly\nhas an n-bit \ufb01le BDhbn/NUL1;bn/NUL2;:::;b 0i. Alice and Bob wish to know if their\n\ufb01les are identical. To avoid transmitting all of AorB, they use the following fast\nprobabilistic check. Together, they select a prime q > 1000n and randomly select\nan integer xfromf0; 1; : : : ; q/NUL1g. Then, Alice evaluates\nA.x/D n/NUL1X\niD0aixi!\nmodq\nand Bob similarly evaluates B.x/ . Prove that if A\u00a4B, there is at most one\nchance in 1000 thatA.x/DB.x/ , whereas if the two \ufb01les are the same, A.x/ is\nnecessarily the same as B.x/ .(Hint: See Exercise 31.4-4.)\n32.3 String matching with \ufb01nite automata\nMany string-matching algorithms build a \ufb01nite automaton\u2014a simple machine for\nprocessing information\u2014that scans the text string Tfor all occurrences of the pat-\nternP. This section presents a method for building such an automaton. These\nstring-matching automata are very ef\ufb01cient: they examine each text character ex-\nactly once , taking constant time per text character. The matching time used\u2014after\npreprocessing the pattern to build the automaton\u2014is therefore \u201a.n/ . The time to\nbuild the automaton, however, can be large if \u2020is large. Section 32.4 describes a\nclever way around this problem.\nWe begin this section with the de\ufb01nition of a \ufb01nite automaton. We then examine\na special string-matching automaton and show how to use it to \ufb01nd occurrences\nof a pattern in a text. Finally, we shall show how to construct the string-matching\nautomaton for a given input pattern.\nFinite automata\nA\ufb01nite automaton M, illustrated in Figure 32.6, is a 5-tuple .Q; q 0;A ;\u2020;\u0131/ ,\nwhere\n/SIQis a \ufb01nite set of states ,\n/SIq02Qis thestart state ,\n/SIA/DC2Qis a distinguished set of accepting states ,\n/SI\u2020is a \ufb01nite input alphabet ,\n/SI\u0131is a function from Q/STX\u2020intoQ, called the transition function ofM.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "1016": {"page_number": 1017, "page_information": "996 Chapter 32 String Matching\n10\n00abinput\nstate\n01\n(a)a\na\nbb\n(b)0 1\nFigure 32.6 A simple two-state \ufb01nite automaton with state set QDf0; 1g,s t a r ts t a t e q0D0,\nand input alphabet \u2020Dfa;bg.(a)A tabular representation of the transition function \u0131.(b)An\nequivalent state-transition diagram. State 1, shown blackend, is the only accepting state. Directed\nedges represent transitions. For example, the edge from state 1to state 0labeled bindicates that\n\u0131.1;b/D0. This automaton accepts those strings that end in an odd number of a\u2019s. More precisely,\nit accepts a string xif and only if xDy\u00b4,w h e r e yD\"oryends with a b,a n d \u00b4Dak,w h e r e kis\nodd. For example, on input abaaa , including the start state, this automaton enters the sequence of\nstatesh0; 1; 0; 1; 0; 1i, and so it accepts this input. For input abbaa , it enters the sequence of states\nh0; 1; 0; 0; 1; 0i, and so it rejects this input.\nThe \ufb01nite automaton begins in state q0and reads the characters of its input string\none at a time. If the automaton is in state qand reads input character a, it moves\n(\u201cmakes a transition\u201d) from state qto state \u0131.q;a/ . Whenever its current state qis\nam e m b e ro f A, the machine Mhasaccepted the string read so far. An input that\nis not accepted is rejected .\nA \ufb01nite automaton Minduces a function /RS, called the \ufb01nal-state function ,\nfrom \u2020/ETXtoQsuch that /RS.w/ is the state Mends up in after scanning the string w.\nThus, Maccepts a string wif and only if /RS.w/2A. We de\ufb01ne the function /RS\nrecursively, using the transition function:\n/RS.\"/Dq0;\n/RS.wa/D\u0131./RS.w/;a/ forw2\u2020/ETX;a2\u2020.\nString-matching automata\nFor a given pattern P, we construct a string-matching automaton in a preprocess-\ning step before using it to search the text string. Figure 32.7 illustrates how we\nconstruct the automaton for the pattern PDababaca . From now on, we shall\nassume that Pis a given \ufb01xed pattern string; for brevity, we shall not indicate the\ndependence upon Pin our notation.\nIn order to specify the string-matching automaton corresponding to a given pat-\nternP\u0152 1::m /c141 , we \ufb01rst de\ufb01ne an auxiliary function /ESC, called the suf\ufb01x function\ncorresponding to P. The function /ESCmaps \u2020/ETXtof0; 1; : : : ; mgsuch that /ESC.x/ is the\nlength of the longest pre\ufb01x of Pthat is also a suf\ufb01x of x:\n/ESC.x/DmaxfkWPk=xg: (32.3)", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "1017": {"page_number": 1018, "page_information": "32.3 String matching with \ufb01nite automata 997\n0 1 2 3 4 5 6 7ababaca\nbaaa\na\nb\n(a)\n100\n120\n300\n140\n500\n146\n700\n1200\n1234567stateinput\nabc\nababacaP\n(b)123456789 1 0 1 1\nabababacaba\n012345456\n723\u2014\n\u2014\n(c)i\nT\u0152 i/c141\nstate/RS.T i/\nFigure 32.7 (a) A state-transition diagram for the string-matching automaton that accepts all\nstrings ending in the string ababaca . State 0is the start state, and state 7(shown blackened) is\nthe only accepting state. A directed edge from state ito state jlabeled arepresents \u0131.i; a/Dj.T h e\nright-going edges forming the \u201cspine\u201d of the automaton, shown heavy in the \ufb01gure, correspond to\nsuccessful matches between pattern and input characters. The left-going edges correspond to failingmatches. Some edges corresponding to failing matches are omitted; by convention, if a state ihas\nno outgoing edge labeled afor some a2\u2020,t h e n \u0131.i; a/D0.(b)The corresponding transition\nfunction \u0131, and the pattern string PDababaca . The entries corresponding to successful matches\nbetween pattern and input characters are shown shaded. (c)The operation of the automaton on the\ntextTDabababacaba . Under each text character T\u0152 i/c141 appears the state /RS.T\ni/that the automa-\nton is in after processing the pre\ufb01x Ti. The automaton \ufb01nds one occurrence of the pattern, ending in\nposition 9.\nThe suf\ufb01x function /ESCis well de\ufb01ned since the empty string P0D\"is a suf-\n\ufb01x of every string. As examples, for the pattern PDab,w eh a v e /ESC.\"/D0,\n/ESC.ccaca /D1,a n d /ESC.ccab /D2. For a pattern Pof length m,w eh a v e\n/ESC.x/Dmif and only if P=x. From the de\ufb01nition of the suf\ufb01x function,\nx=yimplies /ESC.x//DC4/ESC.y/ .\nWe de\ufb01ne the string-matching automaton that corresponds to a given pattern\nP\u0152 1::m /c141 as follows:", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "1018": {"page_number": 1019, "page_information": "998 Chapter 32 String Matching\n/SIThe state set Qisf0; 1; : : : ; mg. The start state q0is state 0, and state mis the\nonly accepting state.\n/SIThe transition function \u0131is de\ufb01ned by the following equation, for any state q\nand character a:\n\u0131.q;a/D/ESC.P qa/ : (32.4)\nWe de\ufb01ne \u0131.q;a/D/ESC.P qa/because we want to keep track of the longest pre-\n\ufb01x of the pattern Pthat has matched the text string Tso far. We consider the\nmost recently read characters of T. In order for a substring of T\u2014let\u2019s say the\nsubstring ending at T\u0152 i/c141\u2014to match some pre\ufb01x PjofP,t h i sp r e \ufb01 x Pjmust be a\nsuf\ufb01x of Ti. Suppose that qD/RS.T i/, so that after reading Ti, the automaton is in\nstateq. We design the transition function \u0131so that this state number, q, tells us the\nlength of the longest pre\ufb01x of Pthat matches a suf\ufb01x of Ti. That is, in state q,\nPq=TiandqD/ESC.T i/. (Whenever qDm,a l lmcharacters of Pmatch a suf\ufb01x\nofTi, and so we have found a match.) Thus, since /RS.T i/and/ESC.T i/both equal q,\nwe shall see (in Theorem 32.4, below) that the automaton maintains the followinginvariant:\n/RS.T\ni/D/ESC.T i/: (32.5)\nIf the automaton is in state qand reads the next character T\u0152 iC1/c141Da,t h e nw e\nwant the transition to lead to the state corresponding to the longest pre\ufb01x of Pthat\nis a suf\ufb01x of Tia, and that state is /ESC.T ia/. Because Pqis the longest pre\ufb01x of P\nthat is a suf\ufb01x of Ti, the longest pre\ufb01x of Pthat is a suf\ufb01x of Tiais not only /ESC.T ia/,\nbut also /ESC.P qa/. (Lemma 32.3, on page 1000, proves that /ESC.T ia/D/ESC.P qa/.)\nThus, when the automaton is in state q, we want the transition function on charac-\nterato take the automaton to state /ESC.P qa/.\nThere are two cases to consider. In the \ufb01rst case, aDP\u0152 qC1/c141, so that the\ncharacter acontinues to match the pattern; in this case, because \u0131.q;a/DqC1,t h e\ntransition continues to go along the \u201cspine\u201d of the automaton (the heavy edges inFigure 32.7). In the second case, a\u00a4P\u0152 qC1/c141,s ot h a t adoes not continue to match\nthe pattern. Here, we must \ufb01nd a smaller pre\ufb01x of Pthat is also a suf\ufb01x of T\ni.\nBecause the preprocessing step matches the pattern against itself when creating thestring-matching automaton, the transition function quickly identi\ufb01es the longestsuch smaller pre\ufb01x of P.\nLet\u2019s look at an example. The string-matching automaton of Figure 32.7 has\n\u0131.5;c/D6, illustrating the \ufb01rst case, in which the match continues. To illus-\ntrate the second case, observe that the automaton of Figure 32.7 has \u0131.5;b/D4.\nWe make this transition because if the automaton reads a bin state qD5,t h e n\nP\nqbDababab , and the longest pre\ufb01x of Pthat is also a suf\ufb01x of ababab is\nP4Dabab .", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "1019": {"page_number": 1020, "page_information": "32.3 String matching with \ufb01nite automata 999\nx\na\nPrPr\u20131\nFigure 32.8 An illustration for the proof of Lemma 32.2. The \ufb01gure shows that r/DC4/ESC.x/C1,\nwhere rD/ESC.xa/ .\nTo clarify the operation of a string-matching automaton, we now give a simple,\nef\ufb01cient program for simulating the behavior of such an automaton (representedby its transition function \u0131) in \ufb01nding occurrences of a pattern Pof length min an\ninput text T\u0152 1::n /c141 . As for any string-matching automaton for a pattern of length m,\nthe state set Qisf0; 1; : : : ; mg, the start state is 0, and the only accepting state is\nstatem.\nF\nINITE -AUTOMATON -MATCHER . T;\u0131;m /\n1nDT:length\n2qD0\n3foriD1ton\n4 qD\u0131.q;T \u0152i/c141/\n5 ifq==m\n6 print \u201cPattern occurs with shift\u201d i/NULm\nFrom the simple loop structure of F INITE -AUTOMATON -MATCHER , we can easily\nsee that its matching time on a text string of length nis\u201a.n/ . This matching\ntime, however, does not include the preprocessing time required to compute thetransition function \u0131. We address this problem later, after \ufb01rst proving that the\nprocedure F\nINITE -AUTOMATON -MATCHER operates correctly.\nConsider how the automaton operates on an input text T\u0152 1::n /c141 . We shall prove\nthat the automaton is in state /ESC.T i/after scanning character T\u0152 i/c141.S i n c e /ESC.T i/Dm\nif and only if P=Ti, the machine is in the accepting state mif and only if it has\njust scanned the pattern P. To prove this result, we make use of the following two\nlemmas about the suf\ufb01x function /ESC.\nLemma 32.2 (Suf\ufb01x-function inequality)\nFor any string xand character a,w eh a v e /ESC.xa//DC4/ESC.x/C1.\nProof Referring to Figure 32.8, let rD/ESC.xa/ .I frD0, then the conclusion\n/ESC.xa/Dr/DC4/ESC.x/C1is trivially satis\ufb01ed, by the nonnegativity of /ESC.x/ .N o w\nassume that r>0 . Then, Pr=xa, by the de\ufb01nition of /ESC. Thus, Pr/NUL1=x,b y", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "1020": {"page_number": 1021, "page_information": "1000 Chapter 32 String Matching\nx\na\na Pq\nPr\nFigure 32.9 An illustration for the proof of Lemma 32.3. The \ufb01gure shows that rD/ESC.P qa/,\nwhere qD/ESC.x/ andrD/ESC.xa/ .\ndropping the afrom the end of Prand from the end of xa. Therefore, r/NUL1/DC4/ESC.x/ ,\nsince /ESC.x/ is the largest ksuch that Pk=x, and thus /ESC.xa/Dr/DC4/ESC.x/C1.\nLemma 32.3 (Suf\ufb01x-function recursion lemma)\nFor any string xand character a,i fqD/ESC.x/ ,t h e n /ESC.xa/D/ESC.P qa/.\nProof From the de\ufb01nition of /ESC,w eh a v e Pq=x. As Figure 32.9 shows, we\nalso have Pqa=xa.I f w e l e t rD/ESC.xa/ ,t h e n Pr=xaand, by Lemma 32.2,\nr/DC4qC1. Thus, we havejPrjDr/DC4qC1DjPqaj.S i n c e Pqa=xa,Pr=xa,\nandjPrj/DC4jPqaj, Lemma 32.1 implies that Pr=Pqa. Therefore, r/DC4/ESC.P qa/,\nthat is, /ESC.xa//DC4/ESC.P qa/. But we also have /ESC.P qa//DC4/ESC.xa/ ,s i n c e Pqa=xa.\nThus, /ESC.xa/D/ESC.P qa/.\nWe are now ready to prove our main theorem characterizing the behavior of a\nstring-matching automaton on a given input text. As noted above, this theorem\nshows that the automaton is merely keeping track, at each step, of the longest\npre\ufb01x of the pattern that is a suf\ufb01x of what has been read so far. In other words,the automaton maintains the invariant (32.5).\nTheorem 32.4\nIf/RSis the \ufb01nal-state function of a string-matching automaton for a given pattern P\nandT\u0152 1::n /c141 is an input text for the automaton, then\n/RS.T\ni/D/ESC.T i/\nforiD0; 1; : : : ; n .\nProof The proof is by induction on i.F o r iD0, the theorem is trivially true,\nsince T0D\". Thus, /RS.T 0/D0D/ESC.T 0/.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "1021": {"page_number": 1022, "page_information": "32.3 String matching with \ufb01nite automata 1001\nNow, we assume that /RS.T i/D/ESC.T i/and prove that /RS.T iC1/D/ESC.T iC1/.L e t q\ndenote /RS.T i/,a n dl e t adenote T\u0152 iC1/c141. Then,\n/RS.T iC1/D/RS.T ia/ (by the de\ufb01nitions of TiC1anda)\nD\u0131./RS.T i/; a/ (by the de\ufb01nition of /RS)\nD\u0131.q;a/ (by the de\ufb01nition of q)\nD/ESC.P qa/ (by the de\ufb01nition (32.4) of \u0131)\nD/ESC.T ia/ (by Lemma 32.3 and induction)\nD/ESC.T iC1/ (by the de\ufb01nition of TiC1).\nBy Theorem 32.4, if the machine enters state qon line 4, then qis the largest\nvalue such that Pq=Ti. Thus, we have qDmon line 5 if and only if the ma-\nchine has just scanned an occurrence of the pattern P. We conclude that F INITE -\nAUTOMATON -MATCHER operates correctly.\nComputing the transition function\nThe following procedure computes the transition function \u0131from a given pattern\nP\u0152 1::m /c141 .\nCOMPUTE -TRANSITION -FUNCTION .P; \u2020/\n1mDP:length\n2forqD0tom\n3 foreach character a2\u2020\n4 kDmin.mC1; qC2/\n5 repeat\n6 kDk/NUL1\n7 until Pk=Pqa\n8 \u0131.q;a/Dk\n9return \u0131\nThis procedure computes \u0131.q;a/ in a straightforward manner according to its def-\ninition in equation (32.4). The nested loops beginning on lines 2 and 3 considerall states qand all characters a, and lines 4\u20138 set \u0131.q;a/ to be the largest ksuch\nthatP\nk=Pqa. The code starts with the largest conceivable value of k,w h i c hi s\nmin.m; qC1/. It then decreases kuntilPk=Pqa, which must eventually occur,\nsince P0D\"is a suf\ufb01x of every string.\nThe running time of C OMPUTE -TRANSITION -FUNCTION isO.m3j\u2020j/,b e -\ncause the outer loops contribute a factor of mj\u2020j, the inner repeat loop can run\nat most mC1times, and the test Pk=Pqaon line 7 can require comparing up", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "1022": {"page_number": 1023, "page_information": "1002 Chapter 32 String Matching\ntomcharacters. Much faster procedures exist; by utilizing some cleverly com-\nputed information about the pattern P(see Exercise 32.4-8), we can improve the\ntime required to compute \u0131from PtoO.mj\u2020j/. With this improved procedure for\ncomputing \u0131, we can \ufb01nd all occurrences of a length- mpattern in a length- ntext\nover an alphabet \u2020withO.mj\u2020j/preprocessing time and \u201a.n/ matching time.\nExercises\n32.3-1\nConstruct the string-matching automaton for the pattern PDaabab and illustrate\nits operation on the text string TDaaababaabaababaab .\n32.3-2\nDraw a state-transition diagram for a string-matching automaton for the patternababbabbababbababbabb over the alphabet \u2020Dfa;bg.\n32.3-3\nWe call a pattern Pnonoverlappable ifP\nk=Pqimplies kD0orkDq.D e -\nscribe the state-transition diagram of the string-matching automaton for a nonover-lappable pattern.\n32.3-4 ?\nGiven two patterns PandP\n0, describe how to construct a \ufb01nite automaton that\ndetermines all occurrences of either pattern. Try to minimize the number of states\nin your automaton.\n32.3-5\nGiven a pattern Pcontaining gap characters (see Exercise 32.1-4), show how to\nbuild a \ufb01nite automaton that can \ufb01nd an occurrence of Pin a text TinO.n/\nmatching time, where nDjTj.\n?32.4 The Knuth-Morris-Pratt algorithm\nWe now present a linear-time string-matching algorithm due to Knuth, Morris, and\nPratt. This algorithm avoids computing the transition function \u0131altogether, and its\nmatching time is \u201a.n/ using just an auxiliary function /EM, which we precompute\nfrom the pattern in time \u201a.m/ and store in an array /EM\u0152 1::m /c141 . The array /EMallows\nus to compute the transition function \u0131ef\ufb01ciently (in an amortized sense) \u201con the\n\ufb02y\u201d as needed. Loosely speaking, for any state qD0; 1; : : : ; m and any character", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "1023": {"page_number": 1024, "page_information": "32.4 The Knuth-Morris-Pratt algorithm 1003\na2\u2020,t h ev a l u e /EM\u0152q/c141 contains the information we need to compute \u0131.q;a/ but\nthat does not depend on a. Since the array /EMhas only mentries, whereas \u0131has\n\u201a.mj\u2020j/entries, we save a factor of j\u2020jin the preprocessing time by computing /EM\nrather than \u0131.\nThe pre\ufb01x function for a pattern\nThe pre\ufb01x function /EMfor a pattern encapsulates knowledge about how the pat-\ntern matches against shifts of itself. We can take advantage of this information toavoid testing useless shifts in the naive pattern-matching algorithm and to avoidprecomputing the full transition function \u0131for a string-matching automaton.\nConsider the operation of the naive string matcher. Figure 32.10(a) shows a\nparticular shift sof a template containing the pattern PDababaca against a\ntextT. For this example, qD5of the characters have matched successfully, but\nthe6th pattern character fails to match the corresponding text character. The infor-\nmation that qcharacters have matched successfully determines the corresponding\ntext characters. Knowing these qtext characters allows us to determine immedi-\nately that certain shifts are invalid. In the example of the \ufb01gure, the shift sC1is\nnecessarily invalid, since the \ufb01rst pattern character ( a) would be aligned with a text\ncharacter that we know does not match the \ufb01rst pattern character, but does match\nthe second pattern character ( b). The shift s\n0DsC2shown in part (b) of the \ufb01g-\nure, however, aligns the \ufb01rst three pattern characters with three text characters that\nmust necessarily match. In general, it is useful to know the answer to the followingquestion:\nGiven that pattern characters P\u0152 1::q/c141 match text characters T\u0152 sC1::sCq/c141,\nwhat is the least shift s\n0>ssuch that for some k<q ,\nP\u0152 1::k/c141DT\u0152 s0C1::s0Ck/c141 ; (32.6)\nwhere s0CkDsCq?\nIn other words, knowing that Pq=TsCq, we want the longest proper pre\ufb01x Pk\nofPqthat is also a suf\ufb01x of TsCq.( S i n c e s0CkDsCq,i fw ea r eg i v e n s\nandq, then \ufb01nding the smallest shift s0is tantamount to \ufb01nding the longest pre\ufb01x\nlength k.) We add the difference q/NULkin the lengths of these pre\ufb01xes of Pto the\nshiftsto arrive at our new shift s0,s ot h a t s0DsC.q/NULk/. In the best case, kD0,\nso that s0DsCq, and we immediately rule out shifts sC1; sC2;:::;sCq/NUL1.\nIn any case, at the new shift s0we don\u2019t need to compare the \ufb01rst kcharacters of P\nwith the corresponding characters of T, since equation (32.6) guarantees that they\nmatch.\nWe can precompute the necessary information by comparing the pattern against\nitself, as Figure 32.10(c) demonstrates. Since T\u0152 s0C1::s0Ck/c141is part of the", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "1024": {"page_number": 1025, "page_information": "1004 Chapter 32 String Matching\nbacbab\naba\n(a)abaabcbab\nbacasT\nP\nq\nbacbab\naba\n(b)abaabcbab\nbacas\u2032 = s + 2T\nP\nk\nab\nabaaba\n(c)Pq\nPk\nFigure 32.10 The pre\ufb01x function /EM.(a)The pattern PDababaca aligns with a text Tso that\nthe \ufb01rst qD5characters match. Matching characters, shown shaded, are connected by vertical lines.\n(b)Using only our knowledge of the 5matched characters, we can deduce that a shift of sC1is\ninvalid, but that a shift of s0DsC2is consistent with everything we know about the text and therefore\nis potentially valid. (c)We can precompute useful information for such deductions by comparing the\npattern with itself. Here, we see that the longest pre\ufb01x of Pthat is also a proper suf\ufb01x of P5isP3.\nWe represent this precomputed information in the array /EM,s ot h a t /EM\u01525/c141D3. Given that qcharacters\nhave matched successfully at shift s, the next potentially valid shift is at s0DsC.q/NUL/EM\u0152q/c141/ as shown\nin part (b).\nknown portion of the text, it is a suf\ufb01x of the string Pq. Therefore, we can interpret\nequation (32.6) as asking for the greatest k<q such that Pk=Pq. Then, the new\nshifts0DsC.q/NULk/is the next potentially valid shift. We will \ufb01nd it convenient to\nstore, for each value of q, the number kof matching characters at the new shift s0,\nrather than storing, say, s0/NULs.\nWe formalize the information that we precompute as follows. Given a pattern\nP\u0152 1::m /c141 ,t h epre\ufb01x function for the pattern Pis the function /EMWf1 ;2;:::;mg!\nf0; 1; : : : ; m/NUL1gsuch that\n/EM\u0152q/c141DmaxfkWk<q andPk=Pqg:\nThat is, /EM\u0152q/c141 is the length of the longest pre\ufb01x of Pthat is a proper suf\ufb01x of Pq.\nFigure 32.11(a) gives the complete pre\ufb01x function /EMfor the pattern ababaca .", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "1025": {"page_number": 1026, "page_information": "32.4 The Knuth-Morris-Pratt algorithm 1005\n1234567\n0012301ababaca\n(a)ababaca\nababaca\nababaca\nababaca\n(b)\"i\nP\u0152 i/c141\n/EM\u0152i/c141P5\nP3\nP1\nP0/EM\u01525/c141D3\n/EM\u01523/c141D1\n/EM\u01521/c141D0\nFigure 32.11 An illustration of Lemma 32.5 for the pattern PDababaca andqD5.(a)The/EM\nfunction for the given pattern. Since /EM\u01525/c141D3,/EM\u01523/c141D1,a n d /EM\u01521/c141D0, by iterating /EMwe obtain\n/EM/ETX\u01525/c141Df3; 1; 0g.(b)We slide the template containing the pattern Pto the right and note when some\npre\ufb01x PkofPmatches up with some proper suf\ufb01x of P5; we get matches when kD3,1,a n d 0.I n\nthe \ufb01gure, the \ufb01rst row gives P, and the dotted vertical line is drawn just after P5. Successive rows\nshow all the shifts of Pthat cause some pre\ufb01x PkofPto match some suf\ufb01x of P5. Successfully\nmatched characters are shown shaded. Vertical lines connect aligned matching characters. Thus,\nfkWk<5 andPk=P5gDf3; 1; 0g. Lemma 32.5 claims that /EM/ETX\u0152q/c141DfkWk<q andPk=Pqg\nfor all q.\nThe pseudocode below gives the Knuth-Morris-Pratt matching algorithm as\nthe procedure KMP-M ATCHER . For the most part, the procedure follows from\nFINITE -AUTOMATON -MATCHER , as we shall see. KMP-M ATCHER calls the aux-\niliary procedure C OMPUTE -PREFIX -FUNCTION to compute /EM.\nKMP-M ATCHER .T; P /\n1nDT:length\n2mDP:length\n3/EMDCOMPUTE -PREFIX -FUNCTION .P /\n4qD0 //number of characters matched\n5foriD1ton //scan the text from left to right\n6 while q>0 andP\u0152 qC1/c141\u00a4T\u0152 i/c141\n7 qD/EM\u0152q/c141 //next character does not match\n8 ifP\u0152 qC1/c141==T\u0152 i/c141\n9 qDqC1 //next character matches\n10 ifq==m //is all of Pmatched?\n11 print \u201cPattern occurs with shift\u201d i/NULm\n12 qD/EM\u0152q/c141 //look for the next match", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "1026": {"page_number": 1027, "page_information": "1006 Chapter 32 String Matching\nCOMPUTE -PREFIX -FUNCTION .P /\n1mDP:length\n2l e t /EM\u0152 1::m /c141 be a new array\n3/EM\u01521/c141D0\n4kD0\n5forqD2tom\n6 while k>0 andP\u0152 kC1/c141\u00a4P\u0152 q/c141\n7 kD/EM\u0152k/c141\n8 ifP\u0152 kC1/c141==P\u0152 q/c141\n9 kDkC1\n10 /EM\u0152q/c141Dk\n11return /EM\nThese two procedures have much in common, because both match a string against\nthe pattern P:K M P - M ATCHER matches the text Tagainst P,a n dC OMPUTE -\nPREFIX -FUNCTION matches Pagainst itself.\nWe begin with an analysis of the running times of these procedures. Proving\nthese procedures correct will be more complicated.\nRunning-time analysis\nThe running time of C OMPUTE -PREFIX -FUNCTION is\u201a.m/ , which we show by\nusing the aggregate method of amortized analysis (see Section 17.1). The onlytricky part is showing that the while loop of lines 6\u20137 executes O.m/ times alto-\ngether. We shall show that it makes at most m/NUL1iterations. We start by making\nsome observations about k. First, line 4 starts kat0, and the only way that k\nincreases is by the increment operation in line 9, which executes at most once periteration of the forloop of lines 5\u201310. Thus, the total increase in kis at most m/NUL1.\nSecond, since k<q upon entering the forloop and each iteration of the loop in-\ncrements q,w ea l w a y sh a v e k<q . Therefore, the assignments in lines 3 and 10\nensure that /EM\u0152q/c141 < q for all qD1 ;2;:::;m , which means that each iteration of\nthewhile loop decreases k. Third, knever becomes negative. Putting these facts\ntogether, we see that the total decrease in kfrom the while loop is bounded from\nabove by the total increase in kover all iterations of the forloop, which is m/NUL1.\nThus, the while loop iterates at most m/NUL1times in all, and C\nOMPUTE -PREFIX -\nFUNCTION runs in time \u201a.m/ .\nExercise 32.4-4 asks you to show, by a similar aggregate analysis, that the match-\ning time of KMP-M ATCHER is\u201a.n/ .\nCompared with F INITE -AUTOMATON -MATCHER ,b yu s i n g /EMrather than \u0131,w e\nhave reduced the time for preprocessing the pattern from O.mj\u2020j/to\u201a.m/ , while\nkeeping the actual matching time bounded by \u201a.n/ .", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "1027": {"page_number": 1028, "page_information": "32.4 The Knuth-Morris-Pratt algorithm 1007\nCorrectness of the pre\ufb01x-function computation\nWe shall see a little later that the pre\ufb01x function /EMhelps us simulate the transition\nfunction \u0131in a string-matching automaton. But \ufb01rst, we need to prove that the\nprocedure C OMPUTE -PREFIX -FUNCTION does indeed compute the pre\ufb01x func-\ntion correctly. In order to do so, we will need to \ufb01nd all pre\ufb01xes Pkthat are proper\nsuf\ufb01xes of a given pre\ufb01x Pq.T h ev a l u eo f /EM\u0152q/c141 gives us the longest such pre\ufb01x, but\nthe following lemma, illustrated in Figure 32.11, shows that by iterating the pre\ufb01xfunction /EM, we can indeed enumerate all the pre\ufb01xes P\nkthat are proper suf\ufb01xes\nofPq.L e t\n/EM/ETX\u0152q/c141Df/EM\u0152q/c141;/EM.2/\u0152q/c141; /EM.3/\u0152 q/c141 ;:::;/EM.t/\u0152q/c141g;\nwhere /EM.i/\u0152q/c141is de\ufb01ned in terms of functional iteration, so that /EM.0/\u0152q/c141Dqand\n/EM.i/\u0152q/c141D/EM\u0152/EM.i/NUL1/\u0152q/c141/c141fori/NAK1, and where the sequence in /EM/ETX\u0152q/c141stops upon\nreaching /EM.t/\u0152q/c141D0.\nLemma 32.5 (Pre\ufb01x-function iteration lemma)\nLetPbe a pattern of length mwith pre\ufb01x function /EM. Then, for qD1 ;2;:::;m ,\nwe have /EM/ETX\u0152q/c141DfkWk<q andPk=Pqg.\nProof We \ufb01rst prove that /EM/ETX\u0152q/c141/DC2fkWk<q andPk=Pqgor, equivalently,\ni2/EM/ETX\u0152q/c141implies Pi=Pq: (32.7)\nIfi2/EM/ETX\u0152q/c141,t h e n iD/EM.u/\u0152q/c141for some u>0 . We prove equation (32.7) by\ninduction on u.F o r uD1,w eh a v e iD/EM\u0152q/c141, and the claim follows since i<q\nandP/EM\u0152q/c141=Pqby the de\ufb01nition of /EM. Using the relations /EM\u0152i/c141 < i andP/EM\u0152i/c141=Pi\nand the transitivity of <and=establishes the claim for all iin/EM/ETX\u0152q/c141. Therefore,\n/EM/ETX\u0152q/c141/DC2fkWk<q andPk=Pqg.\nWe now prove that fkWk<q andPk=Pqg/DC2/EM/ETX\u0152q/c141by contradiction. Sup-\npose to the contrary that the set fkWk<q andPk=Pqg/NUL/EM/ETX\u0152q/c141is nonempty,\nand let jbe the largest number in the set. Because /EM\u0152q/c141 is the largest value in\nfkWk<q andPk=Pqgand/EM\u0152q/c1412/EM/ETX\u0152q/c141,w em u s th a v e j</EM \u0152 q /c141 ,a n ds ow e\nletj0denote the smallest integer in /EM/ETX\u0152q/c141that is greater than j. (We can choose\nj0D/EM\u0152q/c141 if no other number in /EM/ETX\u0152q/c141is greater than j.) We have Pj=Pqbecause\nj2fkWk<q andPk=Pqg, and from j02/EM/ETX\u0152q/c141and equation (32.7), we have\nPj0=Pq. Thus, Pj=Pj0by Lemma 32.1, and jis the largest value less than j0\nwith this property. Therefore, we must have /EM\u0152j0/c141Djand, since j02/EM/ETX\u0152q/c141,w e\nmust have j2/EM/ETX\u0152q/c141as well. This contradiction proves the lemma.\nThe algorithm C OMPUTE -PREFIX -FUNCTION computes /EM\u0152q/c141,i no r d e r ,f o r qD\n1 ;2;:::;m . Setting /EM\u01521/c141 to0in line 3 of C OMPUTE -PREFIX -FUNCTION is cer-\ntainly correct, since /EM\u0152q/c141 < q for all q. We shall use the following lemma and", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "1028": {"page_number": 1029, "page_information": "1008 Chapter 32 String Matching\nits corollary to prove that C OMPUTE -PREFIX -FUNCTION computes /EM\u0152q/c141 correctly\nforq>1 .\nLemma 32.6\nLetPbe a pattern of length m,a n dl e t /EMbe the pre\ufb01x function for P.F o r qD\n1 ;2;:::;m ,i f/EM\u0152q/c141 > 0 ,t h e n /EM\u0152q/c141/NUL12/EM/ETX\u0152q/NUL1/c141.\nProof LetrD/EM\u0152q/c141 > 0 ,s ot h a t r<q andPr=Pq; thus, r/NUL1<q/NUL1and\nPr/NUL1=Pq/NUL1(by dropping the last character from PrandPq, which we can do\nbecause r>0 ). By Lemma 32.5, therefore, r/NUL12/EM/ETX\u0152q/NUL1/c141. Thus, we have\n/EM\u0152q/c141/NUL1Dr/NUL12/EM/ETX\u0152q/NUL1/c141.\nForqD2;3 ;:::;m , de\ufb01ne the subset Eq/NUL1/DC2/EM/ETX\u0152q/NUL1/c141by\nEq/NUL1Dfk2/EM/ETX\u0152q/NUL1/c141WP\u0152 kC1/c141DP\u0152 q/c141g\nDfkWk<q/NUL1andPk=Pq/NUL1andP\u0152 kC1/c141DP\u0152 q/c141g(by Lemma 32.5)\nDfkWk<q/NUL1andPkC1=Pqg:\nThe set Eq/NUL1consists of the values k<q/NUL1for which Pk=Pq/NUL1and for which,\nbecause P\u0152 kC1/c141DP\u0152 q/c141 ,w eh a v e PkC1=Pq. Thus, Eq/NUL1consists of those\nvalues k2/EM/ETX\u0152q/NUL1/c141such that we can extend PktoPkC1and get a proper suf\ufb01x\nofPq.\nCorollary 32.7\nLetPbe a pattern of length m,a n dl e t /EMbe the pre\ufb01x function for P.F o r qD\n2;3 ;:::;m ,\n/EM\u0152q/c141D(\n0 ifEq/NUL1D;;\n1Cmaxfk2Eq/NUL1gifEq/NUL1\u00a4;:\nProof IfEq/NUL1is empty, there is no k2/EM/ETX\u0152q/NUL1/c141(including kD0)f o rw h i c h\nwe can extend PktoPkC1and get a proper suf\ufb01x of Pq. Therefore /EM\u0152q/c141D0.\nIfEq/NUL1is nonempty, then for each k2Eq/NUL1we have kC1<q andPkC1=Pq.\nTherefore, from the de\ufb01nition of /EM\u0152q/c141,w eh a v e\n/EM\u0152q/c141/NAK1Cmaxfk2Eq/NUL1g: (32.8)\nNote that /EM\u0152q/c141 > 0 .L e t rD/EM\u0152q/c141/NUL1,s ot h a t rC1D/EM\u0152q/c141 and there-\nforePrC1=Pq.S i n c e rC1>0 ,w eh a v e P\u0152 rC1/c141DP\u0152 q/c141 . Furthermore,\nby Lemma 32.6, we have r2/EM/ETX\u0152q/NUL1/c141. Therefore, r2Eq/NUL1,a n ds o r/DC4\nmaxfk2Eq/NUL1gor, equivalently,\n/EM\u0152q/c141/DC41Cmaxfk2Eq/NUL1g: (32.9)\nCombining equations (32.8) and (32.9) completes the proof.\n", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "1029": {"page_number": 1030, "page_information": "32.4 The Knuth-Morris-Pratt algorithm 1009\nWe now \ufb01nish the proof that C OMPUTE -PREFIX -FUNCTION computes /EMcor-\nrectly. In the procedure C OMPUTE -PREFIX -FUNCTION , at the start of each iter-\nation of the forloop of lines 5\u201310, we have that kD/EM\u0152q/NUL1/c141. This condition\nis enforced by lines 3 and 4 when the loop is \ufb01rst entered, and it remains true ineach successive iteration because of line 10. Lines 6\u20139 adjust kso that it becomes\nthe correct value of /EM\u0152q/c141.T h e while loop of lines 6\u20137 searches through all values\nk2/EM\n/ETX\u0152q/NUL1/c141until it \ufb01nds a value of kfor which P\u0152 kC1/c141DP\u0152 q/c141 ; at that point,\nkis the largest value in the set Eq/NUL1, so that, by Corollary 32.7, we can set /EM\u0152q/c141\ntokC1.I ft h e while loop cannot \ufb01nd a k2/EM/ETX\u0152q/NUL1/c141such that P\u0152 kC1/c141DP\u0152 q/c141 ,\nthenkequals 0at line 8. If P\u0152 1 /c141DP\u0152 q/c141 , then we should set both kand/EM\u0152q/c141 to1;\notherwise we should leave kalone and set /EM\u0152q/c141 to0. Lines 8\u201310 set kand/EM\u0152q/c141\ncorrectly in either case. This completes our proof of the correctness of C OMPUTE -\nPREFIX -FUNCTION .\nCorrectness of the Knuth-Morris-Pratt algorithm\nWe can think of the procedure KMP-M ATCHER as a reimplemented version of\nthe procedure F INITE -AUTOMATON -MATCHER , but using the pre\ufb01x function /EM\nto compute state transitions. Speci\ufb01cally, we shall prove that in the ith iteration of\ntheforloops of both KMP-M ATCHER and F INITE -AUTOMATON -MATCHER ,t h e\nstate qhas the same value when we test for equality with m(at line 10 in KMP-\nMATCHER and at line 5 in F INITE -AUTOMATON -MATCHER ). Once we have\nargued that KMP-M ATCHER simulates the behavior of F INITE -AUTOMATON -\nMATCHER , the correctness of KMP-M ATCHER follows from the correctness of\nFINITE -AUTOMATON -MATCHER (though we shall see a little later why line 12 in\nKMP-M ATCHER is necessary).\nBefore we formally prove that KMP-M ATCHER correctly simulates F INITE -\nAUTOMATON -MATCHER , let\u2019s take a moment to understand how the pre\ufb01x func-\ntion/EMreplaces the \u0131transition function. Recall that when a string-matching\nautomaton is in state qand it scans a character aDT\u0152 i/c141, it moves to a new\nstate \u0131.q;a/ .I faDP\u0152 qC1/c141,s ot h a t acontinues to match the pattern, then\n\u0131.q;a/DqC1. Otherwise, a\u00a4P\u0152 qC1/c141,s ot h a t adoes not continue to match\nthe pattern, and 0/DC4\u0131.q;a//DC4q. In the \ufb01rst case, when acontinues to match,\nKMP-M ATCHER moves to state qC1without referring to the /EMfunction: the\nwhile loop test in line 6 comes up false the \ufb01rst time, the test in line 8 comes up\ntrue, and line 9 increments q.\nThe/EMfunction comes into play when the character adoes not continue to match\nthe pattern, so that the new state \u0131.q;a/ is either qor to the left of qalong the spine\nof the automaton. The while loop of lines 6\u20137 in KMP-M ATCHER iterates through\nthe states in /EM/ETX\u0152q/c141, stopping either when it arrives in a state, say q0, such that a\nmatches P\u0152 q0C1/c141orq0has gone all the way down to 0.I famatches P\u0152 q0C1/c141,", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "1030": {"page_number": 1031, "page_information": "1010 Chapter 32 String Matching\nthen line 9 sets the new state to q0C1, which should equal \u0131.q;a/ for the simulation\nto work correctly. In other words, the new state \u0131.q;a/ should be either state 0or\none greater than some state in /EM/ETX\u0152q/c141.\nLet\u2019s look at the example in Figures 32.7 and 32.11, which are for the pattern\nPDababaca . Suppose that the automaton is in state qD5; the states in\n/EM/ETX\u01525/c141are, in descending order, 3,1,a n d 0. If the next character scanned is c,t h e n\nwe can easily see that the automaton moves to state \u0131.5;c/D6in both F INITE -\nAUTOMATON -MATCHER and KMP-M ATCHER . Now suppose that the next char-\nacter scanned is instead b, so that the automaton should move to state \u0131.5;b/D4.\nThewhile loop in KMP-M ATCHER exits having executed line 7 once, and it ar-\nrives in state q0D/EM\u01525/c141D3.S i n c e P\u0152 q0C1/c141DP\u0152 4 /c141Db, the test in line 8\ncomes up true, and KMP-M ATCHER moves to the new state q0C1D4D\u0131.5;b/.\nFinally, suppose that the next character scanned is instead a, so that the automa-\nton should move to state \u0131.5;a/D1. The \ufb01rst three times that the test in line 6\nexecutes, the test comes up true. The \ufb01rst time, we \ufb01nd that P\u0152 6 /c141Dc\u00a4a,a n d\nKMP-M ATCHER moves to state /EM\u01525/c141D3(the \ufb01rst state in /EM/ETX\u01525/c141). The second\ntime, we \ufb01nd that P\u0152 4 /c141Db\u00a4aand move to state /EM\u01523/c141D1(the second state\nin/EM/ETX\u01525/c141). The third time, we \ufb01nd that P\u0152 2 /c141Db\u00a4aand move to state /EM\u01521/c141D0\n(the last state in /EM/ETX\u01525/c141). The while loop exits once it arrives in state q0D0.N o w ,\nline 8 \ufb01nds that P\u0152 q0C1/c141DP\u0152 1 /c141Da, and line 9 moves the automaton to the new\nstateq0C1D1D\u0131.5;a/.\nThus, our intuition is that KMP-M ATCHER iterates through the states in /EM/ETX\u0152q/c141in\ndecreasing order, stopping at some state q0and then possibly moving to state q0C1.\nAlthough that might seem like a lot of work just to simulate computing \u0131.q;a/ ,\nbear in mind that asymptotically, KMP-M ATCHER is no slower than F INITE -\nAUTOMATON -MATCHER .\nWe are now ready to formally prove the correctness of the Knuth-Morris-Pratt\nalgorithm. By Theorem 32.4, we have that qD/ESC.T i/after each time we execute\nline 4 of F INITE -AUTOMATON -MATCHER . Therefore, it suf\ufb01ces to show that the\nsame property holds with regard to the forloop in KMP-M ATCHER . The proof\nproceeds by induction on the number of loop iterations. Initially, both proceduressetqto0as they enter their respective forloops for the \ufb01rst time. Consider itera-\ntioniof the forloop in KMP-M\nATCHER ,a n dl e t q0be state at the start of this loop\niteration. By the inductive hypothesis, we have q0D/ESC.T i/NUL1/. We need to show\nthatqD/ESC.T i/at line 10. (Again, we shall handle line 12 separately.)\nWhen we consider the character T\u0152 i/c141, the longest pre\ufb01x of Pthat is a suf\ufb01x of Ti\nis either Pq0C1(ifP\u0152 q0C1/c141DT\u0152 i/c141) or some pre\ufb01x (not necessarily proper, and\npossibly empty) of Pq0. We consider separately the three cases in which /ESC.T i/D0,\n/ESC.T i/Dq0C1,a n d 0</ESC . T i//DC4q0.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "1031": {"page_number": 1032, "page_information": "32.4 The Knuth-Morris-Pratt algorithm 1011\n/SIIf/ESC.T i/D0,t h e n P0D\"is the only pre\ufb01x of Pthat is a suf\ufb01x of Ti.T h ewhile\nloop of lines 6\u20137 iterates through the values in /EM/ETX\u0152q0/c141, but although Pq=Tifor\nevery q2/EM/ETX\u0152q0/c141, the loop never \ufb01nds a qsuch that P\u0152 qC1/c141DT\u0152 i/c141. The loop\nterminates when qreaches 0, and of course line 9 does not execute. Therefore,\nqD0at line 10, so that qD/ESC.T i/.\n/SIIf/ESC.T i/Dq0C1,t h e n P\u0152 q0C1/c141DT\u0152 i/c141,a n dt h e while loop test in line 6\nfails the \ufb01rst time through. Line 9 executes, incrementing qso that afterward\nwe have qDq0C1D/ESC.T i/.\n/SIIf0</ESC . T i//DC4q0, then the while loop of lines 6\u20137 iterates at least once,\nchecking in decreasing order each value q2/EM/ETX\u0152q0/c141until it stops at some q<q0.\nThus, Pqis the longest pre\ufb01x of Pq0for which P\u0152 qC1/c141DT\u0152 i/c141, so that when the\nwhile loop terminates, qC1D/ESC.P q0T\u0152 i/c141 / .S i n c e q0D/ESC.T i/NUL1/, Lemma 32.3\nimplies that /ESC.T i/NUL1T\u0152 i/c141 /D/ESC.P q0T\u0152 i/c141 / . Thus, we have\nqC1D/ESC.P q0T\u0152 i/c141 /\nD/ESC.T i/NUL1T\u0152 i/c141 /\nD/ESC.T i/\nwhen the while loop terminates. After line 9 increments q,w eh a v e qD/ESC.T i/.\nLine 12 is necessary in KMP-M ATCHER , because otherwise, we might refer-\nence P\u0152 mC1/c141on line 6 after \ufb01nding an occurrence of P. (The argument that\nqD/ESC.T i/NUL1/upon the next execution of line 6 remains valid by the hint given in\nExercise 32.4-8: \u0131.m;a/D\u0131./EM\u0152m/c141;a/ or, equivalently, /ESC.Pa/D/ESC.P /EM\u0152m/c141a/for\nanya2\u2020.) The remaining argument for the correctness of the Knuth-Morris-\nPratt algorithm follows from the correctness of F INITE -AUTOMATON -MATCHER ,\ns i n c ew eh a v es h o w nt h a tK M P - M ATCHER simulates the behavior of F INITE -\nAUTOMATON -MATCHER .\nExercises\n32.4-1\nCompute the pre\ufb01x function /EMfor the pattern ababbabbabbababbabb .\n32.4-2\nGive an upper bound on the size of /EM/ETX\u0152q/c141as a function of q. Give an example to\nshow that your bound is tight.\n32.4-3\nExplain how to determine the occurrences of pattern Pin the text Tby examining\nthe/EMfunction for the string PT(the string of length mCnthat is the concatenation\nofPandT).", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "1032": {"page_number": 1033, "page_information": "1012 Chapter 32 String Matching\n32.4-4\nUse an aggregate analysis to show that the running time of KMP-M ATCHER\nis\u201a.n/ .\n32.4-5\nUse a potential function to show that the running time of KMP-M ATCHER is\u201a.n/ .\n32.4-6\nShow how to improve KMP-M ATCHER by replacing the occurrence of /EMin line 7\n(but not line 12) by /EM0,w h e r e /EM0is de\ufb01ned recursively for qD1 ;2;:::;m/NUL1by\nthe equation\n/EM0\u0152q/c141D/c128\n0 if/EM\u0152q/c141D0;\n/EM0\u0152/EM\u0152q/c141/c141 if/EM\u0152q/c141\u00a40andP\u0152 /EM\u0152 q/c141C1/c141DP\u0152 qC1/c141 ;\n/EM\u0152q/c141 if/EM\u0152q/c141\u00a40andP\u0152 /EM\u0152 q/c141C1/c141\u00a4P\u0152 qC1/c141 :\nExplain why the modi\ufb01ed algorithm is correct, and explain in what sense this\nchange constitutes an improvement.\n32.4-7\nGive a linear-time algorithm to determine whether a text Tis a cyclic rotation of\nanother string T0. For example, arc andcar are cyclic rotations of each other.\n32.4-8 ?\nGive an O.mj\u2020j/-time algorithm for computing the transition function \u0131for the\nstring-matching automaton corresponding to a given pattern P.(Hint: Prove that\n\u0131.q;a/D\u0131./EM\u0152q/c141;a/ ifqDmorP\u0152 qC1/c141\u00a4a.)\nProblems\n32-1 String matching based on repetition factors\nLetyidenote the concatenation of string ywith itself itimes. For example,\n.ab/3Dababab . We say that a string x2\u2020/ETXhasrepetition factor rifxDyr\nfor some string y2\u2020/ETXand some r>0 .L e t /SUB.x/ denote the largest rsuch that x\nhas repetition factor r.\na.Give an ef\ufb01cient algorithm that takes as input a pattern P\u0152 1::m /c141 and computes\nthe value /SUB.P i/foriD1 ;2;:::;m . What is the running time of your algo-\nrithm?", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "1033": {"page_number": 1034, "page_information": "Notes for Chapter 32 1013\nb.For any pattern P\u0152 1::m /c141 ,l e t/SUB/ETX.P /be de\ufb01ned as max 1/DC4i/DC4m/SUB.P i/. Prove that if\nthe pattern Pis chosen randomly from the set of all binary strings of length m,\nthen the expected value of /SUB/ETX.P /isO.1/ .\nc.Argue that the following string-matching algorithm correctly \ufb01nds all occur-\nrences of pattern Pin a text T\u0152 1::n /c141 in time O./SUB/ETX.P /nCm/:\nREPETITION -MATCHER .P; T /\n1mDP:length\n2nDT:length\n3kD1C/SUB/ETX.P /\n4qD0\n5sD0\n6while s/DC4n/NULm\n7 ifT\u0152 sCqC1/c141==P\u0152 qC1/c141\n8 qDqC1\n9 ifq==m\n10 print \u201cPattern occurs with shift\u201d s\n11 ifq==morT\u0152 sCqC1/c141\u00a4P\u0152 qC1/c141\n12 sDsCmax.1;dq=ke/\n13 qD0\nThis algorithm is due to Galil and Seiferas. By extending these ideas greatly,\nthey obtained a linear-time string-matching algorithm that uses only O.1/ stor-\nage beyond what is required for PandT.\nChapter notes\nThe relation of string matching to the theory of \ufb01nite automata is discussed by\nAho, Hopcroft, and Ullman [5]. The Knuth-Morris-Pratt algorithm [214] wasinvented independently by Knuth and Pratt and by Morris; they published theirwork jointly. Reingold, Urban, and Gries [294] give an alternative treatment of theKnuth-Morris-Pratt algorithm. The Rabin-Karp algorithm was proposed by Karpand Rabin [201]. Galil and Seiferas [126] give an interesting deterministic linear-time string-matching algorithm that uses only O.1/ space beyond that required to\nstore the pattern and text.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "1034": {"page_number": 1035, "page_information": "33 Computational Geometry\nComputational geometry is the branch of computer science that studies algorithms\nfor solving geometric problems. In modern engineering and mathematics, com-putational geometry has applications in such diverse \ufb01elds as computer graphics,robotics, VLSI design, computer-aided design, molecular modeling, metallurgy,manufacturing, textile layout, forestry, and statistics. The input to a computational-geometry problem is typically a description of a set of geometric objects, such asa set of points, a set of line segments, or the vertices of a polygon in counterclock-wise order. The output is often a response to a query about the objects, such aswhether any of the lines intersect, or perhaps a new geometric object, such as theconvex hull (smallest enclosing convex polygon) of the set of points.\nIn this chapter, we look at a few computational-geometry algorithms in two\ndimensions, that is, in the plane. We represent each input object by a set ofpointsfp\n1;p2;p3;:::g, where each piD.xi;yi/andxi;yi2R.F o r e x a m -\nple, we represent an n-vertex polygon Pby a sequencehp0;p1;p2;:::;p n/NUL1i\nof its vertices in order of their appearance on the boundary of P. Computational\ngeometry can also apply to three dimensions, and even higher-dimensional spaces,but such problems and their solutions can be very dif\ufb01cult to visualize. Even intwo dimensions, however, we can see a good sample of computational-geometrytechniques.\nSection 33.1 shows how to answer basic questions about line segments ef\ufb01-\nciently and accurately: whether one segment is clockwise or counterclockwisefrom another that shares an endpoint, which way we turn when traversing twoadjoining line segments, and whether two line segments intersect. Section 33.2presents a technique called \u201csweeping\u201d that we use to develop an O.n lgn/-time\nalgorithm for determining whether a set of nline segments contains any inter-\nsections. Section 33.3 gives two \u201crotational-sweep\u201d algorithms that compute theconvex hull (smallest enclosing convex polygon) of a set of npoints: Graham\u2019s\nscan, which runs in time O.n lgn/, and Jarvis\u2019s march, which takes O.nh/ time,\nwhere his the number of vertices of the convex hull. Finally, Section 33.4 gives", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "1035": {"page_number": 1036, "page_information": "33.1 Line-segment properties 1015\nanO.n lgn/-time divide-and-conquer algorithm for \ufb01nding the closest pair of\npoints in a set of npoints in the plane.\n33.1 Line-segment properties\nSeveral of the computational-geometry algorithms in this chapter require answers\nto questions about the properties of line segments. A convex combination of two\ndistinct points p1D.x1;y1/andp2D.x2;y2/is any point p3D.x3;y3/such\nthat for some \u02dbin the range 0/DC4\u02db/DC41,w eh a v e x3D\u02dbx1C.1/NUL\u02db/x 2and\ny3D\u02dby1C.1/NUL\u02db/y 2. We also write that p3D\u02dbp1C.1/NUL\u02db/p 2. Intuitively, p3\nis any point that is on the line passing through p1andp2and is on or between p1\nandp2on the line. Given two distinct points p1andp2,t h eline segment\n p1p2\nis the set of convex combinations of p1andp2. We call p1andp2theendpoints\nof segment\n p1p2. Sometimes the ordering of p1andp2matters, and we speak of\nthedirected segment/NUL/NUL/NUL!p1p2.I fp1is theorigin .0; 0/ , then we can treat the directed\nsegment/NUL/NUL/NUL!p1p2as the vector p2.\nIn this section, we shall explore the following questions:\n1. Given two directed segments/NUL/NUL/NUL!p0p1and/NUL/NUL/NUL!p0p2,i s/NUL/NUL/NUL!p0p1clockwise from/NUL/NUL/NUL!p0p2\nwith respect to their common endpoint p0?\n2. Given two line segments\n p0p1and\np1p2, if we traverse\n p0p1and then\n p1p2,\ndo we make a left turn at point p1?\n3. Do line segments\n p1p2and\np3p4intersect?\nThere are no restrictions on the given points.\nWe can answer each question in O.1/ time, which should come as no surprise\nsince the input size of each question is O.1/ . Moreover, our methods use only ad-\nditions, subtractions, multiplications, and comparisons. We need neither divisionnor trigonometric functions, both of which can be computationally expensive andprone to problems with round-off error. For example, the \u201cstraightforward\u201d methodof determining whether two segments intersect\u2014compute the line equation of theform yDmxCbfor each segment ( mis the slope and bis the y-intercept),\n\ufb01nd the point of intersection of the lines, and check whether this point is on both\nsegments\u2014uses division to \ufb01nd the point of intersection. When the segments are\nnearly parallel, this method is very sensitive to the precision of the division opera-\ntion on real computers. The method in this section, which avoids division, is much\nmore accurate.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "1036": {"page_number": 1037, "page_information": "1016 Chapter 33 Computational Geometry\np2\nxy\n(0,0)p1p1 +p2\n(a) (b)y\nx(0,0)p\nFigure 33.1 (a) The cross product of vectors p1andp2is the signed area of the parallelogram.\n(b)The lightly shaded region contains vectors that are clockwise from p. The darkly shaded region\ncontains vectors that are counterclockwise from p.\nCross products\nComputing cross products lies at the heart of our line-segment methods. Consider\nvectors p1andp2, shown in Figure 33.1(a). We can interpret the cross product\np1/STXp2as the signed area of the parallelogram formed by the points .0; 0/ ,p1,p2,\nandp1Cp2D.x1Cx2;y1Cy2/. An equivalent, but more useful, de\ufb01nition gives\nthe cross product as the determinant of a matrix:1\np1/STXp2Ddet/DC2x1x2\ny1y2/DC3\nDx1y2/NULx2y1\nD/NUL p2/STXp1:\nIfp1/STXp2is positive, then p1is clockwise from p2with respect to the origin .0; 0/ ;\nif this cross product is negative, then p1is counterclockwise from p2.( S e e E x e r -\ncise 33.1-1.) Figure 33.1(b) shows the clockwise and counterclockwise regions\nrelative to a vector p. A boundary condition arises if the cross product is 0;i nt h i s\ncase, the vectors are colinear , pointing in either the same or opposite directions.\nTo determine whether a directed segment/NUL/NUL/NUL!p0p1is closer to a directed seg-\nment/NUL/NUL/NUL!p0p2in a clockwise direction or in a counterclockwise direction with respect\nto their common endpoint p0, we simply translate to use p0as the origin. That\nis, we let p1/NULp0denote the vector p0\n1D.x0\n1;y0\n1/,w h e r e x0\n1Dx1/NULx0and\ny0\n1Dy1/NULy0, and we de\ufb01ne p2/NULp0similarly. We then compute the cross product\n1Actually, the cross product is a three-dimensional concept. It is a vector that is perpendicular to\nbothp1andp2according to the \u201cright-hand rule\u201d and whose magnitude is jx1y2/NULx2y1j.I n t h i s\nchapter, however, we \ufb01nd it convenient to treat the cross product simply as the value x1y2/NULx2y1.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "1037": {"page_number": 1038, "page_information": "33.1 Line-segment properties 1017\np0p1p2\np0p1p2\ncounterclockwise\n(a) (b)clockwise\nFigure 33.2 Using the cross product to determine how consecutive line segments\n p0p1and\np1p2\nturn at point p1. We check whether the directed segment/NUL/NUL/NUL!p0p2is clockwise or counterclockwise\nrelative to the directed segment/NUL/NUL/NUL!p0p1.(a)If counterclockwise, the points make a left turn. (b)If\nclockwise, they make a right turn.\n.p1/NULp0//STX.p2/NULp0/D.x1/NULx0/.y2/NULy0//NUL.x2/NULx0/.y1/NULy0/:\nIf this cross product is positive, then/NUL/NUL/NUL!p0p1is clockwise from/NUL/NUL/NUL!p0p2; if negative, it\nis counterclockwise.\nDetermining whether consecutive segments turn left or right\nOur next question is whether two consecutive line segments\n p0p1and\np1p2turn\nleft or right at point p1. Equivalently, we want a method to determine which way a\ngiven angle\u2020p0p1p2turns. Cross products allow us to answer this question with-\nout computing the angle. As Figure 33.2 shows, we simply check whether directedsegment/NUL/NUL/NUL!p\n0p2is clockwise or counterclockwise relative to directed segment/NUL/NUL/NUL!p0p1.\nTo do so, we compute the cross product .p2/NULp0//STX.p1/NULp0/. If the sign of\nthis cross product is negative, then/NUL/NUL/NUL!p0p2is counterclockwise with respect to/NUL/NUL/NUL!p0p1,\nand thus we make a left turn at p1. A positive cross product indicates a clockwise\norientation and a right turn. A cross product of 0means that points p0,p1,a n d p2\nare colinear.\nDetermining whether two line segments intersect\nTo determine whether two line segments intersect, we check whether each segment\nstraddles the line containing the other. A segment\n p1p2straddles a line if point p1\nlies on one side of the line and point p2lies on the other side. A boundary case\narises if p1orp2lies directly on the line. Two line segments intersect if and only\nif either (or both) of the following conditions holds:\n1. Each segment straddles the line containing the other.\n2. An endpoint of one segment lies on the other segment. (This condition comes\nfrom the boundary case.)", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "1038": {"page_number": 1039, "page_information": "1018 Chapter 33 Computational Geometry\nThe following procedures implement this idea. S EGMENTS -INTERSECT returns\nTRUE if segments\n p1p2and\np3p4intersect and FALSE if they do not. It calls\nthe subroutines D IRECTION , which computes relative orientations using the cross-\nproduct method above, and O N-SEGMENT , which determines whether a point\nknown to be colinear with a segment lies on that segment.\nSEGMENTS -INTERSECT .p1;p2;p3;p4/\n1d1DDIRECTION .p3;p4;p1/\n2d2DDIRECTION .p3;p4;p2/\n3d3DDIRECTION .p1;p2;p3/\n4d4DDIRECTION .p1;p2;p4/\n5if..d1>0andd2<0 / or.d1<0andd2>0 / / and\n..d3>0andd4<0 / or.d3<0andd4>0 / /\n6 return TRUE\n7elseif d1==0and O N-SEGMENT .p3;p4;p1/\n8 return TRUE\n9elseif d2==0and O N-SEGMENT .p3;p4;p2/\n10 return TRUE\n11elseif d3==0and O N-SEGMENT .p1;p2;p3/\n12 return TRUE\n13elseif d4==0and O N-SEGMENT .p1;p2;p4/\n14 return TRUE\n15else return FALSE\nDIRECTION .pi;pj;pk/\n1return .pk/NULpi//STX.pj/NULpi/\nON-SEGMENT .pi;pj;pk/\n1ifmin.xi;xj//DC4xk/DC4max.xi;xj/and min .yi;yj//DC4yk/DC4max.yi;yj/\n2 return TRUE\n3else return FALSE\nSEGMENTS -INTERSECT works as follows. Lines 1\u20134 compute the relative ori-\nentation diof each endpoint piwith respect to the other segment. If all the relative\norientations are nonzero, then we can easily determine whether segments\n p1p2\nand\np3p4intersect, as follows. Segment\n p1p2straddles the line containing seg-\nment\n p3p4if directed segments/NUL/NUL/NUL!p3p1and/NUL/NUL/NUL!p3p2have opposite orientations relative\nto/NUL/NUL/NUL!p3p4. In this case, the signs of d1andd2differ. Similarly,\n p3p4straddles\nthe line containing\n p1p2if the signs of d3andd4differ. If the test of line 5 is\ntrue, then the segments straddle each other, and S EGMENTS -INTERSECT returns\nTRUE . Figure 33.3(a) shows this case. Otherwise, the segments do not straddle", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "1039": {"page_number": 1040, "page_information": "33.1 Line-segment properties 1019\np1\np2\np3p4 (p1\u2013p3)\u00d7 (p4\u2013p3) < 0\n(p4\u2013p1)\u00d7 (p2\u2013p1) < 0\n(p2\u2013p3)\u00d7 (p4\u2013p3) > 0(p3\u2013p1)\u00d7 (p2\u2013p1) > 0\n(a)p1p2\np3p4 (p1\u2013p3)\u00d7 (p4\u2013p3) < 0\n(p4\u2013p1)\u00d7 (p2\u2013p1) < 0\n(p2\u2013p3)\u00d7 (p4\u2013p3) < 0\n(p3\u2013p1)\u00d7 (p2\u2013p1) > 0\n(b)\np1\np2p3p4\n(c)p1\np2p3p4\n(d)\nFigure 33.3 Cases in the procedure S EGMENTS -INTERSECT .(a)The segments\n p1p2and\np3p4\nstraddle each other\u2019s lines. Because\n p3p4straddles the line containing\n p1p2, the signs of the cross\nproducts .p3/NULp1//STX.p2/NULp1/and.p4/NULp1//STX.p2/NULp1/differ. Because\n p1p2straddles the line\ncontaining\n p3p4, the signs of the cross products .p1/NULp3//STX.p4/NULp3/and.p2/NULp3//STX.p4/NULp3/\ndiffer. (b)Segment\n p3p4straddles the line containing\n p1p2,b u t\n p1p2does not straddle the line\ncontaining\n p3p4. The signs of the cross products .p1/NULp3//STX.p4/NULp3/and.p2/NULp3//STX.p4/NULp3/\nare the same. (c)Point p3is colinear with\n p1p2and is between p1andp2.(d)Point p3is colinear\nwith\np1p2, but it is not between p1andp2. The segments do not intersect.\neach other\u2019s lines, although a boundary case may apply. If all the relative orienta-\ntions are nonzero, no boundary case applies. All the tests against 0in lines 7\u201313\nthen fail, and S EGMENTS -INTERSECT returns FALSE in line 15. Figure 33.3(b)\nshows this case.\nA boundary case occurs if any relative orientation dkis0. Here, we know that pk\nis colinear with the other segment. It is directly on the other segment if and only\nif it is between the endpoints of the other segment. The procedure O N-SEGMENT\nreturns whether pkis between the endpoints of segment\n pipj, which will be the\nother segment when called in lines 7\u201313; the procedure assumes that pkis colinear\nwith segment\n pipj. Figures 33.3(c) and (d) show cases with colinear points. In\nFigure 33.3(c), p3is on\n p1p2,a n ds oS EGMENTS -INTERSECT returns TRUE in\nline 12. No endpoints are on other segments in Figure 33.3(d), and so S EGMENTS -\nINTERSECT returns FALSE in line 15.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "1040": {"page_number": 1041, "page_information": "1020 Chapter 33 Computational Geometry\nOther applications of cross products\nLater sections of this chapter introduce additional uses for cross products. In Sec-\ntion 33.3, we shall need to sort a set of points according to their polar angles withrespect to a given origin. As Exercise 33.1-3 asks you to show, we can use crossproducts to perform the comparisons in the sorting procedure. In Section 33.2, weshall use red-black trees to maintain the vertical ordering of a set of line segments.Rather than keeping explicit key values which we compare to each other in thered-black tree code, we shall compute a cross-product to determine which of twosegments that intersect a given vertical line is above the other.\nExercises\n33.1-1\nProve that if p\n1/STXp2is positive, then vector p1is clockwise from vector p2with\nrespect to the origin .0; 0/ and that if this cross product is negative, then p1is\ncounterclockwise from p2.\n33.1-2\nProfessor van Pelt proposes that only the x-dimension needs to be tested in line 1\nof O N-SEGMENT . Show why the professor is wrong.\n33.1-3\nThepolar angle of a point p1with respect to an origin point p0is the angle of the\nvector p1/NULp0in the usual polar coordinate system. For example, the polar angle\nof.3; 5/ with respect to .2; 4/ is the angle of the vector .1; 1/ ,w h i c hi s 45degrees\nor/EM=4 radians. The polar angle of .3; 3/ with respect to .2; 4/ is the angle of the\nvector .1;/NUL1/,w h i c hi s 315degrees or 7/EM=4 radians. Write pseudocode to sort a\nsequencehp1;p2;:::;p niofnpoints according to their polar angles with respect\nto a given origin point p0. Your procedure should take O.n lgn/time and use cross\nproducts to compare angles.\n33.1-4\nShow how to determine in O.n2lgn/time whether any three points in a set of n\npoints are colinear.\n33.1-5\nApolygon is a piecewise-linear, closed curve in the plane. That is, it is a curve\nending on itself that is formed by a sequence of straight-line segments, called thesides of the polygon. A point joining two consecutive sides is a vertex of the poly-\ngon. If the polygon is simple , as we shall generally assume, it does not cross itself.\nThe set of points in the plane enclosed by a simple polygon forms the interior of", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "1041": {"page_number": 1042, "page_information": "33.2 Determining whether any pair of segments intersects 1021\nthe polygon, the set of points on the polygon itself forms its boundary , and the set\nof points surrounding the polygon forms its exterior . A simple polygon is convex\nif, given any two points on its boundary or in its interior, all points on the linesegment drawn between them are contained in the polygon\u2019s boundary or interior.A vertex of a convex polygon cannot be expressed as a convex combination of anytwo distinct points on the boundary or in the interior of the polygon.\nProfessor Amundsen proposes the following method to determine whether a se-\nquencehp\n0;p1;:::;p n/NUL1iofnpoints forms the consecutive vertices of a convex\npolygon. Output \u201cyes\u201d if the set f\u2020pipiC1piC2WiD0; 1; : : : ; n/NUL1g, where sub-\nscript addition is performed modulo n, does not contain both left turns and right\nturns; otherwise, output \u201cno.\u201d Show that although this method runs in linear time,it does not always produce the correct answer. Modify the professor\u2019s method sothat it always produces the correct answer in linear time.\n33.1-6\nGiven a point p\n0D.x0;y0/,t h eright horizontal ray from p0is the set of points\nfpiD.xi;yi/Wxi/NAKx0andyiDy0g, that is, it is the set of points due right of p0\nalong with p0itself. Show how to determine whether a given right horizontal ray\nfrom p0intersects a line segment\n p1p2inO.1/ time by reducing the problem to\nthat of determining whether two line segments intersect.\n33.1-7\nOne way to determine whether a point p0is in the interior of a simple, but not\nnecessarily convex, polygon Pis to look at any ray from p0and check that the ray\nintersects the boundary of Pan odd number of times but that p0itself is not on\nthe boundary of P. Show how to compute in \u201a.n/ time whether a point p0is in\nthe interior of an n-vertex polygon P.(Hint: Use Exercise 33.1-6. Make sure your\nalgorithm is correct when the ray intersects the polygon boundary at a vertex andwhen the ray overlaps a side of the polygon.)\n33.1-8\nShow how to compute the area of an n-vertex simple, but not necessarily convex,\npolygon in \u201a.n/ time. (See Exercise 33.1-5 for de\ufb01nitions pertaining to polygons.)\n33.2 Determining whether any pair of segments intersects\nThis section presents an algorithm for determining whether any two line segments\nin a set of segments intersect. The algorithm uses a technique known as \u201csweep-ing,\u201d which is common to many computational-geometry algorithms. Moreover, as", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "1042": {"page_number": 1043, "page_information": "1022 Chapter 33 Computational Geometry\nthe exercises at the end of this section show, this algorithm, or simple variations of\nit, can help solve other computational-geometry problems.\nThe algorithm runs in O.n lgn/time, where nis the number of segments we are\ngiven. It determines only whether or not any intersection exists; it does not printall the intersections. (By Exercise 33.2-1, it takes /DEL.n\n2/time in the worst case to\n\ufb01ndallthe intersections in a set of nline segments.)\nInsweeping , an imaginary vertical sweep line passes through the given set of\ngeometric objects, usually from left to right. We treat the spatial dimension that\nthe sweep line moves across, in this case the x-dimension, as a dimension of\ntime. Sweeping provides a method for ordering geometric objects, usually by plac-ing them into a dynamic data structure, and for taking advantage of relationshipsamong them. The line-segment-intersection algorithm in this section considers allthe line-segment endpoints in left-to-right order and checks for an intersection eachtime it encounters an endpoint.\nTo describe and prove correct our algorithm for determining whether any two\nofnline segments intersect, we shall make two simplifying assumptions. First, we\nassume that no input segment is vertical. Second, we assume that no three input\nsegments intersect at a single point. Exercises 33.2-8 and 33.2-9 ask you to show\nthat the algorithm is robust enough that it needs only a slight modi\ufb01cation to workeven when these assumptions do not hold. Indeed, removing such simplifyingassumptions and dealing with boundary conditions often present the most dif\ufb01cultchallenges when programming computational-geometry algorithms and proving\ntheir correctness.\nOrdering segments\nBecause we assume that there are no vertical segments, we know that any input\nsegment intersecting a given vertical sweep line intersects it at a single point. Thus,\nwe can order the segments that intersect a vertical sweep line according to the y-\ncoordinates of the points of intersection.\nTo be more precise, consider two segments s\n1ands2. We say that these segments\narecomparable atxif the vertical sweep line with x-coordinate xintersects both of\nthem. We say that s1isabove s2atx, written s1<xs2,i fs1ands2are comparable\natxand the intersection of s1with the sweep line at xis higher than the intersection\nofs2with the same sweep line, or if s1ands2intersect at the sweep line. In\nFigure 33.4(a), for example, we have the relationships a<rc,a<tb,b<tc,\na<tc,a n d b<uc.S e g m e n t dis not comparable with any other segment.\nFor any given x, the relation \u201c <x\u201d is a total preorder (see Section B.2) for all\nsegments that intersect the sweep line at x. That is, the relation is transitive, and\nif segments s1ands2each intersect the sweep line at x, then either s1<xs2\nors2<xs1, or both (if s1ands2intersect at the sweep line). (The relation <xis", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "1043": {"page_number": 1044, "page_information": "33.2 Determining whether any pair of segments intersects 1023\nrt ua\ncbd\n(a) (b)vwe\nfg\nhi\nz\nFigure 33.4 The ordering among line segments at various vertical sweep lines. (a)We have a<rc,\na<tb,b<tc,a<tc,a n d b<uc.S e g m e n t dis comparable with no other segment shown.\n(b)When segments eandfintersect, they reverse their orders: we have e</ETBfbutf <we.A n y\nsweep line (such as \u00b4) that passes through the shaded region has eandfconsecutive in the ordering\ngiven by the relation <\u00b4.\nalso re\ufb02exive, but neither symmetric nor antisymmetric.) The total preorder may\ndiffer for differing values of x, however, as segments enter and leave the ordering.\nA segment enters the ordering when its left endpoint is encountered by the sweep,and it leaves the ordering when its right endpoint is encountered.\nWhat happens when the sweep line passes through the intersection of two seg-\nments? As Figure 33.4(b) shows, the segments reverse their positions in the totalpreorder. Sweep lines /ETBandware to the left and right, respectively, of the point\nof intersection of segments eandf, and we have e<\n/ETBfandf <we.N o t e\nthat because we assume that no three segments intersect at the same point, theremust be some vertical sweep line xfor which intersecting segments eandfare\nconsecutive in the total preorder <\nx. Any sweep line that passes through the shaded\nregion of Figure 33.4(b), such as \u00b4,h a seandfconsecutive in its total preorder.\nMoving the sweep line\nSweeping algorithms typically manage two sets of data:\n1. The sweep-line status gives the relationships among the objects that the sweep\nline intersects.\n2. The event-point schedule is a sequence of points, called event points ,w h i c h\nwe order from left to right according to their x-coordinates. As the sweep\nprogresses from left to right, whenever the sweep line reaches the x-coordinate\nof an event point, the sweep halts, processes the event point, and then resumes.\nChanges to the sweep-line status occur only at event points.\nFor some algorithms (the algorithm asked for in Exercise 33.2-7, for example),\nthe event-point schedule develops dynamically as the algorithm progresses. The al-gorithm at hand, however, determines all the event points before the sweep, based", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "1044": {"page_number": 1045, "page_information": "1024 Chapter 33 Computational Geometry\nsolely on simple properties of the input data. In particular, each segment endpoint\nis an event point. We sort the segment endpoints by increasing x-coordinate and\nproceed from left to right. (If two or more endpoints are covertical , i.e., they have\nthe same x-coordinate, we break the tie by putting all the covertical left endpoints\nbefore the covertical right endpoints. Within a set of covertical left endpoints, weput those with lower y-coordinates \ufb01rst, and we do the same within a set of cover-\ntical right endpoints.) When we encounter a segment\u2019s left endpoint, we insert thesegment into the sweep-line status, and we delete the segment from the sweep-line\nstatus upon encountering its right endpoint. Whenever two segments \ufb01rst become\nconsecutive in the total preorder, we check whether they intersect.\nThe sweep-line status is a total preorder T, for which we require the following\noperations:\n/SIINSERT .T; s/ : insert segment sintoT.\n/SIDELETE .T; s/ : delete segment sfrom T.\n/SIABOVE .T; s/ : return the segment immediately above segment sinT.\n/SIBELOW .T; s/ : return the segment immediately below segment sinT.\nIt is possible for segments s1ands2to be mutually above each other in the total\npreorder T; this situation can occur if s1ands2intersect at the sweep line whose\ntotal preorder is given by T. In this case, the two segments may appear in either\norder in T.\nIf the input contains nsegments, we can perform each of the operations I NSERT ,\nDELETE ,ABOVE ,a n dB ELOW inO.lgn/time using red-black trees. Recall that\nthe red-black-tree operations in Chapter 13 involve comparing keys. We can re-place the key comparisons by comparisons that use cross products to determine therelative ordering of two segments (see Exercise 33.2-2).\nSegment-intersection pseudocode\nThe following algorithm takes as input a set Sofnline segments, returning the\nboolean value\nTRUE if any pair of segments in Sintersects, and FALSE otherwise.\nA red-black tree maintains the total preorder T.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "1045": {"page_number": 1046, "page_information": "33.2 Determining whether any pair of segments intersects 1025\nANY-SEGMENTS -INTERSECT .S/\n1TD;\n2 sort the endpoints of the segments in Sfrom left to right,\nbreaking ties by putting left endpoints before right endpointsand breaking further ties by putting points with lowery-coordinates \ufb01rst\n3foreach point pin the sorted list of endpoints\n4 ifpis the left endpoint of a segment s\n5I\nNSERT .T; s/\n6 if(ABOVE .T; s/ exists and intersects s)\nor (B ELOW .T; s/ exists and intersects s)\n7 return TRUE\n8 ifpis the right endpoint of a segment s\n9 ifboth A BOVE .T; s/ and B ELOW .T; s/ exist\nand A BOVE .T; s/ intersects B ELOW .T; s/\n10 return TRUE\n11 D ELETE .T; s/\n12return FALSE\nFigure 33.5 illustrates how the algorithm works. Line 1 initializes the total preorder\nto be empty. Line 2 determines the event-point schedule by sorting the 2nsegment\nendpoints from left to right, breaking ties as described above. One way to perform\nline 2 is by lexicographically sorting the endpoints on . x;e;y/ ,w h e r e xandyare\nthe usual coordinates, eD0for a left endpoint, and eD1for a right endpoint.\nEach iteration of the forloop of lines 3\u201311 processes one event point p.I fpis\nthe left endpoint of a segment s, line 5 adds sto the total preorder, and lines 6\u20137\nreturn TRUE ifsintersects either of the segments it is consecutive with in the total\npreorder de\ufb01ned by the sweep line passing through p. (A boundary condition\noccurs if plies on another segment s0. In this case, we require only that sands0\nbe placed consecutively into T.) If pis the right endpoint of a segment s,t h e n\nwe need to delete sfrom the total preorder. But \ufb01rst, lines 9\u201310 return TRUE if\nthere is an intersection between the segments surrounding sin the total preorder\nde\ufb01ned by the sweep line passing through p. If these segments do not intersect,\nline 11 deletes segment sfrom the total preorder. If the segments surrounding\nsegment sintersect, they would have become consecutive after deleting shad the\nreturn statement in line 10 not prevented line 11 from executing. The correctness\nargument, which follows, will make it clear why it suf\ufb01ces to check the segmentssurrounding s. Finally, if we never \ufb01nd any intersections after having processed\nall2nevent points, line 12 returns\nFALSE .", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "1046": {"page_number": 1047, "page_information": "1026 Chapter 33 Computational Geometry\naa\nba\nc\nbd\na\nc\nbd\nc\nbe\nd\nc\nba\nbcde\nf\ntime\nFigure 33.5 The execution of A NY-SEGMENTS -INTERSECT . Each dashed line is the sweep line at\nan event point. Except for the rightmost sweep line, the ordering of segment names below each sweep\nline corresponds to the total preorder Tat the end of the forloop processing the corresponding event\npoint. The rightmost sweep line occurs when processing the right endpoint of segment c; because\nsegments dandbsurround cand intersect each other, the procedure returns TRUE .\nCorrectness\nTo show that A NY-SEGMENTS -INTERSECT is correct, we will prove that the call\nANY-SEGMENTS -INTERSECT .S/returns TRUE if and only if there is an intersec-\ntion among the segments in S.\nIt is easy to see that A NY-SEGMENTS -INTERSECT returns TRUE (on lines 7\nand 10) only if it \ufb01nds an intersection between two of the input segments. Hence,if it returns\nTRUE , there is an intersection.\nWe also need to show the converse: that if there is an intersection, then A NY-\nSEGMENTS -INTERSECT returns TRUE . Let us suppose that there is at least one\nintersection. Let pbe the leftmost intersection point, breaking ties by choosing the\npoint with the lowest y-coordinate, and let aandbbe the segments that intersect\natp. Since no intersections occur to the left of p, the order given by Tis correct at\nall points to the left of p. Because no three segments intersect at the same point, a\nandbbecome consecutive in the total preorder at some sweep line \u00b4.2Moreover,\n\u00b4is to the left of por goes through p. Some segment endpoint qon sweep line \u00b4\n2If we allow three segments to intersect at the same point, there may be an intervening segment cthat\nintersects both aandbat point p.T h a ti s ,w em a yh a v e a<wcandc<wbfor all sweep lines wto\nthe left of pfor which a<wb. Exercise 33.2-8 asks you to show that A NY-SEGMENTS -INTERSECT\nis correct even if three segments do intersect at the same point.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "1047": {"page_number": 1048, "page_information": "33.2 Determining whether any pair of segments intersects 1027\nis the event point at which aandbbecome consecutive in the total preorder. If p\nis on sweep line \u00b4,t h e n qDp.I fpis not on sweep line \u00b4,t h e n qis to the left\nofp. In either case, the order given by Tis correct just before encountering q.\n(Here is where we use the lexicographic order in which the algorithm processesevent points. Because pis the lowest of the leftmost intersection points, even if p\nis on sweep line \u00b4and some other intersection point p\n0is on \u00b4, event point qDp\nis processed before the other intersection p0can interfere with the total preorder T.\nMoreover, even if pis the left endpoint of one segment, say a, and the right end-\npoint of the other segment, say b, because left endpoint events occur before right\nendpoint events, segment bis inTupon \ufb01rst encountering segment a.) Either event\npoint qis processed by A NY-SEGMENTS -INTERSECT or it is not processed.\nIfqis processed by A NY-SEGMENTS -INTERSECT , only two possible actions\nmay occur:\n1. Either aorbis inserted into T, and the other segment is above or below it in\nthe total preorder. Lines 4\u20137 detect this case.\n2. Segments aandbare already in T, and a segment between them in the total\npreorder is deleted, making aandbbecome consecutive. Lines 8\u201311 detect this\ncase.\nIn either case, we \ufb01nd the intersection pand A NY-SEGMENTS -INTERSECT returns\nTRUE .\nIf event point qis not processed by A NY-SEGMENTS -INTERSECT , the proce-\ndure must have returned before processing all event points. This situation could\nhave occurred only if A NY-SEGMENTS -INTERSECT had already found an inter-\nsection and returned TRUE .\nThus, if there is an intersection, A NY-SEGMENTS -INTERSECT returns TRUE .\nAs we have already seen, if A NY-SEGMENTS -INTERSECT returns TRUE , there is\nan intersection. Therefore, A NY-SEGMENTS -INTERSECT always returns a correct\nanswer.\nRunning time\nIf set Scontains nsegments, then A NY-SEGMENTS -INTERSECT runs in time\nO.n lgn/. Line 1 takes O.1/ time. Line 2 takes O.n lgn/time, using merge\nsort or heapsort. The forloop of lines 3\u201311 iterates at most once per event point,\na n ds ow i t h 2nevent points, the loop iterates at most 2ntimes. Each iteration takes\nO.lgn/time, since each red-black-tree operation takes O.lgn/time and, using the\nmethod of Section 33.1, each intersection test takes O.1/ time. The total time is\nthusO.n lgn/.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "1048": {"page_number": 1049, "page_information": "1028 Chapter 33 Computational Geometry\nExercises\n33.2-1\nShow that a set of nline segments may contain \u201a.n2/intersections.\n33.2-2\nGiven two segments aandbthat are comparable at x, show how to determine\ninO.1/ time which of a<xborb<xaholds. Assume that neither segment\nis vertical. ( Hint: Ifaandbdo not intersect, you can just use cross products.\nIfaandbintersect\u2014which you can of course determine using only cross prod-\nucts\u2014you can still use only addition, subtraction, and multiplication, avoidingdivision. Of course, in the application of the <\nxrelation used here, if aandb\nintersect, we can just stop and declare that we have found an intersection.)\n33.2-3\nProfessor Mason suggests that we modify A NY-SEGMENTS -INTERSECT so that\ninstead of returning upon \ufb01nding an intersection, it prints the segments that inter-sect and continues on to the next iteration of the forloop. The professor calls the\nresulting procedure P\nRINT -INTERSECTING -SEGMENTS and claims that it prints\nall intersections, from left to right, as they occur in the set of line segments. Pro-fessor Dixon disagrees, claiming that Professor Mason\u2019s idea is incorrect. Whichprofessor is right? Will P\nRINT -INTERSECTING -SEGMENTS always \ufb01nd the left-\nmost intersection \ufb01rst? Will it always \ufb01nd all the intersections?\n33.2-4\nGive an O.n lgn/-time algorithm to determine whether an n-vertex polygon is\nsimple.\n33.2-5\nGive an O.n lgn/-time algorithm to determine whether two simple polygons with\na total of nvertices intersect.\n33.2-6\nAdisk consists of a circle plus its interior and is represented by its center point and\nradius. Two disks intersect if they have any point in common. Give an O.n lgn/-\ntime algorithm to determine whether any two disks in a set of nintersect.\n33.2-7\nGiven a set of nline segments containing a total of kintersections, show how to\noutput all kintersections in O..nCk/lgn/time.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "1049": {"page_number": 1050, "page_information": "33.3 Finding the convex hull 1029\n33.2-8\nArgue that A NY-SEGMENTS -INTERSECT works correctly even if three or more\nsegments intersect at the same point.\n33.2-9\nShow that A NY-SEGMENTS -INTERSECT works correctly in the presence of verti-\ncal segments if we treat the bottom endpoint of a vertical segment as if it were aleft endpoint and the top endpoint as if it were a right endpoint. How does youranswer to Exercise 33.2-2 change if we allow vertical segments?\n33.3 Finding the convex hull\nTheconvex hull of a set Qof points, denoted by CH .Q/, is the smallest convex\npolygon Pfor which each point in Qis either on the boundary of Por in its\ninterior. (See Exercise 33.1-5 for a precise de\ufb01nition of a convex polygon.) Weimplicitly assume that all points in the set Qare unique and that Qcontains at\nleast three points which are not colinear. Intuitively, we can think of each point\ninQas being a nail sticking out from a board. The convex hull is then the shape\nformed by a tight rubber band that surrounds all the nails. Figure 33.6 shows a setof points and its convex hull.\nIn this section, we shall present two algorithms that compute the convex hull\nof a set of npoints. Both algorithms output the vertices of the convex hull in\ncounterclockwise order. The \ufb01rst, known as Graham\u2019s scan, runs in O.n lgn/time.\nThe second, called Jarvis\u2019s march, runs in O.nh/ time, where his the number of\nvertices of the convex hull. As Figure 33.6 illustrates, every vertex of CH .Q/ is a\np0p1p2p3p4p5p6 p7\np8p9p10\np11\np12\nFigure 33.6 A set of points QDfp0;p1;:::;p 12gwith its convex hull CH .Q/ in gray.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "1050": {"page_number": 1051, "page_information": "1030 Chapter 33 Computational Geometry\npoint in Q. Both algorithms exploit this property, deciding which vertices in Qto\nkeep as vertices of the convex hull and which vertices in Qto reject.\nWe can compute convex hulls in O.n lgn/time by any one of several methods.\nBoth Graham\u2019s scan and Jarvis\u2019s march use a technique called \u201crotational sweep,\u201dprocessing vertices in the order of the polar angles they form with a referencevertex. Other methods include the following:\n/SIIn the incremental method , we \ufb01rst sort the points from left to right, yielding a\nsequencehp1;p2;:::;p ni.A t t h e ith stage, we update the convex hull of the\ni/NUL1leftmost points, CH .fp1;p2;:::;p i/NUL1g/, according to the ith point from\nthe left, thus forming CH .fp1;p2;:::;p ig/. Exercise 33.3-6 asks you how to\nimplement this method to take a total of O.n lgn/time.\n/SIIn the divide-and-conquer method , we divide the set of npoints in \u201a.n/ time\ninto two subsets, one containing the leftmost dn=2epoints and one containing\nthe rightmostbn=2cpoints, recursively compute the convex hulls of the subsets,\nand then, by means of a clever method, combine the hulls in O.n/ time. The\nrunning time is described by the familiar recurrence T .n/D2T .n=2/CO.n/ ,\nand so the divide-and-conquer method runs in O.n lgn/time.\n/SITheprune-and-search method is similar to the worst-case linear-time median\nalgorithm of Section 9.3. With this method, we \ufb01nd the upper portion (or \u201cupper\nchain\u201d) of the convex hull by repeatedly throwing out a constant fraction of the\nremaining points until only the upper chain of the convex hull remains. We thendo the same for the lower chain. This method is asymptotically the fastest: ifthe convex hull contains hvertices, it runs in only O.n lgh/time.\nComputing the convex hull of a set of points is an interesting problem in its own\nright. Moreover, algorithms for some other computational-geometry problems startby computing a convex hull. Consider, for example, the two-dimensional farthest-\npair problem : we are given a set of npoints in the plane and wish to \ufb01nd the\ntwo points whose distance from each other is maximum. As Exercise 33.3-3 asksyou to prove, these two points must be vertices of the convex hull. Although wewon\u2019t prove it here, we can \ufb01nd the farthest pair of vertices of an n-vertex convex\npolygon in O.n/ time. Thus, by computing the convex hull of the ninput points\ninO.n lgn/time and then \ufb01nding the farthest pair of the resulting convex-polygon\nvertices, we can \ufb01nd the farthest pair of points in any set of npoints in O.n lgn/\ntime.\nGraham\u2019s scan\nGraham\u2019s scan solves the convex-hull problem by maintaining a stack Sof can-\ndidate points. It pushes each point of the input set Qonto the stack one time,", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "1051": {"page_number": 1052, "page_information": "33.3 Finding the convex hull 1031\nand it eventually pops from the stack each point that is not a vertex of CH .Q/.\nWhen the algorithm terminates, stack Scontains exactly the vertices of CH .Q/,i n\ncounterclockwise order of their appearance on the boundary.\nThe procedure G RAHAM -SCAN takes as input a set Qof points, wherejQj/NAK3.\nIt calls the functions T OP.S/, which returns the point on top of stack Swithout\nchanging S,a n dN EXT-TO-TOP.S/, which returns the point one entry below the\ntop of stack Swithout changing S. As we shall prove in a moment, the stack S\nreturned by G RAHAM -SCAN contains, from bottom to top, exactly the vertices\nof CH .Q/ in counterclockwise order.\nGRAHAM -SCAN.Q/\n1l e t p0be the point in Qwith the minimum y-coordinate,\nor the leftmost such point in case of a tie\n2l e thp1;p2;:::;p mibe the remaining points in Q,\nsorted by polar angle in counterclockwise order around p0\n(if more than one point has the same angle, remove all but\nthe one that is farthest from p0)\n3l e t Sbe an empty stack\n4P USH.p0;S/\n5P USH.p1;S/\n6P USH.p2;S/\n7foriD3tom\n8 while the angle formed by points N EXT-TO-TOP.S/,TOP.S/,\nandpimakes a nonleft turn\n9P OP.S/\n10 P USH.pi;S/\n11return S\nFigure 33.7 illustrates the progress of G RAHAM -SCAN. Line 1 chooses point p0\nas the point with the lowest y-coordinate, picking the leftmost such point in case\nof a tie. Since there is no point in Qthat is below p0and any other points with\nthe same y-coordinate are to its right, p0m u s tb eav e r t e xo fC H .Q/.L i n e 2\nsorts the remaining points of Qby polar angle relative to p0, using the same\nmethod\u2014comparing cross products\u2014as in Exercise 33.1-3. If two or more pointshave the same polar angle relative to p\n0, all but the farthest such point are convex\ncombinations of p0and the farthest point, and so we remove them entirely from\nconsideration. We let mdenote the number of points other than p0that remain.\nThe polar angle, measured in radians, of each point in Qrelative to p0is in the\nhalf-open interval \u01520; /EM/ . Since the points are sorted according to polar angles,\nthey are sorted in counterclockwise order relative to p0. We designate this sorted\nsequence of points by hp1;p2;:::;p mi. Note that points p1andpmare vertices", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "1052": {"page_number": 1053, "page_information": "1032 Chapter 33 Computational Geometry\np12p11p10\np9\np8p7p6\np5\np4 p3\np2\np1\np0 (a)p12p11p10\np9\np8p7p6\np5\np4 p3\np2\np1\np0 (b)\np12p11p10\np9\np8p7p6\np5\np4p3\np2\np1\np0 (c)p12p11p10\np9\np8p7p6\np5\np4p3\np2\np1\np0 (d)\np12p11p10\np9\np8p7p6\np5\np4 p3\np2\np1\np0 (e)p12p11p10\np9\np8p7p6\np5\np4 p3\np2\np1\np0 (f)\nFigure 33.7 The execution of G RAHAM -SCAN on the set Qof Figure 33.6. The current convex\nhull contained in stack Sis shown in gray at each step. (a)The sequencehp1;p2;:::;p 12iof points\nnumbered in order of increasing polar angle relative to p0, and the initial stack Scontaining p0,p1,\nandp2.(b)\u2013(k) Stack Safter each iteration of the forloop of lines 7\u201310. Dashed lines show nonleft\nturns, which cause points to be popped from the stack. In part (h), for example, the right turn at\nangle\u2020p7p8p9causes p8to be popped, and then the right turn at angle \u2020p6p7p9causes p7to be\npopped.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "1053": {"page_number": 1054, "page_information": "33.3 Finding the convex hull 1033\np12p11p10\np9\np8p7p6\np5\np4 p3\np2\np1\np0 (g)p12p11p10\np9\np8p6\np5\np4 p3\np2\np1\np0 (h)\np12p11p10\np9\np8p7p6 p5\np3\np2\np1\np0 (i)p12p11p10\np9\np8p7p6\np3\np2\np1\np0 (j)\np12p11p10\np9\np8p7p6\np5\np4 p3\np2\np1\np0 (k)p12p11p10\np9\np8p7p6\np5\np4 p3\np2\np1\np0 (l)p4 p4p5p7\nFigure 33.7, continued (l) The convex hull returned by the procedure, which matches that of\nFigure 33.6.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "1054": {"page_number": 1055, "page_information": "1034 Chapter 33 Computational Geometry\nof CH .Q/ (see Exercise 33.3-1). Figure 33.7(a) shows the points of Figure 33.6\nsequentially numbered in order of increasing polar angle relative to p0.\nThe remainder of the procedure uses the stack S. Lines 3\u20136 initialize the stack\nto contain, from bottom to top, the \ufb01rst three points p0,p1,a n d p2. Figure 33.7(a)\nshows the initial stack S.T h e forloop of lines 7\u201310 iterates once for each point\nin the subsequence hp3;p4;:::;p mi. We shall see that after processing point pi,\nstack Scontains, from bottom to top, the vertices of CH .fp0;p1;:::;p ig/in coun-\nterclockwise order. The while loop of lines 8\u20139 removes points from the stack if\nwe \ufb01nd them not to be vertices of the convex hull. When we traverse the convex\nhull counterclockwise, we should make a left turn at each vertex. Thus, each timethewhile loop \ufb01nds a vertex at which we make a nonleft turn, we pop the vertex\nfrom the stack. (By checking for a nonleft turn, rather than just a right turn, thistest precludes the possibility of a straight angle at a vertex of the resulting convexhull. We want no straight angles, since no vertex of a convex polygon may be aconvex combination of other vertices of the polygon.) After we pop all verticesthat have nonleft turns when heading toward point p\ni, we push pionto the stack.\nFigures 33.7(b)\u2013(k) show the state of the stack Safter each iteration of the for\nloop. Finally, G RAHAM -SCAN returns the stack Sin line 11. Figure 33.7(l) shows\nthe corresponding convex hull.\nThe following theorem formally proves the correctness of G RAHAM -SCAN.\nTheorem 33.1 (Correctness of Graham\u2019s scan)\nIf G RAHAM -SCAN executes on a set Qof points, wherejQj/NAK3, then at termina-\ntion, the stack Sconsists of, from bottom to top, exactly the vertices of CH .Q/ in\ncounterclockwise order.\nProof After line 2, we have the sequence of points hp1;p2;:::;p mi.L e t u s\nde\ufb01ne, for iD2;3 ;:::;m , the subset of points QiDfp0;p1;:::;p ig.T h e\npoints in Q/NULQmare those that were removed because they had the same polar\nangle relative to p0as some point in Qm; these points are not in CH .Q/,a n d\nso CH .Qm/DCH.Q/. Thus, it suf\ufb01ces to show that when G RAHAM -SCAN\nterminates, the stack Sconsists of the vertices of CH .Qm/in counterclockwise\norder, when listed from bottom to top. Note that just as p0,p1,a n d pmare vertices\nof CH .Q/, the points p0,p1,a n d piare all vertices of CH .Qi/.\nThe proof uses the following loop invariant:\nAt the start of each iteration of the forloop of lines 7\u201310, stack Sconsists of,\nfrom bottom to top, exactly the vertices of CH .Qi/NUL1/in counterclockwise\norder.\nInitialization: The invariant holds the \ufb01rst time we execute line 7, since at that\ntime, stack Sconsists of exactly the vertices of Q2DQi/NUL1, and this set of three", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "1055": {"page_number": 1056, "page_information": "33.3 Finding the convex hull 1035\np0p1p2pkpj\npi\nQj\n(a)p0p1pj\npi\n(b)ptpr\nFigure 33.8 The proof of correctness of G RAHAM -SCAN.(a)Because pi\u2019s polar angle relative\ntop0is greater than pj\u2019s polar angle, and because the angle \u2020pkpjpimakes a left turn, adding pi\nto CH .Qj/gives exactly the vertices of CH .Qj[fpig/.(b)If the angle\u2020prptpimakes a nonleft\nturn, then ptis either in the interior of the triangle formed by p0,pr,a n d pior on a side of the\ntriangle, which means that it cannot be a vertex of CH .Qi/.\nvertices forms its own convex hull. Moreover, they appear in counterclockwise\norder from bottom to top.\nMaintenance: Entering an iteration of the forloop, the top point on stack S\nispi/NUL1, which was pushed at the end of the previous iteration (or before the\n\ufb01rst iteration, when iD3). Let pjbe the top point on Safter executing the\nwhile loop of lines 8\u20139 but before line 10 pushes pi,a n dl e t pkbe the point\njust below pjonS. At the moment that pjis the top point on Sand we have\nnot yet pushed pi, stack Scontains exactly the same points it contained after\niteration jof the forloop. By the loop invariant, therefore, Scontains exactly\nthe vertices of CH .Qj/at that moment, and they appear in counterclockwise\norder from bottom to top.\nLet us continue to focus on this moment just before pushing pi. We know\nthatpi\u2019s polar angle relative to p0is greater than pj\u2019s polar angle and that\nthe angle\u2020pkpjpimakes a left turn (otherwise we would have popped pj).\nTherefore, because Scontains exactly the vertices of CH .Qj/, we see from\nFigure 33.8(a) that once we push pi, stack Swill contain exactly the vertices\nof CH .Qj[fpig/, still in counterclockwise order from bottom to top.\nWe now show that CH .Qj[fpig/is the same set of points as CH .Qi/. Consider\nany point ptthat was popped during iteration iof the forloop, and let prbe\nthe point just below pton stack Sat the time ptwas popped ( prmight be pj).\nThe angle\u2020prptpimakes a nonleft turn, and the polar angle of ptrelative\ntop0is greater than the polar angle of pr. As Figure 33.8(b) shows, ptmust", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "1056": {"page_number": 1057, "page_information": "1036 Chapter 33 Computational Geometry\nbe either in the interior of the triangle formed by p0,pr,a n d pior on a side of\nthis triangle (but it is not a vertex of the triangle). Clearly, since ptis within a\ntriangle formed by three other points of Qi, it cannot be a vertex of CH .Qi/.\nSince ptis not a vertex of CH .Qi/,w eh a v et h a t\nCH.Qi/NULfptg/DCH.Qi/: (33.1)\nLetPibe the set of points that were popped during iteration iof the forloop.\nSince the equality (33.1) applies for all points in Pi, we can apply it repeatedly\nto show that CH .Qi/NULPi/DCH.Qi/.B u t Qi/NULPiDQj[fpig,a n ds ow e\nconclude that CH .Qj[fpig/DCH.Qi/NULPi/DCH.Qi/.\nWe have shown that once we push pi, stack Scontains exactly the vertices\nof CH .Qi/in counterclockwise order from bottom to top. Incrementing iwill\nthen cause the loop invariant to hold for the next iteration.\nTermination: When the loop terminates, we have iDmC1, and so the loop\ninvariant implies that stack Sconsists of exactly the vertices of CH .Qm/,w h i c h\nis CH .Q/, in counterclockwise order from bottom to top. This completes the\nproof.\nWe now show that the running time of G RAHAM -SCAN isO.n lgn/,w h e r e\nnDjQj. Line 1 takes \u201a.n/ time. Line 2 takes O.n lgn/time, using merge sort\nor heapsort to sort the polar angles and the cross-product method of Section 33.1to compare angles. (We can remove all but the farthest point with the same polarangle in total of O.n/ time over all npoints.) Lines 3\u20136 take O.1/ time. Because\nm/DC4n/NUL1,t h eforloop of lines 7\u201310 executes at most n/NUL3times. Since P\nUSH\ntakes O.1/ time, each iteration takes O.1/ time exclusive of the time spent in the\nwhile loop of lines 8\u20139, and thus overall the forloop takes O.n/ time exclusive of\nthe nested while loop.\nWe use aggregate analysis to show that the while loop takes O.n/ time overall.\nForiD0; 1; : : : ; m , we push each point pionto stack Sexactly once. As in the\nanalysis of the M ULTIPOP procedure of Section 17.1, we observe that we can pop at\nmost the number of items that we push. At least three points\u2014 p0,p1,a n d pm\u2014are\nnever popped from the stack, so that in fact at most m/NUL2POPoperations are\nperformed in total. Each iteration of the while loop performs one P OP,a n ds o\nthere are at most m/NUL2iterations of the while loop altogether. Since the test in\nline 8 takes O.1/ time, each call of P OPtakes O.1/ time, and m/DC4n/NUL1, the total\ntime taken by the while loop is O.n/ . Thus, the running time of G RAHAM -SCAN\nisO.n lgn/.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "1057": {"page_number": 1058, "page_information": "33.3 Finding the convex hull 1037\np4 p2\np0p1right chain left chain\nright chain left chainp3\nFigure 33.9 The operation of Jarvis\u2019s march. We choose the \ufb01rst vertex as the lowest point p0.\nThe next vertex, p1, has the smallest polar angle of any point with respect to p0. Then, p2has the\nsmallest polar angle with respect to p1. The right chain goes as high as the highest point p3. Then,\nwe construct the left chain by \ufb01nding smallest polar angles with respect to the negative x-axis.\nJarvis\u2019s march\nJarvis\u2019s march computes the convex hull of a set Qof points by a technique known\naspackage wrapping (orgift wrapping ). The algorithm runs in time O.nh/ ,\nwhere his the number of vertices of CH .Q/.W h e n hiso.lgn/, Jarvis\u2019s march is\nasymptotically faster than Graham\u2019s scan.\nIntuitively, Jarvis\u2019s march simulates wrapping a taut piece of paper around the\nsetQ. We start by taping the end of the paper to the lowest point in the set, that is,\nto the same point p0with which we start Graham\u2019s scan. We know that this point\nmust be a vertex of the convex hull. We pull the paper to the right to make it taut,and then we pull it higher until it touches a point. This point must also be a vertexof the convex hull. Keeping the paper taut, we continue in this way around the setof vertices until we come back to our original point p\n0.\nMore formally, Jarvis\u2019s march builds a sequence HDhp0;p1;:::;p h/NUL1iof the\nvertices of CH .Q/. We start with p0. As Figure 33.9 shows, the next vertex p1\nin the convex hull has the smallest polar angle with respect to p0. (In case of ties,\nwe choose the point farthest from p0.) Similarly, p2has the smallest polar angle", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "1058": {"page_number": 1059, "page_information": "1038 Chapter 33 Computational Geometry\nwith respect to p1, and so on. When we reach the highest vertex, say pk(breaking\nties by choosing the farthest such vertex), we have constructed, as Figure 33.9shows, the right chain of CH .Q/. To construct the left chain , we start at p\nkand\nchoose pkC1as the point with the smallest polar angle with respect to pk,b u t from\nthe negative x-axis . We continue on, forming the left chain by taking polar angles\nfrom the negative x-axis, until we come back to our original vertex p0.\nWe could implement Jarvis\u2019s march in one conceptual sweep around the convex\nhull, that is, without separately constructing the right and left chains. Such imple-\nmentations typically keep track of the angle of the last convex-hull side chosen and\nrequire the sequence of angles of hull sides to be strictly increasing (in the rangeof0to2/EMradians). The advantage of constructing separate chains is that we need\nnot explicitly compute angles; the techniques of Section 33.1 suf\ufb01ce to compareangles.\nIf implemented properly, Jarvis\u2019s march has a running time of O.nh/ . For each\nof the hvertices of CH .Q/, we \ufb01nd the vertex with the minimum polar angle. Each\ncomparison between polar angles takes O.1/ time, using the techniques of Sec-\ntion 33.1. As Section 9.1 shows, we can compute the minimum of nvalues in O.n/\ntime if each comparison takes O.1/ time. Thus, Jarvis\u2019s march takes O.nh/ time.\nExercises\n33.3-1\nProve that in the procedure G\nRAHAM -SCAN, points p1andpmmust be vertices\nof CH .Q/.\n33.3-2\nConsider a model of computation that supports addition, comparison, and multipli-cation and for which there is a lower bound of /DEL.n lgn/to sort nnumbers. Prove\nthat/DEL.n lgn/is a lower bound for computing, in order, the vertices of the convex\nhull of a set of npoints in such a model.\n33.3-3\nGiven a set of points Q, prove that the pair of points farthest from each other must\nbe vertices of CH .Q/.\n33.3-4\nFor a given polygon Pand a point qon its boundary, the shadow ofqis the set\nof points rsuch that the segment\nqris entirely on the boundary or in the interior\nofP. As Figure 33.10 illustrates, a polygon Pisstar-shaped if there exists a\npoint pin the interior of Pthat is in the shadow of every point on the boundary\nofP. The set of all such points pis called the kernel ofP. Given an n-vertex,", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "1059": {"page_number": 1060, "page_information": "33.4 Finding the closest pair of points 1039\np\n(a) (b)qq\u2032\nFigure 33.10 The de\ufb01nition of a star-shaped polygon, for use in Exercise 33.3-4. (a)A star-shaped\npolygon. The segment from point pto any point qon the boundary intersects the boundary only at q.\n(b)A non-star-shaped polygon. The shaded region on the left is the shadow of q, and the shaded\nregion on the right is the shadow of q0. Since these regions are disjoint, the kernel is empty.\nstar-shaped polygon Pspeci\ufb01ed by its vertices in counterclockwise order, show\nhow to compute CH .P /inO.n/ time.\n33.3-5\nIn the on-line convex-hull problem , we are given the set Qofnpoints one point at\na time. After receiving each point, we compute the convex hull of the points seenso far. Obviously, we could run Graham\u2019s scan once for each point, with a totalrunning time of O.n\n2lgn/. Show how to solve the on-line convex-hull problem in\na total of O.n2/time.\n33.3-6 ?\nShow how to implement the incremental method for computing the convex hullofnpoints so that it runs in O.n lgn/time.\n33.4 Finding the closest pair of points\nWe now consider the problem of \ufb01nding the closest pair of points in a set Qof\nn/NAK2points. \u201cClosest\u201d refers to the usual euclidean distance: the distance between\npoints p1D.x1;y1/andp2D.x2;y2/isp\n.x1/NULx2/2C.y1/NULy2/2. Two points\nin set Qmay be coincident, in which case the distance between them is zero. This\nproblem has applications in, for example, traf\ufb01c-control systems. A system for\ncontrolling air or sea traf\ufb01c might need to identify the two closest vehicles in order\nto detect potential collisions.\nA brute-force closest-pair algorithm simply looks at all the/NULn\n2/SOH\nD\u201a.n2/pairs\nof points. In this section, we shall describe a divide-and-conquer algorithm for", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "1060": {"page_number": 1061, "page_information": "1040 Chapter 33 Computational Geometry\nthis problem, whose running time is described by the familiar recurrence T .n/D\n2T .n=2/CO.n/ . Thus, this algorithm uses only O.n lgn/time.\nThe divide-and-conquer algorithm\nEach recursive invocation of the algorithm takes as input a subset P/DC2Qand\narrays XandY, each of which contains all the points of the input subset P.\nThe points in array Xare sorted so that their x-coordinates are monotonically\nincreasing. Similarly, array Yis sorted by monotonically increasing y-coordinate.\nNote that in order to attain the O.n lgn/time bound, we cannot afford to sort\nin each recursive call; if we did, the recurrence for the running time would beT .n/D2T .n=2/CO.n lgn/, whose solution is T .n/DO.n lg\n2n/.( U s e t h e\nversion of the master method given in Exercise 4.6-2.) We shall see a little later\nhow to use \u201cpresorting\u201d to maintain this sorted property without actually sorting in\neach recursive call.\nA given recursive invocation with inputs P,X,a n d Y\ufb01rst checks whether\njPj/DC43. If so, the invocation simply performs the brute-force method described\nabove: try all/NULjPj\n2/SOH\npairs of points and return the closest pair. If jPj>3,t h e\nrecursive invocation carries out the divide-and-conquer paradigm as follows.\nDivide: Find a vertical line lthat bisects the point set Pinto two sets PLandPR\nsuch thatjPLjDdjPj=2e,jPRjDbjPj=2c, all points in PLare on or to the\nleft of line l, and all points in PRare on or to the right of l. Divide the array X\ninto arrays XLandXR, which contain the points of PLandPRrespectively,\nsorted by monotonically increasing x-coordinate. Similarly, divide the array Y\ninto arrays YLandYR, which contain the points of PLandPRrespectively,\nsorted by monotonically increasing y-coordinate.\nConquer: Having divided PintoPLandPR, make two recursive calls, one to \ufb01nd\nthe closest pair of points in PLand the other to \ufb01nd the closest pair of points\ninPR. The inputs to the \ufb01rst call are the subset PLand arrays XLandYL;t h e\nsecond call receives the inputs PR,XR,a n d YR. Let the closest-pair distances\nreturned for PLandPRbe\u0131Land\u0131R, respectively, and let \u0131Dmin.\u0131L;\u0131R/.\nCombine: The closest pair is either the pair with distance \u0131found by one of the\nrecursive calls, or it is a pair of points with one point in PLand the other in PR.\nThe algorithm determines whether there is a pair with one point in PLand the\nother point in PRand whose distance is less than \u0131. Observe that if a pair of\npoints has distance less than \u0131, both points of the pair must be within \u0131units\nof line l. Thus, as Figure 33.11(a) shows, they both must reside in the 2\u0131-wide\nvertical strip centered at line l. To \ufb01nd such a pair, if one exists, we do the\nfollowing:", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "1061": {"page_number": 1062, "page_information": "33.4 Finding the closest pair of points 1041\n1. Create an array Y0, which is the array Ywith all points not in the 2\u0131-wide\nvertical strip removed. The array Y0is sorted by y-coordinate, just as Yis.\n2. For each point pin the array Y0, try to \ufb01nd points in Y0that are within \u0131\nunits of p. As we shall see shortly, only the 7points in Y0that follow pneed\nbe considered. Compute the distance from pto each of these 7points, and\nkeep track of the closest-pair distance \u01310found over all pairs of points in Y0.\n3. If\u01310<\u0131, then the vertical strip does indeed contain a closer pair than the\nrecursive calls found. Return this pair and its distance \u01310. Otherwise, return\nthe closest pair and its distance \u0131found by the recursive calls.\nThe above description omits some implementation details that are necessary to\nachieve the O.n lgn/running time. After proving the correctness of the algorithm,\nwe shall show how to implement the algorithm to achieve the desired time bound.\nCorrectness\nThe correctness of this closest-pair algorithm is obvious, except for two aspects.\nFirst, by bottoming out the recursion when jPj/DC43, we ensure that we never try to\nsolve a subproblem consisting of only one point. The second aspect is that we need\nonly check the 7points following each point pin array Y0; we shall now prove this\nproperty.\nSuppose that at some level of the recursion, the closest pair of points is pL2PL\nandpR2PR. Thus, the distance \u01310between pLandpRis strictly less than \u0131.\nPoint pLmust be on or to the left of line land less than \u0131units away. Similarly, pR\nis on or to the right of land less than \u0131units away. Moreover, pLandpRare\nwithin \u0131units of each other vertically. Thus, as Figure 33.11(a) shows, pLandpR\nare within a \u0131/STX2\u0131rectangle centered at line l. (There may be other points within\nthis rectangle as well.)\nWe next show that at most 8points of Pcan reside within this \u0131/STX2\u0131rectangle.\nConsider the \u0131/STX\u0131square forming the left half of this rectangle. Since all points\nwithin PLare at least \u0131units apart, at most 4points can reside within this square;\nFigure 33.11(b) shows how. Similarly, at most 4points in PRcan reside within\nthe\u0131/STX\u0131square forming the right half of the rectangle. Thus, at most 8points of P\ncan reside within the \u0131/STX2\u0131rectangle. (Note that since points on line lmay be in\neither PLorPR,t h e r em a yb eu pt o 4points on l. This limit is achieved if there are\ntwo pairs of coincident points such that each pair consists of one point from PLand\none point from PR, one pair is at the intersection of land the top of the rectangle,\nand the other pair is where lintersects the bottom of the rectangle.)\nHaving shown that at most 8points of Pcan reside within the rectangle, we\ncan easily see why we need to check only the 7points following each point in the\narray Y0. Still assuming that the closest pair is pLandpR, let us assume without", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "1062": {"page_number": 1063, "page_information": "1042 Chapter 33 Computational Geometry\nlpLpRPLPR\n\u03b42\u03b4\n(a)PR\nPL\n(b)lcoincident points,\n  one in PL,\n  one in PR\ncoincident points,\n  one in PL,\n  one in PR\u03b4 \u03b4\n\u03b4\nFigure 33.11 Key concepts in the proof that the closest-pair algorithm needs to check only 7points\nfollowing each point in the array Y0.(a)IfpL2PLandpR2PRare less than \u0131units apart, they\nmust reside within a \u0131/STX2\u0131rectangle centered at line l.(b)How 4points that are pairwise at least \u0131\nunits apart can all reside within a \u0131/STX\u0131square. On the left are 4points in PL, and on the right are 4\npoints in PR.T h e \u0131/STX2\u0131rectangle can contain 8points if the points shown on line lare actually\npairs of coincident points with one point in PLand one in PR.\nloss of generality that pLprecedes pRin array Y0. Then, even if pLoccurs as early\nas possible in Y0andpRoccurs as late as possible, pRis in one of the 7positions\nfollowing pL. Thus, we have shown the correctness of the closest-pair algorithm.\nImplementation and running time\nAs we have noted, our goal is to have the recurrence for the running time be T .n/D\n2T .n=2/CO.n/ ,w h e r e T .n/ is the running time for a set of npoints. The main\ndif\ufb01culty comes from ensuring that the arrays XL,XR,YL,a n d YR, which are\npassed to recursive calls, are sorted by the proper coordinate and also that thearray Y\n0is sorted by y-coordinate. (Note that if the array Xthat is received by a\nrecursive call is already sorted, then we can easily divide set PintoPLandPRin\nlinear time.)\nThe key observation is that in each call, we wish to form a sorted subset of a\nsorted array. For example, a particular invocation receives the subset Pand the\narray Y, sorted by y-coordinate. Having partitioned PintoPLandPR, it needs to\nform the arrays YLandYR, which are sorted by y-coordinate, in linear time. We\ncan view the method as the opposite of the M ERGE procedure from merge sort in", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "1063": {"page_number": 1064, "page_information": "33.4 Finding the closest pair of points 1043\nSection 2.3.1: we are splitting a sorted array into two sorted arrays. The following\npseudocode gives the idea.\n1l e t YL\u0152 1::Y: length /c141andYR\u01521 : : Y: length /c141be new arrays\n2YL:lengthDYR:lengthD0\n3foriD1toY:length\n4 ifY\u0152 i/c1412PL\n5 YL:lengthDYL:lengthC1\n6 YL\u0152YL:length /c141DY\u0152 i/c141\n7 elseYR:lengthDYR:lengthC1\n8 YR\u0152YR:length /c141DY\u0152 i/c141\nWe simply examine the points in array Yin order. If a point Y\u0152 i/c141 is in PL,w e\nappend it to the end of array YL; otherwise, we append it to the end of array YR.\nSimilar pseudocode works for forming arrays XL,XR,a n d Y0.\nThe only remaining question is how to get the points sorted in the \ufb01rst place. We\npresort them; that is, we sort them once and for all before the \ufb01rst recursive call.\nWe pass these sorted arrays into the \ufb01rst recursive call, and from there we whittlethem down through the recursive calls as necessary. Presorting adds an additionalO.n lgn/term to the running time, but now each step of the recursion takes linear\ntime exclusive of the recursive calls. Thus, if we let T .n/ be the running time of\neach recursive step and T\n0.n/be the running time of the entire algorithm, we get\nT0.n/DT .n/CO.n lgn/and\nT .n/D(\n2T .n=2/CO.n/ ifn>3;\nO.1/ ifn/DC43:\nThus, T .n/DO.n lgn/andT0.n/DO.n lgn/.\nExercises\n33.4-1\nProfessor Williams comes up with a scheme that allows the closest-pair algorithmto check only 5points following each point in array Y\n0. The idea is always to place\npoints on line linto set PL. Then, there cannot be pairs of coincident points on\nlinelwith one point in PLand one in PR. Thus, at most 6points can reside in\nthe\u0131/STX2\u0131rectangle. What is the \ufb02aw in the professor\u2019s scheme?\n33.4-2\nShow that it actually suf\ufb01ces to check only the points in the 5array positions fol-\nlowing each point in the array Y0.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "1064": {"page_number": 1065, "page_information": "1044 Chapter 33 Computational Geometry\n33.4-3\nWe can de\ufb01ne the distance between two points in ways other than euclidean. Inthe plane, the L\nm-distance between points p1andp2is given by the expres-\nsion.jx1/NULx2jmCjy1/NULy2jm/1=m. Euclidean distance, therefore, is L2-distance.\nModify the closest-pair algorithm to use the L1-distance, which is also known as\ntheManhattan distance .\n33.4-4\nGiven two points p1andp2in the plane, the L1-distance between them is\ngiven by max .jx1/NULx2j;jy1/NULy2j/. Modify the closest-pair algorithm to use the\nL1-distance.\n33.4-5\nSuppose that /DEL.n/ of the points given to the closest-pair algorithm are covertical.\nShow how to determine the sets PLandPRand how to determine whether each\npoint of Yis inPLorPRso that the running time for the closest-pair algorithm\nremains O.n lgn/.\n33.4-6\nSuggest a change to the closest-pair algorithm that avoids presorting the Yarray\nbut leaves the running time as O.n lgn/.(Hint: Merge sorted arrays YLandYRto\nform the sorted array Y.)\nProblems\n33-1 Convex layers\nGiven a set Qof points in the plane, we de\ufb01ne the convex layers ofQinductively.\nThe \ufb01rst convex layer of Qconsists of those points in Qthat are vertices of CH .Q/.\nFori>1 ,d e \ufb01 n e Qito consist of the points of Qwith all points in convex layers\n1 ;2;:::;i/NUL1removed. Then, the ith convex layer of Qis CH .Qi/ifQi\u00a4; and\nis unde\ufb01ned otherwise.\na.Give an O.n2/-time algorithm to \ufb01nd the convex layers of a set of npoints.\nb.Prove that /DEL.n lgn/time is required to compute the convex layers of a set of n\npoints with any model of computation that requires /DEL.n lgn/time to sort nreal\nnumbers.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "1065": {"page_number": 1066, "page_information": "Problems for Chapter 33 1045\n33-2 Maximal layers\nLetQbe a set of npoints in the plane. We say that point .x; y/ dominates\npoint .x0;y0/ifx/NAKx0andy/NAKy0. A point in Qthat is dominated by no other\npoints in Qis said to be maximal . Note that Qmay contain many maximal points,\nwhich can be organized into maximal layers as follows. The \ufb01rst maximal layer L1\nis the set of maximal points of Q.F o r i>1 ,t h eith maximal layer Liis the set of\nmaximal points in Q/NULSi/NUL1\njD1Lj.\nSuppose that Qhasknonempty maximal layers, and let yibe the y-coordinate\nof the leftmost point in LiforiD1 ;2;:::;k . For now, assume that no two points\ninQhave the same x-o ry-coordinate.\na.Show that y1>y 2>/SOH/SOH/SOH>y k.\nConsider a point .x; y/ that is to the left of any point in Qand for which yis\ndistinct from the y-coordinate of any point in Q.L e t Q0DQ[f.x; y/g.\nb.Letjbe the minimum index such that yj<y, unless y<y k, in which case\nwe let jDkC1. Show that the maximal layers of Q0are as follows:\n/SIIfj/DC4k, then the maximal layers of Q0are the same as the maximal layers\nofQ, except that Ljalso includes .x; y/ as its new leftmost point.\n/SIIfjDkC1, then the \ufb01rst kmaximal layers of Q0are the same as for Q,b u t\nin addition, Q0has a nonempty .kC1/st maximal layer: LkC1Df.x; y/g.\nc.Describe an O.n lgn/-time algorithm to compute the maximal layers of a set Q\nofnpoints. ( Hint: Move a sweep line from right to left.)\nd.Do any dif\ufb01culties arise if we now allow input points to have the same x-o r\ny-coordinate? Suggest a way to resolve such problems.\n33-3 Ghostbusters and ghosts\nA group of nGhostbusters is battling nghosts. Each Ghostbuster carries a proton\npack, which shoots a stream at a ghost, eradicating it. A stream goes in a straightline and terminates when it hits the ghost. The Ghostbusters decide upon the fol-lowing strategy. They will pair off with the ghosts, forming nGhostbuster-ghost\npairs, and then simultaneously each Ghostbuster will shoot a stream at his cho-\nsen ghost. As we all know, it is very dangerous to let streams cross, and so the\nGhostbusters must choose pairings for which no streams will cross.\nAssume that the position of each Ghostbuster and each ghost is a \ufb01xed point in\nthe plane and that no three positions are colinear.\na.Argue that there exists a line passing through one Ghostbuster and one ghost\nsuch that the number of Ghostbusters on one side of the line equals the number\nof ghosts on the same side. Describe how to \ufb01nd such a line in O.n lgn/time.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "1066": {"page_number": 1067, "page_information": "1046 Chapter 33 Computational Geometry\nb.Give an O.n2lgn/-time algorithm to pair Ghostbusters with ghosts in such a\nway that no streams cross.\n33-4 Picking up sticks\nProfessor Charon has a set of nsticks, which are piled up in some con\ufb01guration.\nEach stick is speci\ufb01ed by its endpoints, and each endpoint is an ordered triplegiving its . x;y;\u00b4 / coordinates. No stick is vertical. He wishes to pick up all the\nsticks, one at a time, subject to the condition that he may pick up a stick only if\nthere is no other stick on top of it.\na.Give a procedure that takes two sticks aandband reports whether ais above,\nbelow, or unrelated to b.\nb.Describe an ef\ufb01cient algorithm that determines whether it is possible to pick up\nall the sticks, and if so, provides a legal order in which to pick them up.\n33-5 Sparse-hulled distributions\nConsider the problem of computing the convex hull of a set of points in the planethat have been drawn according to some known random distribution. Sometimes,the number of points, or size, of the convex hull of npoints drawn from such a\ndistribution has expectation O.n\n1/NUL/SI/for some constant /SI>0 . We call such a\ndistribution sparse-hulled . Sparse-hulled distributions include the following:\n/SIPoints drawn uniformly from a unit-radius disk. The convex hull has expected\nsize\u201a.n1=3/.\n/SIPoints drawn uniformly from the interior of a convex polygon with ksides, for\nany constant k. The convex hull has expected size \u201a.lgn/.\n/SIPoints drawn according to a two-dimensional normal distribution. The convex\nhull has expected size \u201a.p\nlgn/.\na.Given two convex polygons with n1andn2vertices respectively, show how to\ncompute the convex hull of all n1Cn2points in O.n 1Cn2/time. (The polygons\nmay overlap.)\nb.Show how to compute the convex hull of a set of npoints drawn independently\naccording to a sparse-hulled distribution in O.n/ average-case time. ( Hint:\nRecursively \ufb01nd the convex hulls of the \ufb01rst n=2 points and the second n=2\npoints, and then combine the results.)", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "1067": {"page_number": 1068, "page_information": "Notes for Chapter 33 1047\nChapter notes\nThis chapter barely scratches the surface of computational-geometry algorithms\nand techniques. Books on computational geometry include those by Preparata andShamos [282], Edelsbrunner [99], and O\u2019Rourke [269].\nAlthough geometry has been studied since antiquity, the development of algo-\nrithms for geometric problems is relatively new. Preparata and Shamos note that\nthe earliest notion of the complexity of a problem was given by E. Lemoine in 1902.He was studying euclidean constructions\u2014those using a compass and a ruler\u2014anddevised a set of \ufb01ve primitives: placing one leg of the compass on a given point,placing one leg of the compass on a given line, drawing a circle, passing the ruler\u2019sedge through a given point, and drawing a line. Lemoine was interested in thenumber of primitives needed to effect a given construction; he called this amountthe \u201csimplicity\u201d of the construction.\nThe algorithm of Section 33.2, which determines whether any segments inter-\nsect, is due to Shamos and Hoey [313].\nThe original version of Graham\u2019s scan is given by Graham [150]. The package-\nwrapping algorithm is due to Jarvis [189]. Using a decision-tree model of com-putation, Yao [359] proved a worst-case lower bound of /DEL.n lgn/for the running\ntime of any convex-hull algorithm. When the number of vertices hof the con-\nvex hull is taken into account, the prune-and-search algorithm of Kirkpatrick and\nSeidel [206], which takes O.n lgh/time, is asymptotically optimal.\nTheO.n lgn/-time divide-and-conquer algorithm for \ufb01nding the closest pair of\npoints is by Shamos and appears in Preparata and Shamos [282]. Preparata andShamos also show that the algorithm is asymptotically optimal in a decision-treemodel.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "1068": {"page_number": 1069, "page_information": "34 NP-Completeness\nAlmost all the algorithms we have studied thus far have been polynomial-time al-\ngorithms : on inputs of size n, their worst-case running time is O.nk/for some con-\nstant k. You might wonder whether allproblems can be solved in polynomial time.\nThe answer is no. For example, there are problems, such as Turing\u2019s famous \u201cHalt-ing Problem,\u201d that cannot be solved by any computer, no matter how much time weallow. There are also problems that can be solved, but not in time O.n\nk/for any\nconstant k. Generally, we think of problems that are solvable by polynomial-time\nalgorithms as being tractable, or easy, and problems that require superpolynomial\ntime as being intractable, or hard.\nThe subject of this chapter, however, is an interesting class of problems, called\nthe \u201cNP-complete\u201d problems, whose status is unknown. No polynomial-time al-\ngorithm has yet been discovered for an NP-complete problem, nor has anyone yetbeen able to prove that no polynomial-time algorithm can exist for any one of them.This so-called P\u00a4NP question has been one of the deepest, most perplexing open\nresearch problems in theoretical computer science since it was \ufb01rst posed in 1971.\nSeveral NP-complete problems are particularly tantalizing because they seem\non the surface to be similar to problems that we know how to solve in polynomialtime. In each of the following pairs of problems, one is solvable in polynomialtime and the other is NP-complete, but the difference between problems appears tobe slight:\nShortest vs. longest simple paths: In Chapter 24, we saw that even with negative\nedge weights, we can \ufb01nd shortest paths from a single source in a directed\ngraph GD.V; E/ inO.VE/ time. Finding a longest simple path between two\nvertices is dif\ufb01cult, however. Merely determining whether a graph contains asimple path with at least a given number of edges is NP-complete.\nEuler tour vs. hamiltonian cycle: AnEuler tour of a connected, directed graph\nGD.V; E/ is a cycle that traverses each edge ofGexactly once, although\nit is allowed to visit each vertex more than once. By Problem 22-3, we candetermine whether a graph has an Euler tour in only O.E/ time and, in fact,", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "1069": {"page_number": 1070, "page_information": "Chapter 34 NP-Completeness 1049\nwe can \ufb01nd the edges of the Euler tour in O.E/ time. A hamiltonian cycle of\na directed graph GD.V; E/ is a simple cycle that contains each vertex inV.\nDetermining whether a directed graph has a hamiltonian cycle is NP-complete.(Later in this chapter, we shall prove that determining whether an undirected\ngraph has a hamiltonian cycle is NP-complete.)\n2-CNF satis\ufb01ability vs. 3-CNF satis\ufb01ability: A boolean formula contains vari-\na b l e sw h o s ev a l u e sa r e 0or1; boolean connectives such as ^(AND),_(OR),\nand:(NOT); and parentheses. A boolean formula is satis\ufb01able if there exists\nsome assignment of the values 0and1to its variables that causes it to evaluate\nto1. We shall de\ufb01ne terms more formally later in this chapter, but informally, a\nboolean formula is in k-conjunctive normal form ,o rk-CNF, if it is the AND\nof clauses of ORs of exactly kvariables or their negations. For example, the\nboolean formula .x\n1_:x2/^.:x1_x3/^.:x2_:x3/is in 2-CNF. (It has\nthe satisfying assignment x1D1; x 2D0; x 3D1.) Although we can deter-\nmine in polynomial time whether a 2-CNF formula is satis\ufb01able, we shall seelater in this chapter that determining whether a 3-CNF formula is satis\ufb01able isNP-complete.\nNP-completeness and the classes P and NP\nThroughout this chapter, we shall refer to three classes of problems: P, NP, and\nNPC, the latter class being the NP-complete problems. We describe them infor-mally here, and we shall de\ufb01ne them more formally later on.\nThe class P consists of those problems that are solvable in polynomial time.\nMore speci\ufb01cally, they are problems that can be solved in time O.n\nk/for some\nconstant k,w h e r e nis the size of the input to the problem. Most of the problems\nexamined in previous chapters are in P.\nThe class NP consists of those problems that are \u201cveri\ufb01able\u201d in polynomial time.\nWhat do we mean by a problem being veri\ufb01able? If we were somehow given a\u201ccerti\ufb01cate\u201d of a solution, then we could verify that the certi\ufb01cate is correct in timepolynomial in the size of the input to the problem. For example, in the hamiltonian-cycle problem, given a directed graph GD.V; E/ , a certi\ufb01cate would be a se-\nquenceh/ETB\n1;/ETB2;/ETB3;:::;/ETB jVjiofjVjvertices. We could easily check in polynomial\ntime that ./ETBi;/ETBiC1/2EforiD1; 2; 3; : : : ;jVj/NUL1and that ./ETBjVj;/ETB1/2Eas well.\nAs another example, for 3-CNF satis\ufb01ability, a certi\ufb01cate would be an assignmentof values to variables. We could check in polynomial time that this assignmentsatis\ufb01es the boolean formula.\nAny problem in P is also in NP, since if a problem is in P then we can solve it\nin polynomial time without even being supplied a certi\ufb01cate. We shall formalizethis notion later in this chapter, but for now we can believe that P /DC2NP. The open\nquestion is whether or not P is a proper subset of NP.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "1070": {"page_number": 1071, "page_information": "1050 Chapter 34 NP-Completeness\nInformally, a problem is in the class NPC\u2014and we refer to it as being NP-\ncomplete \u2014if it is in NP and is as \u201chard\u201d as any problem in NP. We shall formally\nde\ufb01ne what it means to be as hard as any problem in NP later in this chapter.In the meantime, we will state without proof that if anyNP-complete problem\ncan be solved in polynomial time, then every problem in NP has a polynomial-\ntime algorithm. Most theoretical computer scientists believe that the NP-completeproblems are intractable, since given the wide range of NP-complete problemsthat have been studied to date\u2014without anyone having discovered a polynomial-\ntime solution to any of them\u2014it would be truly astounding if all of them could\nbe solved in polynomial time. Yet, given the effort devoted thus far to provingthat NP-complete problems are intractable\u2014without a conclusive outcome\u2014wecannot rule out the possibility that the NP-complete problems are in fact solvablein polynomial time.\nTo become a good algorithm designer, you must understand the rudiments of the\ntheory of NP-completeness. If you can establish a problem as NP-complete, you\nprovide good evidence for its intractability. As an engineer, you would then do\nbetter to spend your time developing an approximation algorithm (see Chapter 35)\nor solving a tractable special case, rather than searching for a fast algorithm that\nsolves the problem exactly. Moreover, many natural and interesting problems thaton the surface seem no harder than sorting, graph searching, or network \ufb02ow arein fact NP-complete. Therefore, you should become familiar with this remarkableclass of problems.\nOverview of showing problems to be NP-complete\nThe techniques we use to show that a particular problem is NP-complete differ\nfundamentally from the techniques used throughout most of this book to design\nand analyze algorithms. When we demonstrate that a problem is NP-complete,\nwe are making a statement about how hard it is (or at least how hard we think itis), rather than about how easy it is. We are not trying to prove the existence ofan ef\ufb01cient algorithm, but instead that no ef\ufb01cient algorithm is likely to exist. Inthis way, NP-completeness proofs bear some similarity to the proof in Section 8.1of an /DEL.n lgn/-time lower bound for any comparison sort algorithm; the speci\ufb01c\ntechniques used for showing NP-completeness differ from the decision-tree methodused in Section 8.1, however.\nWe rely on three key concepts in showing a problem to be NP-complete:\nDecision problems vs. optimization problems\nMany problems of interest are optimization problems , in which each feasible (i.e.,\n\u201clegal\u201d) solution has an associated value, and we wish to \ufb01nd a feasible solution\nwith the best value. For example, in a problem that we call SHORTEST-PATH,", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "1071": {"page_number": 1072, "page_information": "Chapter 34 NP-Completeness 1051\nwe are given an undirected graph Gand vertices uand/ETB, and we wish to \ufb01nd a\npath from uto/ETBthat uses the fewest edges. In other words, SHORTEST-PATH\nis the single-pair shortest-path problem in an unweighted, undirected graph. NP-completeness applies directly not to optimization problems, however, but to deci-\nsion problems , in which the answer is simply \u201cyes\u201d or \u201cno\u201d (or, more formally, \u201c1\u201d\nor \u201c0\u201d).\nAlthough NP-complete problems are con\ufb01ned to the realm of decision problems,\nwe can take advantage of a convenient relationship between optimization problems\nand decision problems. We usually can cast a given optimization problem as a re-\nlated decision problem by imposing a bound on the value to be optimized. Forexample, a decision problem related to SHORTEST-PATH is PATH: given a di-rected graph G, vertices uand/ETB, and an integer k, does a path exist from uto/ETB\nconsisting of at most kedges?\nThe relationship between an optimization problem and its related decision prob-\nlem works in our favor when we try to show that the optimization problem is\n\u201chard.\u201d That is because the decision problem is in a sense \u201ceasier,\u201d or at least \u201cno\nharder.\u201d As a speci\ufb01c example, we can solve PATH by solving SHORTEST-PATH\nand then comparing the number of edges in the shortest path found to the value\nof the decision-problem parameter k. In other words, if an optimization prob-\nlem is easy, its related decision problem is easy as well. Stated in a way that hasmore relevance to NP-completeness, if we can provide evidence that a decisionproblem is hard, we also provide evidence that its related optimization problem is\nhard. Thus, even though it restricts attention to decision problems, the theory of\nNP-completeness often has implications for optimization problems as well.\nReductions\nThe above notion of showing that one problem is no harder or no easier than an-other applies even when both problems are decision problems. We take advantageof this idea in almost every NP-completeness proof, as follows. Let us consider adecision problem A, which we would like to solve in polynomial time. We call the\ninput to a particular problem an instance of that problem; for example, in PATH,\nan instance would be a particular graph G, particular vertices uand/ETBofG,a n da\nparticular integer k. Now suppose that we already know how to solve a different\ndecision problem Bin polynomial time. Finally, suppose that we have a procedure\nthat transforms any instance \u02dbofAinto some instance \u02c7ofBwith the following\ncharacteristics:\n/SIThe transformation takes polynomial time.\n/SIThe answers are the same. That is, the answer for \u02dbis \u201cyes\u201d if and only if the\nanswer for \u02c7is also \u201cyes.\u201d", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "1072": {"page_number": 1073, "page_information": "1052 Chapter 34 NP-Completeness\npolynomial-time\nreduction algorithminstance \u03b2 polynomial-time\nalgorithm to decide Byesyes\npolynomial-time algorithm to decide Ano no ofBinstance \u03b1\nofA\nFigure 34.1 How to use a polynomial-time reduction algorithm to solve a decision problem Ain\npolynomial time, given a polynomial-time decision algorithm for another problem B. In polynomial\ntime, we transform an instance \u02dbofAinto an instance \u02c7ofB,w es o l v e Bin polynomial time, and\nwe use the answer for \u02c7as the answer for \u02db.\nWe call such a procedure a polynomial-time reduction algorithm and, as Fig-\nure 34.1 shows, it provides us a way to solve problem Ain polynomial time:\n1. Given an instance \u02dbof problem A, use a polynomial-time reduction algorithm\nto transform it to an instance \u02c7of problem B.\n2. Run the polynomial-time decision algorithm for Bon the instance \u02c7.\n3. Use the answer for \u02c7as the answer for \u02db.\nAs long as each of these steps takes polynomial time, all three together do also, and\nso we have a way to decide on \u02dbin polynomial time. In other words, by \u201creducing\u201d\nsolving problem Ato solving problem B, we use the \u201ceasiness\u201d of Bto prove the\n\u201ceasiness\u201d of A.\nRecalling that NP-completeness is about showing how hard a problem is rather\nthan how easy it is, we use polynomial-time reductions in the opposite way to showthat a problem is NP-complete. Let us take the idea a step further, and show how wecould use polynomial-time reductions to show that no polynomial-time algorithmcan exist for a particular problem B. Suppose we have a decision problem Afor\nwhich we already know that no polynomial-time algorithm can exist. (Let us notconcern ourselves for now with how to \ufb01nd such a problem A.) Suppose further\nthat we have a polynomial-time reduction transforming instances of Ato instances\nofB. Now we can use a simple proof by contradiction to show that no polynomial-\ntime algorithm can exist for B. Suppose otherwise; i.e., suppose that Bhas a\npolynomial-time algorithm. Then, using the method shown in Figure 34.1, we\nwould have a way to solve problem Ain polynomial time, which contradicts our\nassumption that there is no polynomial-time algorithm for A.\nFor NP-completeness, we cannot assume that there is absolutely no polynomial-\ntime algorithm for problem A. The proof methodology is similar, however, in that\nwe prove that problem Bis NP-complete on the assumption that problem Ais also\nNP-complete.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "1073": {"page_number": 1074, "page_information": "34.1 Polynomial time 1053\nA \ufb01rst NP-complete problem\nBecause the technique of reduction relies on having a problem already known tobe NP-complete in order to prove a different problem NP-complete, we need a\u201c\ufb01rst\u201d NP-complete problem. The problem we shall use is the circuit-satis\ufb01abilityproblem, in which we are given a boolean combinational circuit composed of AND,OR, and NOT gates, and we wish to know whether there exists some set of booleaninputs to this circuit that causes its output to be 1. We shall prove that this \ufb01rst\nproblem is NP-complete in Section 34.3.\nChapter outline\nThis chapter studies the aspects of NP-completeness that bear most directly on the\nanalysis of algorithms. In Section 34.1, we formalize our notion of \u201cproblem\u201d and\nde\ufb01ne the complexity class P of polynomial-time solvable decision problems. We\nalso see how these notions \ufb01t into the framework of formal-language theory. Sec-tion 34.2 de\ufb01nes the class NP of decision problems whose solutions are veri\ufb01ablein polynomial time. It also formally poses the P \u00a4NP question.\nSection 34.3 shows we can relate problems via polynomial-time \u201creductions.\u201d\nIt de\ufb01nes NP-completeness and sketches a proof that one problem, called \u201ccircuit\nsatis\ufb01ability,\u201d is NP-complete. Having found one NP-complete problem, we show\nin Section 34.4 how to prove other problems to be NP-complete much more simply\nby the methodology of reductions. We illustrate this methodology by showing that\ntwo formula-satis\ufb01ability problems are NP-complete. With additional reductions,we show in Section 34.5 a variety of other problems to be NP-complete.\n34.1 Polynomial time\nWe begin our study of NP-completeness by formalizing our notion of polynomial-time solvable problems. We generally regard these problems as tractable, but forphilosophical, not mathematical, reasons. We can offer three supporting argu-ments.\nFirst, although we may reasonably regard a problem that requires time \u201a.n\n100/\nto be intractable, very few practical problems require time on the order of such ahigh-degree polynomial. The polynomial-time computable problems encounteredin practice typically require much less time. Experience has shown that once the\ufb01rst polynomial-time algorithm for a problem has been discovered, more ef\ufb01cientalgorithms often follow. Even if the current best algorithm for a problem has arunning time of \u201a.n\n100/, an algorithm with a much better running time will likely\nsoon be discovered.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "1074": {"page_number": 1075, "page_information": "1054 Chapter 34 NP-Completeness\nSecond, for many reasonable models of computation, a problem that can be\nsolved in polynomial time in one model can be solved in polynomial time in an-other. For example, the class of problems solvable in polynomial time by the serialrandom-access machine used throughout most of this book is the same as the classof problems solvable in polynomial time on abstract Turing machines.\n1It is also\nthe same as the class of problems solvable in polynomial time on a parallel com-puter when the number of processors grows polynomially with the input size.\nThird, the class of polynomial-time solvable problems has nice closure proper-\nties, since polynomials are closed under addition, multiplication, and composition.\nFor example, if the output of one polynomial-time algorithm is fed into the input ofanother, the composite algorithm is polynomial. Exercise 34.1-5 asks you to showthat if an algorithm makes a constant number of calls to polynomial-time subrou-tines and performs an additional amount of work that also takes polynomial time,then the running time of the composite algorithm is polynomial.\nAbstract problems\nTo understand the class of polynomial-time solvable problems, we must \ufb01rst have\na formal notion of what a \u201cproblem\u201d is. We de\ufb01ne an abstract problem Qto be a\nbinary relation on a set Iof problem instances and a set Sof problem solutions .\nFor example, an instance for SHORTEST-PATH is a triple consisting of a graph\nand two vertices. A solution is a sequence of vertices in the graph, with perhaps\nthe empty sequence denoting that no path exists. The problem SHORTEST-PATHitself is the relation that associates each instance of a graph and two vertices witha shortest path in the graph that connects the two vertices. Since shortest paths arenot necessarily unique, a given problem instance may have more than one solution.\nThis formulation of an abstract problem is more general than we need for our\npurposes. As we saw above, the theory of NP-completeness restricts attention to\ndecision problems : those having a yes/no solution. In this case, we can view an\nabstract decision problem as a function that maps the instance set Ito the solution\nsetf0; 1g. For example, a decision problem related to SHORTEST-PATH is the\nproblem PATH that we saw earlier. If iDhG;u;/ETB;kiis an instance of the decision\nproblem PATH, then PATH .i/D1(yes) if a shortest path from uto/ETBhas at\nmost kedges, and PATH .i/D0(no) otherwise. Many abstract problems are not\ndecision problems, but rather optimization problems , which require some value to\nbe minimized or maximized. As we saw above, however, we can usually recast anoptimization problem as a decision problem that is no harder.\n1See Hopcroft and Ullman [180] or Lewis and Papadimitriou [236] for a thorough treatment of the\nTuring-machine model.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "1075": {"page_number": 1076, "page_information": "34.1 Polynomial time 1055\nEncodings\nIn order for a computer program to solve an abstract problem, we must represent\nproblem instances in a way that the program understands. An encoding of a set S\nof abstract objects is a mapping efrom Sto the set of binary strings.2For example,\nwe are all familiar with encoding the natural numbers NDf0; 1; 2; 3; 4; : : :gas\nthe stringsf0; 1; 10; 11; 100; : : : g. Using this encoding, e.17/D10001 . If you\nhave looked at computer representations of keyboard characters, you probably haveseen the ASCII code, where, for example, the encoding of Ais1000001 . We can\nencode a compound object as a binary string by combining the representations ofits constituent parts. Polygons, graphs, functions, ordered pairs, programs\u2014all canbe encoded as binary strings.\nThus, a computer algorithm that \u201csolves\u201d some abstract decision problem actu-\nally takes an encoding of a problem instance as input. We call a problem whoseinstance set is the set of binary strings a concrete problem . We say that an algo-\nrithmsolves a concrete problem in time O.T .n// if, when it is provided a problem\ninstance iof length nDjij, the algorithm can produce the solution in O.T .n//\ntime.\n3A concrete problem is polynomial-time solvable , therefore, if there exists\nan algorithm to solve it in time O.nk/for some constant k.\nWe can now formally de\ufb01ne the complexity class Pas the set of concrete deci-\nsion problems that are polynomial-time solvable.\nWe can use encodings to map abstract problems to concrete problems. Given\nan abstract decision problem Qmapping an instance set Itof0; 1g, an encoding\neWI!f0; 1g/ETXcan induce a related concrete decision problem, which we denote\nbye.Q/ .4If the solution to an abstract-problem instance i2IisQ.i/2f0; 1g,\nthen the solution to the concrete-problem instance e.i/2f0; 1g/ETXis also Q.i/ .A sa\ntechnicality, some binary strings might represent no meaningful abstract-probleminstance. For convenience, we shall assume that any such string maps arbitrarilyto0. Thus, the concrete problem produces the same solutions as the abstract prob-\nlem on binary-string instances that represent the encodings of abstract-problem\ninstances.\nWe would like to extend the de\ufb01nition of polynomial-time solvability from con-\ncrete problems to abstract problems by using encodings as the bridge, but we would\n2The codomain of eneed not be binary strings; any set of strings over a \ufb01nite alphabet having at\nleast 2 symbols will do.\n3We assume that the algorithm\u2019s output is separate from its input. Because it takes at least one time\nstep to produce each bit of the output and the algorithm takes O.T.n// time steps, the size of the\noutput is O.T.n// .\n4We denote byf0; 1g/ETXthe set of all strings composed of symbols from the set f0; 1g.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "1076": {"page_number": 1077, "page_information": "1056 Chapter 34 NP-Completeness\nlike the de\ufb01nition to be independent of any particular encoding. That is, the ef-\n\ufb01ciency of solving a problem should not depend on how the problem is encoded.Unfortunately, it depends quite heavily on the encoding. For example, suppose thatan integer kis to be provided as the sole input to an algorithm, and suppose that\nthe running time of the algorithm is \u201a.k/ . If the integer kis provided in unary \u2014a\nstring of k1s\u2014then the running time of the algorithm is O.n/ on length- ninputs,\nwhich is polynomial time. If we use the more natural binary representation of theinteger k, however, then the input length is nDblgkcC1. In this case, the run-\nning time of the algorithm is \u201a.k/D\u201a.2\nn/, which is exponential in the size of the\ninput. Thus, depending on the encoding, the algorithm runs in either polynomialor superpolynomial time.\nHow we encode an abstract problem matters quite a bit to how we understand\npolynomial time. We cannot really talk about solving an abstract problem without\ufb01rst specifying an encoding. Nevertheless, in practice, if we rule out \u201cexpensive\u201dencodings such as unary ones, the actual encoding of a problem makes little dif-ference to whether the problem can be solved in polynomial time. For example,representing integers in base 3instead of binary has no effect on whether a prob-\nlem is solvable in polynomial time, since we can convert an integer represented in\nbase3to an integer represented in base 2in polynomial time.\nWe say that a function fWf0; 1g\n/ETX!f0; 1g/ETXispolynomial-time computable\nif there exists a polynomial-time algorithm Athat, given any input x2f0; 1g/ETX,\nproduces as output f. x/ . For some set Iof problem instances, we say that two en-\ncodings e1ande2arepolynomially related if there exist two polynomial-time com-\nputable functions f12andf21such that for any i2I,w eh a v e f12.e1.i//De2.i/\nandf21.e2.i//De1.i/.5That is, a polynomial-time algorithm can compute the en-\ncoding e2.i/from the encoding e1.i/, and vice versa. If two encodings e1ande2of\nan abstract problem are polynomially related, whether the problem is polynomial-time solvable or not is independent of which encoding we use, as the followinglemma shows.\nLemma 34.1\nLetQbe an abstract decision problem on an instance set I,a n dl e t e\n1ande2be\npolynomially related encodings on I. Then, e1.Q/2P if and only if e2.Q/2P.\n5Technically, we also require the functions f12andf21to \u201cmap noninstances to noninstances.\u201d\nAnoninstance of an encoding eis a string x2f0; 1g/ETXsuch that there is no instance ifor which\ne.i/Dx. We require that f12.x/Dyfor every noninstance xof encoding e1,w h e r e yis some non-\ninstance of e2,a n dt h a t f21.x0/Dy0for every noninstance x0ofe2,w h e r e y0is some noninstance\nofe1.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "1077": {"page_number": 1078, "page_information": "34.1 Polynomial time 1057\nProof We need only prove the forward direction, since the backward direction is\nsymmetric. Suppose, therefore, that e1.Q/ can be solved in time O.nk/for some\nconstant k. Further, suppose that for any problem instance i, the encoding e1.i/\ncan be computed from the encoding e2.i/in time O.nc/for some constant c,w h e r e\nnDje2.i/j. To solve problem e2.Q/, on input e2.i/, we \ufb01rst compute e1.i/and\nthen run the algorithm for e1.Q/ one1.i/. How long does this take? Converting\nencodings takes time O.nc/, and thereforeje1.i/jDO.nc/, since the output of\na serial computer cannot be longer than its running time. Solving the problem\none1.i/takes time O.je1.i/jk/DO.nck/, which is polynomial since both candk\nare constants.\nThus, whether an abstract problem has its instances encoded in binary or base 3\ndoes not affect its \u201ccomplexity,\u201d that is, whether it is polynomial-time solvable or\nnot; but if instances are encoded in unary, its complexity may change. In order to\nbe able to converse in an encoding-independent fashion, we shall generally assumethat problem instances are encoded in any reasonable, concise fashion, unless wespeci\ufb01cally say otherwise. To be precise, we shall assume that the encoding of aninteger is polynomially related to its binary representation, and that the encoding ofa \ufb01nite set is polynomially related to its encoding as a list of its elements, enclosedin braces and separated by commas. (ASCII is one such encoding scheme.) Withsuch a \u201cstandard\u201d encoding in hand, we can derive reasonable encodings of othermathematical objects, such as tuples, graphs, and formulas. To denote the standardencoding of an object, we shall enclose the object in angle braces. Thus, hGi\ndenotes the standard encoding of a graph G.\nAs long as we implicitly use an encoding that is polynomially related to this\nstandard encoding, we can talk directly about abstract problems without referenceto any particular encoding, knowing that the choice of encoding has no effect on\nwhether the abstract problem is polynomial-time solvable. Henceforth, we shall\ngenerally assume that all problem instances are binary strings encoded using the\nstandard encoding, unless we explicitly specify the contrary. We shall also typically\nneglect the distinction between abstract and concrete problems. You should watch\nout for problems that arise in practice, however, in which a standard encoding is\nnot obvious and the encoding does make a difference.\nA formal-language framework\nBy focusing on decision problems, we can take advantage of the machinery of\nformal-language theory. Let\u2019s review some de\ufb01nitions from that theory. An\nalphabet \u2020is a \ufb01nite set of symbols. A language Lover \u2020is any set of\nstrings made up of symbols from \u2020. For example, if \u2020Df0; 1g, the set\nLDf10; 11; 101; 111; 1011; 1101; 10001; : : : gis the language of binary represen-", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "1078": {"page_number": 1079, "page_information": "1058 Chapter 34 NP-Completeness\ntations of prime numbers. We denote the empty string by\",t h eempty language\nby;, and the language of all strings over \u2020by\u2020/ETX. For example, if \u2020Df0; 1g,\nthen\u2020/ETXDf\"; 0; 1; 00; 01; 10; 11; 000; : : : gis the set of all binary strings. Every\nlanguage Lover\u2020is a subset of \u2020/ETX.\nWe can perform a variety of operations on languages. Set-theoretic operations,\nsuch as union andintersection , follow directly from the set-theoretic de\ufb01nitions.\nWe de\ufb01ne the complement ofLby\nLD\u2020/ETX/NULL.T h econcatenation L1L2of two\nlanguages L1andL2is the language\nLDfx1x2Wx12L1andx22L2g:\nTheclosure orKleene star of a language Lis the language\nL/ETXDf\"g[L[L2[L3[/SOH/SOH/SOH ;\nwhere Lkis the language obtained by concatenating Lto itself ktimes.\nFrom the point of view of language theory, the set of instances for any decision\nproblem Qis simply the set \u2020/ETX,w h e r e \u2020Df0; 1g.S i n c e Qis entirely character-\nized by those problem instances that produce a 1 (yes) answer, we can view Qas\na language Lover\u2020Df0; 1g,w h e r e\nLDfx2\u2020/ETXWQ.x/D1g:\nFor example, the decision problem PATH has the corresponding language\nPATHDfhG; u; /ETB; kiWGD.V; E/ is an undirected graph,\nu; /ETB2V;\nk/NAK0is an integer, and\nthere exists a path from uto/ETBinG\nconsisting of at most kedgesg:\n(Where convenient, we shall sometimes use the same name\u2014PATH in this case\u2014\nto refer to both a decision problem and its corresponding language.)\nThe formal-language framework allows us to express concisely the relation be-\ntween decision problems and algorithms that solve them. We say that an al-gorithm Aaccepts a string x2f0; 1g\n/ETXif, given input x, the algorithm\u2019s out-\nputA.x/ is1. The language accepted by an algorithm Ais the set of strings\nLDfx2f0; 1g/ETXWA.x/D1g, that is, the set of strings that the algorithm accepts.\nAn algorithm Arejects a string xifA.x/D0.\nEven if language Lis accepted by an algorithm A, the algorithm will not neces-\nsarily reject a string x62Lprovided as input to it. For example, the algorithm may\nloop forever. A language Lisdecided by an algorithm Aif every binary string\ninLis accepted by Aand every binary string not in Lis rejected by A.A l a n -\nguage Lisaccepted in polynomial time by an algorithm Aif it is accepted by A\nand if in addition there exists a constant ksuch that for any length- nstring x2L,", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "1079": {"page_number": 1080, "page_information": "34.1 Polynomial time 1059\nalgorithm Aaccepts xin time O.nk/. A language Lisdecided in polynomial\ntime by an algorithm Aif there exists a constant ksuch that for any length- nstring\nx2f0; 1g/ETX, the algorithm correctly decides whether x2Lin time O.nk/. Thus,\nto accept a language, an algorithm need only produce an answer when provided astring in L, but to decide a language, it must correctly accept or reject every string\ninf0; 1g\n/ETX.\nAs an example, the language PATH can be accepted in polynomial time. One\npolynomial-time accepting algorithm veri\ufb01es that Gencodes an undirected graph,\nveri\ufb01es that uand/ETBare vertices in G, uses breadth-\ufb01rst search to compute a short-\nest path from uto/ETBinG, and then compares the number of edges on the shortest\npath obtained with k.I fGencodes an undirected graph and the path found from u\nto/ETBhas at most kedges, the algorithm outputs 1and halts. Otherwise, the algo-\nrithm runs forever. This algorithm does not decide PATH, however, since it doesnot explicitly output 0for instances in which a shortest path has more than kedges.\nA decision algorithm for PATH must explicitly reject binary strings that do not be-\nlong to PATH. For a decision problem such as PATH, such a decision algorithm is\neasy to design: instead of running forever when there is not a path from uto/ETBwith\nat most kedges, it outputs 0and halts. (It must also output 0and halt if the input\nencoding is faulty.) For other problems, such as Turing\u2019s Halting Problem, thereexists an accepting algorithm, but no decision algorithm exists.\nWe can informally de\ufb01ne a complexity class as a set of languages, membership\nin which is determined by a complexity measure , such as running time, of an\nalgorithm that determines whether a given string xbelongs to language L.T h e\nactual de\ufb01nition of a complexity class is somewhat more technical.\n6\nUsing this language-theoretic framework, we can provide an alternative de\ufb01ni-\ntion of the complexity class P:\nPDfL/DC2f0; 1g/ETXWthere exists an algorithm Athat decides L\nin polynomial timeg:\nIn fact, P is also the class of languages that can be accepted in polynomial time.\nTheorem 34.2\nPDfLWLis accepted by a polynomial-time algorithm g:\nProof Because the class of languages decided by polynomial-time algorithms is\na subset of the class of languages accepted by polynomial-time algorithms, weneed only show that if Lis accepted by a polynomial-time algorithm, it is de-\ncided by a polynomial-time algorithm. Let Lbe the language accepted by some\n6For more on complexity classes, see the seminal paper by Hartmanis and Stearns [162].", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "1080": {"page_number": 1081, "page_information": "1060 Chapter 34 NP-Completeness\npolynomial-time algorithm A. We shall use a classic \u201csimulation\u201d argument to\nconstruct another polynomial-time algorithm A0that decides L. Because Aac-\ncepts Lin time O.nk/for some constant k, there also exists a constant csuch\nthatAaccepts Lin at most cnksteps. For any input string x, the algorithm A0\nsimulates cnksteps of A. After simulating cnksteps, algorithm A0inspects the be-\nhavior of A.I fAhas accepted x,t h e n A0accepts xby outputting a 1.I fAhas not\naccepted x,t h e n A0rejects xby outputting a 0. The overhead of A0simulating A\ndoes not increase the running time by more than a polynomial factor, and thus A0\nis a polynomial-time algorithm that decides L.\nNote that the proof of Theorem 34.2 is nonconstructive. For a given language\nL2P, we may not actually know a bound on the running time for the algorithm A\nthat accepts L. Nevertheless, we know that such a bound exists, and therefore, that\nan algorithm A0exists that can check the bound, even though we may not be able\nto \ufb01nd the algorithm A0easily.\nExercises\n34.1-1\nDe\ufb01ne the optimization problem LONGEST -PATH-LENGTH as the relation that\nassociates each instance of an undirected graph and two vertices with the num-ber of edges in a longest simple path between the two vertices. De\ufb01ne the de-cision problem LONGEST-PATH Df h G; u; /ETB; kiWGD.V; E/ is an undi-\nrected graph, u; /ETB2V,k/NAK0is an integer, and there exists a simple path\nfrom uto/ETBinGconsisting of at least kedgesg. Show that the optimization prob-\nlem LONGEST-PATH-LENGTH can be solved in polynomial time if and only if\nLONGEST-PATH2P.\n34.1-2\nGive a formal de\ufb01nition for the problem of \ufb01nding the longest simple cycle in an\nundirected graph. Give a related decision problem. Give the language correspond-\ning to the decision problem.\n34.1-3\nGive a formal encoding of directed graphs as binary strings using an adjacency-\nmatrix representation. Do the same using an adjacency-list representation. Arguethat the two representations are polynomially related.\n34.1-4\nIs the dynamic-programming algorithm for the 0-1 knapsack problem that is asked\nfor in Exercise 16.2-2 a polynomial-time algorithm? Explain your answer.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "1081": {"page_number": 1082, "page_information": "34.2 Polynomial-time veri\ufb01cation 1061\n34.1-5\nShow that if an algorithm makes at most a constant number of calls to polynomial-time subroutines and performs an additional amount of work that also takes polyno-mial time, then it runs in polynomial time. Also show that a polynomial number ofcalls to polynomial-time subroutines may result in an exponential-time algorithm.\n34.1-6\nShow that the class P, viewed as a set of languages, is closed under union, inter-section, concatenation, complement, and Kleene star. That is, if L\n1;L22P, then\nL1[L22P,L1\\L22P,L1L22P,\nL12P, and L/ETX\n12P.\n34.2 Polynomial-time veri\ufb01cation\nWe now look at algorithms that verify membership in languages. For example,\nsuppose that for a given instance hG; u; /ETB; kiof the decision problem PATH, we\nare also given a path pfrom uto/ETB. We can easily check whether pi sap a t hi n G\nand whether the length of pis at most k, and if so, we can view pas a \u201ccerti\ufb01cate\u201d\nthat the instance indeed belongs to PATH. For the decision problem PATH, this\ncerti\ufb01cate doesn\u2019t seem to buy us much. After all, PATH belongs to P\u2014in fact,we can solve PATH in linear time\u2014and so verifying membership from a givencerti\ufb01cate takes as long as solving the problem from scratch. We shall now examinea problem for which we know of no polynomial-time decision algorithm and yet,given a certi\ufb01cate, veri\ufb01cation is easy.\nHamiltonian cycles\nThe problem of \ufb01nding a hamiltonian cycle in an undirected graph has been stud-\nied for over a hundred years. Formally, a hamiltonian cycle of an undirected graph\nGD.V; E/ is a simple cycle that contains each vertex in V. A graph that con-\ntains a hamiltonian cycle is said to be hamiltonian ; otherwise, it is nonhamilto-\nnian . The name honors W. R. Hamilton, who described a mathematical game on\nthe dodecahedron (Figure 34.2(a)) in which one player sticks \ufb01ve pins in any \ufb01veconsecutive vertices and the other player must complete the path to form a cycle", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "1082": {"page_number": 1083, "page_information": "1062 Chapter 34 NP-Completeness\n(a) (b)\nFigure 34.2 (a) A graph representing the vertices, edges, and faces of a dodecahedron, with a\nhamiltonian cycle shown by shaded edges. (b)A bipartite graph with an odd number of vertices.\nAny such graph is nonhamiltonian.\ncontaining all the vertices.7The dodecahedron is hamiltonian, and Figure 34.2(a)\nshows one hamiltonian cycle. Not all graphs are hamiltonian, however. For ex-ample, Figure 34.2(b) shows a bipartite graph with an odd number of vertices.Exercise 34.2-2 asks you to show that all such graphs are nonhamiltonian.\nWe can de\ufb01ne the hamiltonian-cycle problem ,\u201c D o e sag r a p h Ghave a hamil-\ntonian cycle?\u201d as a formal language:\nHAM-CYCLEDfhGiWGis a hamiltonian graph g:\nHow might an algorithm decide the language HAM-CYCLE? Given a problem\ninstancehGi, one possible decision algorithm lists all permutations of the vertices\nofGand then checks each permutation to see if it is a hamiltonian path. What is\nthe running time of this algorithm? If we use the \u201creasonable\u201d encoding of a graphas its adjacency matrix, the number mof vertices in the graph is /DEL.p\nn/,w h e r e\nnDjhGijis the length of the encoding of G.T h e r ea r e m\u0160possible permutations\n7In a letter dated 17 October 1856 to his friend John T. Graves, Hamilton [157, p. 624] wrote, \u201cI\nhave found that some young persons have been much amused by trying a new mathematical game\nw h i c h t h e I c o s i o n f u r n i s h e s , o n e p e r s o n s t i c k i n g \ufb01 v e p i n s i n a n y \ufb01 v e c o n s e c u t i v e p o i n t s ...a n d t h e\nother player then aiming to insert, which by the theory in this letter can always be done, \ufb01fteen other\npins, in cyclical succession, so as to cover all the other points, and to end in immediate proximity to\nthe pin wherewith his antagonist had begun.\u201d", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "1083": {"page_number": 1084, "page_information": "34.2 Polynomial-time veri\ufb01cation 1063\nof the vertices, and therefore the running time is /DEL.m\u0160/D/DEL.p\nn\u0160 /D/DEL.2p\nn/,\nwhich is not O.nk/for any constant k. Thus, this naive algorithm does not run\nin polynomial time. In fact, the hamiltonian-cycle problem is NP-complete, as weshall prove in Section 34.5.\nVeri\ufb01cation algorithms\nConsider a slightly easier problem. Suppose that a friend tells you that a given\ngraph Gis hamiltonian, and then offers to prove it by giving you the vertices in\norder along the hamiltonian cycle. It would certainly be easy enough to verify theproof: simply verify that the provided cycle is hamiltonian by checking whetherit is a permutation of the vertices of Vand whether each of the consecutive edges\nalong the cycle actually exists in the graph. You could certainly implement thisveri\ufb01cation algorithm to run in O.n\n2/time, where nis the length of the encoding\nofG. Thus, a proof that a hamiltonian cycle exists in a graph can be veri\ufb01ed in\npolynomial time.\nWe de\ufb01ne a veri\ufb01cation algorithm as being a two-argument algorithm A,w h e r e\none argument is an ordinary input string xand the other is a binary string ycalled\nacerti\ufb01cate . A two-argument algorithm Averi\ufb01es an input string xif there exists\na certi\ufb01cate ysuch that A.x; y/D1.T h e language veri\ufb01ed by a veri\ufb01cation\nalgorithm Ais\nLDfx2f0; 1g/ETXWthere exists y2f0; 1g/ETXsuch that A.x; y/D1g:\nIntuitively, an algorithm Averi\ufb01es a language Lif for any string x2L,t h e r e\nexists a certi\ufb01cate ythatAcan use to prove that x2L. Moreover, for any string\nx62L, there must be no certi\ufb01cate proving that x2L. For example, in the\nhamiltonian-cycle problem, the certi\ufb01cate is the list of vertices in some hamilto-nian cycle. If a graph is hamiltonian, the hamiltonian cycle itself offers enoughinformation to verify this fact. Conversely, if a graph is not hamiltonian, therecan be no list of vertices that fools the veri\ufb01cation algorithm into believing that thegraph is hamiltonian, since the veri\ufb01cation algorithm carefully checks the proposed\u201ccycle\u201d to be sure.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "1084": {"page_number": 1085, "page_information": "1064 Chapter 34 NP-Completeness\nThe complexity class NP\nThecomplexity class NPis the class of languages that can be veri\ufb01ed by a poly-\nnomial-time algorithm.8More precisely, a language Lbelongs to NP if and only if\nthere exist a two-input polynomial-time algorithm Aand a constant csuch that\nLDfx2f0; 1g/ETXWthere exists a certi\ufb01cate ywithjyjDO.jxjc/\nsuch that A.x; y/D1g:\nWe say that algorithm Averi\ufb01es language Lin polynomial time .\nFrom our earlier discussion on the hamiltonian-cycle problem, we now see that\nHAM-CYCLE2NP. (It is always nice to know that an important set is nonempty.)\nMoreover, if L2P, then L2NP, since if there is a polynomial-time algorithm\nto decide L, the algorithm can be easily converted to a two-argument veri\ufb01cation\nalgorithm that simply ignores any certi\ufb01cate and accepts exactly those input stringsit determines to be in L. Thus, P/DC2NP.\nIt is unknown whether P DNP, but most researchers believe that P and NP are\nnot the same class. Intuitively, the class P consists of problems that can be solvedquickly. The class NP consists of problems for which a solution can be veri\ufb01edquickly. You may have learned from experience that it is often more dif\ufb01cult tosolve a problem from scratch than to verify a clearly presented solution, especiallywhen working under time constraints. Theoretical computer scientists generallybelieve that this analogy extends to the classes P and NP, and thus that NP includeslanguages that are not in P.\nThere is more compelling, though not conclusive, evidence that P \u00a4NP\u2014the\nexistence of languages that are \u201cNP-complete.\u201d We shall study this class in Sec-tion 34.3.\nMany other fundamental questions beyond the P \u00a4NP question remain unre-\nsolved. Figure 34.3 shows some possible scenarios. Despite much work by manyresearchers, no one even knows whether the class NP is closed under comple-ment. That is, does L2NP imply\nL2NP? We can de\ufb01ne the complexity class\nco-NP as the set of languages Lsuch that\n L2NP. We can restate the question\nof whether NP is closed under complement as whether NP Dco-NP. Since P is\nclosed under complement (Exercise 34.1-6), it follows from Exercise 34.2-9 thatP/DC2NP\\co-NP. Once again, however, no one knows whether P DNP\\co-NP\nor whether there is some language in NP \\co-NP/NULP.\n8The name \u201cNP\u201d stands for \u201cnondeterministic polynomial time.\u201d The class NP was originally studied\nin the context of nondeterminism, but this book uses the somewhat simpler yet equivalent notion of\nveri\ufb01cation. Hopcroft and Ullman [180] give a good presentation of NP-completeness in terms of\nnondeterministic models of computation.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "1085": {"page_number": 1086, "page_information": "34.2 Polynomial-time veri\ufb01cation 1065\nco-NP NP\n(c)P = NP \u2229 co-NPco-NP NP\n(d)PP = NP = co-NP\n(a)NP = co-NP\n(b)P\nNP\u2229 co-NP\nFigure 34.3 Four possibilities for relationships among complexity classes. In each diagram, one\nregion enclosing another indicates a proper-subset relation. (a)PDNPDco-NP. Most researchers\nregard this possibility as the most unlikely. (b)If NP is closed under complement, then NP Dco-NP,\nbut it need not be the case that P DNP.(c)PDNP\\co-NP, but NP is not closed under complement.\n(d)NP\u00a4co-NP and P\u00a4NP\\co-NP. Most researchers regard this possibility as the most likely.\nThus, our understanding of the precise relationship between P and NP is woe-\nfully incomplete. Nevertheless, even though we might not be able to prove that aparticular problem is intractable, if we can prove that it is NP-complete, then wehave gained valuable information about it.\nExercises\n34.2-1\nConsider the language GRAPH-ISOMORPHISM DfhG\n1;G2iWG1andG2are\nisomorphic graphsg. Prove that GRAPH-ISOMORPHISM 2NP by describing a\npolynomial-time algorithm to verify the language.\n34.2-2\nProve that if Gis an undirected bipartite graph with an odd number of vertices,\nthenGis nonhamiltonian.\n34.2-3\nShow that if HAM-CYCLE 2P, then the problem of listing the vertices of a\nhamiltonian cycle, in order, is polynomial-time solvable.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "1086": {"page_number": 1087, "page_information": "1066 Chapter 34 NP-Completeness\n34.2-4\nProve that the class NP of languages is closed under union, intersection, concate-nation, and Kleene star. Discuss the closure of NP under complement.\n34.2-5\nShow that any language in NP can be decided by an algorithm running in\ntime2\nO.nk/for some constant k.\n34.2-6\nAhamiltonian path in a graph is a simple path that visits every vertex exactly\nonce. Show that the language HAM-PATH DfhG; u; /ETBiWthere is a hamiltonian\npath from uto/ETBin graph Ggbelongs to NP.\n34.2-7\nShow that the hamiltonian-path problem from Exercise 34.2-6 can be solved inpolynomial time on directed acyclic graphs. Give an ef\ufb01cient algorithm for theproblem.\n34.2-8\nLet/RSbe a boolean formula constructed from the boolean input variables x\n1;x2;\n:::;x k, negations (:), ANDs (^), ORs (_), and parentheses. The formula /RSis a\ntautology if it evaluates to 1for every assignment of 1and0to the input variables.\nDe\ufb01ne TAUTOLOGY as the language of boolean formulas that are tautologies.Show that TAUTOLOGY 2co-NP.\n34.2-9\nProve that P/DC2co-NP.\n34.2-10\nProve that if NP\u00a4co-NP, then P\u00a4NP.\n34.2-11\nLetGbe a connected, undirected graph with at least 3vertices, and let G\n3be the\ngraph obtained by connecting all pairs of vertices that are connected by a path in G\nof length at most 3. Prove that G3is hamiltonian. ( Hint: Construct a spanning tree\nforG, and use an inductive argument.)", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "1087": {"page_number": 1088, "page_information": "34.3 NP-completeness and reducibility 1067\n34.3 NP-completeness and reducibility\nPerhaps the most compelling reason why theoretical computer scientists believe\nthat P\u00a4NP comes from the existence of the class of \u201cNP-complete\u201d problems.\nThis class has the intriguing property that if anyNP-complete problem can be\nsolved in polynomial time, then every problem in NP has a polynomial-time solu-\ntion, that is, PDNP. Despite years of study, though, no polynomial-time algorithm\nhas ever been discovered for any NP-complete problem.\nThe language HAM-CYCLE is one NP-complete problem. If we could decide\nHAM-CYCLE in polynomial time, then we could solve every problem in NP inpolynomial time. In fact, if NP /NULP should turn out to be nonempty, we could say\nwith certainty that HAM-CYCLE 2NP/NULP.\nThe NP-complete languages are, in a sense, the \u201chardest\u201d languages in NP. In\nthis section, we shall show how to compare the relative \u201chardness\u201d of languagesusing a precise notion called \u201cpolynomial-time reducibility.\u201d Then we formallyde\ufb01ne the NP-complete languages, and we \ufb01nish by sketching a proof that onesuch language, called CIRCUIT-SAT, is NP-complete. In Sections 34.4 and 34.5,we shall use the notion of reducibility to show that many other problems are NP-complete.\nReducibility\nIntuitively, a problem Qcan be reduced to another problem Q\n0if any instance of Q\ncan be \u201ceasily rephrased\u201d as an instance of Q0, the solution to which provides a\nsolution to the instance of Q. For example, the problem of solving linear equations\nin an indeterminate xreduces to the problem of solving quadratic equations. Given\nan instance axCbD0, we transform it to 0x2CaxCbD0, whose solution\nprovides a solution to axCbD0. Thus, if a problem Qreduces to another\nproblem Q0,t h e n Qis, in a sense, \u201cno harder to solve\u201d than Q0.\nReturning to our formal-language framework for decision problems, we say that\na language L1ispolynomial-time reducible to a language L2, written L1/DC4PL2,\nif there exists a polynomial-time computable function fWf0; 1g/ETX!f0; 1g/ETXsuch\nthat for all x2f0; 1g/ETX,\nx2L1if and only if f. x/2L2: (34.1)\nWe call the function fthereduction function , and a polynomial-time algorithm F\nthat computes fis areduction algorithm .\nFigure 34.4 illustrates the idea of a polynomial-time reduction from a lan-\nguage L1to another language L2. Each language is a subset of f0; 1g/ETX.T h e\nreduction function fprovides a polynomial-time mapping such that if x2L1,", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "1088": {"page_number": 1089, "page_information": "1068 Chapter 34 NP-Completeness\nL2L1{0,1}* {0,1}* f\nFigure 34.4 An illustration of a polynomial-time reduction from a language L1to a language L2\nvia a reduction function f. For any input x2f0; 1g/ETX, the question of whether x2L1has the same\nanswer as the question of whether f. x/2L2.\nthenf. x/2L2. Moreover, if x62L1,t h e n f. x/62L2. Thus, the reduction func-\ntion maps any instance xof the decision problem represented by the language L1\nto an instance f. x/ of the problem represented by L2. Providing an answer to\nwhether f. x/2L2directly provides the answer to whether x2L1.\nPolynomial-time reductions give us a powerful tool for proving that various lan-\nguages belong to P.\nLemma 34.3\nIfL1;L2/DC2f0; 1g/ETXare languages such that L1/DC4PL2,t h e n L22P implies\nL12P.\nProof LetA2be a polynomial-time algorithm that decides L2,a n dl e t Fbe a\npolynomial-time reduction algorithm that computes the reduction function f.W e\nshall construct a polynomial-time algorithm A1that decides L1.\nFigure 34.5 illustrates how we construct A1. For a given input x2f0; 1g/ETX,\nalgorithm A1usesFto transform xintof. x/ , and then it uses A2to test whether\nf. x/2L2. Algorithm A1takes the output from algorithm A2and produces that\nanswer as its own output.\nThe correctness of A1follows from condition (34.1). The algorithm runs in poly-\nnomial time, since both FandA2run in polynomial time (see Exercise 34.1-5).\nNP-completeness\nPolynomial-time reductions provide a formal means for showing that one prob-\nlem is at least as hard as another, to within a polynomial-time factor. That is, ifL\n1/DC4PL2,t h e n L1is not more than a polynomial factor harder than L2,w h i c hi s", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "1089": {"page_number": 1090, "page_information": "34.3 NP-completeness and reducibility 1069\nx\nFf. x/\nA1A2yes,f. x/2L2\nno,f. x/62L2yes,x2L1\nno,x62L1\nFigure 34.5 The proof of Lemma 34.3. The algorithm Fis a reduction algorithm that computes the\nreduction function ffrom L1toL2in polynomial time, and A2is a polynomial-time algorithm that\ndecides L2. Algorithm A1decides whether x2L1by using Fto transform any input xintof. x/\nand then using A2to decide whether f. x/2L2.\nwhy the \u201cless than or equal to\u201d notation for reduction is mnemonic. We can now\nde\ufb01ne the set of NP-complete languages, which are the hardest problems in NP.\nA language L/DC2f0; 1g/ETXisNP-complete if\n1.L2NP, and\n2.L0/DC4PLfor every L02NP.\nIf a language Lsatis\ufb01es property 2, but not necessarily property 1, we say that L\nisNP-hard . We also de\ufb01ne NPC to be the class of NP-complete languages.\nAs the following theorem shows, NP-completeness is at the crux of deciding\nwhether P is in fact equal to NP.\nTheorem 34.4\nIf any NP-complete problem is polynomial-time solvable, then P DNP. Equiva-\nlently, if any problem in NP is not polynomial-time solvable, then no NP-complete\nproblem is polynomial-time solvable.\nProof Suppose that L2P and also that L2NPC. For any L02NP, we\nhave L0/DC4PLby property 2 of the de\ufb01nition of NP-completeness. Thus, by\nLemma 34.3, we also have that L02P, which proves the \ufb01rst statement of the\ntheorem.\nTo prove the second statement, note that it is the contrapositive of the \ufb01rst state-\nment.\nIt is for this reason that research into the P \u00a4NP question centers around the\nNP-complete problems. Most theoretical computer scientists believe that P \u00a4NP,\nwhich leads to the relationships among P, NP, and NPC shown in Figure 34.6.But, for all we know, someone may yet come up with a polynomial-time algo-\nrithm for an NP-complete problem, thus proving that P DNP. Nevertheless, since\nno polynomial-time algorithm for any NP-complete problem has yet been discov-", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "1090": {"page_number": 1091, "page_information": "1070 Chapter 34 NP-Completeness\nNPC\nPNP\nFigure 34.6 How most theoretical computer scientists view the relationships among P, NP,\nand NPC. Both P and NPC are wholly contained within NP, and P \\NPCD;.\nered, a proof that a problem is NP-complete provides excellent evidence that it is\nintractable.\nCircuit satis\ufb01ability\nWe have de\ufb01ned the notion of an NP-complete problem, but up to this point, we\nhave not actually proved that any problem is NP-complete. Once we prove that atleast one problem is NP-complete, we can use polynomial-time reducibility as atool to prove other problems to be NP-complete. Thus, we now focus on demon-strating the existence of an NP-complete problem: the circuit-satis\ufb01ability prob-lem.\nUnfortunately, the formal proof that the circuit-satis\ufb01ability problem is NP-\ncomplete requires technical detail beyond the scope of this text. Instead, we shallinformally describe a proof that relies on a basic understanding of boolean combi-national circuits.\nBoolean combinational circuits are built from boolean combinational elements\nthat are interconnected by wires. A boolean combinational element is any circuit\nelement that has a constant number of boolean inputs and outputs and that performsa well-de\ufb01ned function. Boolean values are drawn from the set f0; 1g,w h e r e 0\nrepresents\nFALSE and1represents TRUE .\nThe boolean combinational elements that we use in the circuit-satis\ufb01ability prob-\nlem compute simple boolean functions, and they are known as logic gates .F i g -\nure 34.7 shows the three basic logic gates that we use in the circuit-satis\ufb01abilityproblem: the NOT gate (orinverter ), theAND gate ,a n dt h e OR gate .T h e N O T\ngate takes a single binary input x, whose value is either 0or1, and produces a\nbinary output \u00b4whose value is opposite that of the input value. Each of the other\ntwo gates takes two binary inputs xandyand produces a single binary output \u00b4.\nWe can describe the operation of each gate, and of any boolean combinational\nelement, by a truth table , shown under each gate in Figure 34.7. A truth table gives\nthe outputs of the combinational element for each possible setting of the inputs. For", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "1091": {"page_number": 1092, "page_information": "34.3 NP-completeness and reducibility 1071\nx\nyzx\nyz\n00 0\n01 0\n10 011 100 0\n01 1\n10 111 1\n(b) (c)xz\n01\n10\n(a)x x xy y :xx ^yx _y\nFigure 34.7 Three basic logic gates, with binary inputs and outputs. Under each gate is the truth\ntable that describes the gate\u2019s operation. (a)The NOT gate. (b)The AND gate. (c)The OR gate.\nexample, the truth table for the OR gate tells us that when the inputs are xD0\nandyD1, the output value is \u00b4D1. We use the symbols :to denote the NOT\nfunction,^to denote the AND function, and _to denote the OR function. Thus,\nfor example, 0_1D1.\nWe can generalize AND and OR gates to take more than two inputs. An AND\ngate\u2019s output is 1if all of its inputs are 1, and its output is 0otherwise. An OR gate\u2019s\noutput is 1if any of its inputs are 1, and its output is 0otherwise.\nAboolean combinational circuit consists of one or more boolean combinational\nelements interconnected by wires . A wire can connect the output of one element\nto the input of another, thereby providing the output value of the \ufb01rst element as aninput value of the second. Figure 34.8 shows two similar boolean combinationalcircuits, differing in only one gate. Part (a) of the \ufb01gure also shows the values onthe individual wires, given the input hx\n1D1; x 2D1; x 3D0i. Although a single\nwire may have no more than one combinational-element output connected to it, it\ncan feed several element inputs. The number of element inputs fed by a wire is\ncalled the fan-out of the wire. If no element output is connected to a wire, the wire\nis acircuit input , accepting input values from an external source. If no element\ninput is connected to a wire, the wire is a circuit output , providing the results of\nthe circuit\u2019s computation to the outside world. (An internal wire can also fan out\nto a circuit output.) For the purpose of de\ufb01ning the circuit-satis\ufb01ability problem,we limit the number of circuit outputs to 1, though in actual hardware design, a\nboolean combinational circuit may have multiple outputs.\nBoolean combinational circuits contain no cycles. In other words, suppose we\ncreate a directed graph GD.V; E/ with one vertex for each combinational element\nand with kdirected edges for each wire whose fan-out is k; the graph contains\na directed edge .u; /ETB/ if a wire connects the output of element uto an input of\nelement /ETB.T h e n Gmust be acyclic.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "1092": {"page_number": 1093, "page_information": "1072 Chapter 34 NP-Completeness\nx3x2x1\n(a)1\n1\n0\n111111\n11\n0\n0\n1111\nx3x2x1\n(b)\nFigure 34.8 Two instances of the circuit-satis\ufb01ability problem. (a)The assignmenthx1D1;\nx2D1; x3D0ito the inputs of this circuit causes the output of the circuit to be 1. The circuit\nis therefore satis\ufb01able. (b)No assignment to the inputs of this circuit can cause the output of the\ncircuit to be 1. The circuit is therefore unsatis\ufb01able.\nAtruth assignment for a boolean combinational circuit is a set of boolean input\nvalues. We say that a one-output boolean combinational circuit is satis\ufb01able if it\nhas asatisfying assignment : a truth assignment that causes the output of the circuit\nto be 1. For example, the circuit in Figure 34.8(a) has the satisfying assignment\nhx1D1; x 2D1; x 3D0i, and so it is satis\ufb01able. As Exercise 34.3-1 asks you to\nshow, no assignment of values to x1,x2,a n d x3causes the circuit in Figure 34.8(b)\nto produce a 1output; it always produces 0, and so it is unsatis\ufb01able.\nThecircuit-satis\ufb01ability problem is, \u201cGiven a boolean combinational circuit\ncomposed of AND, OR, and NOT gates, is it satis\ufb01able?\u201d In order to pose this\nquestion formally, however, we must agree on a standard encoding for circuits.Thesizeof a boolean combinational circuit is the number of boolean combina-\ntional elements plus the number of wires in the circuit. We could devise a graphlike\nencoding that maps any given circuit Cinto a binary string hCiwhose length is\npolynomial in the size of the circuit itself. As a formal language, we can therefore\nde\ufb01ne\nCIRCUIT-SATDfhCiWCis a satis\ufb01able boolean combinational circuit g:\nThe circuit-satis\ufb01ability problem arises in the area of computer-aided hardware\noptimization. If a subcircuit always produces 0, that subcircuit is unnecessary;\nthe designer can replace it by a simpler subcircuit that omits all logic gates andprovides the constant 0value as its output. You can see why we would like to have\na polynomial-time algorithm for this problem.\nGiven a circuit C, we might attempt to determine whether it is satis\ufb01able by\nsimply checking all possible assignments to the inputs. Unfortunately, if the circuithaskinputs, then we would have to check up to 2\nkpossible assignments. When", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "1093": {"page_number": 1094, "page_information": "34.3 NP-completeness and reducibility 1073\nthe size of Cis polynomial in k, checking each one takes /DEL.2k/time, which is\nsuperpolynomial in the size of the circuit.9In fact, as we have claimed, there is\nstrong evidence that no polynomial-time algorithm exists that solves the circuit-satis\ufb01ability problem because circuit satis\ufb01ability is NP-complete. We break theproof of this fact into two parts, based on the two parts of the de\ufb01nition of NP-completeness.\nLemma 34.5\nThe circuit-satis\ufb01ability problem belongs to the class NP.\nProof We shall provide a two-input, polynomial-time algorithm Athat can verify\nCIRCUIT-SAT. One of the inputs to Ais (a standard encoding of) a boolean com-\nbinational circuit C. The other input is a certi\ufb01cate corresponding to an assignment\nof boolean values to the wires in C. (See Exercise 34.3-4 for a smaller certi\ufb01cate.)\nWe construct the algorithm Aas follows. For each logic gate in the circuit, it\nchecks that the value provided by the certi\ufb01cate on the output wire is correctlycomputed as a function of the values on the input wires. Then, if the output of theentire circuit is 1, the algorithm outputs 1, since the values assigned to the inputs\nofCprovide a satisfying assignment. Otherwise, Aoutputs 0.\nWhenever a satis\ufb01able circuit Cis input to algorithm A, there exists a certi\ufb01cate\nwhose length is polynomial in the size of Cand that causes Ato output a 1. When-\never an unsatis\ufb01able circuit is input, no certi\ufb01cate can fool Ainto believing that\nthe circuit is satis\ufb01able. Algorithm Aruns in polynomial time: with a good imple-\nmentation, linear time suf\ufb01ces. Thus, we can verify CIRCUIT -SAT in polynomial\ntime, and CIRCUIT-SAT 2NP.\nThe second part of proving that CIRCUIT-SAT is NP-complete is to show that\nthe language is NP-hard. That is, we must show that every language in NP ispolynomial-time reducible to CIRCUIT-SAT. The actual proof of this fact is fullof technical intricacies, and so we shall settle for a sketch of the proof based onsome understanding of the workings of computer hardware.\nA computer program is stored in the computer memory as a sequence of in-\nstructions. A typical instruction encodes an operation to be performed, addresses\nof operands in memory, and an address where the result is to be stored. A spe-\ncial memory location, called the program counter , keeps track of which instruc-\n9On the other hand, if the size of the circuit Cis\u201a.2k/, then an algorithm whose running time\nisO.2k/has a running time that is polynomial in the circuit size. Even if P \u00a4NP, this situa-\ntion would not contradict the NP-completeness of the problem; the existence of a polynomial-time\nalgorithm for a special case does not imply that there is a polynomial-time algorithm for all cases.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "1094": {"page_number": 1095, "page_information": "1074 Chapter 34 NP-Completeness\ntion is to be executed next. The program counter automatically increments upon\nfetching each instruction, thereby causing the computer to execute instructions se-quentially. The execution of an instruction can cause a value to be written to theprogram counter, however, which alters the normal sequential execution and allowsthe computer to loop and perform conditional branches.\nAt any point during the execution of a program, the computer\u2019s memory holds\nthe entire state of the computation. (We take the memory to include the programitself, the program counter, working storage, and any of the various bits of state\nthat a computer maintains for bookkeeping.) We call any particular state of com-\nputer memory a con\ufb01guration . We can view the execution of an instruction as\nmapping one con\ufb01guration to another. The computer hardware that accomplishesthis mapping can be implemented as a boolean combinational circuit, which wedenote by Min the proof of the following lemma.\nLemma 34.6\nThe circuit-satis\ufb01ability problem is NP-hard.\nProof LetLbe any language in NP. We shall describe a polynomial-time algo-\nrithm Fcomputing a reduction function fthat maps every binary string xto a\ncircuit CDf. x/ such that x2Lif and only if C2CIRCUIT-SAT.\nSince L2NP, there must exist an algorithm Athat veri\ufb01es Lin polynomial\ntime. The algorithm Fthat we shall construct uses the two-input algorithm Ato\ncompute the reduction function f.\nLetT .n/ denote the worst-case running time of algorithm Aon length- ninput\nstrings, and let k/NAK1be a constant such that T .n/DO.n\nk/and the length of the\ncerti\ufb01cate is O.nk/. (The running time of Ais actually a polynomial in the total\ninput size, which includes both an input string and a certi\ufb01cate, but since the length\nof the certi\ufb01cate is polynomial in the length nof the input string, the running time\nis polynomial in n.)\nThe basic idea of the proof is to represent the computation of Aas a sequence\nof con\ufb01gurations. As Figure 34.9 illustrates, we can break each con\ufb01guration intoparts consisting of the program for A, the program counter and auxiliary machine\nstate, the input x, the certi\ufb01cate y, and working storage. The combinational cir-\ncuitM, which implements the computer hardware, maps each con\ufb01guration c\nito\nthe next con\ufb01guration ciC1, starting from the initial con\ufb01guration c0. Algorithm A\nwrites its output\u2014 0or1\u2014to some designated location by the time it \ufb01nishes ex-\necuting, and if we assume that thereafter Ahalts, the value never changes. Thus,\nif the algorithm runs for at most T .n/ steps, the output appears as one of the bits\nincT. n /.\nThe reduction algorithm Fconstructs a single combinational circuit that com-\nputes all con\ufb01gurations produced by a given initial con\ufb01guration. The idea is to", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "1095": {"page_number": 1096, "page_information": "34.3 NP-completeness and reducibility 1075\nM\nA PC aux machine state xy working storageA PC aux machine state xy working storage\nM\nA PC aux machine state xy working storage\nM\nA PC aux machine state xy\n\u2026\nworking storage\n0/1 outputMc0\nc1\nc2\ncT(n)\nFigure 34.9 The sequence of con\ufb01gurations produced by an algorithm Arunning on an input xand\ncerti\ufb01cate y. Each con\ufb01guration represents the state of the computer for one step of the computation\nand, besides A,x,a n d y, includes the program counter (PC), auxiliary machine state, and working\nstorage. Except for the certi\ufb01cate y, the initial con\ufb01guration c0is constant. A boolean combinational\ncircuit Mmaps each con\ufb01guration to the next con\ufb01guration. The output is a distinguished bit in the\nworking storage.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "1096": {"page_number": 1097, "page_information": "1076 Chapter 34 NP-Completeness\npaste together T .n/ copies of the circuit M. The output of the ith circuit, which\nproduces con\ufb01guration ci, feeds directly into the input of the .iC1/st circuit. Thus,\nthe con\ufb01gurations, rather than being stored in the computer\u2019s memory, simply re-side as values on the wires connecting copies of M.\nRecall what the polynomial-time reduction algorithm Fmust do. Given an in-\nputx, it must compute a circuit CDf. x/ that is satis\ufb01able if and only if there\nexists a certi\ufb01cate ysuch that A.x; y/D1.W h e n Fobtains an input x,i t\ufb01 r s t\ncomputes nDjxjand constructs a combinational circuit C\n0consisting of T .n/\ncopies of M. The input to C0is an initial con\ufb01guration corresponding to a compu-\ntation on A.x; y/ , and the output is the con\ufb01guration cT. n /.\nAlgorithm Fmodi\ufb01es circuit C0slightly to construct the circuit CDf. x/ .\nFirst, it wires the inputs to C0corresponding to the program for A, the initial pro-\ngram counter, the input x, and the initial state of memory directly to these known\nvalues. Thus, the only remaining inputs to the circuit correspond to the certi\ufb01-catey. Second, it ignores all outputs from C\n0, except for the one bit of cT. n /\ncorresponding to the output of A. This circuit C, so constructed, computes\nC.y/DA.x; y/ for any input yof length O.nk/. The reduction algorithm F,\nwhen provided an input string x, computes such a circuit Cand outputs it.\nWe need to prove two properties. First, we must show that Fcorrectly computes\na reduction function f. That is, we must show that Cis satis\ufb01able if and only if\nthere exists a certi\ufb01cate ysuch that A.x; y/D1. Second, we must show that F\nruns in polynomial time.\nTo show that Fcorrectly computes a reduction function, let us suppose that there\nexists a certi\ufb01cate yof length O.nk/such that A.x; y/D1. Then, if we apply the\nbits of yto the inputs of C, the output of CisC.y/DA.x; y/D1. Thus, if a\ncerti\ufb01cate exists, then Cis satis\ufb01able. For the other direction, suppose that Cis\nsatis\ufb01able. Hence, there exists an input ytoCsuch that C.y/D1, from which\nwe conclude that A.x; y/D1. Thus, Fcorrectly computes a reduction function.\nTo complete the proof sketch, we need only show that Fruns in time polynomial\ninnDjxj. The \ufb01rst observation we make is that the number of bits required to\nrepresent a con\ufb01guration is polynomial in n. The program for Aitself has constant\nsize, independent of the length of its input x. The length of the input xisn,a n d\nthe length of the certi\ufb01cate yisO.nk/. Since the algorithm runs for at most O.nk/\nsteps, the amount of working storage required by Ais polynomial in nas well.\n(We assume that this memory is contiguous; Exercise 34.3-5 asks you to extendthe argument to the situation in which the locations accessed by Aare scattered\nacross a much larger region of memory and the particular pattern of scattering can\ndiffer for each input x.)\nThe combinational circuit Mimplementing the computer hardware has size\npolynomial in the length of a con\ufb01guration, which is O.n\nk/; hence, the size of M\nis polynomial in n. (Most of this circuitry implements the logic of the memory", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "1097": {"page_number": 1098, "page_information": "34.3 NP-completeness and reducibility 1077\nsystem.) The circuit Cconsists of at most tDO.nk/copies of M, and hence it\nhas size polynomial in n. The reduction algorithm Fcan construct Cfrom xin\npolynomial time, since each step of the construction takes polynomial time.\nThe language CIRCUIT-SAT is therefore at least as hard as any language in NP,\nand since it belongs to NP, it is NP-complete.\nTheorem 34.7\nThe circuit-satis\ufb01ability problem is NP-complete.\nProof Immediate from Lemmas 34.5 and 34.6 and from the de\ufb01nition of NP-\ncompleteness.\nExercises\n34.3-1\nVerify that the circuit in Figure 34.8(b) is unsatis\ufb01able.\n34.3-2\nShow that the/DC4Prelation is a transitive relation on languages. That is, show that if\nL1/DC4PL2andL2/DC4PL3,t h e n L1/DC4PL3.\n34.3-3\nProve that L/DC4P\nLif and only if\n L/DC4PL.\n34.3-4\nShow that we could have used a satisfying assignment as a certi\ufb01cate in an alter-native proof of Lemma 34.5. Which certi\ufb01cate makes for an easier proof?\n34.3-5\nThe proof of Lemma 34.6 assumes that the working storage for algorithm Aoccu-\npies a contiguous region of polynomial size. Where in the proof do we exploit thisassumption? Argue that this assumption does not involve any loss of generality.\n34.3-6\nA language Liscomplete for a language class Cwith respect to polynomial-time\nreductions if L2CandL\n0/DC4PLfor all L02C. Show that;andf0; 1g/ETXare the\nonly languages in P that are not complete for P with respect to polynomial-timereductions.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "1098": {"page_number": 1099, "page_information": "1078 Chapter 34 NP-Completeness\n34.3-7\nShow that, with respect to polynomial-time reductions (see Exercise 34.3-6), Lis\ncomplete for NP if and only if\n Lis complete for co-NP.\n34.3-8\nThe reduction algorithm Fin the proof of Lemma 34.6 constructs the circuit\nCDf. x/ based on knowledge of x,A,a n d k. Professor Sartre observes that\nthe string xis input to F, but only the existence of A,k, and the constant factor\nimplicit in the O.nk/running time is known to F(since the language Lbelongs\nto NP), not their actual values. Thus, the professor concludes that Fcan\u2019t possi-\nbly construct the circuit Cand that the language CI RCUIT-SAT is not necessarily\nNP-hard. Explain the \ufb02aw in the professor\u2019s reasoning.\n34.4 NP-completeness proofs\nWe proved that the circuit-satis\ufb01ability problem is NP-complete by a direct proofthatL/DC4\nPCIRCUIT-SAT for every language L2NP. In this section, we shall\nshow how to prove that languages are NP-complete without directly reducing every\nlanguage in NP to the given language. We shall illustrate this methodology byproving that various formula-satis\ufb01ability problems are NP-complete. Section 34.5provides many more examples of the methodology.\nThe following lemma is the basis of our method for showing that a language is\nNP-complete.\nLemma 34.8\nIfLis a language such that L\n0/DC4PLfor some L02NPC, then Lis NP-hard. If, in\naddition, L2NP, then L2NPC.\nProof Since L0is NP-complete, for all L002NP, we have L00/DC4PL0. By sup-\nposition, L0/DC4PL, and thus by transitivity (Exercise 34.3-2), we have L00/DC4PL,\nwhich shows that Lis NP-hard. If L2NP, we also have L2NPC.\nIn other words, by reducing a known NP-complete language L0toL, we implic-\nitly reduce every language in NP to L. Thus, Lemma 34.8 gives us a method for\nproving that a language Lis NP-complete:\n1. Prove L2NP.\n2. Select a known NP-complete language L0.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "1099": {"page_number": 1100, "page_information": "34.4 NP-completeness proofs 1079\n3. Describe an algorithm that computes a function fmapping every instance\nx2f0; 1g/ETXofL0to an instance f. x/ ofL.\n4. Prove that the function fsatis\ufb01es x2L0if and only if f. x/2Lfor all\nx2f0; 1g/ETX.\n5. Prove that the algorithm computing fruns in polynomial time.\n(Steps 2\u20135 show that Lis NP-hard.) This methodology of reducing from a sin-\ngle known NP-complete language is far simpler than the more complicated pro-cess of showing directly how to reduce from every language in NP. ProvingCIRCUIT-SAT2NPC has given us a \u201cfoot in the door.\u201d Because we know that the\ncircuit-satis\ufb01ability problem is NP-complete, we now can prove much more easilythat other problems are NP-complete. Moreover, as we develop a catalog of knownNP-complete problems, we will have more and more choices for languages from\nwhich to reduce.\nFormula satis\ufb01ability\nWe illustrate the reduction methodology by giving an NP-completeness proof for\nthe problem of determining whether a boolean formula, not a circuit, is satis\ufb01able.\nThis problem has the historical honor of being the \ufb01rst problem ever shown to be\nNP-complete.\nWe formulate the (formula) satis\ufb01ability problem in terms of the language SAT\nas follows. An instance of SAT is a boolean formula /RScomposed of\n1.nboolean variables: x\n1;x2;:::;x n;\n2.mboolean connectives: any boolean function with one or two inputs and one\noutput, such as^(AND),_(OR),:(NOT),!(implication),$(if and only\nif); and\n3. parentheses. (Without loss of generality, we assume that there are no redundant\nparentheses, i.e., a formula contains at most one pair of parentheses per booleanconnective.)\nWe can easily encode a boolean formula /RSin a length that is polynomial in nCm.\nAs in boolean combinational circuits, a truth assignment for a boolean formula /RS\nis a set of values for the variables of /RS,a n da satisfying assignment is a truth\nassignment that causes it to evaluate to 1. A formula with a satisfying assignment\nis asatis\ufb01able formula. The satis\ufb01ability problem asks whether a given boolean\nformula is satis\ufb01able; in formal-language terms,\nSATDfh/RSiW/RSis a satis\ufb01able boolean formula g:\nAs an example, the formula", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "1100": {"page_number": 1101, "page_information": "1080 Chapter 34 NP-Completeness\n/RSD..x1!x2/_:..:x1$x3/_x4//^:x2\nhas the satisfying assignment hx1D0; x 2D0; x 3D1; x 4D1i,s i n c e\n/RSD..0!0/_:..:0$1/_1//^:0 (34.2)\nD.1_:.1_1//^1\nD.1_0/^1\nD1;\nand thus this formula /RSbelongs to SAT.\nThe naive algorithm to determine whether an arbitrary boolean formula is satis-\n\ufb01able does not run in polynomial time. A formula with nvariables has 2npossible\nassignments. If the length of h/RSiis polynomial in n, then checking every assign-\nment requires /DEL.2n/time, which is superpolynomial in the length of h/RSi.A s t h e\nfollowing theorem shows, a polynomial-time algorithm is unlikely to exist.\nTheorem 34.9\nSatis\ufb01ability of boolean formulas is NP-complete.\nProof We start by arguing that SAT 2NP. Then we prove that SAT is NP-hard by\nshowing that CIRCUIT-SAT /DC4PSAT; by Lemma 34.8, this will prove the theorem.\nTo show that SAT belongs to NP, we show that a certi\ufb01cate consisting of a\nsatisfying assignment for an input formula /RScan be veri\ufb01ed in polynomial time.\nThe verifying algorithm simply replaces each variable in the formula with its cor-\nresponding value and then evaluates the expression, much as we did in equa-\ntion (34.2) above. This task is easy to do in polynomial time. If the expressionevaluates to 1, then the algorithm has veri\ufb01ed that the formula is satis\ufb01able. Thus,\nthe \ufb01rst condition of Lemma 34.8 for NP-completeness holds.\nTo prove that SAT is NP-hard, we show that CIRCUIT-SAT /DC4\nPSAT. In other\nwords, we need to show how to reduce any instance of circuit satis\ufb01ability to aninstance of formula satis\ufb01ability in polynomial time. We can use induction toexpress any boolean combinational circuit as a boolean formula. We simply lookat the gate that produces the circuit output and inductively express each of thegate\u2019s inputs as formulas. We then obtain the formula for the circuit by writing anexpression that applies the gate\u2019s function to its inputs\u2019 formulas.\nUnfortunately, this straightforward method does not amount to a polynomial-\ntime reduction. As Exercise 34.4-1 asks you to show, shared subformulas\u2014whicharise from gates whose output wires have fan-out of 2 or more\u2014can cause thesize of the generated formula to grow exponentially. Thus, the reduction algorithmmust be somewhat more clever.\nFigure 34.10 illustrates how we overcome this problem, using as an example\nthe circuit from Figure 34.8(a). For each wire x\niin the circuit C, the formula /RS", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "1101": {"page_number": 1102, "page_information": "34.4 NP-completeness proofs 1081\nx6\nx3x4 x7x10 x9x8x5\nx2x1\nFigure 34.10 Reducing circuit satis\ufb01ability to formula satis\ufb01ability. The formula produced by the\nreduction algorithm has a variable for each wire in the circuit.\nhas a variable xi. We can now express how each gate operates as a small formula\ninvolving the variables of its incident wires. For example, the operation of theoutput AND gate is x\n10$.x7^x8^x9/. We call each of these small formulas a\nclause .\nThe formula /RSproduced by the reduction algorithm is the AND of the circuit-\noutput variable with the conjunction of clauses describing the operation of eachgate. For the circuit in the \ufb01gure, the formula is\n/RSDx\n10^.x4$:x3/\n^.x5$.x1_x2//\n^.x6$:x4/\n^.x7$.x1^x2^x4//\n^.x8$.x5_x6//\n^.x9$.x6_x7//\n^.x10$.x7^x8^x9// :\nGiven a circuit C, it is straightforward to produce such a formula /RSin polynomial\ntime.\nWhy is the circuit Csatis\ufb01able exactly when the formula /RSis satis\ufb01able? If C\nhas a satisfying assignment, then each wire of the circuit has a well-de\ufb01ned value,and the output of the circuit is 1. Therefore, when we assign wire values to\nvariables in /RS, each clause of /RSevaluates to 1, and thus the conjunction of all\nevaluates to 1. Conversely, if some assignment causes /RSto evaluate to 1,t h e\ncircuit Cis satis\ufb01able by an analogous argument. Thus, we have shown that\nCIRCUIT-SAT/DC4\nPSAT, which completes the proof.\n", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "1102": {"page_number": 1103, "page_information": "1082 Chapter 34 NP-Completeness\n3-CNF satis\ufb01ability\nWe can prove many problems NP-complete by reducing from formula satis\ufb01ability.\nThe reduction algorithm must handle any input formula, though, and this require-ment can lead to a huge number of cases that we must consider. We often preferto reduce from a restricted language of boolean formulas, so that we need to con-sider fewer cases. Of course, we must not restrict the language so much that itbecomes polynomial-time solvable. One convenient language is 3-CNF satis\ufb01abil-ity, or 3-CNF-SAT.\nWe de\ufb01ne 3-CNF satis\ufb01ability using the following terms. A literal in a boolean\nformula is an occurrence of a variable or its negation. A boolean formula is inconjunctive normal form ,o rCNF , if it is expressed as an AND of clauses , each\nof which is the OR of one or more literals. A boolean formula is in 3-conjunctive\nnormal form ,o r3-CNF , if each clause has exactly three distinct literals.\nFor example, the boolean formula\n.x\n1_:x1_:x2/^.x3_x2_x4/^.:x1_:x3_:x4/\nis in 3-CNF. The \ufb01rst of its three clauses is .x1_:x1_:x2/, which contains the\nthree literals x1,:x1,a n d:x2.\nIn 3-CNF-SAT, we are asked whether a given boolean formula /RSin 3-CNF is\nsatis\ufb01able. The following theorem shows that a polynomial-time algorithm thatcan determine the satis\ufb01ability of boolean formulas is unlikely to exist, even whenthey are expressed in this simple normal form.\nTheorem 34.10\nSatis\ufb01ability of boolean formulas in 3-conjunctive normal form is NP-complete.\nProof The argument we used in the proof of Theorem 34.9 to show that SAT 2\nNP applies equally well here to show that 3-CNF-SAT 2NP. By Lemma 34.8,\ntherefore, we need only show that SAT /DC4\nP3-CNF-SAT.\nWe break the reduction algorithm into three basic steps. Each step progressively\ntransforms the input formula /RScloser to the desired 3-conjunctive normal form.\nThe \ufb01rst step is similar to the one used to prove CIRCUIT-SAT /DC4PSAT in\nTheorem 34.9. First, we construct a binary \u201cparse\u201d tree for the input formula /RS,\nwith literals as leaves and connectives as internal nodes. Figure 34.11 shows sucha parse tree for the formula\n/RSD..x\n1!x2/_:..:x1$x3/_x4//^:x2: (34.3)\nShould the input formula contain a clause such as the OR of several literals, we use\nassociativity to parenthesize the expression fully so that every internal node in theresulting tree has 1or2children. We can now think of the binary parse tree as a\ncircuit for computing the function.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "1103": {"page_number": 1104, "page_information": "34.4 NP-completeness proofs 1083\n:x1x1:x2\nx2\nx3x4y1\ny2\ny3 y4\ny5\ny6^\n$_\n_: !\nFigure 34.11 The tree corresponding to the formula /RSD..x1!x2/_:..:x1$x3/_x4//^:x2:\nMimicking the reduction in the proof of Theorem 34.9, we introduce a vari-\nableyifor the output of each internal node. Then, we rewrite the original for-\nmula /RSas the AND of the root variable and a conjunction of clauses describing the\noperation of each node. For the formula (34.3), the resulting expression is\n/RS0Dy1^.y1$.y2^:x2//\n^.y2$.y3_y4//\n^.y3$.x1!x2//\n^.y4$:y5/\n^.y5$.y6_x4//\n^.y6$.:x1$x3// :\nObserve that the formula /RS0thus obtained is a conjunction of clauses /RS0\ni, each of\nwhich has at most 3 literals. The only requirement that we might fail to meet isthat each clause has to be an OR of 3literals.\nThe second step of the reduction converts each clause /RS\n0\niinto conjunctive normal\nform. We construct a truth table for /RS0\niby evaluating all possible assignments to\nits variables. Each row of the truth table consists of a possible assignment of thevariables of the clause, together with the value of the clause under that assignment.Using the truth-table entries that evaluate to 0, we build a formula in disjunctive\nnormal form (orDNF )\u2014an OR of ANDs\u2014that is equivalent to :/RS\n0\ni.W e t h e n\nnegate this formula and convert it into a CNF formula /RS00\niby using DeMorgan\u2019s", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "1104": {"page_number": 1105, "page_information": "1084 Chapter 34 NP-Completeness\ny1y2x2\n.y1$.y2^:x2//\n111\n 0\n110\n 1\n101\n 0\n100\n 0\n011\n 1\n010\n 0\n001\n 1\n000\n 1\nFigure 34.12 The truth table for the clause .y1$.y2^:x2//.\nlaws for propositional logic,\n:.a^b/D: a_:b;\n:.a_b/D: a^:b;\nto complement all literals, change ORs into ANDs, and change ANDs into ORs.\nIn our example, we convert the clause /RS0\n1D.y1$.y2^:x2//into CNF\nas follows. The truth table for /RS0\n1appears in Figure 34.12. The DNF formula\nequivalent to:/RS0\n1is\n.y1^y2^x2/_.y1^:y2^x2/_.y1^:y2^:x2/_.:y1^y2^:x2/:\nNegating and applying DeMorgan\u2019s laws, we get the CNF formula/RS\n00\n1D.:y1_:y2_:x2/^.:y1_y2_:x2/\n^.:y1_y2_x2/^.y1_:y2_x2/;\nwhich is equivalent to the original clause /RS0\n1.\nAt this point, we have converted each clause /RS0\niof the formula /RS0into a CNF\nformula /RS00\ni, and thus /RS0is equivalent to the CNF formula /RS00consisting of the\nconjunction of the /RS00\ni. Moreover, each clause of /RS00has at most 3literals.\nThe third and \ufb01nal step of the reduction further transforms the formula so that\neach clause has exactly 3distinct literals. We construct the \ufb01nal 3-CNF formula /RS000\nfrom the clauses of the CNF formula /RS00. The formula /RS000also uses two auxiliary\nvariables that we shall call pandq. For each clause Ciof/RS00, we include the\nfollowing clauses in /RS000:\n/SIIfCihas3distinct literals, then simply include Cia sac l a u s eo f /RS000.\n/SIIfCihas 2 distinct literals, that is, if CiD.l1_l2/,w h e r e l1andl2are literals,\nthen include .l1_l2_p/^.l1_l2_:p/as clauses of /RS000. The literals\npand:pmerely ful\ufb01ll the syntactic requirement that each clause of /RS000has", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "1105": {"page_number": 1106, "page_information": "34.4 NP-completeness proofs 1085\nexactly 3distinct literals. Whether pD0orpD1, one of the clauses is\nequivalent to l1_l2, and the other evaluates to 1, which is the identity for AND.\n/SIIfCihas just 1distinct literal l, then include .l_p_q/^.l_p_:q/^\n.l_:p_q/^.l_:p_:q/as clauses of /RS000. Regardless of the values of p\nandq, one of the four clauses is equivalent to l, and the other 3evaluate to 1.\nWe can see that the 3-CNF formula /RS000is satis\ufb01able if and only if /RSis satis\ufb01able\nby inspecting each of the three steps. Like the reduction from C IRCUIT-SAT to\nSAT, the construction of /RS0from /RSin the \ufb01rst step preserves satis\ufb01ability. The\nsecond step produces a CNF formula /RS00that is algebraically equivalent to /RS0.T h e\nthird step produces a 3-CNF formula /RS000that is effectively equivalent to /RS00,s i n c e\nany assignment to the variables pandqproduces a formula that is algebraically\nequivalent to /RS00.\nWe must also show that the reduction can be computed in polynomial time. Con-\nstructing /RS0from /RSintroduces at most 1variable and 1clause per connective in /RS.\nConstructing /RS00from /RS0can introduce at most 8clauses into /RS00for each clause\nfrom /RS0, since each clause of /RS0has at most 3variables, and the truth table for\neach clause has at most 23D8rows. The construction of /RS000from /RS00introduces\nat most 4clauses into /RS000for each clause of /RS00. Thus, the size of the resulting\nformula /RS000is polynomial in the length of the original formula. Each of the con-\nstructions can easily be accomplished in polynomial time.\nExercises\n34.4-1\nConsider the straightforward (nonpolynomial-time) reduction in the proof of The-orem 34.9. Describe a circuit of size nthat, when converted to a formula by this\nmethod, yields a formula whose size is exponential in n.\n34.4-2\nShow the 3-CNF formula that results when we use the method of Theorem 34.10\non the formula (34.3).\n34.4-3\nProfessor Jagger proposes to show that SAT /DC4\nP3-CNF-SAT by using only the\ntruth-table technique in the proof of Theorem 34.10, and not the other steps. Thatis, the professor proposes to take the boolean formula /RS, form a truth table for\nits variables, derive from the truth table a formula in 3-DNF that is equivalentto:/RS, and then negate and apply DeMorgan\u2019s laws to produce a 3-CNF formula\nequivalent to /RS. Show that this strategy does not yield a polynomial-time reduction.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "1106": {"page_number": 1107, "page_information": "1086 Chapter 34 NP-Completeness\n34.4-4\nShow that the problem of determining whether a boolean formula is a tautology iscomplete for co-NP. ( Hint: See Exercise 34.3-7.)\n34.4-5\nShow that the problem of determining the satis\ufb01ability of boolean formulas in dis-junctive normal form is polynomial-time solvable.\n34.4-6\nSuppose that someone gives you a polynomial-time algorithm to decide formula\nsatis\ufb01ability. Describe how to use this algorithm to \ufb01nd satisfying assignments in\npolynomial time.\n34.4-7\nLet 2-CNF-SAT be the set of satis\ufb01able boolean formulas in CNF with exactly 2literals per clause. Show that 2-CNF-SAT 2P. Make your algorithm as ef\ufb01cient as\npossible. ( Hint: Observe that x_yis equivalent to:x!y. Reduce 2-CNF-SAT\nto an ef\ufb01ciently solvable problem on a directed graph.)\n34.5 NP-complete problems\nNP-complete problems arise in diverse domains: boolean logic, graphs, arithmetic,network design, sets and partitions, storage and retrieval, sequencing and schedul-ing, mathematical programming, algebra and number theory, games and puzzles,automata and language theory, program optimization, biology, chemistry, physics,and more. In this section, we shall use the reduction methodology to provide NP-completeness proofs for a variety of problems drawn from graph theory and setpartitioning.\nFigure 34.13 outlines the structure of the NP-completeness proofs in this section\nand Section 34.4. We prove each language in the \ufb01gure to be NP-complete by\nreduction from the language that points to it. At the root is CIRCUIT-SAT, which\nwe proved NP-complete in Theorem 34.7.\n34.5.1 The clique problem\nAclique in an undirected graph GD.V; E/ is a subset V\n0/DC2Vof vertices, each\npair of which is connected by an edge in E. In other words, a clique is a complete\nsubgraph of G.T h e sizeof a clique is the number of vertices it contains. The\nclique problem is the optimization problem of \ufb01nding a clique of maximum size in", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "1107": {"page_number": 1108, "page_information": "34.5 NP-complete problems 1087\nCIRCUIT-SAT\nSAT\n3-CNF-SAT\nCLIQUE\nVERTEX-COVERSUBSET-SUM\nHAM-CYCLE\nTSP\nFigure 34.13 The structure of NP-completeness proofs in Sections 34.4 and 34.5. All proofs ulti-\nmately follow by reduction from the NP-completeness of CIRCUIT-SAT.\na graph. As a decision problem, we ask simply whether a clique of a given size k\nexists in the graph. The formal de\ufb01nition is\nCLIQUEDfhG; kiWGis a graph containing a clique of size kg:\nA naive algorithm for determining whether a graph GD.V; E/ withjVjver-\ntices has a clique of size kis to list all k-subsets of V, and check each one to\nsee whether it forms a clique. The running time of this algorithm is /DEL.k2/NULjVj\nk/SOH\n/,\nwhich is polynomial if kis a constant. In general, however, kcould be nearjVj=2,\nin which case the algorithm runs in superpolynomial time. Indeed, an ef\ufb01cientalgorithm for the clique problem is unlikely to exist.\nTheorem 34.11\nThe clique problem is NP-complete.\nProof To show that CLIQUE 2NP, for a given graph GD.V; E/ ,w eu s et h e\nsetV\n0/DC2Vof vertices in the clique as a certi\ufb01cate for G. We can check whether V0\nis a clique in polynomial time by checking whether, for each pair u; /ETB2V0,t h e\nedge .u; /ETB/ belongs to E.\nWe next prove that 3-CNF-SAT /DC4PCLIQUE, which shows that the clique prob-\nlem is NP-hard. You might be surprised that we should be able to prove such aresult, since on the surface logical formulas seem to have little to do with graphs.\nThe reduction algorithm begins with an instance of 3-CNF-SAT. Let /RSD\nC\n1^C2^/SOH/SOH/SOH^ Ckbe a boolean formula in 3-CNF with kclauses. For rD", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "1108": {"page_number": 1109, "page_information": "1088 Chapter 34 NP-Completeness\nx1x1\nx2 x2\nx3 x3:x1:x2:x3C1Dx1_:x2_:x3\nC2D:x1_x2_x3 C3Dx1_x2_x3\nFigure 34.14 The graph Gderived from the 3-CNF formula /RSDC1^C2^C3,w h e r e C1D\n.x1_:x2_:x3/,C2D.:x1_x2_x3/,a n d C3D.x1_x2_x3/, in reducing 3-CNF-SAT to\nCLIQUE. A satisfying assignment of the formula has x2D0,x3D1,a n d x1either 0or1.T h i s\nassignment satis\ufb01es C1with:x2, and it satis\ufb01es C2andC3withx3, corresponding to the clique\nwith lightly shaded vertices.\n1 ;2;:::;k , each clause Crhas exactly three distinct literals lr\n1,lr\n2,a n d lr\n3.W es h a l l\nconstruct a graph Gsuch that /RSis satis\ufb01able if and only if Ghas a clique of size k.\nWe construct the graph GD.V; E/ as follows. For each clause CrD\n.lr\n1_lr\n2_lr\n3/in/RS, we place a triple of vertices /ETBr\n1,/ETBr\n2,a n d /ETBr\n3intoV. We put\nan edge between two vertices /ETBr\niand/ETBs\njif both of the following hold:\n/SI/ETBr\niand/ETBs\njare in different triples, that is, r\u00a4s,a n d\n/SItheir corresponding literals are consistent ,t h a ti s , lr\niis not the negation of ls\nj.\nWe can easily build this graph from /RSin polynomial time. As an example of this\nconstruction, if we have\n/RSD.x1_:x2_:x3/^.:x1_x2_x3/^.x1_x2_x3/;\nthenGis the graph shown in Figure 34.14.\nWe must show that this transformation of /RSintoGis a reduction. First, suppose\nthat/RShas a satisfying assignment. Then each clause Crcontains at least one\nliteral lr\nithat is assigned 1, and each such literal corresponds to a vertex /ETBr\ni. Picking\none such \u201ctrue\u201d literal from each clause yields a set V0ofkvertices. We claim that\nV0is a clique. For any two vertices /ETBr\ni;/ETBs\nj2V0,w h e r e r\u00a4s, both corresponding\nliterals lr\niandls\njmap to 1by the given satisfying assignment, and thus the literals", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "1109": {"page_number": 1110, "page_information": "34.5 NP-complete problems 1089\ncannot be complements. Thus, by the construction of G, the edge ./ETBr\ni;/ETBs\nj/belongs\ntoE.\nConversely, suppose that Ghas a clique V0of size k. No edges in Gconnect\nvertices in the same triple, and so V0contains exactly one vertex per triple. We can\nassign 1to each literal lr\nisuch that /ETBr\ni2V0without fear of assigning 1to both a\nliteral and its complement, since Gcontains no edges between inconsistent literals.\nEach clause is satis\ufb01ed, and so /RSis satis\ufb01ed. (Any variables that do not correspond\nto a vertex in the clique may be set arbitrarily.)\nIn the example of Figure 34.14, a satisfying assignment of /RShasx2D0and\nx3D1. A corresponding clique of size kD3consists of the vertices correspond-\ning to:x2from the \ufb01rst clause, x3from the second clause, and x3from the third\nclause. Because the clique contains no vertices corresponding to either x1or:x1,\nwe can set x1to either 0or1in this satisfying assignment.\nObserve that in the proof of Theorem 34.11, we reduced an arbitrary instance\nof 3-CNF-SAT to an instance of CLIQUE with a particular structure. You mightthink that we have shown only that CLIQUE is NP-hard in graphs in which thevertices are restricted to occur in triples and in which there are no edges betweenvertices in the same triple. Indeed, we have shown that CLIQUE is NP-hard onlyin this restricted case, but this proof suf\ufb01ces to show that CLIQUE is NP-hard ingeneral graphs. Why? If we had a polynomial-time algorithm that solved CLIQUEon general graphs, it would also solve CLIQUE on restricted graphs.\nThe opposite approach\u2014reducing instances of 3-CNF-SAT with a special struc-\nture to general instances of CLIQUE\u2014would not have suf\ufb01ced, however. Whynot? Perhaps the instances of 3-CNF-SAT that we chose to reduce from were\u201ceasy,\u201d and so we would not have reduced an NP-hard problem to CLIQUE.\nObserve also that the reduction used the instance of 3-CNF-SAT, but not the\nsolution. We would have erred if the polynomial-time reduction had relied on\nknowing whether the formula /RSis satis\ufb01able, since we do not know how to decide\nwhether /RSis satis\ufb01able in polynomial time.\n34.5.2 The vertex-cover problem\nAvertex cover of an undirected graph GD.V; E/ is a subset V\n0/DC2Vsuch that\nif.u; /ETB/2E,t h e n u2V0or/ETB2V0(or both). That is, each vertex \u201ccovers\u201d its\nincident edges, and a vertex cover for Gis a set of vertices that covers all the edges\ninE.T h e sizeof a vertex cover is the number of vertices in it. For example, the\ngraph in Figure 34.15(b) has a vertex cover fw;\u00b4gof size 2.\nThevertex-cover problem is to \ufb01nd a vertex cover of minimum size in a given\ngraph. Restating this optimization problem as a decision problem, we wish to", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "1110": {"page_number": 1111, "page_information": "1090 Chapter 34 NP-Completeness\nu v\ny xz w\n(a)u v\ny xz w\n(b)\nFigure 34.15 Reducing CLIQUE to VERTEX-COVER. (a)An undirected graph GD.V; E/ with\nclique V0Dfu; /ETB; x; yg.(b)The graph\n Gproduced by the reduction algorithm that has vertex cover\nV/NULV0Dfw;\u00b4g.\ndetermine whether a graph has a vertex cover of a given size k. As a language, we\nde\ufb01ne\nVERTEX-COVER DfhG; kiWgraph Ghas a vertex cover of size kg:\nThe following theorem shows that this problem is NP-complete.\nTheorem 34.12\nThe vertex-cover problem is NP-complete.\nProof We \ufb01rst show that VERTEX-COVER 2NP. Suppose we are given a graph\nGD.V; E/ and an integer k. The certi\ufb01cate we choose is the vertex cover V0/DC2V\nitself. The veri\ufb01cation algorithm af\ufb01rms that jV0jDk, and then it checks, for each\nedge .u; /ETB/2E,t h a t u2V0or/ETB2V0. We can easily verify the certi\ufb01cate in\npolynomial time.\nWe prove that the vertex-cover problem is NP-hard by showing that CLIQUE /DC4P\nVERTEX-COVER. This reduction relies on the notion of the \u201ccomplement\u201d of a\ngraph. Given an undirected graph GD.V; E/ ,w ed e \ufb01 n et h e complement ofG\nas\nGD.V;\nE/,w h e r e\n EDf.u; /ETB/Wu; /ETB2V;u\u00a4/ETB;and.u; /ETB/62Eg.I n o t h e r\nwords,\n Gis the graph containing exactly those edges that are not in G. Figure 34.15\nshows a graph and its complement and illustrates the reduction from CLIQUE toVERTEX-COVER.\nThe reduction algorithm takes as input an instance hG;kiof the clique problem.\nIt computes the complement\nG, which we can easily do in polynomial time. The\noutput of the reduction algorithm is the instance h\nG;jVj/NULkiof the vertex-cover\nproblem. To complete the proof, we show that this transformation is indeed a", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "1111": {"page_number": 1112, "page_information": "34.5 NP-complete problems 1091\nreduction: the graph Ghas a clique of size kif and only if the graph\n Gh a sav e r t e x\ncover of sizejVj/NULk.\nSuppose that Ghas a clique V0/DC2VwithjV0jDk. We claim that V/NULV0is a\nvertex cover in\n G.L e t .u; /ETB/ be any edge in\n E. Then, .u; /ETB/62E, which implies\nthat at least one of uor/ETBdoes not belong to V0, since every pair of vertices in V0is\nconnected by an edge of E. Equivalently, at least one of uor/ETBis inV/NULV0,w h i c h\nmeans that edge .u; /ETB/ is covered by V/NULV0.S i n c e .u; /ETB/ was chosen arbitrarily\nfrom\n E, every edge of\n Eis covered by a vertex in V/NULV0. Hence, the set V/NULV0,\nwhich has sizejVj/NULk, forms a vertex cover for\n G.\nConversely, suppose that\n Ghas a vertex cover V0/DC2V,w h e r ejV0jDjVj/NULk.\nThen, for all u; /ETB2V,i f.u; /ETB/2\nE,t h e n u2V0or/ETB2V0or both. The\ncontrapositive of this implication is that for all u; /ETB2V,i fu62V0and/ETB62V0,\nthen.u; /ETB/2E. In other words, V/NULV0is a clique, and it has size jVj/NULjV0jDk.\nSince VERTEX-COVER is NP-complete, we don\u2019t expect to \ufb01nd a polynomial-\ntime algorithm for \ufb01nding a minimum-size vertex cover. Section 35.1 presents apolynomial-time \u201capproximation algorithm,\u201d however, which produces \u201capproxi-mate\u201d solutions for the vertex-cover problem. The size of a vertex cover producedby the algorithm is at most twice the minimum size of a vertex cover.\nThus, we shouldn\u2019t give up hope just because a problem is NP-complete. We\nmay be able to design a polynomial-time approximation algorithm that obtainsnear-optimal solutions, even though \ufb01nding an optimal solution is NP-complete.Chapter 35 gives several approximation algorithms for NP-complete problems.\n34.5.3 The hamiltonian-cycle problem\nWe now return to the hamiltonian-cycle problem de\ufb01ned in Section 34.2.\nTheorem 34.13\nThe hamiltonian cycle problem is NP-complete.\nProof We \ufb01rst show that HAM-CYCLE belongs to NP. Given a graph GD\n.V; E/ , our certi\ufb01cate is the sequence of jVjvertices that makes up the hamiltonian\ncycle. The veri\ufb01cation algorithm checks that this sequence contains each vertex\ninVexactly once and that with the \ufb01rst vertex repeated at the end, it forms a cycle\ninG. That is, it checks that there is an edge between each pair of consecutive\nvertices and between the \ufb01rst and last vertices. We can verify the certi\ufb01cate inpolynomial time.\nWe now prove that VERTEX-COVER /DC4\nPHAM-CYCLE, which shows that\nHAM-CYCLE is NP-complete. Given an undirected graph GD.V; E/ and an", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "1112": {"page_number": 1113, "page_information": "1092 Chapter 34 NP-Completeness\n[u,v,1]\n[u,v,2]\n[u,v,3]\n[u,v,4]\n[u,v,5]\n[u,v,6][v,u,1]\n[v,u,2]\n[v,u,3]\n[v,u,4]\n[v,u,5]\n[v,u,6]Wuv\n(a)Wuv\n(b)[u,v,1]\n[u,v,6][v,u,1]\n[v,u,6]Wuv\n(c)[u,v,1]\n[u,v,6][v,u,1]\n[v,u,6]Wuv\n(d)[u,v,1]\n[u,v,6][v,u,1]\n[v,u,6]\nFigure 34.16 The widget used in reducing the vertex-cover problem to the hamiltonian-cycle prob-\nlem. An edge .u; /ETB/ of graph Gcorresponds to widget Wu/ETBin the graph G0created in the reduction.\n(a)The widget, with individual vertices labeled. (b)\u2013(d) The shaded paths are the only possible ones\nthrough the widget that include all vertices, assuming that the only connections from the widget to\nthe remainder of G0are through vertices \u0152u; /ETB; 1/c141 ,\u0152u; /ETB; 6/c141 ,\u0152/ETB; u; 1/c141 ,a n d \u0152/ETB; u; 6/c141 .\ninteger k, we construct an undirected graph G0D.V0;E0/that has a hamiltonian\ncycle if and only if Ghas a vertex cover of size k.\nOur construction uses a widget , which is a piece of a graph that enforces certain\nproperties. Figure 34.16(a) shows the widget we use. For each edge .u; /ETB/2E,t h e\ngraph G0that we construct will contain one copy of this widget, which we denote\nbyWu/ETB. We denote each vertex in Wu/ETBby\u0152 u ;/ETB;i/c141 or\u0152 /ETB;u ;i/c141 ,w h e r e 1/DC4i/DC46,s o\nthat each widget Wu/ETBcontains 12vertices. Widget Wu/ETBalso contains the 14edges\nshown in Figure 34.16(a).\nAlong with the internal structure of the widget, we enforce the properties we\nwant by limiting the connections between the widget and the remainder of thegraph G\n0that we construct. In particular, only vertices \u0152 u ;/ETB;1 /c141 ,\u0152 u ;/ETB;6 /c141 ,\u0152 /ETB;u ;1 /c141 ,\nand\u0152 /ETB;u ;6 /c141 will have edges incident from outside Wu/ETB. Any hamiltonian cycle\nofG0must traverse the edges of Wu/ETBin one of the three ways shown in Fig-\nures 34.16(b)\u2013(d). If the cycle enters through vertex \u0152 u ;/ETB;1 /c141 , it must exit through\nvertex \u0152 u ;/ETB;6 /c141 , and it either visits all 12of the widget\u2019s vertices (Figure 34.16(b))\nor the six vertices \u0152 u ;/ETB;1 /c141 through \u0152 u ;/ETB;6 /c141 (Figure 34.16(c)). In the latter case,\nthe cycle will have to reenter the widget to visit vertices \u0152 /ETB;u ;1 /c141 through \u0152 /ETB;u ;6 /c141 .\nSimilarly, if the cycle enters through vertex \u0152 /ETB;u ;1 /c141 , it must exit through ver-\ntex\u0152 /ETB;u ;6 /c141 , and it either visits all 12of the widget\u2019s vertices (Figure 34.16(d)) or\nthe six vertices \u0152 /ETB;u ;1 /c141 through \u0152 /ETB;u ;6 /c141 (Figure 34.16(c)). No other paths through\nthe widget that visit all 12vertices are possible. In particular, it is impossible to\nconstruct two vertex-disjoint paths, one of which connects \u0152 u ;/ETB;1 /c141 to\u0152 /ETB;u ;6 /c141 and\nthe other of which connects \u0152 /ETB;u ;1 /c141 to\u0152 u ;/ETB;6 /c141 , such that the union of the two paths\ncontains all of the widget\u2019s vertices.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "1113": {"page_number": 1114, "page_information": "34.5 NP-complete problems 1093\n[w,x,1]\n[w,x,6][x,w,1]\n[x,w,6]Wwx(b)\n[x,y,1]\n[x,y,6][y,x,1]\n[y,x,6]Wxy[w,y,1]\n[w,y,6][y,w,1]\n[y,w,6]Wwy[w,z,1]\n[w,z,6][z,w,1]\n[z,w,6]Wwzs1\ns2w x\nz y(a)\nFigure 34.17 Reducing an instance of the vertex-cover problem to an instance of the hamiltonian-\ncycle problem. (a)An undirected graph Gwith a vertex cover of size 2, consisting of the lightly\nshaded vertices wandy.(b)The undirected graph G0produced by the reduction, with the hamilto-\nnian path corresponding to the vertex cover shaded. The vertex cover fw;ygcorresponds to edges\n.s1;\u0152 w;x;1 /c141 / and.s2;\u0152 y;x;1 /c141 / appearing in the hamiltonian cycle.\nThe only other vertices in V0other than those of widgets are selector vertices\ns1;s2;:::;s k. We use edges incident on selector vertices in G0to select the k\nvertices of the cover in G.\nIn addition to the edges in widgets, E0contains two other types of edges, which\nFigure 34.17 shows. First, for each vertex u2V, we add edges to join pairs\nof widgets in order to form a path containing all widgets corresponding to edges\nincident on uinG. We arbitrarily order the vertices adjacent to each vertex\nu2Vasu.1/;u.2/;:::;u.degree .u//, where degree .u/is the number of vertices\nadjacent to u. We create a path in G0through all the widgets corresponding\nto edges incident on uby adding to E0the edgesf.\u0152u; u.i/; 6/c141; \u0152u; u.iC1/;1 /c141 /W\n1/DC4i/DC4degree .u//NUL1g. In Figure 34.17, for example, we order the vertices ad-\njacent to wasx;y;\u00b4 , and so graph G0in part (b) of the \ufb01gure includes the edges", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "1114": {"page_number": 1115, "page_information": "1094 Chapter 34 NP-Completeness\n.\u0152w;x;6/c141;\u0152w;y;1/c141/ and.\u0152w;y;6/c141;\u0152w;\u00b4;1/c141/ . For each vertex u2V, these edges\ninG0\ufb01ll in a path containing all widgets corresponding to edges incident on u\ninG.\nThe intuition behind these edges is that if we choose a vertex u2Vin the vertex\ncover of G, we can construct a path from \u0152u; u.1/;1 /c141to\u0152u; u.degree .u//;6 /c141inG0that\n\u201ccovers\u201d all widgets corresponding to edges incident on u. That is, for each of these\nwidgets, say Wu;u.i/, the path either includes all 12vertices (if uis in the vertex\ncover but u.i/is not) or just the six vertices \u0152u; u.i/; 1/c141; \u0152u; u.i/;2 /c141 ;:::;\u0152 u ;u.i/;6 /c141(if\nbothuandu.i/are in the vertex cover).\nThe \ufb01nal type of edge in E0joins the \ufb01rst vertex \u0152u; u.1/;1 /c141and the last vertex\n\u0152u; u.degree .u//;6 /c141of each of these paths to each of the selector vertices. That is, we\ninclude the edges\nf.sj;\u0152 u ;u.1/;1 /c141 /Wu2Vand1/DC4j/DC4kg\n[f.sj;\u0152 u ;u.degree .u//;6 /c141 /Wu2Vand1/DC4j/DC4kg:\nNext, we show that the size of G0is polynomial in the size of G, and hence we\ncan construct G0in time polynomial in the size of G. The vertices of G0are those\nin the widgets, plus the selector vertices. With 12vertices per widget, plus k/DC4jVj\nselector vertices, we have a total of\njV0jD12jEjCk\n/DC412jEjCjVj\nvertices. The edges of G0are those in the widgets, those that go between widgets,\nand those connecting selector vertices to widgets. Each widget contains 14edges,\ntotaling 14jEjin all widgets. For each vertex u2V,g r a p h G0has degree .u//NUL1\nedges going between widgets, so that summed over all vertices in V,\nX\nu2V.degree .u//NUL1/D2jEj/NULjVj\nedges go between widgets. Finally, G0has two edges for each pair consisting of a\nselector vertex and a vertex of V, totaling 2kjVjsuch edges. The total number of\nedges of G0is therefore\njE0jD.14jEj/C.2jEj/NULjVj/C.2kjVj/\nD16jEjC.2k/NUL1/jVj\n/DC416jEjC.2jVj/NUL1/jVj:\nNow we show that the transformation from graph GtoG0is a reduction. That is,\nwe must show that Ghas a vertex cover of size kif and only if G0has a hamiltonian\ncycle.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "1115": {"page_number": 1116, "page_information": "34.5 NP-complete problems 1095\nSuppose that GD.V; E/ h a sav e r t e xc o v e r V/ETX/DC2Vof size k.L e t\nV/ETXDfu1;u2;:::;u kg. As Figure 34.17 shows, we form a hamiltonian cy-\ncle in G0by including the following edges10for each vertex uj2V/ETX. Include\nedges\u02da\n.\u0152uj;u.i/\nj; 6/c141; \u0152u j;u.iC1/\nj;1 /c141 /W1/DC4i/DC4degree .uj//NUL1/TAB\n, which connect all\nwidgets corresponding to edges incident on uj. We also include the edges within\nthese widgets as Figures 34.16(b)\u2013(d) show, depending on whether the edge is cov-ered by one or two vertices in V\n/ETX. The hamiltonian cycle also includes the edges\nf.sj;\u0152 uj;u.1/\nj;1 /c141 /W1/DC4j/DC4kg\n[f.sjC1;\u0152 uj;u.degree .uj//\nj ;6 /c141 /W1/DC4j/DC4k/NUL1g\n[f.s1;\u0152 uk;u.degree .uk//\nk;6 /c141 /g:\nBy inspecting Figure 34.17, you can verify that these edges form a cycle. The cycle\nstarts at s1, visits all widgets corresponding to edges incident on u1, then visits s2,\nvisits all widgets corresponding to edges incident on u2, and so on, until it returns\ntos1. The cycle visits each widget either once or twice, depending on whether one\nor two vertices of V/ETXcover its corresponding edge. Because V/ETXis a vertex cover\nforG, each edge in Eis incident on some vertex in V/ETX, and so the cycle visits each\nvertex in each widget of G0. Because the cycle also visits every selector vertex, it\nis hamiltonian.\nConversely, suppose that G0D.V0;E0/has a hamiltonian cycle C/DC2E0.W e\nclaim that the set\nV/ETXDfu2VW.sj;\u0152 u ;u.1/;1 /c141 /2Cfor some 1/DC4j/DC4kg (34.4)\nis a vertex cover for G. To see why, partition Cinto maximal paths that start at\nsome selector vertex si, traverse an edge .si;\u0152 u ;u.1/;1 /c141 /for some u2V,a n de n d\nat a selector vertex sjwithout passing through any other selector vertex. Let us call\neach such path a \u201ccover path.\u201d From how G0is constructed, each cover path must\nstart at some si, take the edge .si;\u0152 u ;u.1/;1 /c141 /for some vertex u2V, pass through\nall the widgets corresponding to edges in Eincident on u, and then end at some\nselector vertex sj. We refer to this cover path as pu, and by equation (34.4), we\nputuintoV/ETX. Each widget visited by pumust be Wu/ETBorW/ETBufor some /ETB2V.\nFor each widget visited by pu, its vertices are visited by either one or two cover\npaths. If they are visited by one cover path, then edge .u; /ETB/2Eis covered in G\nby vertex u. If two cover paths visit the widget, then the other cover path must\nbep/ETB, which implies that /ETB2V/ETX, and edge .u; /ETB/2Eis covered by both uand/ETB.\n10Technically, we de\ufb01ne a cycle in terms of vertices rather than edges (see Section B.4). In the\ninterest of clarity, we abuse notation here and de\ufb01ne the hamiltonian cycle in terms of edges.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "1116": {"page_number": 1117, "page_information": "1096 Chapter 34 NP-Completeness\nu v\nx w4\n2 3\n51\n1\nFigure 34.18 An instance of the traveling-salesman problem. Shaded edges represent a minimum-\ncost tour, with cost 7.\nBecause each vertex in each widget is visited by some cover path, we see that each\nedge in Eis covered by some vertex in V/ETX.\n34.5.4 The traveling-salesman problem\nIn the traveling-salesman problem , which is closely related to the hamiltonian-\ncycle problem, a salesman must visit ncities. Modeling the problem as a complete\ngraph with nvertices, we can say that the salesman wishes to make a tour,o r\nhamiltonian cycle, visiting each city exactly once and \ufb01nishing at the city he startsfrom. The salesman incurs a nonnegative integer cost c.i;j/ to travel from city i\nto city j, and the salesman wishes to make the tour whose total cost is minimum,\nwhere the total cost is the sum of the individual costs along the edges of the tour.For example, in Figure 34.18, a minimum-cost tour is hu; w; /ETB; x; ui, with cost 7.\nThe formal language for the corresponding decision problem is\nTSPDfhG; c; kiWGD.V; E/ is a complete graph ;\ncis a function from V/STXV!Z;\nk2Z,a n d\nGhas a traveling-salesman tour with cost at most kg:\nThe following theorem shows that a fast algorithm for the traveling-salesman\nproblem is unlikely to exist.\nTheorem 34.14\nThe traveling-salesman problem is NP-complete.\nProof We \ufb01rst show that TSP belongs to NP. Given an instance of the problem,\nwe use as a certi\ufb01cate the sequence of nvertices in the tour. The veri\ufb01cation\nalgorithm checks that this sequence contains each vertex exactly once, sums up the\nedge costs, and checks whether the sum is at most k. This process can certainly be\ndone in polynomial time.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "1117": {"page_number": 1118, "page_information": "34.5 NP-complete problems 1097\nTo prove that TSP is NP-hard, we show that HAM-CYCLE /DC4PTSP. Let\nGD.V; E/ be an instance of HAM-CYCLE. We construct an instance of TSP as\nfollows. We form the complete graph G0D.V; E0/,w h e r e E0Df.i; j /Wi;j2V\nandi\u00a4jg, and we de\ufb01ne the cost function cby\nc.i;j/D(\n0if.i; j /2E;\n1if.i; j /62E:\n(Note that because Gis undirected, it has no self-loops, and so c./ETB;/ETB/D1for all\nvertices /ETB2V.) The instance of TSP is then hG0;c;0i, which we can easily create\nin polynomial time.\nWe now show that graph Ghas a hamiltonian cycle if and only if graph G0has a\ntour of cost at most 0. Suppose that graph Ghas a hamiltonian cycle h. Each edge\ninhbelongs to Eand thus has cost 0inG0. Thus, his a tour in G0with cost 0.\nConversely, suppose that graph G0has a tour h0of cost at most 0. Since the costs\nof the edges in E0are0and1, the cost of tour h0is exactly 0and each edge on the\ntour must have cost 0. Therefore, h0contains only edges in E. We conclude that h0\nis a hamiltonian cycle in graph G.\n34.5.5 The subset-sum problem\nWe next consider an arithmetic NP-complete problem. In the subset-sum problem ,\nwe are given a \ufb01nite set Sof positive integers and an integer target t>0 . We ask\nwhether there exists a subset S0/DC2Swhose elements sum to t. For example,\nifSDf1; 2; 7; 14; 49; 98; 343; 686; 2409; 2793; 16808; 17206; 117705; 117993 g\nandtD138457 , then the subset S0Df1; 2; 7; 98; 343; 686; 2409; 17206; 117705 g\nis a solution.\nAs usual, we de\ufb01ne the problem as a language:\nSUBSET-SUMDfhS;tiWthere exists a subset S0/DC2Ssuch that tDP\ns2S0sg:\nAs with any arithmetic problem, it is important to recall that our standard encoding\nassumes that the input integers are coded in binary. With this assumption in mind,\nwe can show that the subset-sum problem is unlikely to have a fast algorithm.\nTheorem 34.15\nThe subset-sum problem is NP-complete.\nProof To show that SUBSET-SUM is in NP, for an instance hS;tiof the problem,\nwe let the subset S0be the certi\ufb01cate. A veri\ufb01cation algorithm can check whether\ntDP\ns2S0sin polynomial time.\nWe now show that 3-CNF-SAT /DC4PSUBSET-SUM. Given a 3-CNF formula /RS\nover variables x1;x2;:::;x nwith clauses C1;C2;:::;C k, each containing exactly", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "1118": {"page_number": 1119, "page_information": "1098 Chapter 34 NP-Completeness\nthree distinct literals, the reduction algorithm constructs an instance hS; tiof the\nsubset-sum problem such that /RSis satis\ufb01able if and only if there exists a subset\nofSwhose sum is exactly t. Without loss of generality, we make two simplifying\nassumptions about the formula /RS. First, no clause contains both a variable and its\nnegation, for such a clause is automatically satis\ufb01ed by any assignment of valuesto the variables. Second, each variable appears in at least one clause, because itdoes not matter what value is assigned to a variable that appears in no clauses.\nThe reduction creates two numbers in set Sfor each variable x\niand two numbers\ninSfor each clause Cj. We shall create numbers in base 10, where each number\ncontains nCkdigits and each digit corresponds to either one variable or one clause.\nBase 10(and other bases, as we shall see) has the property we need of preventing\ncarries from lower digits to higher digits.\nAs Figure 34.19 shows, we construct set Sand target tas follows. We label\neach digit position by either a variable or a clause. The least signi\ufb01cant kdigits are\nlabeled by the clauses, and the most signi\ufb01cant ndigits are labeled by variables.\n/SIThe target thas a 1in each digit labeled by a variable and a 4in each digit\nlabeled by a clause.\n/SIFor each variable xi, setScontains two integers /ETBiand/ETB0\ni. Each of /ETBiand/ETB0\ni\nhas a 1in the digit labeled by xiand0s in the other variable digits. If literal xi\nappears in clause Cj, then the digit labeled by Cjin/ETBicontains a 1. If lit-\neral:xiappears in clause Cj, then the digit labeled by Cjin/ETB0\nicontains a 1.\nAll other digits labeled by clauses in /ETBiand/ETB0\niare0.\nAll/ETBiand/ETB0\nivalues in set Sare unique. Why? For l\u00a4i,n o/ETBlor/ETB0\nlvalues can\nequal /ETBiand/ETB0\niin the most signi\ufb01cant ndigits. Furthermore, by our simplifying\nassumptions above, no /ETBiand/ETB0\nican be equal in all kleast signi\ufb01cant digits.\nIf/ETBiand/ETB0\niwere equal, then xiand:xiwould have to appear in exactly the\nsame set of clauses. But we assume that no clause contains both xiand:xi\nand that either xior:xiappears in some clause, and so there must be some\nclause Cjfor which /ETBiand/ETB0\nidiffer.\n/SIFor each clause Cj, setScontains two integers sjands0\nj. Each of sjands0\njhas\n0s in all digits other than the one labeled by Cj.F o r sj, there is a 1in the Cj\ndigit, and s0\njhas a 2in this digit. These integers are \u201cslack variables,\u201d which we\nuse to get each clause-labeled digit position to add to the target value of 4.\nSimple inspection of Figure 34.19 demonstrates that all sjands0\njvalues in S\nare unique in set S.\nNote that the greatest sum of digits in any one digit position is 6, which occurs in\nthe digits labeled by clauses (three 1s from the /ETBiand/ETB0\nivalues, plus 1and2from", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "1119": {"page_number": 1120, "page_information": "34.5 NP-complete problems 1099\n=1001001\n=1000110=0100001=0101110=0010011=0011100=0001000=0002000=0000100=0000200=0000010=0000020=0000001=0000002\n=1114444x1x2x3C1C2C3C4\n/ETB1\n/ETB0\n1\n/ETB2\n/ETB0\n2\n/ETB3\n/ETB0\n3\ns1\ns0\n1\ns2\ns0\n2\ns3\ns0\n3\ns4\ns0\n4\nt\nFigure 34.19 The reduction of 3-CNF-SAT to SUBSET-SUM. The formula in 3-CNF is /RSD\nC1^C2^C3^C4,w h e r e C1D.x1_:x2_:x3/,C2D.:x1_:x2_:x3/,C3D.:x1_:x2_x3/,\nandC4D.x1_x2_x3/. A satisfying assignment of /RSishx1D0; x2D0; x3D1i.T h e s e t S\nproduced by the reduction consists of the base- 10numbers shown; reading from top to bottom, SD\nf1001001; 1000110; 100001; 101110; 10011; 11100; 1000; 2000; 100; 200; 10; 20; 1; 2 g.T h et a r g e t t\nis1114444 . The subset S0/DC2Sis lightly shaded, and it contains /ETB0\n1,/ETB0\n2,a n d /ETB3, corresponding to the\nsatisfying assignment. It also contains slack variables s1,s0\n1,s0\n2,s3,s4,a n d s0\n4to achieve the target\nvalue of 4in the digits labeled by C1through C4.\nthesjands0\njvalues). Interpreting these numbers in base 10, therefore, no carries\ncan occur from lower digits to higher digits.11\nWe can perform the reduction in polynomial time. The set Scontains 2nC2k\nvalues, each of which has nCkdigits, and the time to produce each digit is poly-\nnomial in nCk.T h et a r g e t thasnCkdigits, and the reduction produces each in\nconstant time.\nWe now show that the 3-CNF formula /RSis satis\ufb01able if and only if there exists\na subset S0/DC2Swhose sum is t. First, suppose that /RShas a satisfying assignment.\nForiD1 ;2;:::;n ,i fxiD1in this assignment, then include /ETBiinS0. Otherwise,\ninclude /ETB0\ni. In other words, we include in S0exactly the /ETBiand/ETB0\nivalues that cor-\n11In fact, any base b,w h e r e b/NAK7, would work. The instance at the beginning of this subsection is\nthe set Sand target tin Figure 34.19 interpreted in base 7,w i t h Slisted in sorted order.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "1120": {"page_number": 1121, "page_information": "1100 Chapter 34 NP-Completeness\nrespond to literals with the value 1in the satisfying assignment. Having included\neither /ETBior/ETB0\ni, but not both, for all i, and having put 0in the digits labeled by\nvariables in all sjands0\nj, we see that for each variable-labeled digit, the sum of the\nvalues of S0must be 1, which matches those digits of the target t. Because each\nclause is satis\ufb01ed, the clause contains some literal with the value 1. Therefore,\neach digit labeled by a clause has at least one 1contributed to its sum by a /ETBior/ETB0\ni\nvalue in S0. In fact, 1,2,o r3literals may be 1in each clause, and so each clause-\nlabeled digit has a sum of 1,2,o r3from the /ETBiand/ETB0\nivalues in S0. In Figure 34.19\nfor example, literals :x1,:x2,a n d x3have the value 1in a satisfying assignment.\nEach of clauses C1andC4contains exactly one of these literals, and so together /ETB0\n1,\n/ETB0\n2,a n d /ETB3contribute 1to the sum in the digits for C1andC4.C l a u s e C2contains\ntwo of these literals, and /ETB0\n1,/ETB0\n2,a n d /ETB3contribute 2to the sum in the digit for C2.\nClause C3contains all three of these literals, and /ETB0\n1,/ETB0\n2,a n d /ETB3contribute 3to the\nsum in the digit for C3. We achieve the target of 4in each digit labeled by clause Cj\nby including in S0the appropriate nonempty subset of slack variables fsj;s0\njg.I n\nFigure 34.19, S0includes s1,s0\n1,s0\n2,s3,s4,a n d s0\n4. Since we have matched the target\nin all digits of the sum, and no carries can occur, the values of S0sum to t.\nNow, suppose that there is a subset S0/DC2Sthat sums to t. The subset S0must\ninclude exactly one of /ETBiand/ETB0\nifor each iD1 ;2;:::;n , for otherwise the digits\nlabeled by variables would not sum to 1.I f/ETBi2S0, we set xiD1. Otherwise,\n/ETB0\ni2S0, and we set xiD0. We claim that every clause Cj,f o rjD1 ;2;:::;k ,i s\nsatis\ufb01ed by this assignment. To prove this claim, note that to achieve a sum of 4in\nthe digit labeled by Cj, the subset S0must include at least one /ETBior/ETB0\nivalue that\nhas a 1 in the digit labeled by Cj, since the contributions of the slack variables sj\nands0\njtogether sum to at most 3.I fS0includes a /ETBithat has a 1 in Cj\u2019s position,\nthen the literal xiappears in clause Cj. Since we have set xiD1when /ETBi2S0,\nclause Cjis satis\ufb01ed. If S0includes a /ETB0\nithat has a 1 in that position, then the\nliteral:xiappears in Cj. Since we have set xiD0when /ETB0\ni2S0,c l a u s e Cjis\nagain satis\ufb01ed. Thus, all clauses of /RSare satis\ufb01ed, which completes the proof.\nExercises\n34.5-1\nThesubgraph-isomorphism problem takes two undirected graphs G1andG2,a n d\nit asks whether G1is isomorphic to a subgraph of G2. Show that the subgraph-\nisomorphism problem is NP-complete.\n34.5-2\nG i v e na ni n t e g e r m/STXnmatrix Aand an integer m-vector b,t h e0-1 integer-\nprogramming problem asks whether there exists an integer n-vector xwith ele-", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "1121": {"page_number": 1122, "page_information": "Problems for Chapter 34 1101\nments in the setf0; 1gsuch that Ax/DC4b. Prove that 0-1 integer programming is\nNP-complete. ( Hint: Reduce from 3-CNF-SAT.)\n34.5-3\nTheinteger linear-programming problem is like the 0-1 integer-programming\nproblem given in Exercise 34.5-2, except that the values of the vector xmay be\nany integers rather than just 0or1. Assuming that the 0-1 integer-programming\nproblem is NP-hard, show that the integer linear-programming problem is NP-complete.\n34.5-4\nShow how to solve the subset-sum problem in polynomial time if the target value t\nis expressed in unary.\n34.5-5\nTheset-partition problem takes as input a set Sof numbers. The question is\nwhether the numbers can be partitioned into two sets Aand\nADS/NULAsuch\nthatP\nx2AxDP\nx2\nAx. Show that the set-partition problem is NP-complete.\n34.5-6\nShow that the hamiltonian-path problem is NP-complete.\n34.5-7\nThelongest-simple-cycle problem is the problem of determining a simple cycle\n(no repeated vertices) of maximum length in a graph. Formulate a related decisionproblem, and show that the decision problem is NP-complete.\n34.5-8\nIn the half 3-CNF satis\ufb01ability problem, we are given a 3-CNF formula /RSwithn\nvariables and mclauses, where mis even. We wish to determine whether there\nexists a truth assignment to the variables of /RSsuch that exactly half the clauses\nevaluate to 0and exactly half the clauses evaluate to 1. Prove that the half 3-CNF\nsatis\ufb01ability problem is NP-complete.\nProblems\n34-1 Independent set\nAnindependent set of a graph GD.V; E/ i sas u b s e t V0/DC2Vof vertices such\nthat each edge in Eis incident on at most one vertex in V0.T h e independent-set\nproblem is to \ufb01nd a maximum-size independent set in G.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "1122": {"page_number": 1123, "page_information": "1102 Chapter 34 NP-Completeness\na.Formulate a related decision problem for the independent-set problem, and\nprove that it is NP-complete. ( Hint: Reduce from the clique problem.)\nb.Suppose that you are given a \u201cblack-box\u201d subroutine to solve the decision prob-\nlem you de\ufb01ned in part (a). Give an algorithm to \ufb01nd an independent set of max-imum size. The running time of your algorithm should be polynomial in jVj\nandjEj, counting queries to the black box as a single step.\nAlthough the independent-set decision problem is NP-complete, certain special\ncases are polynomial-time solvable.\nc.Give an ef\ufb01cient algorithm to solve the independent-set problem when each ver-\ntex in Ghas degree 2. Analyze the running time, and prove that your algorithm\nworks correctly.\nd.Give an ef\ufb01cient algorithm to solve the independent-set problem when Gis\nbipartite. Analyze the running time, and prove that your algorithm works cor-rectly. ( Hint: Use the results of Section 26.3.)\n34-2 Bonnie and Clyde\nBonnie and Clyde have just robbed a bank. They have a bag of money and want\nto divide it up. For each of the following scenarios, either give a polynomial-timealgorithm, or prove that the problem is NP-complete. The input in each case is al i s to ft h e nitems in the bag, along with the value of each.\na.The bag contains ncoins, but only 2different denominations: some coins are\nworth xdollars, and some are worth ydollars. Bonnie and Clyde wish to divide\nthe money exactly evenly.\nb.The bag contains ncoins, with an arbitrary number of different denominations,\nbut each denomination is a nonnegative integer power of 2, i.e., the possible\ndenominations are 1dollar, 2dollars, 4dollars, etc. Bonnie and Clyde wish to\ndivide the money exactly evenly.\nc.The bag contains nchecks, which are, in an amazing coincidence, made out to\n\u201cBonnie or Clyde.\u201d They wish to divide the checks so that they each get theexact same amount of money.\nd.The bag contains nchecks as in part (c), but this time Bonnie and Clyde are\nwilling to accept a split in which the difference is no larger than 100dollars.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "1123": {"page_number": 1124, "page_information": "Problems for Chapter 34 1103\n34-3 Graph coloring\nMapmakers try to use as few colors as possible when coloring countries on a map,as long as no two countries that share a border have the same color. We can modelthis problem with an undirected graph GD.V; E/ in which each vertex repre-\nsents a country and vertices whose respective countries share a border are adjacent.Then, a k-coloring is a function cWV!f1 ;2;:::;kgsuch that c.u/\u00a4c./ETB/ for\nevery edge .u; /ETB/2E. In other words, the numbers 1 ;2;:::;k represent the kcol-\nors, and adjacent vertices must have different colors. The graph-coloring problem\nis to determine the minimum number of colors needed to color a given graph.\na.Give an ef\ufb01cient algorithm to determine a 2-coloring of a graph, if one exists.\nb.Cast the graph-coloring problem as a decision problem. Show that your deci-\nsion problem is solvable in polynomial time if and only if the graph-coloringproblem is solvable in polynomial time.\nc.Let the language 3-COLOR be the set of graphs that can be 3-colored. Show\nthat if 3-COLOR is NP-complete, then your decision problem from part (b) isNP-complete.\nTo prove that 3-COLOR is NP-complete, we use a reduction from 3-CNF-SAT.\nGiven a formula /RSofmclauses on nvariables x\n1,x2,..., xn, we construct a graph\nGD.V; E/ as follows. The set Vconsists of a vertex for each variable, a vertex\nfor the negation of each variable, 5vertices for each clause, and 3special vertices:\nTRUE ,FALSE ,a n d RED. The edges of the graph are of two types: \u201cliteral\u201d edges\nthat are independent of the clauses and \u201cclause\u201d edges that depend on the clauses.The literal edges form a triangle on the special vertices and also form a triangle onx\ni,:xi,a n d RED foriD1 ;2;:::;n .\nd.Argue that in any 3-coloring cof a graph containing the literal edges, exactly\none of a variable and its negation is colored c.TRUE /and the other is colored\nc.FALSE /. Argue that for any truth assignment for /RS, there exists a 3-coloring\nof the graph containing just the literal edges.\nThe widget shown in Figure 34.20 helps to enforce the condition corresponding to\nac l a u s e .x_y_\u00b4/. Each clause requires a unique copy of the 5vertices that are\nheavily shaded in the \ufb01gure; they connect as shown to the literals of the clause andthe special vertex\nTRUE .\ne.Argue that if each of x,y,a n d \u00b4is colored c.TRUE /orc.FALSE /, then the\nwidget is 3-colorable if and only if at least one of x,y,o r\u00b4is colored c.TRUE /.\nf.Complete the proof that 3-COLOR is NP-complete.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "1124": {"page_number": 1125, "page_information": "1104 Chapter 34 NP-Completeness\nx\ny\nzTRUE\nFigure 34.20 The widget corresponding to a clause .x_y_\u00b4/, used in Problem 34-3.\n34-4 Scheduling with pro\ufb01ts and deadlines\nSuppose that we have one machine and a set of ntasks a1;a2;:::;a n, each of\nwhich requires time on the machine. Each task ajrequires tjtime units on the\nmachine (its processing time), yields a pro\ufb01t of pj, and has a deadline dj.T h e\nmachine can process only one task at a time, and task ajmust run without inter-\nruption for tjconsecutive time units. If we complete task ajby its deadline dj,w e\nreceive a pro\ufb01t pj, but if we complete it after its deadline, we receive no pro\ufb01t. As\nan optimization problem, we are given the processing times, pro\ufb01ts, and deadlinesfor a set of ntasks, and we wish to \ufb01nd a schedule that completes all the tasks and\nreturns the greatest amount of pro\ufb01t. The processing times, pro\ufb01ts, and deadlinesare all nonnegative numbers.\na.State this problem as a decision problem.\nb.Show that the decision problem is NP-complete.\nc.Give a polynomial-time algorithm for the decision problem, assuming that all\nprocessing times are integers from 1ton.(Hint: Use dynamic programming.)\nd.Give a polynomial-time algorithm for the optimization problem, assuming that\nall processing times are integers from 1ton.\nChapter notes\nThe book by Garey and Johnson [129] provides a wonderful guide to NP-complete-\nness, discussing the theory at length and providing a catalogue of many problems\nthat were known to be NP-complete in 1979. The proof of Theorem 34.13 isadapted from their book, and the list of NP-complete problem domains at the begin-ning of Section 34.5 is drawn from their table of contents. Johnson wrote a series", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "1125": {"page_number": 1126, "page_information": "Notes for Chapter 34 1105\nof 23 columns in the Journal of Algorithms between 1981 and 1992 reporting new\ndevelopments in NP-completeness. Hopcroft, Motwani, and Ullman [177], Lewisand Papadimitriou [236], Papadimitriou [270], and Sipser [317] have good treat-ments of NP-completeness in the context of complexity theory. NP-completenessand several reductions also appear in books by Aho, Hopcroft, and Ullman [5];Dasgupta, Papadimitriou, and Vazirani [82]; Johnsonbaugh and Schaefer [193];and Kleinberg and Tardos [208].\nThe class P was introduced in 1964 by Cobham [72] and, independently, in 1965\nby Edmonds [100], who also introduced the class NP and conjectured that P \u00a4NP.\nThe notion of NP-completeness was proposed in 1971 by Cook [75], who gavethe \ufb01rst NP-completeness proofs for formula satis\ufb01ability and 3-CNF satis\ufb01abil-ity. Levin [234] independently discovered the notion, giving an NP-completenessproof for a tiling problem. Karp [199] introduced the methodology of reductionsin 1972 and demonstrated the rich variety of NP-complete problems. Karp\u2019s pa-per included the original NP-completeness proofs of the clique, vertex-cover, andhamiltonian-cycle problems. Since then, thousands of problems have been provento be NP-complete by many researchers. In a talk at a meeting celebrating Karp\u2019s60th birthday in 1995, Papadimitriou remarked, \u201cabout 6000 papers each year havethe term \u2018NP-complete\u2019 on their title, abstract, or list of keywords. This is morethan each of the terms \u2018compiler,\u2019 \u2018database,\u2019 \u2018expert,\u2019 \u2018neural network,\u2019 or \u2018oper-ating system.\u2019 \u201d\nRecent work in complexity theory has shed light on the complexity of computing\napproximate solutions. This work gives a new de\ufb01nition of NP using \u201cprobabilis-\ntically checkable proofs.\u201d This new de\ufb01nition implies that for problems such asclique, vertex cover, the traveling-salesman problem with the triangle inequality,and many others, computing good approximate solutions is NP-hard and hence noeasier than computing optimal solutions. An introduction to this area can be foundin Arora\u2019s thesis [20]; a chapter by Arora and Lund in Hochbaum [172]; a surveyarticle by Arora [21]; a book edited by Mayr, Pr\u00a8 omel, and Steger [246]; and a\nsurvey article by Johnson [191].", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "1126": {"page_number": 1127, "page_information": "35 Approximation Algorithms\nMany problems of practical signi\ufb01cance are NP-complete, yet they are too impor-\ntant to abandon merely because we don\u2019t know how to \ufb01nd an optimal solution inpolynomial time. Even if a problem is NP-complete, there may be hope. We have atleast three ways to get around NP-completeness. First, if the actual inputs are small,an algorithm with exponential running time may be perfectly satisfactory. Second,we may be able to isolate important special cases that we can solve in polynomialtime. Third, we might come up with approaches to \ufb01nd near-optimal solutions in\npolynomial time (either in the worst case or the expected case). In practice, near-\noptimality is often good enough. We call an algorithm that returns near-optimal\nsolutions an approximation algorithm . This chapter presents polynomial-time ap-\nproximation algorithms for several NP-complete problems.\nPerformance ratios for approximation algorithms\nSuppose that we are working on an optimization problem in which each potential\nsolution has a positive cost, and we wish to \ufb01nd a near-optimal solution. Dependingon the problem, we may de\ufb01ne an optimal solution as one with maximum possi-ble cost or one with minimum possible cost; that is, the problem may be either amaximization or a minimization problem.\nWe say that an algorithm for a problem has an approximation ratio of/SUB.n/ if,\nfor any input of size n, the cost Cof the solution produced by the algorithm is\nwithin a factor of /SUB.n/ of the cost C\n/ETXof an optimal solution:\nmax/DC2C\nC/ETX;C/ETX\nC/DC3\n/DC4/SUB.n/ : (35.1)\nIf an algorithm achieves an approximation ratio of /SUB.n/, we call it a /SUB.n/-approx-\nimation algorithm . The de\ufb01nitions of the approximation ratio and of a /SUB.n/-\napproximation algorithm apply to both minimization and maximization problems.For a maximization problem, 0<C/DC4C\n/ETX, and the ratio C/ETX=Cgives the factor\nby which the cost of an optimal solution is larger than the cost of the approximate", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "1127": {"page_number": 1128, "page_information": "Chapter 35 Approximation Algorithms 1107\nsolution. Similarly, for a minimization problem, 0<C/ETX/DC4C, and the ratio C=C/ETX\ngives the factor by which the cost of the approximate solution is larger than the\ncost of an optimal solution. Because we assume that all solutions have positivecost, these ratios are always well de\ufb01ned. The approximation ratio of an approx-imation algorithm is never less than 1,s i n c e C=C\n/ETX/DC41implies C/ETX=C/NAK1.\nTherefore, a 1-approximation algorithm1produces an optimal solution, and an ap-\nproximation algorithm with a large approximation ratio may return a solution thatis much worse than optimal.\nFor many problems, we have polynomial-time approximation algorithms with\nsmall constant approximation ratios, although for other problems, the best knownpolynomial-time approximation algorithms have approximation ratios that growas functions of the input size n. An example of such a problem is the set-cover\nproblem presented in Section 35.3.\nSome NP-complete problems allow polynomial-time approximation algorithms\nthat can achieve increasingly better approximation ratios by using more and more\ncomputation time. That is, we can trade computation time for the quality of the\napproximation. An example is the subset-sum problem studied in Section 35.5.\nThis situation is important enough to deserve a name of its own.\nAnapproximation scheme for an optimization problem is an approximation al-\ngorithm that takes as input not only an instance of the problem, but also a value/SI>0 such that for any \ufb01xed /SI, the scheme is a .1C/SI/-approximation algorithm.\nWe say that an approximation scheme is a polynomial-time approximation scheme\nif for any \ufb01xed /SI>0 , the scheme runs in time polynomial in the size nof its input\ninstance.\nThe running time of a polynomial-time approximation scheme can increase very\nrapidly as /SIdecreases. For example, the running time of a polynomial-time ap-\nproximation scheme might be O.n\n2=/SI/. Ideally, if /SIdecreases by a constant factor,\nthe running time to achieve the desired approximation should not increase by morethan a constant factor (though not necessarily the same constant factor by which /SI\ndecreased).\nWe say that an approximation scheme is a fully polynomial-time approximation\nscheme if it is an approximation scheme and its running time is polynomial in\nboth1=/SIand the size nof the input instance. For example, the scheme might have\na running time of O..1=/SI/\n2n3/. With such a scheme, any constant-factor decrease\nin/SIcomes with a corresponding constant-factor increase in the running time.\n1When the approximation ratio is independent of n, we use the terms \u201capproximation ratio of /SUB\u201da n d\n\u201c/SUB-approximation algorithm,\u201d indicating no dependence on n.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "1128": {"page_number": 1129, "page_information": "1108 Chapter 35 Approximation Algorithms\nChapter outline\nThe \ufb01rst four sections of this chapter present some examples of polynomial-time\napproximation algorithms for NP-complete problems, and the \ufb01fth section presentsa fully polynomial-time approximation scheme. Section 35.1 begins with a studyof the vertex-cover problem, an NP-complete minimization problem that has anapproximation algorithm with an approximation ratio of 2. Section 35.2 presents\nan approximation algorithm with an approximation ratio of 2for the case of the\ntraveling-salesman problem in which the cost function satis\ufb01es the triangle in-equality. It also shows that without the triangle inequality, for any constant /SUB/NAK1,\na/SUB-approximation algorithm cannot exist unless P DNP. In Section 35.3, we\nshow how to use a greedy method as an effective approximation algorithm for theset-covering problem, obtaining a covering whose cost is at worst a logarithmicfactor larger than the optimal cost. Section 35.4 presents two more approximationalgorithms. First we study the optimization version of 3-CNF satis\ufb01ability and\ngive a simple randomized algorithm that produces a solution with an expected ap-\nproximation ratio of 8=7. Then we examine a weighted variant of the vertex-cover\nproblem and show how to use linear programming to develop a 2-approximation\nalgorithm. Finally, Section 35.5 presents a fully polynomial-time approximation\nscheme for the subset-sum problem.\n35.1 The vertex-cover problem\nSection 34.5.2 de\ufb01ned the vertex-cover problem and proved it NP-complete. Recallthat a vertex cover of an undirected graph GD.V; E/ i sas u b s e t V\n0/DC2Vsuch\nthat if .u; /ETB/ is an edge of G, then either u2V0or/ETB2V0(or both). The size of a\nvertex cover is the number of vertices in it.\nThevertex-cover problem is to \ufb01nd a vertex cover of minimum size in a given\nundirected graph. We call such a vertex cover an optimal vertex cover . This prob-\nlem is the optimization version of an NP-complete decision problem.\nEven though we don\u2019t know how to \ufb01nd an optimal vertex cover in a graph G\nin polynomial time, we can ef\ufb01ciently \ufb01nd a vertex cover that is near-optimal.The following approximation algorithm takes as input an undirected graph Gand\nreturns a vertex cover whose size is guaranteed to be no more than twice the sizeof an optimal vertex cover.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "1129": {"page_number": 1130, "page_information": "35.1 The vertex-cover problem 1109\nbcd\nae fg\n(a)bcd\nae fg\n(b)\nbcd\nae fg\n(c)bcd\nae fg\n(d)\nbcd\nae fg\n(e)bcd\nae fg\n(f)\nFigure 35.1 The operation of A PPROX -VERTEX -COVER .(a)The input graph G, which has 7\nvertices and 8 edges. (b)The edge .b; c/ , shown heavy, is the \ufb01rst edge chosen by A PPROX -VERTEX -\nCOVER . Vertices bandc, shown lightly shaded, are added to the set Ccontaining the vertex cover\nbeing created. Edges .a; b/ ,.c; e/ ,a n d.c; d/ , shown dashed, are removed since they are now covered\nby some vertex in C.(c)Edge .e; f / is chosen; vertices eandfare added to C.(d)Edge .d; g/\nis chosen; vertices dandgare added to C.(e)The set C, which is the vertex cover produced by\nAPPROX -VERTEX -COVER , contains the six vertices b;c; d;e; f;g .(f)The optimal vertex cover for\nthis problem contains only three vertices: b,d,a n d e.\nAPPROX -VERTEX -COVER .G/\n1CD;\n2E0DG:E\n3while E0\u00a4;\n4l e t .u; /ETB/ be an arbitrary edge of E0\n5 CDC[fu; /ETBg\n6 remove from E0every edge incident on either uor/ETB\n7return C\nFigure 35.1 illustrates how A PPROX -VERTEX -COVER operates on an example\ngraph. The variable Ccontains the vertex cover being constructed. Line 1 ini-\ntializes Cto the empty set. Line 2 sets E0to be a copy of the edge set G:Eof\nthe graph. The loop of lines 3\u20136 repeatedly picks an edge .u; /ETB/ from E0, adds its", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "1130": {"page_number": 1131, "page_information": "1110 Chapter 35 Approximation Algorithms\nendpoints uand/ETBtoC, and deletes all edges in E0that are covered by either u\nor/ETB. Finally, line 7 returns the vertex cover C. The running time of this algorithm\nisO.VCE/, using adjacency lists to represent E0.\nTheorem 35.1\nAPPROX -VERTEX -COVER is a polynomial-time 2-approximation algorithm.\nProof We have already shown that A PPROX -VERTEX -COVER runs in polyno-\nmial time.\nThe set Cof vertices that is returned by A PPROX -VERTEX -COVER is a vertex\ncover, since the algorithm loops until every edge in G:Ehas been covered by some\nvertex in C.\nTo see that A PPROX -VERTEX -COVER returns a vertex cover that is at most twice\nthe size of an optimal cover, let Adenote the set of edges that line 4 of A PPROX -\nVERTEX -COVER picked. In order to cover the edges in A, any vertex cover\u2014in\nparticular, an optimal cover C/ETX\u2014must include at least one endpoint of each edge\ninA. No two edges in Ashare an endpoint, since once an edge is picked in line 4,\nall other edges that are incident on its endpoints are deleted from E0in line 6. Thus,\nno two edges in Aare covered by the same vertex from C/ETX, and we have the lower\nbound\njC/ETXj/NAKjAj (35.2)\non the size of an optimal vertex cover. Each execution of line 4 picks an edge for\nwhich neither of its endpoints is already in C, yielding an upper bound (an exact\nupper bound, in fact) on the size of the vertex cover returned:\njCjD2jAj: (35.3)\nCombining equations (35.2) and (35.3), we obtain\njCjD2jAj\n/DC42jC/ETXj;\nthereby proving the theorem.\nLet us re\ufb02ect on this proof. At \ufb01rst, you might wonder how we can possibly\nprove that the size of the vertex cover returned by A PPROX -VERTEX -COVER is at\nmost twice the size of an optimal vertex cover, when we do not even know the sizeof an optimal vertex cover. Instead of requiring that we know the exact size of anoptimal vertex cover, we rely on a lower bound on the size. As Exercise 35.1-2 asksyou to show, the set Aof edges that line 4 of A\nPPROX -VERTEX -COVER selects is\nactually a maximal matching in the graph G.( Amaximal matching is a matching\nthat is not a proper subset of any other matching.) The size of a maximal matching", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "1131": {"page_number": 1132, "page_information": "35.2 The traveling-salesman problem 1111\nis, as we argued in the proof of Theorem 35.1, a lower bound on the size of an\noptimal vertex cover. The algorithm returns a vertex cover whose size is at mosttwice the size of the maximal matching A. By relating the size of the solution\nreturned to the lower bound, we obtain our approximation ratio. We will use thismethodology in later sections as well.\nExercises\n35.1-1\nGive an example of a graph for which A\nPPROX -VERTEX -COVER always yields a\nsuboptimal solution.\n35.1-2\nProve that the set of edges picked in line 4 of A PPROX -VERTEX -COVER forms a\nmaximal matching in the graph G.\n35.1-3 ?\nProfessor B\u00a8 undchen proposes the following heuristic to solve the vertex-cover\nproblem. Repeatedly select a vertex of highest degree, and remove all of its in-cident edges. Give an example to show that the professor\u2019s heuristic does not have\nan approximation ratio of 2.(Hint: Try a bipartite graph with vertices of uniform\ndegree on the left and vertices of varying degree on the right.)\n35.1-4\nGive an ef\ufb01cient greedy algorithm that \ufb01nds an optimal vertex cover for a tree inlinear time.\n35.1-5\nFrom the proof of Theorem 34.12, we know that the vertex-cover problem and theNP-complete clique problem are complementary in the sense that an optimal vertexcover is the complement of a maximum-size clique in the complement graph. Doesthis relationship imply that there is a polynomial-time approximation algorithmwith a constant approximation ratio for the clique problem? Justify your answer.\n35.2 The traveling-salesman problem\nIn the traveling-salesman problem introduced in Section 34.5.4, we are given acomplete undirected graph GD.V; E/ that has a nonnegative integer cost c.u;/ETB/\nassociated with each edge .u; /ETB/2E, and we must \ufb01nd a hamiltonian cycle (a\ntour) of Gwith minimum cost. As an extension of our notation, let c.A/ denote\nthe total cost of the edges in the subset A/DC2E:", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "1132": {"page_number": 1133, "page_information": "1112 Chapter 35 Approximation Algorithms\nc.A/DX\n.u;/ETB/ 2Ac.u;/ETB/ :\nIn many practical situations, the least costly way to go from a place uto a place w\nis to go directly, with no intermediate steps. Put another way, cutting out an inter-\nmediate stop never increases the cost. We formalize this notion by saying that thecost function csatis\ufb01es the triangle inequality if, for all vertices u; /ETB; w2V,\nc.u;w//DC4c.u;/ETB/Cc./ETB;w/ :\nThe triangle inequality seems as though it should naturally hold, and it is au-\ntomatically satis\ufb01ed in several applications. For example, if the vertices of thegraph are points in the plane and the cost of traveling between two vertices is theordinary euclidean distance between them, then the triangle inequality is satis\ufb01ed.Furthermore, many cost functions other than euclidean distance satisfy the triangleinequality.\nAs Exercise 35.2-2 shows, the traveling-salesman problem is NP-complete even\nif we require that the cost function satisfy the triangle inequality. Thus, we shouldnot expect to \ufb01nd a polynomial-time algorithm for solving this problem exactly.Instead, we look for good approximation algorithms.\nIn Section 35.2.1, we examine a 2-approximation algorithm for the traveling-\nsalesman problem with the triangle inequality. In Section 35.2.2, we show that\nwithout the triangle inequality, a polynomial-time approximation algorithm with a\nconstant approximation ratio does not exist unless P DNP.\n35.2.1 The traveling-salesman problem with the triangle inequality\nApplying the methodology of the previous section, we shall \ufb01rst compute a struc-\nture\u2014a minimum spanning tree\u2014whose weight gives a lower bound on the length\nof an optimal traveling-salesman tour. We shall then use the minimum spanning\ntree to create a tour whose cost is no more than twice that of the minimum spanning\ntree\u2019s weight, as long as the cost function satis\ufb01es the triangle inequality. The fol-\nlowing algorithm implements this approach, calling the minimum-spanning-tree\nalgorithm MST-P\nRIM from Section 23.2 as a subroutine. The parameter Gis a\ncomplete undirected graph, and the cost function csatis\ufb01es the triangle inequality.\nAPPROX -TSP-T OUR.G; c/\n1 select a vertex r2G:Vto be a \u201croot\u201d vertex\n2 compute a minimum spanning tree TforGfrom root r\nusing MST-P RIM. G ;c;r/\n3l e t Hbe a list of vertices, ordered according to when they are \ufb01rst visited\nin a preorder tree walk of T\n4return the hamiltonian cycle H", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "1133": {"page_number": 1134, "page_information": "35.2 The traveling-salesman problem 1113\n(a)a d\nb fe\ng\nc\nh\n(b)a d\nb fe\ng\nc\nh\n(c)\na d\ne\nc\nh\n(d)a d\nb fe\ng\nc\nh\n(e)b f ge\nhca\nb f gd\nFigure 35.2 The operation of A PPROX -TSP-T OUR.(a)A complete undirected graph. Vertices lie\non intersections of integer grid lines. For example, fis one unit to the right and two units up from h.\nThe cost function between two points is the ordinary euclidean distance. (b)A minimum spanning\ntreeTof the complete graph, as computed by MST-P RIM.V e r t e x ais the root vertex. Only edges\nin the minimum spanning tree are shown. The vertices happen to be labeled in such a way that they\nare added to the main tree by MST-P RIM in alphabetical order. (c)Aw a l ko f T, starting at a.A\nfull walk of the tree visits the vertices in the order a; b;c; b;h; b;a;d; e;f;e; g;e;d; a . A preorder\nwalk of Tlists a vertex just when it is \ufb01rst encountered, as indicated by the dot next to each vertex,\nyielding the ordering a; b; c; h; d; e; f; g .(d)A tour obtained by visiting the vertices in the order\ngiven by the preorder walk, which is the tour Hreturned by A PPROX -TSP-T OUR. Its total cost\nis approximately 19:074 .(e)An optimal tour H/ETXfor the original complete graph. Its total cost is\napproximately 14:715 .\nRecall from Section 12.1 that a preorder tree walk recursively visits every vertex\nin the tree, listing a vertex when it is \ufb01rst encountered, before visiting any of its\nchildren.\nFigure 35.2 illustrates the operation of A PPROX -TSP-T OUR. Part (a) of the \ufb01g-\nure shows a complete undirected graph, and part (b) shows the minimum spanningtreeTgrown from root vertex aby MST-P\nRIM. Part (c) shows how a preorder\nwalk of Tvisits the vertices, and part (d) displays the corresponding tour, which is\nthe tour returned by A PPROX -TSP-T OUR. Part (e) displays an optimal tour, which\nis about 23% shorter.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "1134": {"page_number": 1135, "page_information": "1114 Chapter 35 Approximation Algorithms\nBy Exercise 23.2-2, even with a simple implementation of MST-P RIM, the run-\nning time of A PPROX -TSP-T OUR is\u201a.V2/. We now show that if the cost function\nfor an instance of the traveling-salesman problem satis\ufb01es the triangle inequality,then A\nPPROX -TSP-T OUR returns a tour whose cost is not more than twice the cost\nof an optimal tour.\nTheorem 35.2\nAPPROX -TSP-T OUR is a polynomial-time 2-approximation algorithm for the\ntraveling-salesman problem with the triangle inequality.\nProof We have already seen that A PPROX -TSP-T OUR runs in polynomial time.\nLetH/ETXdenote an optimal tour for the given set of vertices. We obtain a spanning\ntree by deleting any edge from a tour, and each edge cost is nonnegative. Therefore,\nthe weight of the minimum spanning tree Tcomputed in line 2 of A PPROX -TSP-\nTOUR provides a lower bound on the cost of an optimal tour:\nc.T//DC4c.H/ETX/: (35.4)\nAfull walk ofTlists the vertices when they are \ufb01rst visited and also whenever\nthey are returned to after a visit to a subtree. Let us call this full walk W. The full\nwalk of our example gives the order\na;b;c;b;h;b;a;d;e;f;e;g; e;d; a :Since the full walk traverses every edge of Texactly twice, we have (extending\nour de\ufb01nition of the cost cin the natural manner to handle multisets of edges)\nc.W /D2c.T/ : (35.5)\nInequality (35.4) and equation (35.5) imply thatc.W //DC42c.H\n/ETX/; (35.6)\nand so the cost of Wis within a factor of 2of the cost of an optimal tour.\nUnfortunately, the full walk Wis generally not a tour, since it visits some ver-\ntices more than once. By the triangle inequality, however, we can delete a visit toany vertex from Wand the cost does not increase. (If we delete a vertex /ETBfrom W\nbetween visits to uandw, the resulting ordering speci\ufb01es going directly from u\ntow.) By repeatedly applying this operation, we can remove from Wall but the\n\ufb01rst visit to each vertex. In our example, this leaves the ordering\na;b;c;h;d;e;f;g :\nThis ordering is the same as that obtained by a preorder walk of the tree T.L e t H\nbe the cycle corresponding to this preorder walk. It is a hamiltonian cycle, since ev-", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "1135": {"page_number": 1136, "page_information": "35.2 The traveling-salesman problem 1115\nery vertex is visited exactly once, and in fact it is the cycle computed by A PPROX -\nTSP-T OUR.S i n c e His obtained by deleting vertices from the full walk W,w e\nhave\nc.H//DC4c.W / : (35.7)\nCombining inequalities (35.6) and (35.7) gives c.H//DC42c.H/ETX/, which completes\nthe proof.\nIn spite of the nice approximation ratio provided by Theorem 35.2, A PPROX -\nTSP-T OUR is usually not the best practical choice for this problem. There are other\napproximation algorithms that typically perform much better in practice. (See thereferences at the end of this chapter.)\n35.2.2 The general traveling-salesman problem\nIf we drop the assumption that the cost function csatis\ufb01es the triangle inequality,\nthen we cannot \ufb01nd good approximate tours in polynomial time unless P DNP.\nTheorem 35.3\nIf P\u00a4NP, then for any constant /SUB/NAK1, there is no polynomial-time approximation\nalgorithm with approximation ratio /SUBfor the general traveling-salesman problem.\nProof The proof is by contradiction. Suppose to the contrary that for some num-\nber/SUB/NAK1, there is a polynomial-time approximation algorithm Awith approx-\nimation ratio /SUB. Without loss of generality, we assume that /SUBis an integer, by\nrounding it up if necessary. We shall then show how to use Ato solve instances\nof the hamiltonian-cycle problem (de\ufb01ned in Section 34.2) in polynomial time.Since Theorem 34.13 tells us that the hamiltonian-cycle problem is NP-complete,Theorem 34.4 implies that if we can solve it in polynomial time, then P DNP.\nLetGD.V; E/ be an instance of the hamiltonian-cycle problem. We wish to\ndetermine ef\ufb01ciently whether Gcontains a hamiltonian cycle by making use of\nthe hypothesized approximation algorithm A.W e t u r n Ginto an instance of the\ntraveling-salesman problem as follows. Let G\n0D.V; E0/be the complete graph\nonV;t h a ti s ,\nE0Df.u; /ETB/Wu; /ETB2Vandu\u00a4/ETBg:\nAssign an integer cost to each edge in E0as follows:\nc.u;/ETB/D(\n1 if.u; /ETB/2E;\n/SUBjVjC1otherwise :\nWe can create representations of G0andcfrom a representation of Gin time poly-\nnomial injVjandjEj.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "1136": {"page_number": 1137, "page_information": "1116 Chapter 35 Approximation Algorithms\nNow, consider the traveling-salesman problem .G0;c/. If the original graph G\nhas a hamiltonian cycle H, then the cost function cassigns to each edge of Ha\ncost of 1,a n ds o .G0;c/contains a tour of cost jVj. On the other hand, if Gdoes\nnot contain a hamiltonian cycle, then any tour of G0must use some edge not in E.\nBut any tour that uses an edge not in Ehas a cost of at least\n./SUBjVjC1/C.jVj/NUL1/D/SUBjVjCjVj\n>/SUBjVj:\nBecause edges not in Gare so costly, there is a gap of at least /SUBjVjbetween the cost\nof a tour that is a hamiltonian cycle in G(costjVj) and the cost of any other tour\n(cost at least /SUBjVjCjVj). Therefore, the cost of a tour that is not a hamiltonian\ncycle in Gis at least a factor of /SUBC1greater than the cost of a tour that is a\nhamiltonian cycle in G.\nNow, suppose that we apply the approximation algorithm Ato the traveling-\nsalesman problem .G0;c/. Because Ais guaranteed to return a tour of cost no\nmore than /SUBtimes the cost of an optimal tour, if Gcontains a hamiltonian cycle,\nthenAmust return it. If Ghas no hamiltonian cycle, then Areturns a tour of cost\nmore than /SUBjVj. Therefore, we can use Ato solve the hamiltonian-cycle problem\nin polynomial time.\nThe proof of Theorem 35.3 serves as an example of a general technique for\nproving that we cannot approximate a problem very well. Suppose that given anNP-hard problem X, we can produce in polynomial time a minimization prob-\nlemYsuch that \u201cyes\u201d instances of Xcorrespond to instances of Ywith value at\nmost k(for some k), but that \u201cno\u201d instances of Xcorrespond to instances of Y\nwith value greater than /SUBk. Then, we have shown that, unless P DNP, there is no\npolynomial-time /SUB-approximation algorithm for problem Y.\nExercises\n35.2-1\nSuppose that a complete undirected graph GD.V; E/ with at least 3vertices has\na cost function cthat satis\ufb01es the triangle inequality. Prove that c.u;/ETB//NAK0for all\nu; /ETB2V.\n35.2-2\nShow how in polynomial time we can transform one instance of the traveling-\nsalesman problem into another instance whose cost function satis\ufb01es the triangleinequality. The two instances must have the same set of optimal tours. Explainwhy such a polynomial-time transformation does not contradict Theorem 35.3, as-suming that P\u00a4NP.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "1137": {"page_number": 1138, "page_information": "35.3 The set-covering problem 1117\n35.2-3\nConsider the following closest-point heuristic for building an approximate trav-\neling-salesman tour whose cost function satis\ufb01es the triangle inequality. Beginwith a trivial cycle consisting of a single arbitrarily chosen vertex. At each step,identify the vertex uthat is not on the cycle but whose distance to any vertex on the\ncycle is minimum. Suppose that the vertex on the cycle that is nearest uis vertex /ETB.\nExtend the cycle to include uby inserting ujust after /ETB. Repeat until all vertices\nare on the cycle. Prove that this heuristic returns a tour whose total cost is not more\nthan twice the cost of an optimal tour.\n35.2-4\nIn the bottleneck traveling-salesman problem , we wish to \ufb01nd the hamiltonian cy-\ncle that minimizes the cost of the most costly edge in the cycle. Assuming that thecost function satis\ufb01es the triangle inequality, show that there exists a polynomial-time approximation algorithm with approximation ratio 3for this problem. ( Hint:\nShow recursively that we can visit all the nodes in a bottleneck spanning tree, asdiscussed in Problem 23-3, exactly once by taking a full walk of the tree and skip-ping nodes, but without skipping more than two consecutive intermediate nodes.Show that the costliest edge in a bottleneck spanning tree has a cost that is at mostthe cost of the costliest edge in a bottleneck hamiltonian cycle.)\n35.2-5\nSuppose that the vertices for an instance of the traveling-salesman problem arepoints in the plane and that the cost c.u;/ETB/ is the euclidean distance between\npoints uand/ETB. Show that an optimal tour never crosses itself.\n35.3 The set-covering problem\nThe set-covering problem is an optimization problem that models many problems\nthat require resources to be allocated. Its corresponding decision problem general-izes the NP-complete vertex-cover problem and is therefore also NP-hard. The ap-proximation algorithm developed to handle the vertex-cover problem doesn\u2019t apply\nhere, however, and so we need to try other approaches. We shall examine a simple\ngreedy heuristic with a logarithmic approximation ratio. That is, as the size of theinstance gets larger, the size of the approximate solution may grow, relative to thesize of an optimal solution. Because the logarithm function grows rather slowly,however, this approximation algorithm may nonetheless give useful results.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "1138": {"page_number": 1139, "page_information": "1118 Chapter 35 Approximation Algorithms\nS3S6\nS4 S5S2S1\nFigure 35.3 An instance .X;F/of the set-covering problem, where Xconsists of the 12black\npoints and FDfS1;S2;S3;S4;S5;S6g. A minimum-size set cover is CDfS3;S4;S5g,w i t h\nsize3. The greedy algorithm produces a cover of size 4by selecting either the sets S1,S4,S5,\nandS3or the sets S1,S4,S5,a n d S6,i no r d e r .\nAn instance .X;F/of the set-covering problem consists of a \ufb01nite set Xand\na family Fof subsets of X, such that every element of Xbelongs to at least one\nsubset in F:\nXD[\nS2FS:\nWe say that a subset S2Fcovers its elements. The problem is to \ufb01nd a minimum-\nsize subset C/DC2Fwhose members cover all of X:\nXD[\nS2CS: (35.8)\nWe say that any Csatisfying equation (35.8) covers X. Figure 35.3 illustrates the\nset-covering problem. The size of Cis the number of sets it contains, rather than\nthe number of individual elements in these sets, since every subset Cthat covers X\nmust contain alljXjindividual elements. In Figure 35.3, the minimum set cover\nhas size 3.\nThe set-covering problem abstracts many commonly arising combinatorial prob-\nlems. As a simple example, suppose that Xrepresents a set of skills that are needed\nto solve a problem and that we have a given set of people available to work on theproblem. We wish to form a committee, containing as few people as possible,such that for every requisite skill in X, at least one member of the committee has\nthat skill. In the decision version of the set-covering problem, we ask whether acovering exists with size at most k,w h e r e kis an additional parameter speci\ufb01ed\nin the problem instance. The decision version of the problem is NP-complete, as\nExercise 35.3-2 asks you to show.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "1139": {"page_number": 1140, "page_information": "35.3 The set-covering problem 1119\nA greedy approximation algorithm\nThe greedy method works by picking, at each stage, the set Sthat covers the great-\nest number of remaining elements that are uncovered.\nGREEDY -SET-COVER .X;F/\n1UDX\n2CD;\n3while U\u00a4;\n4 select an S2Fthat maximizesjS\\Uj\n5 UDU/NULS\n6 CDC[fSg\n7return C\nIn the example of Figure 35.3, G REEDY -SET-COVER adds to C, in order, the sets\nS1,S4,a n d S5, followed by either S3orS6.\nThe algorithm works as follows. The set Ucontains, at each stage, the set of\nremaining uncovered elements. The set Ccontains the cover being constructed.\nLine4is the greedy decision-making step, choosing a subset Sthat covers as many\nuncovered elements as possible (breaking ties arbitrarily). After Sis selected,\nline 5 removes its elements from U, and line 6 places SintoC. When the algorithm\nterminates, the set Ccontains a subfamily of Fthat covers X.\nWe can easily implement G REEDY -SET-COVER to run in time polynomial in jXj\nandjFj. Since the number of iterations of the loop on lines 3\u20136 is bounded from\nabove by min .jXj;jFj/, and we can implement the loop body to run in time\nO.jXjjFj/, a simple implementation runs in time O.jXjjFjmin.jXj;jFj//.E x -\nercise 35.3-3 asks for a linear-time algorithm.\nAnalysis\nWe now show that the greedy algorithm returns a set cover that is not too much\nlarger than an optimal set cover. For convenience, in this chapter we denote the dth\nharmonic number HdDPd\niD11=i(see Section A.1) by H.d/ . As a boundary\ncondition, we de\ufb01ne H.0/D0.\nTheorem 35.4\nGREEDY -SET-COVER is a polynomial-time /SUB.n/-approximation algorithm, where\n/SUB.n/DH.maxfjSjWS2Fg/:\nProof We have already shown that G REEDY -SET-COVER runs in polynomial\ntime.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "1140": {"page_number": 1141, "page_information": "1120 Chapter 35 Approximation Algorithms\nTo show that G REEDY -SET-COVER is a/SUB.n/-approximation algorithm, we as-\nsign a cost of 1to each set selected by the algorithm, distribute this cost over\nthe elements covered for the \ufb01rst time, and then use these costs to derive the de-sired relationship between the size of an optimal set cover C\n/ETXand the size of the\nset cover Creturned by the algorithm. Let Sidenote the ith subset selected by\nGREEDY -SET-COVER ; the algorithm incurs a cost of 1when it adds SitoC.W e\nspread this cost of selecting Sievenly among the elements covered for the \ufb01rst time\nbySi.L e t cxdenote the cost allocated to element x, for each x2X. Each element\nis assigned a cost only once, when it is covered for the \ufb01rst time. If xis covered\nfor the \ufb01rst time by Si,t h e n\ncxD1\njSi/NUL.S1[S2[/SOH/SOH/SOH[ Si/NUL1/j:\nEach step of the algorithm assigns 1unit of cost, and so\njCjDX\nx2Xcx: (35.9)\nEach element x2Xis in at least one set in the optimal cover C/ETX, and so we haveX\nS2C/ETXX\nx2Scx/NAKX\nx2Xcx: (35.10)\nCombining equation (35.9) and inequality (35.10), we have that\njCj/DC4X\nS2C/ETXX\nx2Scx: (35.11)\nThe remainder of the proof rests on the following key inequality, which we shall\nprove shortly. For any set Sbelonging to the family F,X\nx2Scx/DC4H.jSj/: (35.12)\nFrom inequalities (35.11) and (35.12), it follows that\njCj/DC4X\nS2C/ETXH.jSj/\n/DC4jC/ETXj/SOHH.maxfjSjWS2Fg/;\nthus proving the theorem.\nAll that remains is to prove inequality (35.12). Consider any set S2Fand any\niD1 ;2;:::;jCj,a n dl e t\nuiDjS/NUL.S1[S2[/SOH/SOH/SOH[ Si/j\nbe the number of elements in Sthat remain uncovered after the algorithm has\nselected sets S1;S2;:::;S i.W e d e \ufb01 n e u0DjSjto be the number of elements", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "1141": {"page_number": 1142, "page_information": "35.3 The set-covering problem 1121\nofS, which are all initially uncovered. Let kbe the least index such that ukD0,\nso that every element in Sis covered by at least one of the sets S1;S2;:::;S kand\nsome element in Sis uncovered by S1[S2[/SOH/SOH/SOH[ Sk/NUL1. Then, ui/NUL1/NAKui,a n d\nui/NUL1/NULuielements of Sare covered for the \ufb01rst time by Si,f o riD1 ;2;:::;k .\nThus,\nX\nx2ScxDkX\niD1.ui/NUL1/NULui//SOH1\njSi/NUL.S1[S2[/SOH/SOH/SOH[ Si/NUL1/j:\nObserve that\njSi/NUL.S1[S2[/SOH/SOH/SOH[ Si/NUL1/j/NAKjS/NUL.S1[S2[/SOH/SOH/SOH[ Si/NUL1/j\nDui/NUL1;\nbecause the greedy choice of Siguarantees that Scannot cover more new ele-\nments than Sidoes (otherwise, the algorithm would have chosen Sinstead of Si).\nConsequently, we obtain\nX\nx2Scx/DC4kX\niD1.ui/NUL1/NULui//SOH1\nui/NUL1:\nWe now bound this quantity as follows:\nX\nx2Scx/DC4kX\niD1.ui/NUL1/NULui//SOH1\nui/NUL1\nDkX\niD1ui/NUL1X\njDuiC11\nui/NUL1\n/DC4kX\niD1ui/NUL1X\njDuiC11\nj(because j/DC4ui/NUL1)\nDkX\niD1 ui/NUL1X\njD11\nj/NULuiX\njD11\nj!\nDkX\niD1.H.u i/NUL1//NULH.u i//\nDH.u 0//NULH.u k/ (because the sum telescopes)\nDH.u 0//NULH.0/\nDH.u 0/ (because H.0/D0)\nDH.jSj/;\nwhich completes the proof of inequality (35.12).\n", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "1142": {"page_number": 1143, "page_information": "1122 Chapter 35 Approximation Algorithms\nCorollary 35.5\nGREEDY -SET-COVER is a polynomial-time .lnjXjC1/-approximation algorithm.\nProof Use inequality (A.14) and Theorem 35.4.\nIn some applications, max fjSjWS2Fgis a small constant, and so the solution\nreturned by G REEDY -SET-COVER is at most a small constant times larger than\noptimal. One such application occurs when this heuristic \ufb01nds an approximatevertex cover for a graph whose vertices have degree at most 3. In this case, the\nsolution found by G\nREEDY -SET-COVER is not more than H.3/D11=6 times as\nlarge as an optimal solution, a performance guarantee that is slightly better thanthat of A\nPPROX -VERTEX -COVER .\nExercises\n35.3-1\nConsider each of the following words as a set of letters: farid ;dash ;drain ;\nheard ;lost ;nose ;shun ;slate ;snare ;threadg. Show which set cover\nGREEDY -SET-COVER produces when we break ties in favor of the word that ap-\npears \ufb01rst in the dictionary.\n35.3-2\nShow that the decision version of the set-covering problem is NP-complete byreducing it from the vertex-cover problem.\n35.3-3\nShow how to implement G\nREEDY -SET-COVER in such a way that it runs in time\nO/DLEP\nS2FjSj/DC1\n.\n35.3-4\nShow that the following weaker form of Theorem 35.4 is trivially true:\njCj/DC4jC/ETXjmaxfjSjWS2Fg:\n35.3-5\nGREEDY -SET-COVER can return a number of different solutions, depending on\nhow we break ties in line 4. Give a procedure B AD-SET-COVER -INSTANCE .n/\nthat returns an n-element instance of the set-covering problem for which, depend-\ning on how we break ties in line 4, G REEDY -SET-COVER can return a number of\ndifferent solutions that is exponential in n.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "1143": {"page_number": 1144, "page_information": "35.4 Randomization and linear programming 1123\n35.4 Randomization and linear programming\nIn this section, we study two useful techniques for designing approximation algo-\nrithms: randomization and linear programming. We shall give a simple randomizedalgorithm for an optimization version of 3-CNF satis\ufb01ability, and then we shall uselinear programming to help design an approximation algorithm for a weighted ver-\nsion of the vertex-cover problem. This section only scratches the surface of these\ntwo powerful techniques. The chapter notes give references for further study ofthese areas.\nA randomized approximation algorithm for MAX-3-CNF satis\ufb01ability\nJust as some randomized algorithms compute exact solutions, some randomized\nalgorithms compute approximate solutions. We say that a randomized algorithmfor a problem has an approximation ratio of/SUB.n/ if, for any input of size n,t h e\nexpected costCof the solution produced by the randomized algorithm is within a\nfactor of /SUB.n/ of the cost C\n/ETXof an optimal solution:\nmax/DC2C\nC/ETX;C/ETX\nC/DC3\n/DC4/SUB.n/ : (35.13)\nWe call a randomized algorithm that achieves an approximation ratio of /SUB.n/ a\nrandomized /SUB.n/-approximation algorithm. In other words, a randomized ap-\nproximation algorithm is like a deterministic approximation algorithm, except thatthe approximation ratio is for an expected cost.\nA particular instance of 3-CNF satis\ufb01ability, as de\ufb01ned in Section 34.4, may or\nmay not be satis\ufb01able. In order to be satis\ufb01able, there must exist an assignment ofthe variables so that every clause evaluates to 1. If an instance is not satis\ufb01able, we\nmay want to compute how \u201cclose\u201d to satis\ufb01able it is, that is, we may wish to \ufb01nd an\nassignment of the variables that satis\ufb01es as many clauses as possible. We call the\nresulting maximization problem MAX-3-CNF satis\ufb01ability . The input to MAX-3-\nCNF satis\ufb01ability is the same as for 3-CNF satis\ufb01ability, and the goal is to return\nan assignment of the variables that maximizes the number of clauses evaluating\nto1. We now show that randomly setting each variable to 1with probability 1=2\nand to 0with probability 1=2yields a randomized 8=7-approximation algorithm.\nAccording to the de\ufb01nition of 3-CNF satis\ufb01ability from Section 34.4, we require\neach clause to consist of exactly three distinct literals. We further assume thatno clause contains both a variable and its negation. (Exercise 35.4-1 asks you toremove this last assumption.)", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "1144": {"page_number": 1145, "page_information": "1124 Chapter 35 Approximation Algorithms\nTheorem 35.6\nGiven an instance of MAX-3-CNF satis\ufb01ability with nvariables x1;x2;:::;x n\nandmclauses, the randomized algorithm that independently sets each vari-\nable to 1with probability 1=2 and to 0with probability 1=2 is a randomized\n8=7-approximation algorithm.\nProof Suppose that we have independently set each variable to 1with probabil-\nity1=2and to 0with probability 1=2.F o r iD1 ;2;:::;m , we de\ufb01ne the indicator\nrandom variable\nYiDIfclause iis satis\ufb01edg;\nso that YiD1as long as we have set at least one of the literals in the ith clause\nto1. Since no literal appears more than once in the same clause, and since we have\nassumed that no variable and its negation appear in the same clause, the settings of\nthe three literals in each clause are independent. A clause is not satis\ufb01ed only if all\nthree of its literals are set to 0,a n ds oP rfclause iis not satis\ufb01edgD.1=2/3D1=8.\nThus, we have Prfclause iis satis\ufb01edgD1/NUL1=8D7=8, and by Lemma 5.1,\nwe have E \u0152Yi/c141D7=8.L e t Ybe the number of satis\ufb01ed clauses overall, so that\nYDY1CY2C/SOH/SOH/SOHC Ym. Then, we have\nE\u0152Y /c141DE\"mX\niD1Yi#\nDmX\niD1E\u0152Yi/c141 (by linearity of expectation)\nDmX\niD17=8\nD7m=8 :\nClearly, mis an upper bound on the number of satis\ufb01ed clauses, and hence the\napproximation ratio is at most m=.7m=8/D8=7.\nApproximating weighted vertex cover using linear programming\nIn the minimum-weight vertex-cover problem , we are given an undirected graph\nGD.V; E/ in which each vertex /ETB2Vhas an associated positive weight w./ETB/ .\nFor any vertex cover V0/DC2V, we de\ufb01ne the weight of the vertex cover w.V0/DP\n/ETB2V0w./ETB/ . The goal is to \ufb01nd a vertex cover of minimum weight.\nWe cannot apply the algorithm used for unweighted vertex cover, nor can we use\na random solution; both methods may return solutions that are far from optimal.We shall, however, compute a lower bound on the weight of the minimum-weight", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "1145": {"page_number": 1146, "page_information": "35.4 Randomization and linear programming 1125\nvertex cover, by using a linear program. We shall then \u201cround\u201d this solution and\nuse it to obtain a vertex cover.\nSuppose that we associate a variable x./ETB/ with each vertex /ETB2V,a n dl e tu s\nrequire that x./ETB/ equals either 0or1for each /ETB2V. We put /ETBinto the vertex cover\nif and only if x./ETB/D1. Then, we can write the constraint that for any edge .u; /ETB/ ,\nat least one of uand/ETBmust be in the vertex cover as x.u/Cx./ETB//NAK1.T h i sv i e w\ngives rise to the following 0-1 integer program for \ufb01nding a minimum-weight\nvertex cover:\nminimizeX\n/ETB2Vw./ETB/ x./ETB/ (35.14)\nsubject to\nx.u/Cx./ETB//NAK1 for each .u; /ETB/2E (35.15)\nx./ETB/2f0; 1gfor each /ETB2V: (35.16)\nIn the special case in which all the weights w./ETB/ are equal to 1, this formu-\nlation is the optimization version of the NP-hard vertex-cover problem. Sup-\npose, however, that we remove the constraint that x./ETB/2f0; 1gand replace it\nby0/DC4x./ETB//DC41. We then obtain the following linear program, which is known as\nthelinear-programming relaxation :\nminimizeX\n/ETB2Vw./ETB/ x./ETB/ (35.17)\nsubject to\nx.u/Cx./ETB//NAK1for each .u; /ETB/2E (35.18)\nx./ETB//DC41for each /ETB2V (35.19)\nx./ETB//NAK0for each /ETB2V: (35.20)\nAny feasible solution to the 0-1 integer program in lines (35.14)\u2013(35.16) is also\na feasible solution to the linear program in lines (35.17)\u2013(35.20). Therefore, thevalue of an optimal solution to the linear program gives a lower bound on the value\nof an optimal solution to the 0-1 integer program, and hence a lower bound on the\noptimal weight in the minimum-weight vertex-cover problem.\nThe following procedure uses the solution to the linear-programming relaxation\nto construct an approximate solution to the minimum-weight vertex-cover problem:", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "1146": {"page_number": 1147, "page_information": "1126 Chapter 35 Approximation Algorithms\nAPPROX -MIN-WEIGHT -VC.G; w/\n1CD;\n2 computeNx, an optimal solution to the linear program in lines (35.17)\u2013(35.20)\n3foreach/ETB2V\n4 ifNx./ETB//NAK1=2\n5 CDC[f/ETBg\n6return C\nThe A PPROX -MIN-WEIGHT -VC procedure works as follows. Line 1 initial-\nizes the vertex cover to be empty. Line 2 formulates the linear program inlines (35.17)\u2013(35.20) and then solves this linear program. An optimal solutiongives each vertex /ETBan associated value Nx./ETB/ ,w h e r e 0/DC4Nx./ETB//DC41. We use this\nvalue to guide the choice of which vertices to add to the vertex cover Cin lines 3\u20135.\nIfNx./ETB//NAK1=2,w ea d d /ETBtoC; otherwise we do not. In effect, we are \u201crounding\u201d\neach fractional variable in the solution to the linear program to 0or1in order to\nobtain a solution to the 0-1 integer program in lines (35.14)\u2013(35.16). Finally, line 6returns the vertex cover C.\nTheorem 35.7\nAlgorithm A\nPPROX -MIN-WEIGHT -VC is a polynomial-time 2-approximation al-\ngorithm for the minimum-weight vertex-cover problem.\nProof Because there is a polynomial-time algorithm to solve the linear program\nin line 2, and because the forloop of lines 3\u20135 runs in polynomial time, A PPROX -\nMIN-WEIGHT -VC is a polynomial-time algorithm.\nNow we show that A PPROX -MIN-WEIGHT -VC is a 2-approximation algo-\nrithm. Let C/ETXbe an optimal solution to the minimum-weight vertex-cover prob-\nlem, and let \u00b4/ETXbe the value of an optimal solution to the linear program in\nlines (35.17)\u2013(35.20). Since an optimal vertex cover is a feasible solution to thelinear program, \u00b4\n/ETXmust be a lower bound on w.C/ETX/,t h a ti s ,\n\u00b4/ETX/DC4w.C/ETX/: (35.21)\nNext, we claim that by rounding the fractional values of the variables Nx./ETB/ ,w e\nproduce a set Cthat is a vertex cover and satis\ufb01es w.C//DC42\u00b4/ETX. To see that Cis\na vertex cover, consider any edge .u; /ETB/2E. By constraint (35.18), we know that\nx.u/Cx./ETB//NAK1, which implies that at least one of Nx.u/ andNx./ETB/ is at least 1=2.\nTherefore, at least one of uand/ETBis included in the vertex cover, and so every edge\nis covered.\nNow, we consider the weight of the cover. We have", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "1147": {"page_number": 1148, "page_information": "35.4 Randomization and linear programming 1127\n\u00b4/ETXDX\n/ETB2Vw./ETB/Nx./ETB/\n/NAKX\n/ETB2VWNx./ETB//NAK1=2w./ETB/Nx./ETB/\n/NAKX\n/ETB2VWNx./ETB//NAK1=2w./ETB//SOH1\n2\nDX\n/ETB2Cw./ETB//SOH1\n2\nD1\n2X\n/ETB2Cw./ETB/\nD1\n2w.C/ : (35.22)\nCombining inequalities (35.21) and (35.22) gives\nw.C//DC42\u00b4/ETX/DC42w.C/ETX/;\nand hence A PPROX -MIN-WEIGHT -VC is a 2-approximation algorithm.\nExercises\n35.4-1\nShow that even if we allow a clause to contain both a variable and its negation, ran-domly setting each variable to 1with probability 1=2and to 0with probability 1=2\nstill yields a randomized 8=7-approximation algorithm.\n35.4-2\nTheMAX-CNF satis\ufb01ability problem is like the MAX-3-CNF satis\ufb01ability prob-\nlem, except that it does not restrict each clause to have exactly 3literals. Give a\nrandomized 2-approximation algorithm for the MAX-CNF satis\ufb01ability problem.\n35.4-3\nIn the MAX-CUT problem, we are given an unweighted undirected graph GD\n.V; E/ . We de\ufb01ne a cut .S; V/NULS/as in Chapter 23 and the weight of a cut as the\nnumber of edges crossing the cut. The goal is to \ufb01nd a cut of maximum weight.Suppose that for each vertex /ETB, we randomly and independently place /ETBinSwith\nprobability 1=2and in V/NULSwith probability 1=2. Show that this algorithm is a\nrandomized 2-approximation algorithm.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "1148": {"page_number": 1149, "page_information": "1128 Chapter 35 Approximation Algorithms\n35.4-4\nShow that the constraints in line (35.19) are redundant in the sense that if we re-move them from the linear program in lines (35.17)\u2013(35.20), any optimal solutionto the resulting linear program must satisfy x./ETB//DC41for each /ETB2V.\n35.5 The subset-sum problem\nRecall from Section 34.5.5 that an instance of the subset-sum problem is a\npair.S; t/ ,w h e r e Sis a setfx1;x2;:::;x ngof positive integers and tis a posi-\ntive integer. This decision problem asks whether there exists a subset of Sthat\nadds up exactly to the target value t. As we saw in Section 34.5.5, this problem is\nNP-complete.\nThe optimization problem associated with this decision problem arises in prac-\ntical applications. In the optimization problem, we wish to \ufb01nd a subset of\nfx1;x2;:::;x ngwhose sum is as large as possible but not larger than t.F o r e x -\nample, we may have a truck that can carry no more than tpounds, and ndifferent\nboxes to ship, the ith of which weighs xipounds. We wish to \ufb01ll the truck with as\nheavy a load as possible without exceeding the given weight limit.\nIn this section, we present an exponential-time algorithm that computes the op-\ntimal value for this optimization problem, and then we show how to modify thealgorithm so that it becomes a fully polynomial-time approximation scheme. (Re-call that a fully polynomial-time approximation scheme has a running time that ispolynomial in 1=/SIas well as in the size of the input.)\nAn exponential-time exact algorithm\nSuppose that we computed, for each subset S\n0ofS, the sum of the elements\ninS0, and then we selected, among the subsets whose sum does not exceed t,\nthe one whose sum was closest to t. Clearly this algorithm would return the op-\ntimal solution, but it could take exponential time. To implement this algorithm,\nwe could use an iterative procedure that, in iteration i, computes the sums of\nall subsets offx1;x2;:::;x ig, using as a starting point the sums of all subsets\noffx1;x2;:::;x i/NUL1g. In doing so, we would realize that once a particular subset S0\nhad a sum exceeding t, there would be no reason to maintain it, since no super-\nset of S0could be the optimal solution. We now give an implementation of this\nstrategy.\nThe procedure E XACT -SUBSET -SUMtakes an input set SDfx1;x2;:::;x ng\nand a target value t; we\u2019ll see its pseudocode in a moment. This procedure it-", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "1149": {"page_number": 1150, "page_information": "35.5 The subset-sum problem 1129\neratively computes Li,t h el i s to fs u m so fa l ls u b s e t so f fx1;:::;x igthat do not\nexceed t, and then it returns the maximum value in Ln.\nIfLis a list of positive integers and xis another positive integer, then we let\nLCxdenote the list of integers derived from Lby increasing each element of L\nbyx. For example, if LDh1; 2; 3; 5; 9i,t h e n LC2Dh3; 4; 5; 7; 11i.W ea l s ou s e\nthis notation for sets, so that\nSCxDfsCxWs2Sg:\nWe also use an auxiliary procedure M ERGE -LISTS.L; L0/, which returns the\nsorted list that is the merge of its two sorted input lists LandL0with duplicate\nvalues removed. Like the M ERGE procedure we used in merge sort (Section 2.3.1),\nMERGE -LISTS runs in time O.jLjCjL0j/. We omit the pseudocode for M ERGE -\nLISTS.\nEXACT -SUBSET -SUM.S; t/\n1nDjSj\n2L0Dh0i\n3foriD1ton\n4 LiDMERGE -LISTS.Li/NUL1;Li/NUL1Cxi/\n5 remove from Lievery element that is greater than t\n6return the largest element in Ln\nTo see how E XACT -SUBSET -SUMworks, let Pidenote the set of all values\nobtained by selecting a (possibly empty) subset of fx1;x2;:::;x igand summing\nits members. For example, if SDf1; 4; 5g,t h e n\nP1Df0; 1g;\nP2Df0; 1; 4; 5g;\nP3Df0; 1; 4; 5; 6; 9; 10g:\nGiven the identityP\niDPi/NUL1[.Pi/NUL1Cxi/; (35.23)\nwe can prove by induction on i(see Exercise 35.5-1) that the list Liis a sorted list\ncontaining every element of Piwhose value is not more than t. Since the length\nofLican be as much as 2i,EXACT -SUBSET -SUMis an exponential-time algorithm\nin general, although it is a polynomial-time algorithm in the special cases in which t\nis polynomial injSjor all the numbers in Sare bounded by a polynomial in jSj.\nA fully polynomial-time approximation scheme\nWe can derive a fully polynomial-time approximation scheme for the subset-sum\nproblem by \u201ctrimming\u201d each list Liafter it is created. The idea behind trimming is", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "1150": {"page_number": 1151, "page_information": "1130 Chapter 35 Approximation Algorithms\nthat if two values in Lare close to each other, then since we want just an approxi-\nmate solution, we do not need to maintain both of them explicitly. More precisely,we use a trimming parameter \u0131such that 0<\u0131<1 .W h e nw e trim a list Lby\u0131,\nwe remove as many elements from Las possible, in such a way that if L\n0is the\nresult of trimming L, then for every element ythat was removed from L, there is\nan element \u00b4still in L0that approximates y,t h a ti s ,\ny\n1C\u0131/DC4\u00b4/DC4y: (35.24)\nWe can think of such a \u00b4as \u201crepresenting\u201d yin the new list L0. Each removed\nelement yis represented by a remaining element \u00b4satisfying inequality (35.24).\nFor example, if \u0131D0:1and\nLDh10; 11; 12; 15; 20; 21; 22; 23; 24; 29 i;\nthen we can trim Lto obtain\nL0Dh10; 12; 15; 20; 23; 29 i;\nwhere the deleted value 11is represented by 10, the deleted values 21and22\nare represented by 20, and the deleted value 24is represented by 23. Because\nevery element of the trimmed version of the list is also an element of the originalversion of the list, trimming can dramatically decrease the number of elements keptwhile keeping a close (and slightly smaller) representative value in the list for eachdeleted element.\nThe following procedure trims list LDhy\n1;y2;:::;y miin time \u201a.m/ ,g i v e n L\nand\u0131, and assuming that Lis sorted into monotonically increasing order. The\noutput of the procedure is a trimmed, sorted list.\nTRIM.L; \u0131/\n1l e t mbe the length of L\n2L0Dhy1i\n3lastDy1\n4foriD2tom\n5 ifyi>last/SOH.1C\u0131/ //yi/NAKlastbecause Lis sorted\n6 append yionto the end of L0\n7 lastDyi\n8return L0\nThe procedure scans the elements of Lin monotonically increasing order. A num-\nber is appended onto the returned list L0only if it is the \ufb01rst element of Lor if it\ncannot be represented by the most recent number placed into L0.\nGiven the procedure T RIM, we can construct our approximation scheme as fol-\nlows. This procedure takes as input a set SDfx1;x2;:::;x ngofnintegers (in\narbitrary order), a target integer t, and an \u201capproximation parameter\u201d /SI,w h e r e", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "1151": {"page_number": 1152, "page_information": "35.5 The subset-sum problem 1131\n0</SI<1: (35.25)\nIt returns a value \u00b4whose value is within a 1C/SIfactor of the optimal solution.\nAPPROX -SUBSET -SUM. S;t;/SI/\n1nDjSj\n2L0Dh0i\n3foriD1ton\n4 LiDMERGE -LISTS.Li/NUL1;Li/NUL1Cxi/\n5 LiDTRIM.Li;/SI= 2n /\n6 remove from Lievery element that is greater than t\n7l e t \u00b4/ETXbe the largest value in Ln\n8return \u00b4/ETX\nLine 2 initializes the list L0to be the list containing just the element 0.T h e for\nloop in lines 3\u20136 computes Lias a sorted list containing a suitably trimmed ver-\nsion of the set Pi, with all elements larger than tremoved. Since we create Li\nfrom Li/NUL1, we must ensure that the repeated trimming doesn\u2019t introduce too much\ncompounded inaccuracy. In a moment, we shall see that A PPROX -SUBSET -SUM\nreturns a correct approximation if one exists.\nAs an example, suppose we have the instance\nSDh104; 102; 201; 101i\nwithtD308and/SID0:40. The trimming parameter \u0131is/SI=8D0:05.APPROX -\nSUBSET -SUMcomputes the following values on the indicated lines:\nline 2: L0Dh 0i;\nline 4: L1Dh 0; 104i;\nline 5: L1Dh 0; 104i;\nline 6: L1Dh 0; 104i;\nline 4: L2Dh 0; 102; 104; 206i;\nline 5: L2Dh 0; 102; 206i;\nline 6: L2Dh 0; 102; 206i;\nline 4: L3Dh 0; 102; 201; 206; 303; 407 i;\nline 5: L3Dh 0; 102; 201; 303; 407 i;\nline 6: L3Dh 0; 102; 201; 303i;\nline 4: L4Dh 0; 101; 102; 201; 203; 302; 303; 404 i;\nline 5: L4Dh 0; 101; 201; 302; 404 i;\nline 6: L4Dh 0; 101; 201; 302i:", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "1152": {"page_number": 1153, "page_information": "1132 Chapter 35 Approximation Algorithms\nThe algorithm returns \u00b4/ETXD302as its answer, which is well within /SID40%o f\nthe optimal answer 307D104C102C101; in fact, it is within 2%.\nTheorem 35.8\nAPPROX -SUBSET -SUMis a fully polynomial-time approximation scheme for the\nsubset-sum problem.\nProof The operations of trimming Liin line 5 and removing from Lievery ele-\nment that is greater than tmaintain the property that every element of Liis also a\nmember of Pi. Therefore, the value \u00b4/ETXreturned in line 8 is indeed the sum of some\nsubset of S.L e t y/ETX2Pndenote an optimal solution to the subset-sum problem.\nThen, from line 6, we know that \u00b4/ETX/DC4y/ETX. By inequality (35.1), we need to show\nthaty/ETX=\u00b4/ETX/DC41C/SI. We must also show that the running time of this algorithm is\npolynomial in both 1=/SIand the size of the input.\nAs Exercise 35.5-2 asks you to show, for every element yinPithat is at most t,\nthere exists an element \u00b42Lisuch that\ny\n.1C/SI=2n/i/DC4\u00b4/DC4y: (35.26)\nInequality (35.26) must hold for y/ETX2Pn, and therefore there exists an element\n\u00b42Lnsuch that\ny/ETX\n.1C/SI=2n/n/DC4\u00b4/DC4y/ETX;\nand thus\ny/ETX\n\u00b4/DC4/DLE\n1C/SI\n2n/DC1n\n: (35.27)\nSince there exists an element \u00b42Lnful\ufb01lling inequality (35.27), the inequality\nmust hold for \u00b4/ETX, which is the largest value in Ln;t h a ti s ,\ny/ETX\n\u00b4/ETX/DC4/DLE\n1C/SI\n2n/DC1n\n: (35.28)\nNow, we show that y/ETX=\u00b4/ETX/DC41C/SI.W ed os ob ys h o w i n gt h a t .1C/SI=2n/n/DC4\n1C/SI. By equation (3.14), we have lim n!1.1C/SI=2n/nDe/SI=2. Exercise 35.5-3\nasks you to show that\nd\ndn/DLE\n1C/SI\n2n/DC1n\n>0: (35.29)\nTherefore, the function .1C/SI=2n/nincreases with nas it approaches its limit\nofe/SI=2, and we have", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "1153": {"page_number": 1154, "page_information": "35.5 The subset-sum problem 1133\n/DLE\n1C/SI\n2n/DC1n\n/DC4e/SI=2\n/DC41C/SI=2C./SI=2/2(by inequality (3.13))\n/DC41C/SI (by inequality (35.25)) . (35.30)\nCombining inequalities (35.28) and (35.30) completes the analysis of the approxi-\nmation ratio.\nTo show that A PPROX -SUBSET -SUMis a fully polynomial-time approximation\nscheme, we derive a bound on the length of Li. After trimming, successive ele-\nments \u00b4and\u00b40ofLimust have the relationship \u00b40=\u00b4 > 1C/SI=2n . That is, they must\ndiffer by a factor of at least 1C/SI=2n . Each list, therefore, contains the value 0,\npossibly the value 1, and up to/EOT\nlog1C/SI=2nt\u02d8\nadditional values. The number of\nelements in each list Liis at most\nlog1C/SI=2ntC2Dlnt\nln.1C/SI=2n/C2\n/DC42n.1C/SI=2n/ lnt\n/SIC2(by inequality (3.17))\n<3nlnt\n/SIC2 (by inequality (35.25)) .\nThis bound is polynomial in the size of the input\u2014which is the number of bits lg t\nneeded to represent tplus the number of bits needed to represent the set S,w h i c hi s\nin turn polynomial in n\u2014and in 1=/SI. Since the running time of A PPROX -SUBSET -\nSUMis polynomial in the lengths of the Li, we conclude that A PPROX -SUBSET -\nSUMis a fully polynomial-time approximation scheme.\nExercises\n35.5-1\nProve equation (35.23). Then show that after executing line 5 of E XACT -SUBSET -\nSUM,Liis a sorted list containing every element of Piwhose value is not more\nthant.\n35.5-2\nUsing induction on i, prove inequality (35.26).\n35.5-3\nProve inequality (35.29).", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "1154": {"page_number": 1155, "page_information": "1134 Chapter 35 Approximation Algorithms\n35.5-4\nHow would you modify the approximation scheme presented in this section to \ufb01nda good approximation to the smallest value not less than tthat is a sum of some\nsubset of the given input list?\n35.5-5\nModify the A\nPPROX -SUBSET -SUMprocedure to also return the subset of Sthat\nsums to the value \u00b4/ETX.\nProblems\n35-1 Bin packing\nSuppose that we are given a set of nobjects, where the size siof the ith object\nsatis\ufb01es 0<s i<1. We wish to pack all the objects into the minimum number of\nunit-size bins. Each bin can hold any subset of the objects whose total size doesnot exceed 1.\na.Prove that the problem of determining the minimum number of bins required is\nNP-hard. ( Hint: Reduce from the subset-sum problem.)\nThe\ufb01rst-\ufb01t heuristic takes each object in turn and places it into the \ufb01rst bin that\ncan accommodate it. Let SDP\nn\niD1si.\nb.Argue that the optimal number of bins required is at least dSe.\nc.Argue that the \ufb01rst-\ufb01t heuristic leaves at most one bin less than half full.\nd.Prove that the number of bins used by the \ufb01rst-\ufb01t heuristic is never more\nthand2Se.\ne.Prove an approximation ratio of 2for the \ufb01rst-\ufb01t heuristic.\nf.Give an ef\ufb01cient implementation of the \ufb01rst-\ufb01t heuristic, and analyze its running\ntime.\n35-2 Approximating the size of a maximum clique\nLetGD.V; E/ be an undirected graph. For any k/NAK1,d e \ufb01 n e G.k/to be the undi-\nrected graph .V.k/;E.k//,w h e r e V.k/is the set of all ordered k-tuples of vertices\nfrom VandE.k/is de\ufb01ned so that ./ETB1;/ETB2;:::;/ETB k/is adjacent to .w1;w2;:::;w k/\nif and only if for iD1 ;2;:::;k , either vertex /ETBiis adjacent to wiinG,o re l s e\n/ETBiDwi.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "1155": {"page_number": 1156, "page_information": "Problems for Chapter 35 1135\na.Prove that the size of the maximum clique in G.k/is equal to the kth power of\nthe size of the maximum clique in G.\nb.Argue that if there is an approximation algorithm that has a constant approxi-\nmation ratio for \ufb01nding a maximum-size clique, then there is a polynomial-timeapproximation scheme for the problem.\n35-3 Weighted set-covering problem\nSuppose that we generalize the set-covering problem so that each set S\niin the\nfamily Fhas an associated weight wiand the weight of a cover CisP\nSi2Cwi.\nWe wish to determine a minimum-weight cover. (Section 35.3 handles the case inwhich w\niD1for all i.)\nShow how to generalize the greedy set-covering heuristic in a natural manner\nto provide an approximate solution for any instance of the weighted set-coveringproblem. Show that your heuristic has an approximation ratio of H.d/ ,w h e r e dis\nthe maximum size of any set S\ni.\n35-4 Maximum matching\nRecall that for an undirected graph G, a matching is a set of edges such that no\ntwo edges in the set are incident on the same vertex. In Section 26.3, we saw howto \ufb01nd a maximum matching in a bipartite graph. In this problem, we will look atmatchings in undirected graphs in general (i.e., the graphs are not required to bebipartite).\na.Amaximal matching is a matching that is not a proper subset of any other\nmatching. Show that a maximal matching need not be a maximum matching by\nexhibiting an undirected graph Gand a maximal matching MinGthat is not a\nmaximum matching. ( Hint: You can \ufb01nd such a graph with only four vertices.)\nb.Consider an undirected graph GD.V; E/ .G i v e a n O.E/ -time greedy algo-\nrithm to \ufb01nd a maximal matching in G.\nIn this problem, we shall concentrate on a polynomial-time approximation algo-\nrithm for maximum matching. Whereas the fastest known algorithm for maximum\nmatching takes superlinear (but polynomial) time, the approximation algorithmhere will run in linear time. You will show that the linear-time greedy algorithmfor maximal matching in part (b) is a 2-approximation algorithm for maximum\nmatching.\nc.Show that the size of a maximum matching in Gis a lower bound on the size\nof any vertex cover for G.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "1156": {"page_number": 1157, "page_information": "1136 Chapter 35 Approximation Algorithms\nd.Consider a maximal matching MinGD.V; E/ .L e t\nTDf/ETB2VWsome edge in Mis incident on /ETBg:\nWhat can you say about the subgraph of Ginduced by the vertices of Gthat\nare not in T?\ne.Conclude from part (d) that 2jMjis the size of a vertex cover for G.\nf.Using parts (c) and (e), prove that the greedy algorithm in part (b) is a 2-approx-\nimation algorithm for maximum matching.\n35-5 Parallel machine scheduling\nIn the parallel-machine-scheduling problem ,w ea r eg i v e n njobs, J1;J2;:::;J n,\nwhere each job Jkhas an associated nonnegative processing time of pk.W e a r e\nalso given midentical machines, M1;M 2;:::;M m. Any job can run on any ma-\nchine. A schedule speci\ufb01es, for each job Jk, the machine on which it runs and\nthe time period during which it runs. Each job Jkmust run on some machine Mi\nforpkconsecutive time units, and during that time period no other job may run\nonMi.L e t Ckdenote the completion time of job Jk, that is, the time at which\njobJkcompletes processing. Given a schedule, we de\ufb01ne CmaxDmax 1/DC4j/DC4nCjto\nbe the makespan of the schedule. The goal is to \ufb01nd a schedule whose makespan\nis minimum.\nFor example, suppose that we have two machines M1andM2and that we have\nfour jobs J1;J2;J3;J4, with p1D2,p2D12,p3D4,a n d p4D5. Then one\npossible schedule runs, on machine M1,j o b J1followed by job J2, and on ma-\nchine M2, it runs job J4followed by job J3. For this schedule, C1D2,C2D14,\nC3D9,C4D5,a n d CmaxD14. An optimal schedule runs J2on machine M1,a n d\nit runs jobs J1,J3,a n d J4on machine M2. For this schedule, C1D2,C2D12,\nC3D6,C4D11,a n d CmaxD12.\nGiven a parallel-machine-scheduling problem, we let C/ETX\nmaxdenote the makespan\nof an optimal schedule.\na.Show that the optimal makespan is at least as large as the greatest processing\ntime, that is,\nC/ETX\nmax/NAKmax\n1/DC4k/DC4npk:\nb.Show that the optimal makespan is at least as large as the average machine load,\nthat is,\nC/ETX\nmax/NAK1\nmX\n1/DC4k/DC4npk:", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "1157": {"page_number": 1158, "page_information": "Problems for Chapter 35 1137\nSuppose that we use the following greedy algorithm for parallel machine schedul-\ning: whenever a machine is idle, schedule any job that has not yet been scheduled.\nc.Write pseudocode to implement this greedy algorithm. What is the running\ntime of your algorithm?\nd.For the schedule returned by the greedy algorithm, show that\nCmax/DC41\nmX\n1/DC4k/DC4npkCmax\n1/DC4k/DC4npk:\nConclude that this algorithm is a polynomial-time 2-approximation algorithm.\n35-6 Approximating a maximum spanning tree\nLetGD.V; E/ be an undirected graph with distinct edge weights w.u;/ETB/ on each\nedge .u; /ETB/2E. For each vertex /ETB2V,l e tm a x ./ETB/Dmax .u;/ETB/ 2Efw.u;/ETB/gbe\nthe maximum-weight edge incident on that vertex. Let SGDfmax./ETB/W/ETB2Vg\nbe the set of maximum-weight edges incident on each vertex, and let TGbe the\nmaximum-weight spanning tree of G, that is, the spanning tree of maximum total\nweight. For any subset of edges E0/DC2E,d e \ufb01 n e w.E0/DP\n.u;/ETB/ 2E0w.u;/ETB/ .\na.Give an example of a graph with at least 4vertices for which SGDTG.\nb.Give an example of a graph with at least 4vertices for which SG\u00a4TG.\nc.Prove that SG/DC2TGfor any graph G.\nd.Prove that w.T G//NAKw.S G/=2for any graph G.\ne.Give an O.VCE/-time algorithm to compute a 2-approximation to the maxi-\nmum spanning tree.\n35-7 An approximation algorithm for the 0-1 knapsack problem\nRecall the knapsack problem from Section 16.2. There are nitems, where the ith\nitem is worth /ETBidollars and weighs wipounds. We are also given a knapsack\nthat can hold at most Wpounds. Here, we add the further assumptions that each\nweight wiis at most Wand that the items are indexed in monotonically decreasing\norder of their values: /ETB1/NAK/ETB2/NAK/SOH/SOH/SOH/NAK /ETBn.\nIn the 0-1 knapsack problem, we wish to \ufb01nd a subset of the items whose total\nweight is at most Wand whose total value is maximum. The fractional knapsack\nproblem is like the 0-1 knapsack problem, except that we are allowed to take afraction of each item, rather than being restricted to taking either all or none of", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "1158": {"page_number": 1159, "page_information": "1138 Chapter 35 Approximation Algorithms\neach item. If we take a fraction xiof item i,w h e r e 0/DC4xi/DC41, we contribute\nxiwito the weight of the knapsack and receive value xi/ETBi. Our goal is to develop\na polynomial-time 2-approximation algorithm for the 0-1 knapsack problem.\nIn order to design a polynomial-time algorithm, we consider restricted instances\nof the 0-1 knapsack problem. Given an instance Iof the knapsack problem, we\nform restricted instances Ij,f o rjD1 ;2;:::;n , by removing items 1 ;2;:::;j/NUL1\nand requiring the solution to include item j(all of item jin both the fractional\nand 0-1 knapsack problems). No items are removed in instance I1. For instance Ij,\nletPjdenote an optimal solution to the 0-1 problem and Qjdenote an optimal\nsolution to the fractional problem.\na.Argue that an optimal solution to instance Iof the 0-1 knapsack problem is one\noffP1;P2;:::;P ng.\nb.Prove that we can \ufb01nd an optimal solution Qjto the fractional problem for in-\nstance Ijby including item jand then using the greedy algorithm in which\nat each step, we take as much as possible of the unchosen item in the set\nfjC1; jC2;:::;ngwith maximum value per pound /ETBi=wi.\nc.Prove that we can always construct an optimal solution Qjto the fractional\nproblem for instance Ijthat includes at most one item fractionally. That is, for\nall items except possibly one, we either include all of the item or none of theitem in the knapsack.\nd.Given an optimal solution Q\njto the fractional problem for instance Ij,f o r m\nsolution Rjfrom Qjby deleting any fractional items from Qj.L e t /ETB.S/ denote\nthe total value of items taken in a solution S. Prove that /ETB.R j//NAK/ETB.Q j/=2/NAK\n/ETB.P j/=2.\ne.Give a polynomial-time algorithm that returns a maximum-value solution from\nthe setfR1;R2;:::;R ng, and prove that your algorithm is a polynomial-time\n2-approximation algorithm for the 0-1 knapsack problem.\nChapter notes\nAlthough methods that do not necessarily compute exact solutions have been\nknown for thousands of years (for example, methods to approximate the valueof/EM), the notion of an approximation algorithm is much more recent. Hochbaum\n[172] credits Garey, Graham, and Ullman [128] and Johnson [190] with formal-izing the concept of a polynomial-time approximation algorithm. The \ufb01rst suchalgorithm is often credited to Graham [149].", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "1159": {"page_number": 1160, "page_information": "Notes for Chapter 35 1139\nSince this early work, thousands of approximation algorithms have been de-\nsigned for a wide range of problems, and there is a wealth of literature on this\ufb01eld. Recent texts by Ausiello et al. [26], Hochbaum [172], and Vazirani [345]deal exclusively with approximation algorithms, as do surveys by Shmoys [315]and Klein and Young [207]. Several other texts, such as Garey and Johnson [129]and Papadimitriou and Steiglitz [271], have signi\ufb01cant coverage of approximationalgorithms as well. Lawler, Lenstra, Rinnooy Kan, and Shmoys [225] provide anextensive treatment of approximation algorithms for the traveling-salesman prob-\nlem.\nPapadimitriou and Steiglitz attribute the algorithm A\nPPROX -VERTEX -COVER\nto F. Gavril and M. Yannakakis. The vertex-cover problem has been studied exten-sively (Hochbaum [172] lists 16 different approximation algorithms for this prob-lem), but all the approximation ratios are at least 2/NULo.1/.\nThe algorithm A\nPPROX -TSP-T OUR appears in a paper by Rosenkrantz, Stearns,\nand Lewis [298]. Christo\ufb01des improved on this algorithm and gave a 3=2-approx-\nimation algorithm for the traveling-salesman problem with the triangle inequality.\nArora [22] and Mitchell [257] have shown that if the points are in the euclidean\nplane, there is a polynomial-time approximation scheme. Theorem 35.3 is due to\nSahni and Gonzalez [301].\nThe analysis of the greedy heuristic for the set-covering problem is modeled\nafter the proof published by Chv\u00b4 atal [68] of a more general result; the basic result\nas presented here is due to Johnson [190] and Lov\u00b4 asz [238].\nThe algorithm A PPROX -SUBSET -SUMand its analysis are loosely modeled after\nrelated approximation algorithms for the knapsack and subset-sum problems byIbarra and Kim [187].\nProblem 35-7 is a combinatorial version of a more general result on approximat-\ning knapsack-type integer programs by Bienstock and McClosky [45].\nThe randomized algorithm for MAX-3-CNF satis\ufb01ability is implicit in the work\nof Johnson [190]. The weighted vertex-cover algorithm is by Hochbaum [171].Section 35.4 only touches on the power of randomization and linear program-ming in the design of approximation algorithms. A combination of these two ideasyields a technique called \u201crandomized rounding,\u201d which formulates a problem asan integer linear program, solves the linear-programming relaxation, and interpretsthe variables in the solution as probabilities. These probabilities then help guidethe solution of the original problem. This technique was \ufb01rst used by Raghavanand Thompson [290], and it has had many subsequent uses. (See Motwani, Naor,\nand Raghavan [261] for a survey.) Several other notable recent ideas in the \ufb01eld\nof approximation algorithms include the primal-dual method (see Goemans andWilliamson [135] for a survey), \ufb01nding sparse cuts for use in divide-and-conqueralgorithms [229], and the use of semide\ufb01nite programming [134].", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "1160": {"page_number": 1161, "page_information": "1140 Chapter 35 Approximation Algorithms\nAs mentioned in the chapter notes for Chapter 34, recent results in probabilisti-\ncally checkable proofs have led to lower bounds on the approximability of manyproblems, including several in this chapter. In addition to the references there,the chapter by Arora and Lund [23] contains a good description of the relation-ship between probabilistically checkable proofs and the hardness of approximatingvarious problems.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "1161": {"page_number": 1162, "page_information": "", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "1162": {"page_number": 1163, "page_information": "VIII Appendix: Mathematical Background", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "1163": {"page_number": 1164, "page_information": "Introduction\nWhen we analyze algorithms, we often need to draw upon a body of mathematical\ntools. Some of these tools are as simple as high-school algebra, but others may be\nnew to you. In Part I, we saw how to manipulate asymptotic notations and solverecurrences. This appendix comprises a compendium of several other concepts andmethods we use to analyze algorithms. As noted in the introduction to Part I, youmay have seen much of the material in this appendix before having read this book(although the speci\ufb01c notational conventions we use might occasionally differ fromthose you have seen elsewhere). Hence, you should treat this appendix as referencematerial. As in the rest of this book, however, we have included exercises andproblems, in order for you to improve your skills in these areas.\nAppendix A offers methods for evaluating and bounding summations, which\noccur frequently in the analysis of algorithms. Many of the formulas here appearin any calculus text, but you will \ufb01nd it convenient to have these methods compiledin one place.\nAppendix B contains basic de\ufb01nitions and notations for sets, relations, functions,\ngraphs, and trees. It also gives some basic properties of these mathematical objects.\nAppendix C begins with elementary principles of counting: permutations, com-\nbinations, and the like. The remainder contains de\ufb01nitions and properties of basicprobability. Most of the algorithms in this book require no probability for theiranalysis, and thus you can easily omit the latter sections of the chapter on a \ufb01rstreading, even without skimming them. Later, when you encounter a probabilisticanalysis that you want to understand better, you will \ufb01nd Appendix C well orga-nized for reference purposes.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "1164": {"page_number": 1165, "page_information": "1144 Part VIII Appendix: Mathematical Background\nAppendix D de\ufb01nes matrices, their operations, and some of their basic prop-\nerties. You have probably seen most of this material already if you have taken acourse in linear algebra, but you might \ufb01nd it helpful to have one place to look forour notation and de\ufb01nitions.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "1165": {"page_number": 1166, "page_information": "A Summations\nWhen an algorithm contains an iterative control construct such as a while orfor\nloop, we can express its running time as the sum of the times spent on each exe-cution of the body of the loop. For example, we found in Section 2.2 that the jth\niteration of insertion sort took time proportional to jin the worst case. By adding\nup the time spent on each iteration, we obtained the summation (or series)\nnX\njD2j:\nWhen we evaluated this summation, we attained a bound of \u201a.n2/on the worst-\ncase running time of the algorithm. This example illustrates why you should knowhow to manipulate and bound summations.\nSection A.1 lists several basic formulas involving summations. Section A.2 of-\nfers useful techniques for bounding summations. We present the formulas in Sec-\ntion A.1 without proof, though proofs for some of them appear in Section A.2 to\nillustrate the methods of that section. You can \ufb01nd most of the other proofs in any\ncalculus text.\nA.1 Summation formulas and properties\nGiven a sequence a1;a2;:::;a nof numbers, where nis a nonnegative integer, we\ncan write the \ufb01nite sum a1Ca2C/SOH/SOH/SOHC anas\nnX\nkD1ak:\nIfnD0, the value of the summation is de\ufb01ned to be 0. The value of a \ufb01nite series\nis always well de\ufb01ned, and we can add its terms in any order.\nGiven an in\ufb01nite sequence a1;a2;:::of numbers, we can write the in\ufb01nite sum\na1Ca2C/SOH/SOH/SOH as", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "1166": {"page_number": 1167, "page_information": "1146 Appendix A Summations\n1X\nkD1ak;\nwhich we interpret to mean\nlim\nn!1nX\nkD1ak:\nIf the limit does not exist, the series diverges ; otherwise, it converges . The terms\nof a convergent series cannot always be added in any order. We can, however,rearrange the terms of an absolutely convergent series , that is, a seriesP\n1\nkD1ak\nfor which the seriesP1\nkD1jakjalso converges.\nLinearity\nFor any real number cand any \ufb01nite sequences a1;a2;:::;a nandb1;b2;:::;b n,\nnX\nkD1.ca kCbk/DcnX\nkD1akCnX\nkD1bk:\nThe linearity property also applies to in\ufb01nite convergent series.\nWe can exploit the linearity property to manipulate summations incorporating\nasymptotic notation. For example,\nnX\nkD1\u201a.f .k//D\u201a nX\nkD1f. k/!\n:\nIn this equation, the \u201a-notation on the left-hand side applies to the variable k,b u t\non the right-hand side, it applies to n. We can also apply such manipulations to\nin\ufb01nite convergent series.\nArithmetic series\nThe summation\nnX\nkD1kD1C2C/SOH/SOH/SOHC n;\nis anarithmetic series and has the value\nnX\nkD1kD1\n2n.nC1/ (A.1)\nD\u201a.n2/: (A.2)", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "1167": {"page_number": 1168, "page_information": "A.1 Summation formulas and properties 1147\nSums of squares and cubes\nWe have the following summations of squares and cubes:\nnX\nkD0k2Dn.nC1/.2nC1/\n6; (A.3)\nnX\nkD0k3Dn2.nC1/2\n4: (A.4)\nGeometric series\nFor real x\u00a41, the summation\nnX\nkD0xkD1CxCx2C/SOH/SOH/SOHC xn\nis ageometric orexponential series and has the value\nnX\nkD0xkDxnC1/NUL1\nx/NUL1: (A.5)\nWhen the summation is in\ufb01nite and jxj<1, we have the in\ufb01nite decreasing geo-\nmetric series\n1X\nkD0xkD1\n1/NULx: (A.6)\nHarmonic series\nFor positive integers n,t h enthharmonic number is\nHnD1C1\n2C1\n3C1\n4C/SOH/SOH/SOHC1\nn\nDnX\nkD11\nk\nDlnnCO.1/ : (A.7)\n(We shall prove a related bound in Section A.2.)\nIntegrating and differentiating series\nBy integrating or differentiating the formulas above, additional formulas arise. For\nexample, by differentiating both sides of the in\ufb01nite geometric series (A.6) andmultiplying by x,w eg e t", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "1168": {"page_number": 1169, "page_information": "1148 Appendix A Summations\n1X\nkD0kxkDx\n.1/NULx/2(A.8)\nforjxj<1.\nTelescoping series\nFor any sequence a0;a1;:::;a n,\nnX\nkD1.ak/NULak/NUL1/Dan/NULa0; (A.9)\nsince each of the terms a1;a2;:::;a n/NUL1is added in exactly once and subtracted out\nexactly once. We say that the sum telescopes . Similarly,\nn/NUL1X\nkD0.ak/NULakC1/Da0/NULan:\nAs an example of a telescoping sum, consider the series\nn/NUL1X\nkD11\nk.kC1/:\nSince we can rewrite each term as\n1\nk.kC1/D1\nk/NUL1\nkC1;\nwe get\nn/NUL1X\nkD11\nk.kC1/Dn/NUL1X\nkD1/DC21\nk/NUL1\nkC1/DC3\nD1/NUL1\nn:\nProducts\nWe can write the \ufb01nite product a1a2/SOH/SOH/SOHanas\nnY\nkD1ak:\nIfnD0, the value of the product is de\ufb01ned to be 1. We can convert a formula with\na product to a formula with a summation by using the identity\nlg nY\nkD1ak!\nDnX\nkD1lgak:", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "1169": {"page_number": 1170, "page_information": "A.2 Bounding summations 1149\nExercises\nA.1-1\nFind a simple formula forPn\nkD1.2k/NUL1/.\nA.1-2 ?\nShow thatPn\nkD11=.2k/NUL1/Dln.p\nn/CO.1/ by manipulating the harmonic\nseries.\nA.1-3\nShow thatP1\nkD0k2xkDx.1Cx/=.1/NULx/3for0<jxj<1.\nA.1-4 ?\nShow thatP1\nkD0.k/NUL1/=2kD0.\nA.1-5 ?\nEvaluate the sumP1\nkD1.2kC1/x2k.\nA.1-6\nProve thatPn\nkD1O.f k.i//DO/NULPn\nkD1fk.i//SOH\nby using the linearity property of\nsummations.\nA.1-7\nEvaluate the productQn\nkD12/SOH4k.\nA.1-8 ?\nEvaluate the productQn\nkD2.1/NUL1=k2/.\nA.2 Bounding summations\nWe have many techniques at our disposal for bounding the summations that de-\nscribe the running times of algorithms. Here are some of the most frequently usedmethods.\nMathematical induction\nThe most basic way to evaluate a series is to use mathematical induction. As an\nexample, let us prove that the arithmetic seriesP\nn\nkD1kevaluates to1\n2n.nC1/.W e\ncan easily verify this assertion for nD1. We make the inductive assumption that", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "1170": {"page_number": 1171, "page_information": "1150 Appendix A Summations\nit holds for n, and we prove that it holds for nC1.W eh a v e\nnC1X\nkD1kDnX\nkD1kC.nC1/\nD1\n2n.nC1/C.nC1/\nD1\n2.nC1/.nC2/ :\nYou don\u2019t always need to guess the exact value of a summation in order to use\nmathematical induction. Instead, you can use induction to prove a bound on a sum-\nmation. As an example, let us prove that the geometric seriesPn\nkD03kisO.3n/.\nMore speci\ufb01cally, let us prove thatPn\nkD03k/DC4c3nfor some constant c.F o r t h e\ninitial condition nD0,w eh a v eP0\nkD03kD1/DC4c/SOH1as long as c/NAK1. Assuming\nthat the bound holds for n, let us prove that it holds for nC1.W eh a v e\nnC1X\nkD03kDnX\nkD03kC3nC1\n/DC4c3nC3nC1(by the inductive hypothesis)\nD/DC21\n3C1\nc/DC3\nc3nC1\n/DC4c3nC1\nas long as .1=3C1=c//DC41or, equivalently, c/NAK3=2. Thus,Pn\nkD03kDO.3n/,\nas we wished to show.\nWe have to be careful when we use asymptotic notation to prove bounds by in-\nduction. Consider the following fallacious proof thatPn\nkD1kDO.n/ . Certainly,P1\nkD1kDO.1/ . Assuming that the bound holds for n, we now prove it for nC1:\nnC1X\nkD1kDnX\nkD1kC.nC1/\nDO.n/C.nC1//c143 wrong!!\nDO.nC1/ :\nThe bug in the argument is that the \u201cconstant\u201d hidden by the \u201cbig-oh\u201d grows with n\nand thus is not constant. We have not shown that the same constant works for alln.\nBounding the terms\nWe can sometimes obtain a good upper bound on a series by bounding each term\nof the series, and it often suf\ufb01ces to use the largest term to bound the others. For", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "1171": {"page_number": 1172, "page_information": "A.2 Bounding summations 1151\nexample, a quick upper bound on the arithmetic series (A.1) is\nnX\nkD1k/DC4nX\nkD1n\nDn2:\nIn general, for a seriesPn\nkD1ak,i fw el e t amaxDmax 1/DC4k/DC4nak,t h e n\nnX\nkD1ak/DC4n/SOHamax:\nThe technique of bounding each term in a series by the largest term is a weak\nmethod when the series can in fact be bounded by a geometric series. Given theseriesP\nn\nkD0ak, suppose that akC1=ak/DC4rfor all k/NAK0,w h e r e 0<r<1 is a\nconstant. We can bound the sum by an in\ufb01nite decreasing geometric series, since\nak/DC4a0rk, and thus\nnX\nkD0ak/DC41X\nkD0a0rk\nDa01X\nkD0rk\nDa01\n1/NULr:\nWe can apply this method to bound the summationP1\nkD1.k=3k/. In order to\nstart the summation at kD0, we rewrite it asP1\nkD0..kC1/=3kC1/.T h e \ufb01 r s t\nterm ( a0)i s1=3, and the ratio ( r) of consecutive terms is\n.kC2/=3kC2\n.kC1/=3kC1D1\n3/SOHkC2\nkC1\n/DC42\n3\nfor all k/NAK0. Thus, we have\n1X\nkD1k\n3kD1X\nkD0kC1\n3kC1\n/DC41\n3/SOH1\n1/NUL2=3\nD1:", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "1172": {"page_number": 1173, "page_information": "1152 Appendix A Summations\nA common bug in applying this method is to show that the ratio of consecu-\ntive terms is less than 1and then to assume that the summation is bounded by a\ngeometric series. An example is the in\ufb01nite harmonic series, which diverges since\n1X\nkD11\nkD lim\nn!1nX\nkD11\nk\nD lim\nn!1\u201a.lgn/\nD1 :\nThe ratio of the .kC1/st and kth terms in this series is k=.kC1/ < 1 , but the series\nis not bounded by a decreasing geometric series. To bound a series by a geometricseries, we must show that there is an r<1 ,w h i c hi sa constant , such that the ratio\nof all pairs of consecutive terms never exceeds r. In the harmonic series, no such r\nexists because the ratio becomes arbitrarily close to 1.\nSplitting summations\nOne way to obtain bounds on a dif\ufb01cult summation is to express the series as the\nsum of two or more series by partitioning the range of the index and then to boundeach of the resulting series. For example, suppose we try to \ufb01nd a lower boundon the arithmetic seriesP\nn\nkD1k, which we have already seen has an upper bound\nofn2. We might attempt to bound each term in the summation by the smallest term,\nbut since that term is 1, we get a lower bound of nfor the summation\u2014far off from\nour upper bound of n2.\nWe can obtain a better lower bound by \ufb01rst splitting the summation. Assume for\nconvenience that nis even. We have\nnX\nkD1kDn=2X\nkD1kCnX\nkDn=2C1k\n/NAKn=2X\nkD10CnX\nkDn=2C1.n=2/\nD.n=2/2\nD/DEL.n2/;\nwhich is an asymptotically tight bound, sincePn\nkD1kDO.n2/.\nFor a summation arising from the analysis of an algorithm, we can often split\nthe summation and ignore a constant number of the initial terms. Generally, this\ntechnique applies when each term akin a summationPn\nkD0akis independent of n.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "1173": {"page_number": 1174, "page_information": "A.2 Bounding summations 1153\nThen for any constant k0>0, we can write\nnX\nkD0akDk0/NUL1X\nkD0akCnX\nkDk0ak\nD\u201a.1/CnX\nkDk0ak;\nsince the initial terms of the summation are all constant and there are a constant\nnumber of them. We can then use other methods to boundPn\nkDk0ak. This tech-\nnique applies to in\ufb01nite summations as well. For example, to \ufb01nd an asymptotic\nupper bound on\n1X\nkD0k2\n2k;\nwe observe that the ratio of consecutive terms is\n.kC1/2=2kC1\nk2=2kD.kC1/2\n2k2\n/DC48\n9\nifk/NAK3. Thus, the summation can be split into\n1X\nkD0k2\n2kD2X\nkD0k2\n2kC1X\nkD3k2\n2k\n/DC42X\nkD0k2\n2kC9\n81X\nkD0/DC28\n9/DC3k\nDO.1/ ;\nsince the \ufb01rst summation has a constant number of terms and the second summation\nis a decreasing geometric series.\nThe technique of splitting summations can help us determine asymptotic bounds\nin much more dif\ufb01cult situations. For example, we can obtain a bound of O.lgn/\non the harmonic series (A.7):\nHnDnX\nkD11\nk:\nWe do so by splitting the range 1tonintoblgncC1pieces and upper-bounding\nthe contribution of each piece by 1.F o r iD0; 1; : : : ;blgnc,t h eith piece consists", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "1174": {"page_number": 1175, "page_information": "1154 Appendix A Summations\nof the terms starting at 1=2iand going up to but not including 1=2iC1. The last\npiece might contain terms not in the original harmonic series, and thus we have\nnX\nkD11\nk/DC4blgncX\niD02i/NUL1X\njD01\n2iCj\n/DC4blgncX\niD02i/NUL1X\njD01\n2i\nDblgncX\niD01\n/DC4lgnC1: (A.10)\nApproximation by integrals\nWhen a summation has the formPn\nkDmf. k/ ,w h e r e f. k/ is a monotonically in-\ncreasing function, we can approximate it by integrals:\nZn\nm/NUL1f. x/dx/DC4nX\nkDmf. k//DC4ZnC1\nmf. x/dx: (A.11)\nFigure A.1 justi\ufb01es this approximation. The summation is represented as the area\nof the rectangles in the \ufb01gure, and the integral is the shaded region under the curve.When f. k/ is a monotonically decreasing function, we can use a similar method\nto provide the bounds\nZ\nnC1\nmf. x/dx/DC4nX\nkDmf. k//DC4Zn\nm/NUL1f. x/dx: (A.12)\nThe integral approximation (A.12) gives a tight estimate for the nth harmonic\nnumber. For a lower bound, we obtain\nnX\nkD11\nk/NAKZnC1\n1dx\nx\nDln.nC1/ : (A.13)\nFor the upper bound, we derive the inequality\nnX\nkD21\nk/DC4Zn\n1dx\nx\nDlnn;", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "1175": {"page_number": 1176, "page_information": "A.2 Bounding summations 1155\nn+1 n\u20131 n\u20132 m+2 m m\u20131f (m)\nf (m+1)f (m+2)f (n\u20132)f (n\u20131)f (n)f(x)\nx\u2026\u2026n\u2026\u2026\n(a)m+1\nn+1 n\u20131 n\u20132 m+2 m m\u20131f (m)\nf (m+1)f (m+2)f (n\u20132)f (n\u20131)f (n)f(x)\nx\u2026\u2026n\u2026\u2026\n(b)m+1\nFigure A.1 Approximation ofPn\nkDmf. k/ by integrals. The area of each rectangle is shown\nwithin the rectangle, and the total rectangle area represents the value of the summation. The in-tegral is represented by the shaded area under the curve. By comparing areas in (a),w eg e tR\nn\nm/NUL1f. x/dx/DC4Pn\nkDmf. k/ , and then by shifting the rectangles one unit to the right, we getPn\nkDmf. k//DC4RnC1\nmf. x/dx in(b).", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "1176": {"page_number": 1177, "page_information": "1156 Appendix A Summations\nwhich yields the bound\nnX\nkD11\nk/DC4lnnC1: (A.14)\nExercises\nA.2-1\nShow thatPn\nkD11=k2is bounded above by a constant.\nA.2-2\nFind an asymptotic upper bound on the summation\nblgncX\nkD0\u02d9\nn=2k/BEL\n:\nA.2-3\nShow that the nth harmonic number is /DEL.lgn/by splitting the summation.\nA.2-4\nApproximatePn\nkD1k3with an integral.\nA.2-5\nWhy didn\u2019t we use the integral approximation (A.12) directly onPn\nkD11=k to\nobtain an upper bound on the nth harmonic number?\nProblems\nA-1 Bounding summations\nGive asymptotically tight bounds on the following summations. Assume that r/NAK0\nands/NAK0are constants.\na.nX\nkD1kr.\nb.nX\nkD1lgsk.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "1177": {"page_number": 1178, "page_information": "Notes for Appendix A 1157\nc.nX\nkD1krlgsk.\nAppendix notes\nKnuth [209] provides an excellent reference for the material presented here. You\ncan \ufb01nd basic properties of series in any good calculus book, such as Apostol [18]or Thomas et al. [334].", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "1178": {"page_number": 1179, "page_information": "B Sets, Etc.\nMany chapters of this book touch on the elements of discrete mathematics. This\nappendix reviews more completely the notations, de\ufb01nitions, and elementary prop-erties of sets, relations, functions, graphs, and trees. If you are already well versedin this material, you can probably just skim this chapter.\nB.1 Sets\nAsetis a collection of distinguishable objects, called its members orelements .I f\nan object xis a member of a set S, we write x2S(read \u201c xi sam e m b e ro f S\u201d\nor, more brie\ufb02y, \u201c xis in S\u201d). If xis not a member of S, we write x62S.W e\ncan describe a set by explicitly listing its members as a list inside braces. For\nexample, we can de\ufb01ne a set Sto contain precisely the numbers 1,2,a n d 3by\nwriting SDf1; 2; 3g.S i n c e 2is a member of the set S, we can write 22S,a n d\nsince 4is not a member, we have 4\u2026S. A set cannot contain the same object more\nthan once,1and its elements are not ordered. Two sets AandBareequal , written\nADB, if they contain the same elements. For example, f1; 2; 3; 1gDf1; 2; 3gD\nf3; 2; 1g.\nWe adopt special notations for frequently encountered sets:\n/SI;denotes the empty set , that is, the set containing no members.\n/SI Zdenotes the set of integers , that is, the setf:::;/NUL2;/NUL1; 0; 1; 2; : : :g.\n/SI Rdenotes the set of real numbers .\n/SI Ndenotes the set of natural numbers , that is, the setf0; 1; 2; : : :g.2\n1A variation of a set, which can contain the same object more than once, is called a multiset .\n2Some authors start the natural numbers with 1instead of 0. The modern trend seems to be to start\nwith0.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "1179": {"page_number": 1180, "page_information": "B.1 Sets 1159\nIf all the elements of a set Aare contained in a set B,t h a ti s ,i f x2Aimplies\nx2B, then we write A/DC2Band say that Ais asubset ofB. A set Ais a\nproper subset ofB, written A/SUBB,i fA/DC2BbutA\u00a4B. (Some authors use the\nsymbol \u201c/SUB\u201d to denote the ordinary subset relation, rather than the proper-subset\nrelation.) For any set A,w eh a v e A/DC2A. For two sets AandB,w eh a v e ADB\nif and only if A/DC2BandB/DC2A. For any three sets A,B,a n d C,i fA/DC2B\nandB/DC2C,t h e n A/DC2C. For any set A,w eh a v e;/DC2A.\nWe sometimes de\ufb01ne sets in terms of other sets. Given a set A, we can de\ufb01ne a\nsetB/DC2Aby stating a property that distinguishes the elements of B. For example,\nwe can de\ufb01ne the set of even integers by fxWx2Zandx=2is an integerg.T h e\ncolon in this notation is read \u201csuch that.\u201d (Some authors use a vertical bar in placeof the colon.)\nGiven two sets AandB, we can also de\ufb01ne new sets by applying set operations :\n/SITheintersection of sets AandBis the set\nA\\BDfxWx2Aandx2Bg:\n/SITheunion of sets AandBis the set\nA[BDfxWx2Aorx2Bg:\n/SIThedifference between two sets AandBis the set\nA/NULBDfxWx2Aandx\u2026Bg:\nSet operations obey the following laws:\nEmpty set laws:\nA\\; D ; ;\nA[; D A:\nIdempotency laws:\nA\\ADA;\nA[ADA:\nCommutative laws:\nA\\BDB\\A;\nA[BDB[A:", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "1180": {"page_number": 1181, "page_information": "1160 Appendix B Sets, Etc.\nA A A A A\nAB B B B B\n/NUL/NUL\n.B\\C/ [[\nD DD D\nA/NUL.B\\C/ . A/NULB/ .A /NULC/C C C C C\nFigure B.1 A Venn diagram illustrating the \ufb01rst of DeMorgan\u2019s laws (B.2). Each of the sets A,B,\nandCis represented as a circle.\nAssociative laws:\nA\\.B\\C/D.A\\B/\\C;\nA[.B[C/D.A[B/[C:\nDistributive laws:\nA\\.B[C/D.A\\B/[.A\\C/;\nA[.B\\C/D.A[B/\\.A[C/:(B.1)\nAbsorption laws:\nA\\.A[B/DA;\nA[.A\\B/DA:\nDeMorgan\u2019s laws:\nA/NUL.B\\C/D.A/NULB/[.A/NULC/;\nA/NUL.B[C/D.A/NULB/\\.A/NULC/:(B.2)\nFigure B.1 illustrates the \ufb01rst of DeMorgan\u2019s laws, using a Venn diagram : a graph-\nical picture in which sets are represented as regions of the plane.\nOften, all the sets under consideration are subsets of some larger set Ucalled the\nuniverse . For example, if we are considering various sets made up only of integers,\nthe set Zof integers is an appropriate universe. Given a universe U,w ed e \ufb01 n et h e\ncomplement of a set Aas\nADU/NULADfxWx2Uandx62Ag. For any set\nA/DC2U, we have the following laws:\nADA;\nA\\\nAD; ;\nA[\nADU:", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "1181": {"page_number": 1182, "page_information": "B.1 Sets 1161\nWe can rewrite DeMorgan\u2019s laws (B.2) with set complements. For any two sets\nB;C/DC2U,w eh a v e\nB\\CD\nB[\nC;\nB[CD\nB\\\nC:\nTwo sets AandBaredisjoint if they have no elements in common, that is, if\nA\\BD;. A collection SDfSigof nonempty sets forms a partition of a set Sif\n/SIthe sets are pairwise disjoint ,t h a ti s , Si;Sj2Sandi\u00a4jimply Si\\SjD;,\nand\n/SItheir union is S,t h a ti s ,\nSD[\nSi2SSi:\nIn other words, Sforms a partition of Sif each element of Sappears in exactly\noneSi2S.\nThe number of elements in a set is the cardinality (orsize) of the set, denoted jSj.\nTwo sets have the same cardinality if their elements can be put into a one-to-onecorrespondence. The cardinality of the empty set is j;jD0. If the cardinality of a\nset is a natural number, we say the set is \ufb01nite ; otherwise, it is in\ufb01nite . An in\ufb01nite\nset that can be put into a one-to-one correspondence with the natural numbers Nis\ncountably in\ufb01nite ; otherwise, it is uncountable . For example, the integers Zare\ncountable, but the reals Rare uncountable.\nFor any two \ufb01nite sets AandB, we have the identity\njA[BjDjAjCjBj/NULjA\\Bj; (B.3)\nfrom which we can conclude that\njA[Bj/DC4jAjCjBj:\nIfAandBare disjoint, thenjA\\BjD0and thusjA[BjDjAjCj\nBj.I f\nA/DC2B,t h e njAj/DC4jBj.\nA \ufb01nite set of nelements is sometimes called an n-set.A 1-set is called a\nsingleton . A subset of kelements of a set is sometimes called a k-subset .\nWe denote the set of all subsets of a set S, including the empty set and Sitself,\nby2S; we call 2Sthepower set ofS. For example, 2fa;bgDf;;fag;fbg;fa;bgg.\nThe power set of a \ufb01nite set Shas cardinality 2jSj(see Exercise B.1-5).\nWe sometimes care about setlike structures in which the elements are ordered.\nAnordered pair of two elements aandbis denoted .a; b/ and is de\ufb01ned formally\nas the set .a; b/Dfa;fa;bgg. Thus, the ordered pair .a; b/ isnott h es a m ea st h e\nordered pair .b; a/ .", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "1182": {"page_number": 1183, "page_information": "1162 Appendix B Sets, Etc.\nTheCartesian product of two sets AandB, denoted A/STXB, is the set of all\nordered pairs such that the \ufb01rst element of the pair is an element of Aand the\nsecond is an element of B. More formally,\nA/STXBDf.a; b/Wa2Aandb2Bg:\nFor example,fa;bg/STXfa;b;cgDf.a; a/; .a; b/; .a; c/; .b; a/; .b; b/; .b; c/ g.W h e n\nAandBare \ufb01nite sets, the cardinality of their Cartesian product is\njA/STXBjDjAj/SOHjBj: (B.4)\nThe Cartesian product of nsetsA1;A2;:::;A nis the set of n-tuples\nA1/STXA2/STX/SOH/SOH/SOH/STX AnDf.a1;a2;:::;a n/Wai2AiforiD1 ;2;:::;ng;\nwhose cardinality is\njA1/STXA2/STX/SOH/SOH/SOH/STX AnjDjA1j/SOHjA2j/SOH/SOH/SOHjAnj\nif all sets are \ufb01nite. We denote an n-fold Cartesian product over a single set Aby\nthe set\nAnDA/STXA/STX/SOH/SOH/SOH/STX A;\nwhose cardinality is jAnjDjAjnifAis \ufb01nite. We can also view an n-tuple as a\n\ufb01nite sequence of length n(see page 1166).\nExercises\nB.1-1\nDraw Venn diagrams that illustrate the \ufb01rst of the distributive laws (B.1).\nB.1-2\nProve the generalization of DeMorgan\u2019s laws to any \ufb01nite collection of sets:\nA1\\A2\\/SOH/SOH/SOH\\ AnD\nA1[\nA2[/SOH/SOH/SOH[\n An;\nA1[A2[/SOH/SOH/SOH[ AnD\nA1\\\nA2\\/SOH/SOH/SOH\\\n An:", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "1183": {"page_number": 1184, "page_information": "B.2 Relations 1163\nB.1-3 ?\nProve the generalization of equation (B.3), which is called the principle of inclu-\nsion and exclusion :\njA1[A2[/SOH/SOH/SOH[ AnjD\njA1jCjA2jC/SOH/SOH/SOHCjAnj\n/NULjA1\\A2j/NULjA1\\A3j/NUL/SOH/SOH/SOH (all pairs)\nCjA1\\A2\\A3jC/SOH/SOH/SOH (all triples)\n:::\nC./NUL1/n/NUL1jA1\\A2\\/SOH/SOH/SOH\\ Anj:\nB.1-4\nShow that the set of odd natural numbers is countable.\nB.1-5\nShow that for any \ufb01nite set S, the power set 2Shas2jSjelements (that is, there\nare2jSjdistinct subsets of S).\nB.1-6\nGive an inductive de\ufb01nition for an n-tuple by extending the set-theoretic de\ufb01nition\nfor an ordered pair.\nB.2 Relations\nAbinary relation Ron two sets AandBis a subset of the Cartesian product A/STXB.\nIf.a; b/2R, we sometimes write aRb . When we say that Ris a binary relation\non a set A, we mean that Ris a subset of A/STXA. For example, the \u201cless than\u201d\nrelation on the natural numbers is the set f.a; b/Wa;b2Nanda<bg.A n n-ary\nrelation on sets A1;A2;:::;A nis a subset of A1/STXA2/STX/SOH/SOH/SOH/STX An.\nA binary relation R/DC2A/STXAisre\ufb02exive if\naRa\nfor all a2A. For example, \u201cD\u201da n d\u201c/DC4\u201d are re\ufb02exive relations on N,b u t\u201c <\u201di s\nnot. The relation Rissymmetric if\naRb implies bRa\nfor all a;b2A. For example, \u201cD\u201d is symmetric, but \u201c <\u201da n d\u201c/DC4\u201d are not. The\nrelation Ristransitive if\naRb andbRc imply aRc", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "1184": {"page_number": 1185, "page_information": "1164 Appendix B Sets, Etc.\nfor all a;b;c2A. For example, the relations \u201c <,\u201d \u201c/DC4,\u201d and \u201cD\u201d are transitive, but\nthe relation RDf.a; b/Wa;b2NandaDb/NUL1gis not, since 3R4 and4R5\ndo not imply 3R5 .\nA relation that is re\ufb02exive, symmetric, and transitive is an equivalence relation .\nFor example, \u201cD\u201d is an equivalence relation on the natural numbers, but \u201c <\u201d is not.\nIfRis an equivalence relation on a set A, then for a2A,t h eequivalence class\nofais the set \u0152a/c141Dfb2AWaRbg, that is, the set of all elements equivalent to a.\nFor example, if we de\ufb01ne RDf.a; b/Wa;b2NandaCbis an even numberg,\nthenRis an equivalence relation, since aCais even (re\ufb02exive), aCbis even\nimplies bCais even (symmetric), and aCbis even and bCcis even imply\naCcis even (transitive). The equivalence class of 4is\u01524/c141Df0;2;4;6;:::g,a n d\nthe equivalence class of 3is\u01523/c141Df1; 3; 5; 7; : : :g. A basic theorem of equivalence\nclasses is the following.\nTheorem B.1 (An equivalence relation is the same as a partition)\nThe equivalence classes of any equivalence relation Ron a set Aform a partition\nofA, and any partition of Adetermines an equivalence relation on Afor which the\nsets in the partition are the equivalence classes.\nProof For the \ufb01rst part of the proof, we must show that the equivalence classes\nofRare nonempty, pairwise-disjoint sets whose union is A. Because Ris re\ufb02ex-\nive,a2\u0152a/c141, and so the equivalence classes are nonempty; moreover, since every\nelement a2Abelongs to the equivalence class \u0152a/c141, the union of the equivalence\nclasses is A. It remains to show that the equivalence classes are pairwise disjoint,\nthat is, if two equivalence classes \u0152a/c141and\u0152b/c141have an element cin common, then\nthey are in fact the same set. Suppose that aRc andbRc . By symmetry, cRb ,\nand by transitivity, aRb . Thus, for any arbitrary element x2\u0152a/c141,w eh a v e xRa\nand, by transitivity, xRb , and thus \u0152a/c141/DC2\u0152b/c141. Similarly, \u0152b/c141/DC2\u0152a/c141, and thus\n\u0152a/c141D\u0152b/c141.\nFor the second part of the proof, let ADfAigbe a partition of A, and de\ufb01ne\nRDf.a; b/Wthere exists isuch that a2Aiandb2Aig. We claim that Ris an\nequivalence relation on A. Re\ufb02exivity holds, since a2Aiimplies aRa . Symme-\ntry holds, because if aRb ,t h e n aandbare in the same set Ai, and hence bRa .\nIfaRb andbRc , then all three elements are in the same set Ai, and thus aRc\nand transitivity holds. To see that the sets in the partition are the equivalenceclasses of R, observe that if a2A\ni,t h e n x2\u0152a/c141implies x2Ai,a n d x2Ai\nimplies x2\u0152a/c141.\nA binary relation Ron a set Aisantisymmetric if\naRb andbRa imply aDb:", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "1185": {"page_number": 1186, "page_information": "B.2 Relations 1165\nFor example, the \u201c/DC4\u201d relation on the natural numbers is antisymmetric, since a/DC4b\nandb/DC4aimply aDb. A relation that is re\ufb02exive, antisymmetric, and transitive\nis apartial order , and we call a set on which a partial order is de\ufb01ned a partially\nordered set . For example, the relation \u201cis a descendant of\u201d is a partial order on the\nset of all people (if we view individuals as being their own descendants).\nIn a partially ordered set A, there may be no single \u201cmaximum\u201d element asuch\nthatbRa for all b2A. Instead, the set may contain several maximal elements a\nsuch that for no b2A,w h e r e b\u00a4a, is it the case that aRb . For example, a\ncollection of different-sized boxes may contain several maximal boxes that don\u2019t\n\ufb01t inside any other box, yet it has no single \u201cmaximum\u201d box into which any otherbox will \ufb01t.\n3\nA relation Ron a set Ais atotal relation if for all a;b2A,w eh a v e aRb\norbRa (or both), that is, if every pairing of elements of Ais related by R.A\npartial order that is also a total relation is a total order orlinear order . For example,\nthe relation \u201c/DC4\u201d is a total order on the natural numbers, but the \u201cis a descendant\nof\u201d relation is not a total order on the set of all people, since there are individualsneither of whom is descended from the other. A total relation that is transitive, butnot necessarily re\ufb02exive and antisymmetric, is a total preorder .\nExercises\nB.2-1\nProve that the subset relation \u201c /DC2\u201d on all subsets of Zis a partial order but not a\ntotal order.\nB.2-2\nShow that for any positive integer n, the relation \u201cequivalent modulo n\u201d is an equiv-\nalence relation on the integers. (We say that a/DC1b.mod n/if there exists an\ninteger qsuch that a/NULbDqn.) Into what equivalence classes does this relation\npartition the integers?\nB.2-3\nGive examples of relations that are\na.re\ufb02exive and symmetric but not transitive,\nb.re\ufb02exive and transitive but not symmetric,\nc.symmetric and transitive but not re\ufb02exive.\n3To be precise, in order for the \u201c\ufb01t inside\u201d relation to be a partial order, we need to view a box as\n\ufb01tting inside itself.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "1186": {"page_number": 1187, "page_information": "1166 Appendix B Sets, Etc.\nB.2-4\nLetSbe a \ufb01nite set, and let Rbe an equivalence relation on S/STXS. Show that if\nin addition Ris antisymmetric, then the equivalence classes of Swith respect to R\nare singletons.\nB.2-5\nProfessor Narcissus claims that if a relation Ris symmetric and transitive, then it is\nalso re\ufb02exive. He offers the following proof. By symmetry, aRb implies bRa .\nTransitivity, therefore, implies aRa . Is the professor correct?\nB.3 Functions\nGiven two sets AandB,afunction fis a binary relation on AandBsuch that\nfor all a2A, there exists precisely one b2Bsuch that .a; b/2f. The set Ais\ncalled the domain off, and the set Bis called the codomain off. We sometimes\nwrite fWA!B;a n di f .a; b/2f, we write bDf. a / ,s i n c e bis uniquely\ndetermined by the choice of a.\nIntuitively, the function fassigns an element of Bto each element of A.N o\nelement of Ais assigned two different elements of B, but the same element of B\ncan be assigned to two different elements of A. For example, the binary relation\nfDf.a; b/Wa;b2NandbDamod2g\nis a function fWN!f0; 1g, since for each natural number a, there is exactly one\nvalue binf0; 1gsuch that bDamod2. For this example, 0Df. 0 / ,1Df. 1 / ,\n0Df. 2 / , etc. In contrast, the binary relation\ngDf.a; b/Wa;b2NandaCbis eveng\nis not a function, since .1; 3/ and.1; 5/ are both in g, and thus for the choice aD1,\nthere is not precisely one bsuch that .a; b/2g.\nGiven a function fWA!B,i fbDf. a / , we say that ais theargument off\nand that bis thevalue offata. We can de\ufb01ne a function by stating its value for\nevery element of its domain. For example, we might de\ufb01ne f .n/D2nforn2N,\nwhich means fDf.n; 2n/Wn2Ng. Two functions fandgareequal if they\nhave the same domain and codomain and if, for all ain the domain, f. a /Dg.a/ .\nA\ufb01nite sequence of length nis a function fwhose domain is the set of n\nintegersf0; 1; : : : ; n/NUL1g. We often denote a \ufb01nite sequence by listing its values:\nhf. 0 / ;f. 1 / ;:::;f. n /NUL1/i.A nin\ufb01nite sequence is a function whose domain is\nthe set Nof natural numbers. For example, the Fibonacci sequence, de\ufb01ned by\nrecurrence (3.22), is the in\ufb01nite sequence h0; 1; 1; 2; 3; 5; 8; 13; 21; : : : i.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "1187": {"page_number": 1188, "page_information": "B.3 Functions 1167\nWhen the domain of a function fis a Cartesian product, we often omit the extra\nparentheses surrounding the argument of f. For example, if we had a function\nfWA1/STXA2/STX/SOH/SOH/SOH/STX An!B, we would write bDf. a 1;a2;:::;a n/instead\nofbDf ..a 1;a2;:::;a n//. We also call each aianargument to the function f,\nthough technically the (single) argument to fis the n-tuple .a1;a2;:::;a n/.\nIffWA!Bis a function and bDf. a / , then we sometimes say that bis the\nimage ofaunder f. The image of a set A0/DC2Aunder fis de\ufb01ned by\nf. A0/Dfb2BWbDf. a / for some a2A0g:\nTherange offis the image of its domain, that is, f. A / . For example, the range\nof the function fWN! Nde\ufb01ned by f .n/D2nisf.N/DfmWmD2nfor\nsome n2Ng, in other words, the set of nonnegative even integers.\nA function is a surjection if its range is its codomain. For example, the function\nf .n/Dbn=2cis a surjective function from NtoN, since every element in N\nappears as the value of ffor some argument. In contrast, the function f .n/D2n\nis not a surjective function from NtoN, since no argument to fcan produce 3as a\nvalue. The function f .n/D2nis, however, a surjective function from the natural\nnumbers to the even numbers. A surjection fWA!Bis sometimes described as\nmapping AontoB. When we say that fis onto, we mean that it is surjective.\nA function fWA!Bis aninjection if distinct arguments to fproduce\ndistinct values, that is, if a\u00a4a0implies f. a /\u00a4f. a0/. For example, the function\nf .n/D2nis an injective function from NtoN, since each even number bis the\nimage under fof at most one element of the domain, namely b=2. The function\nf .n/Dbn=2cis not injective, since the value 1is produced by two arguments: 2\nand3. An injection is sometimes called a one-to-one function.\nA function fWA!Bis abijection if it is injective and surjective. For example,\nthe function f .n/D./NUL1/ndn=2eis a bijection from NtoZ:\n0! 0;\n1!/NUL 1;\n2! 1;\n3!/NUL 2;\n4! 2;\n:::\nThe function is injective, since no element of Zis the image of more than one\nelement of N. It is surjective, since every element of Zappears as the image of\nsome element of N. Hence, the function is bijective. A bijection is sometimes\ncalled a one-to-one correspondence , since it pairs elements in the domain and\ncodomain. A bijection from a set Ato itself is sometimes called a permutation .\nWhen a function fis bijective, we de\ufb01ne its inverse f/NUL1as\nf/NUL1.b/Daif and only if f. a /Db:", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "1188": {"page_number": 1189, "page_information": "1168 Appendix B Sets, Etc.\nFor example, the inverse of the function f .n/D./NUL1/ndn=2eis\nf/NUL1.m/D(\n2m ifm/NAK0;\n/NUL2m/NUL1ifm<0:\nExercises\nB.3-1\nLetAandBbe \ufb01nite sets, and let fWA!Bbe a function. Show that\na.iffis injective, thenjAj/DC4jBj;\nb.iffis surjective, thenjAj/NAKjBj.\nB.3-2\nIs the function f. x/DxC1bijective when the domain and the codomain are N?\nIs it bijective when the domain and the codomain are Z?\nB.3-3\nGive a natural de\ufb01nition for the inverse of a binary relation such that if a relation\nis in fact a bijective function, its relational inverse is its functional inverse.\nB.3-4 ?\nGive a bijection from ZtoZ/STXZ.\nB.4 Graphs\nThis section presents two kinds of graphs: directed and undirected. Certain def-\ninitions in the literature differ from those given here, but for the most part, the\ndifferences are slight. Section 22.1 shows how we can represent graphs in com-puter memory.\nAdirected graph (ordigraph )Gi sap a i r .V; E/ ,w h e r e Vis a \ufb01nite set and E\nis a binary relation on V. The set Vis called the vertex set ofG, and its elements\nare called vertices (singular: vertex ). The set Eis called the edge set ofG, and its\nelements are called edges . Figure B.2(a) is a pictorial representation of a directed\ngraph on the vertex set f1; 2; 3; 4; 5; 6g. Vertices are represented by circles in the\n\ufb01gure, and edges are represented by arrows. Note that self-loops \u2014edges from a\nvertex to itself\u2014are possible.\nIn an undirected graph GD.V; E/ , the edge set Econsists of unordered\npairs of vertices, rather than ordered pairs. That is, an edge is a set fu; /ETBg,w h e r e", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "1189": {"page_number": 1190, "page_information": "B.4 Graphs 1169\n12 3\n45 6\n(a)12 345 6\n(b)12 3\n6\n(c)\nFigure B.2 Directed and undirected graphs. (a)A directed graph GD.V; E/ ,w h e r e VD\nf1; 2; 3; 4; 5; 6gandEDf.1; 2/; .2; 2/; .2; 4/; .2; 5/; .4; 1/; .4; 5/; .5; 4/; .6; 3/ g. The edge .2; 2/\nis a self-loop. (b)An undirected graph GD.V; E/ ,w h e r e VDf1; 2; 3; 4; 5; 6gandED\nf.1; 2/; .1; 5/; .2; 5/; .3; 6/ g.T h e v e r t e x 4is isolated. (c)The subgraph of the graph in part (a)\ninduced by the vertex set f1; 2; 3; 6g.\nu; /ETB2Vandu\u00a4/ETB. By convention, we use the notation .u; /ETB/ for an edge, rather\nthan the set notation fu; /ETBg, and we consider .u; /ETB/ and./ETB; u/ to be the same edge.\nIn an undirected graph, self-loops are forbidden, and so every edge consists of twodistinct vertices. Figure B.2(b) is a pictorial representation of an undirected graphon the vertex setf1; 2; 3; 4; 5; 6g.\nMany de\ufb01nitions for directed and undirected graphs are the same, although cer-\ntain terms have slightly different meanings in the two contexts. If .u; /ETB/ is an edge\nin a directed graph GD.V; E/ , we say that .u; /ETB/ isincident from orleaves\nvertex uand is incident to orenters vertex /ETB. For example, the edges leaving ver-\ntex2in Figure B.2(a) are .2; 2/ ,.2; 4/ ,a n d .2; 5/ . The edges entering vertex 2are\n.1; 2/ and.2; 2/ .I f.u; /ETB/ is an edge in an undirected graph GD.V; E/ , we say\nthat.u; /ETB/ isincident on vertices uand/ETB. In Figure B.2(b), the edges incident on\nvertex 2are.1; 2/ and.2; 5/ .\nIf.u; /ETB/ is an edge in a graph GD.V; E/ , we say that vertex /ETBisadjacent to\nvertex u. When the graph is undirected, the adjacency relation is symmetric. When\nthe graph is directed, the adjacency relation is not necessarily symmetric. If /ETBis\nadjacent to uin a directed graph, we sometimes write u!/ETB. In parts (a) and (b)\nof Figure B.2, vertex 2is adjacent to vertex 1, since the edge .1; 2/ belongs to both\ngraphs. Vertex 1isnotadjacent to vertex 2in Figure B.2(a), since the edge .2; 1/\ndoes not belong to the graph.\nThedegree of a vertex in an undirected graph is the number of edges incident on\nit. For example, vertex 2in Figure B.2(b) has degree 2. A vertex whose degree is 0,\nsuch as vertex 4in Figure B.2(b), is isolated . In a directed graph, the out-degree\nof a vertex is the number of edges leaving it, and the in-degree o fav e r t e xi st h e\nnumber of edges entering it. The degree of a vertex in a directed graph is its in-", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "1190": {"page_number": 1191, "page_information": "1170 Appendix B Sets, Etc.\ndegree plus its out-degree. Vertex 2in Figure B.2(a) has in-degree 2, out-degree 3,\nand degree 5.\nApath oflength kfrom a vertex uto a vertex u0in a graph GD.V; E/\nis a sequenceh/ETB0;/ETB1;/ETB2; :::;/ETB kiof vertices such that uD/ETB0,u0D/ETBk,a n d\n./ETBi/NUL1;/ETBi/2EforiD1 ;2;:::;k . The length of the path is the number of\nedges in the path. The path contains the vertices /ETB0;/ETB1;:::;/ETB kand the edges\n./ETB0;/ETB1/; ./ETB 1;/ETB2/ ;:::;. /ETB k/NUL1;/ETBk/.( T h e r ei sa l w a y sa 0-length path from utou.) If\nthere is a path pfrom utou0, we say that u0isreachable from uviap,w h i c hw e\nsometimes write as up;u0ifGis directed. A path is simple4if all vertices in the\npath are distinct. In Figure B.2(a), the path h1; 2; 5; 4iis a simple path of length 3.\nThe pathh2;5;4;5iis not simple.\nAsubpath of path pDh/ETB0;/ETB1;:::;/ETB kiis a contiguous subsequence of its ver-\ntices. That is, for any 0/DC4i/DC4j/DC4k, the subsequence of vertices h/ETBi;/ETBiC1;:::;/ETB ji\nis a subpath of p.\nIn a directed graph, a path h/ETB0;/ETB1;:::;/ETB kiforms a cycle if/ETB0D/ETBkand the\npath contains at least one edge. The cycle is simple if, in addition, /ETB1;/ETB2;:::;/ETB k\nare distinct. A self-loop is a cycle of length 1.T w op a t h sh/ETB0;/ETB1;/ETB2;:::;/ETB k/NUL1;/ETB0i\nandh/ETB0\n0;/ETB0\n1;/ETB0\n2;:::;/ETB0\nk/NUL1;/ETB0\n0iform the same cycle if there exists an integer jsuch\nthat/ETB0\niD/ETB.iCj/modkforiD0; 1; : : : ; k/NUL1. In Figure B.2(a), the path h1;2; 4;1i\nforms the same cycle as the paths h2;4; 1; 2iandh4;1; 2;4i. This cycle is simple,\nbut the cycleh1; 2; 4; 5; 4; 1iis not. The cycleh2; 2iformed by the edge .2; 2/ is\na self-loop. A directed graph with no self-loops is simple . In an undirected graph,\nap a t hh/ETB0;/ETB1;:::;/ETB kiforms a cycle ifk/NAK3and/ETB0D/ETBk;t h ec y c l ei s simple if\n/ETB1;/ETB2;:::;/ETB kare distinct. For example, in Figure B.2(b), the path h1; 2; 5; 1iis a\nsimple cycle. A graph with no cycles is acyclic .\nAn undirected graph is connected if every vertex is reachable from all other\nvertices. The connected components of a graph are the equivalence classes of\nvertices under the \u201cis reachable from\u201d relation. The graph in Figure B.2(b) hasthree connected components: f1; 2; 5g,f3; 6g,a n df4g. Every vertex inf1; 2; 5gis\nreachable from every other vertex in f1; 2; 5g. An undirected graph is connected\nif it has exactly one connected component. The edges of a connected componentare those that are incident on only the vertices of the component; in other words,edge .u; /ETB/ is an edge of a connected component only if both uand/ETBare vertices\nof the component.\nA directed graph is strongly connected if every two vertices are reachable from\neach other. The strongly connected components of a directed graph are the equiv-\n4Some authors refer to what we call a path as a \u201cwalk\u201d and to what we call a simple path as just a\n\u201cpath.\u201d We use the terms \u201cpath\u201d and \u201csimple path\u201d throughout this book in a manner consistent withtheir de\ufb01nitions.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "1191": {"page_number": 1192, "page_information": "B.4 Graphs 1171\n12\n3\n4 56\nuv wxyz\n(a)12\n3\n45\nuv wxy\n(b)G\nG\u2032\nFigure B.3 (a) A pair of isomorphic graphs. The vertices of the top graph are mapped to the\nvertices of the bottom graph by f. 1 /Du; f .2/D/ETB;f.3/Dw;f.4/Dx;f.5/Dy;f.6/D\u00b4.\n(b)Two graphs that are not isomorphic, since the top graph has a vertex of degree 4 and the bottom\ngraph does not.\nalence classes of vertices under the \u201care mutually reachable\u201d relation. A directed\ngraph is strongly connected if it has only one strongly connected component. The\ngraph in Figure B.2(a) has three strongly connected components: f1;2;4;5g,f3g,\nandf6g. All pairs of vertices in f1;2;4;5gare mutually reachable. The ver-\nticesf3; 6gdo not form a strongly connected component, since vertex 6cannot\nbe reached from vertex 3.\nTwo graphs GD.V; E/ andG0D.V0;E0/areisomorphic if there exists a\nbijection fWV!V0such that .u; /ETB/2Eif and only if .f .u/; f ./ETB//2E0.\nIn other words, we can relabel the vertices of Gto be vertices of G0, maintain-\ning the corresponding edges in GandG0. Figure B.3(a) shows a pair of iso-\nmorphic graphs GandG0with respective vertex sets VDf1; 2; 3; 4; 5; 6gand\nV0Dfu; /ETB; w; x; y; \u00b4g. The mapping from VtoV0given by f. 1 /Du; f .2/D/ETB;\nf. 3 /Dw;f.4/Dx;f.5/Dy;f.6/D\u00b4provides the required bijective func-\ntion. The graphs in Figure B.3(b) are not isomorphic. Although both graphs have5vertices and 7edges, the top graph has a vertex of degree 4and the bottom graph\ndoes not.\nWe say that a graph G\n0D.V0;E0/is asubgraph ofGD.V; E/ ifV0/DC2V\nandE0/DC2E. Given a set V0/DC2V, the subgraph of Ginduced byV0is the graph\nG0D.V0;E0/,w h e r e\nE0Df.u; /ETB/2EWu; /ETB2V0g:", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "1192": {"page_number": 1193, "page_information": "1172 Appendix B Sets, Etc.\nThe subgraph induced by the vertex set f1; 2; 3; 6gin Figure B.2(a) appears in\nFigure B.2(c) and has the edge set f.1; 2/; .2; 2/; .6; 3/g.\nGiven an undirected graph GD.V; E/ ,t h edirected version ofGis the directed\ngraph G0D.V; E0/,w h e r e .u; /ETB/2E0if and only if .u; /ETB/2E.T h a t i s , w e\nreplace each undirected edge .u; /ETB/ inGby the two directed edges .u; /ETB/ and./ETB; u/\nin the directed version. Given a directed graph GD.V; E/ ,t h eundirected version\nofGis the undirected graph G0D.V; E0/,w h e r e .u; /ETB/2E0if and only if u\u00a4/ETB\nand.u; /ETB/2E. That is, the undirected version contains the edges of G\u201cwith\ntheir directions removed\u201d and with self-loops eliminated. (Since .u; /ETB/ and./ETB; u/\nare the same edge in an undirected graph, the undirected version of a directedgraph contains it only once, even if the directed graph contains both edges .u; /ETB/\nand./ETB; u/ .) In a directed graph GD.V; E/ ,aneighbor of a vertex uis any vertex\nthat is adjacent to uin the undirected version of G.T h a ti s , /ETBis a neighbor of uif\nu\u00a4/ETBand either .u; /ETB/2Eor./ETB; u/2E. In an undirected graph, uand/ETBare\nneighbors if they are adjacent.\nSeveral kinds of graphs have special names. A complete graph is an undirected\ngraph in which every pair of vertices is adjacent. A bipartite graph is an undirected\ngraph GD.V; E/ in which Vcan be partitioned into two sets V\n1andV2such that\n.u; /ETB/2Eimplies either u2V1and/ETB2V2oru2V2and/ETB2V1. That is, all\nedges go between the two sets V1andV2. An acyclic, undirected graph is a forest ,\nand a connected, acyclic, undirected graph is a (free) tree (see Section B.5). We\noften take the \ufb01rst letters of \u201cdirected acyclic graph\u201d and call such a graph a dag.\nThere are two variants of graphs that you may occasionally encounter. A multi-\ngraph is like an undirected graph, but it can have both multiple edges between ver-\ntices and self-loops. A hypergraph is like an undirected graph, but each hyperedge ,\nrather than connecting two vertices, connects an arbitrary subset of vertices. Manyalgorithms written for ordinary directed and undirected graphs can be adapted torun on these graphlike structures.\nThecontraction of an undirected graph GD.V; E/ by an edge eD.u; /ETB/ is a\ngraph G\n0D.V0;E0/,w h e r e V0DV/NULfu; /ETBg[fxgandxis a new vertex. The set\nof edges E0is formed from Eby deleting the edge .u; /ETB/ and, for each vertex w\nincident on uor/ETB, deleting whichever of .u; w/ and./ETB; w/ is inEand adding the\nnew edge .x; w/ . In effect, uand/ETBare \u201ccontracted\u201d into a single vertex.\nExercises\nB.4-1\nAttendees of a faculty party shake hands to greet each other, and each professorremembers how many times he or she shook hands. At the end of the party, thedepartment head adds up the number of times that each professor shook hands.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "1193": {"page_number": 1194, "page_information": "B.5 Trees 1173\nShow that the result is even by proving the handshaking lemma :i fGD.V; E/ is\nan undirected graph, then\nX\n/ETB2Vdegree ./ETB/D2jEj:\nB.4-2\nShow that if a directed or undirected graph contains a path between two vertices u\nand/ETB, then it contains a simple path between uand/ETB. Show that if a directed graph\ncontains a cycle, then it contains a simple cycle.\nB.4-3\nShow that any connected, undirected graph GD.V; E/ satis\ufb01esjEj/NAKjVj/NUL1.\nB.4-4\nVerify that in an undirected graph, the \u201cis reachable from\u201d relation is an equiv-alence relation on the vertices of the graph. Which of the three properties of anequivalence relation hold in general for the \u201cis reachable from\u201d relation on thevertices of a directed graph?\nB.4-5\nWhat is the undirected version of the directed graph in Figure B.2(a)? What is thedirected version of the undirected graph in Figure B.2(b)?\nB.4-6 ?\nShow that we can represent a hypergraph by a bipartite graph if we let incidence inthe hypergraph correspond to adjacency in the bipartite graph. ( Hint: Let one set\nof vertices in the bipartite graph correspond to vertices of the hypergraph, and let\nthe other set of vertices of the bipartite graph correspond to hyperedges.)\nB.5 Trees\nAs with graphs, there are many related, but slightly different, notions of trees. Thissection presents de\ufb01nitions and mathematical properties of several kinds of trees.Sections 10.4 and 22.1 describe how we can represent trees in computer memory.\nB.5.1 Free trees\nAs de\ufb01ned in Section B.4, a free tree is a connected, acyclic, undirected graph. We\noften omit the adjective \u201cfree\u201d when we say that a graph is a tree. If an undirectedgraph is acyclic but possibly disconnected, it is a forest . Many algorithms that work", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "1194": {"page_number": 1195, "page_information": "1174 Appendix B Sets, Etc.\n(a) (b) (c)\nFigure B.4 (a) A free tree. (b)Af o r e s t . (c)A graph that contains a cycle and is therefore neither\nat r e en o raf o r e s t .\nfor trees also work for forests. Figure B.4(a) shows a free tree, and Figure B.4(b)\nshows a forest. The forest in Figure B.4(b) is not a tree because it is not connected.\nThe graph in Figure B.4(c) is connected but neither a tree nor a forest, because itcontains a cycle.\nThe following theorem captures many important facts about free trees.\nTheorem B.2 (Properties of free trees)\nLetGD.V; E/ be an undirected graph. The following statements are equivalent.\n1.Gis a free tree.\n2. Any two vertices in Gare connected by a unique simple path.\n3.Gis connected, but if any edge is removed from E, the resulting graph is dis-\nconnected.\n4.Gis connected, andjEjDjVj/NUL1.\n5.Gis acyclic, andjEjDjVj/NUL1.\n6.Gis acyclic, but if any edge is added to E, the resulting graph contains a cycle.\nProof (1))(2): Since a tree is connected, any two vertices in Gare connected\nby at least one simple path. Suppose, for the sake of contradiction, that vertices u\nand/ETBare connected by two distinct simple paths p\n1andp2, as shown in Figure B.5.\nLetwbe the vertex at which the paths \ufb01rst diverge; that is, wis the \ufb01rst vertex\non both p1andp2whose successor on p1isxand whose successor on p2isy,\nwhere x\u00a4y.L e t \u00b4be the \ufb01rst vertex at which the paths reconverge; that is, \u00b4is\nthe \ufb01rst vertex following wonp1that is also on p2.L e t p0be the subpath of p1\nfrom wthrough xto\u00b4,a n dl e t p00be the subpath of p2from wthrough yto\u00b4.\nPaths p0andp00share no vertices except their endpoints. Thus, the path obtained by\nconcatenating p0and the reverse of p00is a cycle, which contradicts our assumption", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "1195": {"page_number": 1196, "page_information": "B.5 Trees 1175\nuw\nzvx\nyp\u2032\np\u2032\u2032\nFigure B.5 A step in the proof of Theorem B.2: if (1) Gis a free tree, then (2) any two vertices\ninGare connected by a unique simple path. Assume for the sake of contradiction that vertices u\nand/ETBare connected by two distinct simple paths p1andp2. These paths \ufb01rst diverge at vertex w,\nand they \ufb01rst reconverge at vertex \u00b4. The path p0concatenated with the reverse of the path p00forms\na cycle, which yields the contradiction.\nthatGis a tree. Thus, if Gis a tree, there can be at most one simple path between\ntwo vertices.\n(2))(3): If any two vertices in Gare connected by a unique simple path,\nthenGis connected. Let .u; /ETB/ be any edge in E. This edge is a path from uto/ETB,\nand so it must be the unique path from uto/ETB. If we remove .u; /ETB/ from G,t h e r e\nis no path from uto/ETB, and hence its removal disconnects G.\n(3))(4): By assumption, the graph Gis connected, and by Exercise B.4-3, we\nhavejEj/NAKjVj/NUL1. We shall provejEj/DC4jVj/NUL1by induction. A connected\ngraph with nD1ornD2vertices has n/NUL1edges. Suppose that Ghasn/NAK3\nvertices and that all graphs satisfying (3) with fewer than nvertices also satisfy\njEj/DC4jVj/NUL1. Removing an arbitrary edge from Gseparates the graph into k/NAK2\nconnected components (actually kD2). Each component satis\ufb01es (3), or else G\nwould not satisfy (3). If we view each connected component Vi, with edge set Ei,\nas its own free tree, then because each component has fewer than jVjvertices, by\nthe inductive hypothesis we have jEij/DC4jVij/NUL1. Thus, the number of edges in all\ncomponents combined is at most jVj/NULk/DC4jVj/NUL2. Adding in the removed edge\nyieldsjEj/DC4jVj/NUL1.\n(4))(5): Suppose that Gis connected and that jEjDjVj/NUL1. We must show\nthatGis acyclic. Suppose that Ghas a cycle containing kvertices /ETB1;/ETB2;:::;/ETB k,\nand without loss of generality assume that this cycle is simple. Let GkD.Vk;Ek/\nbe the subgraph of Gconsisting of the cycle. Note that jVkjDjEkjDk.\nIfk<jVj, there must be a vertex /ETBkC12V/NULVkthat is adjacent to some ver-\ntex/ETBi2Vk,s i n c e Gis connected. De\ufb01ne GkC1D.VkC1;EkC1/to be the sub-\ngraph of GwithVkC1DVk[f/ETBkC1gandEkC1DEk[f./ETBi;/ETBkC1/g. Note that\njVkC1jDjEkC1jDkC1.I fkC1<jVj, we can continue, de\ufb01ning GkC2in\nthe same manner, and so forth, until we obtain GnD.Vn;En/,w h e r e nDjVj,", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "1196": {"page_number": 1197, "page_information": "1176 Appendix B Sets, Etc.\nVnDV,a n djEnjDjVnjDjVj.S i n c e Gnis a subgraph of G,w eh a v e En/DC2E,\nand hencejEj/NAKjVj, which contradicts the assumption that jEjDjVj/NUL1. Thus,\nGis acyclic.\n(5))(6): Suppose that Gis acyclic and that jEjDjVj/NUL1.L e t kbe the\nnumber of connected components of G. Each connected component is a free tree\nby de\ufb01nition, and since (1) implies (5), the sum of all edges in all connected com-ponents of GisjVj/NULk. Consequently, we must have kD1,a n d Gis in fact a\ntree. Since (1) implies (2), any two vertices in Gare connected by a unique simple\npath. Thus, adding any edge to Gcreates a cycle.\n(6))(1): Suppose that Gis acyclic but that adding any edge to Ecreates a\ncycle. We must show that Gis connected. Let uand/ETBbe arbitrary vertices in G.\nIfuand/ETBare not already adjacent, adding the edge .u; /ETB/ creates a cycle in which\nall edges but .u; /ETB/ belong to G. Thus, the cycle minus edge .u; /ETB/ must contain a\npath from uto/ETB, and since u\nand/ETBwere chosen arbitrarily, Gis connected.\nB.5.2 Rooted and ordered trees\nArooted tree is a free tree in which one of the vertices is distinguished from the\nothers. We call the distinguished vertex the root of the tree. We often refer to a\nvertex of a rooted tree as a node5of the tree. Figure B.6(a) shows a rooted tree on\na set of 12nodes with root 7.\nConsider a node xin a rooted tree Twith root r. We call any node yon the\nunique simple path from rtoxanancestor ofx.I fyis an ancestor of x,t h e n xis\nadescendant ofy. (Every node is both an ancestor and a descendant of itself.) If y\nis an ancestor of xandx\u00a4y,t h e n yis aproper ancestor ofxandxis aproper\ndescendant ofy.T h esubtree rooted at xis the tree induced by descendants of x,\nrooted at x. For example, the subtree rooted at node 8in Figure B.6(a) contains\nnodes 8,6,5,a n d 9.\nIf the last edge on the simple path from the root rof a tree Tto a node xis.y; x/ ,\nthenyis theparent ofx,a n d xis achild ofy. The root is the only node in Twith\nno parent. If two nodes have the same parent, they are siblings . A node with no\nchildren is a leaf orexternal node . A nonleaf node is an internal node .\n5The term \u201cnode\u201d is often used in the graph theory literature as a synonym for \u201cvertex.\u201d We reserve\nthe term \u201cnode\u201d to mean a vertex of a rooted tree.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "1197": {"page_number": 1198, "page_information": "B.5 Trees 1177\n9658\n11231 07\n11 24\nheight = 4depth 0\ndepth 1depth 2depth 3depth 4\n(a)\n9658 1231 07\n11 24\n(b)1\nFigure B.6 Rooted and ordered trees. (a)A rooted tree with height 4. The tree is drawn in a\nstandard way: the root (node 7) is at the top, its children (nodes with depth 1) are beneath it, their\nchildren (nodes with depth 2) are beneath them, and so forth. If the tree is ordered, the relative left-\nto-right order of the children of a node matters; otherwise it doesn\u2019t. (b)Another rooted tree. As a\nrooted tree, it is identical to the tree in (a), but as an ordered tree it is different, since the children of\nnode 3appear in a different order.\nThe number of children of a node xin a rooted tree Tequals the degree ofx.6\nThe length of the simple path from the root rto a node xis the depth ofxinT.\nAlevel of a tree consists of all nodes at the same depth. The height of a node in a\ntree is the number of edges on the longest simple downward path from the node toa leaf, and the height of a tree is the height of its root. The height of a tree is alsoequal to the largest depth of any node in the tree.\nAnordered tree is a rooted tree in which the children of each node are ordered.\nThat is, if a node has kc h i l d r e n , t h e n t h e r e i s a \ufb01 r s t c h i l d , a s e c o n d c h i l d , ...,\nand a kth child. The two trees in Figure B.6 are different when considered to be\nordered trees, but the same when considered to be just rooted trees.\nB.5.3 Binary and positional trees\nWe de\ufb01ne binary trees recursively. A binary tree Tis a structure de\ufb01ned on a \ufb01nite\nset of nodes that either\n/SIcontains no nodes, or\n6Notice that the degree of a node depends on whether we consider Tto be a rooted tree or a free tree.\nThe degree of a vertex in a free tree is, as in any undirected graph, the number of adjacent vertices.\nIn a rooted tree, however, the degree is the number of children\u2014the parent of a node does not count\ntoward its degree.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "1198": {"page_number": 1199, "page_information": "1178 Appendix B Sets, Etc.\n3\n2\n41\n67\n5\n(a)3\n2\n41\n67\n5\n(b)3\n2\n41\n67\n5\n(c)\nFigure B.7 Binary trees. (a)A binary tree drawn in a standard way. The left child of a node is\ndrawn beneath the node and to the left. The right child is drawn beneath and to the right. (b)Ab i n a r y\ntree different from the one in (a). In (a), the left child of node 7is5and the right child is absent.\nIn (b), the left child of node 7is absent and the right child is 5. As ordered trees, these trees are\nthe same, but as binary trees, they are distinct. (c)The binary tree in (a) represented by the internal\nnodes of a full binary tree: an ordered tree in which each internal node has degree 2. The leaves in\nthe tree are shown as squares.\n/SIis composed of three disjoint sets of nodes: a root node, a binary tree called its\nleft subtree , and a binary tree called its right subtree .\nThe binary tree that contains no nodes is called the empty tree ornull tree ,s o m e -\ntimes denoted NIL. If the left subtree is nonempty, its root is called the left child of\nthe root of the entire tree. Likewise, the root of a nonnull right subtree is the right\nchild of the root of the entire tree. If a subtree is the null tree NIL, we say that the\nchild is absent ormissing . Figure B.7(a) shows a binary tree.\nA binary tree is not simply an ordered tree in which each node has degree at\nmost 2. For example, in a binary tree, if a node has just one child, the position\nof the child\u2014whether it is the left child or the right child \u2014matters. In an or-\ndered tree, there is no distinguishing a sole child as being either left or right. Fig-ure B.7(b) shows a binary tree that differs from the tree in Figure B.7(a) because ofthe position of one node. Considered as ordered trees, however, the two trees areidentical.\nWe can represent the positioning information in a binary tree by the internal\nnodes of an ordered tree, as shown in Figure B.7(c). The idea is to replace eachmissing child in the binary tree with a node having no children. These leaf nodesare drawn as squares in the \ufb01gure. The tree that results is a full binary tree : each\nnode is either a leaf or has degree exactly 2. There are no degree- 1nodes. Conse-\nquently, the order of the children of a node preserves the position information.\nWe can extend the positioning information that distinguishes binary trees from\nordered trees to trees with more than 2children per node. In a positional tree ,t h e", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "1199": {"page_number": 1200, "page_information": "B.5 Trees 1179\nheight = 3depth 0\ndepth 1depth 2depth 3\nFigure B.8 A complete binary tree of height 3with8leaves and 7internal nodes.\nchildren of a node are labeled with distinct positive integers. The ith child of a\nnode is absent if no child is labeled with integer i.Ak-ary tree is a positional tree\nin which for every node, all children with labels greater than kare missing. Thus,\na binary tree is a k-ary tree with kD2.\nAcomplete k-ary tree is ak-ary tree in which all leaves have the same depth\nand all internal nodes have degree k. Figure B.8 shows a complete binary tree of\nheight 3. How many leaves does a complete k-ary tree of height hhave? The root\nhaskchildren at depth 1, each of which has kchildren at depth 2, etc. Thus, the\nnumber of leaves at depth hiskh. Consequently, the height of a complete k-ary\ntree with nleaves is logkn. The number of internal nodes of a complete k-ary tree\nof height his\n1CkCk2C/SOH/SOH/SOHC kh/NUL1Dh/NUL1X\niD0ki\nDkh/NUL1\nk/NUL1\nby equation (A.5). Thus, a complete binary tree has 2h/NUL1internal nodes.\nExercises\nB.5-1\nDraw all the free trees composed of the three vertices x,y,a n d \u00b4. Draw all the\nrooted trees with nodes x,y,a n d \u00b4withxas the root. Draw all the ordered trees\nwith nodes x,y,a n d \u00b4withxas the root. Draw all the binary trees with nodes x,\ny,a n d \u00b4withxas the root.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "1200": {"page_number": 1201, "page_information": "1180 Appendix B Sets, Etc.\nB.5-2\nLetGD.V; E/ be a directed acyclic graph in which there is a vertex /ETB02V\nsuch that there exists a unique path from /ETB0to every vertex /ETB2V. Prove that the\nundirected version of Gforms a tree.\nB.5-3\nShow by induction that the number of degree- 2nodes in any nonempty binary tree\nis1fewer than the number of leaves. Conclude that the number of internal nodes\nin a full binary tree is 1fewer than the number of leaves.\nB.5-4\nUse induction to show that a nonempty binary tree with nnodes has height at\nleastblgnc.\nB.5-5 ?\nTheinternal path length of a full binary tree is the sum, taken over all internal\nnodes of the tree, of the depth of each node. Likewise, the external path length is\nthe sum, taken over all leaves of the tree, of the depth of each leaf. Consider a fullbinary tree with ninternal nodes, internal path length i, and external path length e.\nProve that eDiC2n.\nB.5-6 ?\nLet us associate a \u201cweight\u201d w.x/D2\n/NULdwith each leaf xof depth din a binary\ntreeT,a n dl e t Lbe the set of leaves of T. Prove thatP\nx2Lw.x//DC41. (This is\nknown as the Kraft inequality .)\nB.5-7 ?\nShow that if L/NAK2, then every binary tree with Lleaves contains a subtree having\nbetween L=3 and2L=3 leaves, inclusive.\nProblems\nB-1 Graph coloring\nGiven an undirected graph GD.V; E/ ,ak-coloring ofGis a function cWV!\nf0; 1; : : : ; k/NUL1gsuch that c.u/\u00a4c./ETB/ for every edge .u; /ETB/2E. In other words,\nthe numbers 0; 1; : : : ; k/NUL1represent the kcolors, and adjacent vertices must have\ndifferent colors.\na.Show that any tree is 2-colorable.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "1201": {"page_number": 1202, "page_information": "Problems for Appendix B 1181\nb.Show that the following are equivalent:\n1.Gis bipartite.\n2.Gis2-colorable.\n3.Ghas no cycles of odd length.\nc.Letdbe the maximum degree of any vertex in a graph G. Prove that we can\ncolor GwithdC1colors.\nd.Show that if GhasO.jVj/edges, then we can color GwithO.p\njVj/colors.\nB-2 Friendly graphs\nReword each of the following statements as a theorem about undirected graphs,and then prove it. Assume that friendship is symmetric but not re\ufb02exive.\na.Any group of at least two people contains at least two people with the same\nnumber of friends in the group.\nb.Every group of six people contains either at least three mutual friends or at least\nthree mutual strangers.\nc.Any group of people can be partitioned into two subgroups such that at least\nhalf the friends of each person belong to the subgroup of which that person isnotam e m b e r .\nd.If everyone in a group is the friend of at least half the people in the group, then\nthe group can be seated around a table in such a way that everyone is seatedbetween two friends.\nB-3 Bisecting trees\nMany divide-and-conquer algorithms that operate on graphs require that the graphbe bisected into two nearly equal-sized subgraphs, which are induced by a partitionof the vertices. This problem investigates bisections of trees formed by removing asmall number of edges. We require that whenever two vertices end up in the samesubtree after removing edges, then they must be in the same partition.\na.Show that we can partition the vertices of any n-vertex binary tree into two\nsetsAandB, such thatjAj/DC43n=4 andjBj/DC43n=4 ,b yr e m o v i n gas i n g l e\nedge.\nb.Show that the constant 3=4in part (a) is optimal in the worst case by giving\nan example of a simple binary tree whose most evenly balanced partition uponremoval of a single edge has jAjD3n=4 .", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "1202": {"page_number": 1203, "page_information": "1182 Appendix B Sets, Etc.\nc.Show that by removing at most O.lgn/edges, we can partition the vertices\nof any n-vertex binary tree into two sets AandBsuch thatjAjDbn=2c\nandjBjDdn=2e.\nAppendix notes\nG. Boole pioneered the development of symbolic logic, and he introduced many of\nthe basic set notations in a book published in 1854. Modern set theory was createdby G. Cantor during the period 1874\u20131895. Cantor focused primarily on sets ofin\ufb01nite cardinality. The term \u201cfunction\u201d is attributed to G. W. Leibniz, who used itto refer to several kinds of mathematical formulas. His limited de\ufb01nition has beengeneralized many times. Graph theory originated in 1736, when L. Euler provedthat it was impossible to cross each of the seven bridges in the city of K\u00a8 onigsberg\nexactly once and return to the starting point.\nThe book by Harary [160] provides a useful compendium of many de\ufb01nitions\nand results from graph theory.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "1203": {"page_number": 1204, "page_information": "C Counting and Probability\nThis appendix reviews elementary combinatorics and probability theory. If you\nhave a good background in these areas, you may want to skim the beginning of thisappendix lightly and concentrate on the later sections. Most of this book\u2019s chaptersdo not require probability, but for some chapters it is essential.\nSection C.1 reviews elementary results in counting theory, including standard\nformulas for counting permutations and combinations. The axioms of probabilityand basic facts concerning probability distributions form Section C.2. Randomvariables are introduced in Section C.3, along with the properties of expectationand variance. Section C.4 investigates the geometric and binomial distributionsthat arise from studying Bernoulli trials. The study of the binomial distributioncontinues in Section C.5, an advanced discussion of the \u201ctails\u201d of the distribution.\nC.1 Counting\nCounting theory tries to answer the question \u201cHow many?\u201d without actually enu-merating all the choices. For example, we might ask, \u201cHow many different n-bit\nnumbers are there?\u201d or \u201cHow many orderings of ndistinct elements are there?\u201d In\nthis section, we review the elements of counting theory. Since some of the materialassumes a basic understanding of sets, you might wish to start by reviewing thematerial in Section B.1.\nRules of sum and product\nWe can sometimes express a set of items that we wish to count as a union of disjoint\nsets or as a Cartesian product of sets.\nTherule of sum says that the number of ways to choose one element from one\nof two disjoint sets is the sum of the cardinalities of the sets. That is, if AandB\nare two \ufb01nite sets with no members in common, then jA[BjDjAjCjBj,w h i c h", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "1204": {"page_number": 1205, "page_information": "1184 Appendix C Counting and Probability\nfollows from equation (B.3). For example, each position on a car\u2019s license plate\nis a letter or a digit. The number of possibilities for each position is therefore26C10D36, since there are 26 choices if it is a letter and 10 choices if it is a\ndigit.\nTherule of product says that the number of ways to choose an ordered pair is the\nnumber of ways to choose the \ufb01rst element times the number of ways to choose thesecond element. That is, if AandBare two \ufb01nite sets, then jA/STXBjDjAj/SOHjBj,\nwhich is simply equation (B.4). For example, if an ice-cream parlor offers 28\n\ufb02avors of ice cream and 4 toppings, the number of possible sundaes with one scoop\nof ice cream and one topping is 28/SOH4D112.\nStrings\nAstring over a \ufb01nite set Sis a sequence of elements of S. For example, there are 8\nbinary strings of length 3:\n000; 001; 010; 011; 100; 101; 110; 111 :\nWe sometimes call a string of length kak-string .Asubstring s\n0of a string s\nis an ordered sequence of consecutive elements of s.Ak-substring of a string\nis a substring of length k. For example, 010is a3-substring of 01101001 (the\n3-substring that begins in position 4), but 111is not a substring of 01101001 .\nWe can view a k-string over a set Sas an element of the Cartesian product Sk\nofk-tuples; thus, there are jSjkstrings of length k. For example, the number of\nbinary k-strings is 2k. Intuitively, to construct a k-string over an n-set, we have n\nways to pick the \ufb01rst element; for each of these choices, we have nways to pick the\nsecond element; and so forth ktimes. This construction leads to the k-fold product\nn/SOHn/SOH/SOH/SOHnDnkas the number of k-strings.\nPermutations\nApermutation of a \ufb01nite set Sis an ordered sequence of all the elements of S,\nwith each element appearing exactly once. For example, if SDfa;b;cg,t h e n S\nhas6permutations:\nabc;acb;bac;bca;cab;cba :\nThere are n\u0160permutations of a set of nelements, since we can choose the \ufb01rst\nelement of the sequence in nways, the second in n/NUL1ways, the third in n/NUL2\nways, and so on.\nAk-permutation ofSis an ordered sequence of kelements of S, with no ele-\nment appearing more than once in the sequence. (Thus, an ordinary permutation isann-permutation of an n-set.) The twelve 2-permutations of the set fa;b;c;dgare", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "1205": {"page_number": 1206, "page_information": "C.1 Counting 1185\nab;ac;ad;ba;bc;bd;ca;cb;cd;da;db;dc :\nThe number of k-permutations of an n-set is\nn.n/NUL1/.n/NUL2//SOH/SOH/SOH.n/NULkC1/Dn\u0160\n.n/NULk/\u0160; (C.1)\nsince we have nways to choose the \ufb01rst element, n/NUL1ways to choose the second\nelement, and so on, until we have selected kelements, the last being a selection\nfrom the remaining n/NULkC1elements.\nCombinations\nAk-combination of an n-setSis simply a k-subset of S. For example, the 4-set\nfa;b;c;dghas six 2-combinations:\nab;ac;ad;bc;bd;cd :\n(Here we use the shorthand of denoting the 2-subsetfa;bgbyab, and so on.)\nWe can construct a k-combination of an n-set by choosing kdistinct (different)\nelements from the n-set. The order in which we select the elements does not matter.\nWe can express the number of k-combinations of an n-set in terms of the number\nofk-permutations of an n-set. Every k-combination has exactly k\u0160permutations\nof its elements, each of which is a distinct k-permutation of the n-set. Thus, the\nnumber of k-combinations of an n-set is the number of k-permutations divided\nbyk\u0160; from equation (C.1), this quantity is\nn\u0160\nk\u0160.n/NULk/\u0160: (C.2)\nForkD0, this formula tells us that the number of ways to choose 0elements from\nann-set is 1(not0), since 0\u0160D1.\nBinomial coef\ufb01cients\nThe notation/NULn\nk/SOH\n(read \u201c nchoose k\u201d) denotes the number of k-combinations of\nann-set. From equation (C.2), we have\n \nn\nk!\nDn\u0160\nk\u0160.n/NULk/\u0160:\nThis formula is symmetric in kandn/NULk:\n \nn\nk!\nD \nn\nn/NULk!\n: (C.3)", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "1206": {"page_number": 1207, "page_information": "1186 Appendix C Counting and Probability\nThese numbers are also known as binomial coef\ufb01cients , due to their appearance in\nthebinomial expansion :\n.xCy/nDnX\nkD0 \nn\nk!\nxkyn/NULk: (C.4)\nA special case of the binomial expansion occurs when xDyD1:\n2nDnX\nkD0 \nn\nk!\n:\nThis formula corresponds to counting the 2nbinary n-strings by the number of 1s\nthey contain:/NULn\nk/SOH\nbinary n-strings contain exactly k1s, since we have/NULn\nk/SOH\nways to\nchoose kout of the npositions in which to place the 1s.\nMany identities involve binomial coef\ufb01cients. The exercises at the end of this\nsection give you the opportunity to prove a few.\nBinomial bounds\nWe sometimes need to bound the size of a binomial coef\ufb01cient. For 1/DC4k/DC4n,\nwe have the lower bound\n \nn\nk!\nDn.n/NUL1//SOH/SOH/SOH.n/NULkC1/\nk.k/NUL1//SOH/SOH/SOH1\nD/DLEn\nk/DC1/DC2n/NUL1\nk/NUL1/DC3\n/SOH/SOH/SOH/DC2n/NULkC1\n1/DC3\n/NAK/DLEn\nk/DC1k\n:\nTaking advantage of the inequality k\u0160/NAK.k=e/kderived from Stirling\u2019s approxi-\nmation (3.18), we obtain the upper bounds\n \nn\nk!\nDn.n/NUL1//SOH/SOH/SOH.n/NULkC1/\nk.k/NUL1//SOH/SOH/SOH1\n/DC4nk\nk\u0160\n/DC4/DLEen\nk/DC1k\n: (C.5)\nFor all integers ksuch that 0/DC4k/DC4n, we can use induction (see Exercise C.1-12)\nto prove the bound", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "1207": {"page_number": 1208, "page_information": "C.1 Counting 1187\n \nn\nk!\n/DC4nn\nkk.n/NULk/n/NULk; (C.6)\nwhere for convenience we assume that 00D1.F o r kD/NAKn,w h e r e 0/DC4/NAK/DC41,w e\ncan rewrite this bound as\n \nn\n/NAKn!\n/DC4nn\n./NAKn//NAKn..1/NUL/NAK/n/.1/NUL/NAK/n\nD /DC21\n/NAK/DC3/NAK/DC21\n1/NUL/NAK/DC31/NUL/NAK!n\nD2nH. /NAK /;\nwhereH./NAK/D/NUL/NAKlg/NAK/NUL.1/NUL/NAK/lg.1/NUL/NAK/ (C.7)\nis the (binary) entropy function and where, for convenience, we assume that\n0lg0D0,s ot h a t H.0/DH.1/D0.\nExercises\nC.1-1\nHow many k-substrings does an n-string have? (Consider identical k-substrings at\ndifferent positions to be different.) How many substrings does an n-string have in\ntotal?\nC.1-2\nAnn-input, m-output boolean function is a function from f\nTRUE ;FALSEgnto\nfTRUE ;FALSEgm.H o wm a n y n-input, 1-output boolean functions are there? How\nmany n-input, m-output boolean functions are there?\nC.1-3\nIn how many ways can nprofessors sit around a circular conference table? Con-\nsider two seatings to be the same if one can be rotated to form the other.\nC.1-4\nIn how many ways can we choose three distinct numbers from the set f1 ;2;:::;9 9g\nso that their sum is even?", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "1208": {"page_number": 1209, "page_information": "1188 Appendix C Counting and Probability\nC.1-5\nProve the identity\n \nn\nk!\nDn\nk \nn/NUL1\nk/NUL1!\n(C.8)\nfor0<k/DC4n.\nC.1-6\nProve the identity\n \nn\nk!\nDn\nn/NULk \nn/NUL1\nk!\nfor0/DC4k<n .\nC.1-7\nTo choose kobjects from n, you can make one of the objects distinguished and\nconsider whether the distinguished object is chosen. Use this approach to provethat \nn\nk!\nD \nn/NUL1\nk!\nC \nn/NUL1\nk/NUL1!\n:\nC.1-8\nUsing the result of Exercise C.1-7, make a table for nD0; 1; : : : ; 6 and0/DC4k/DC4n\nof the binomial coef\ufb01cients/NUL\nn\nk/SOH\nwith/NUL0\n0/SOH\nat the top,/NUL1\n0/SOH\nand/NUL1\n1/SOH\non the next line, and\nso forth. Such a table of binomial coef\ufb01cients is called Pascal\u2019s triangle .\nC.1-9\nProve that\nnX\niD1iD \nnC1\n2!\n:\nC.1-10\nShow that for any integers n/NAK0and0/DC4k/DC4n, the expression/NULn\nk/SOH\nachieves its\nmaximum value when kDbn=2corkDdn=2e.\nC.1-11 ?\nArgue that for any integers n/NAK0,j/NAK0,k/NAK0,a n d jCk/DC4n,\n \nn\njCk!\n/DC4 \nn\nj! \nn/NULj\nk!\n: (C.9)", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "1209": {"page_number": 1210, "page_information": "C.2 Probability 1189\nProvide both an algebraic proof and an argument based on a method for choosing\njCkitems out of n. Give an example in which equality does not hold.\nC.1-12 ?\nUse induction on all integers ksuch that 0/DC4k/DC4n=2to prove inequality (C.6),\nand use equation (C.3) to extend it to all integers ksuch that 0/DC4k/DC4n.\nC.1-13 ?\nUse Stirling\u2019s approximation to prove that\n \n2n\nn!\nD22n\np\n/EMn.1CO.1=n// : (C.10)\nC.1-14 ?\nBy differentiating the entropy function H./NAK/ , show that it achieves its maximum\nvalue at /NAKD1=2.W h a ti s H.1=2/ ?\nC.1-15 ?\nShow that for any integer n/NAK0,\nnX\nkD0 \nn\nk!\nkDn2n/NUL1: (C.11)\nC.2 Probability\nProbability is an essential tool for the design and analysis of probabilistic and ran-\ndomized algorithms. This section reviews basic probability theory.\nWe de\ufb01ne probability in terms of a sample space S, which is a set whose ele-\nments are called elementary events . We can think of each elementary event as a\npossible outcome of an experiment. For the experiment of \ufb02ipping two distinguish-able coins, with each individual \ufb02ip resulting in a head (\nH)o rat a i l( T), we can view\nthe sample space as consisting of the set of all possible 2-strings overfH;Tg:\nSDfHH;HT;TH;TTg:", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "1210": {"page_number": 1211, "page_information": "1190 Appendix C Counting and Probability\nAnevent i sas u b s e t1of the sample space S. For example, in the experiment of\n\ufb02ipping two coins, the event of obtaining one head and one tail is fHT;THg.T h e\nevent Sis called the certain event , and the event;is called the null event . We say\nthat two events AandBaremutually exclusive ifA\\BD;. We sometimes treat\nan elementary event s2Sas the eventfsg. By de\ufb01nition, all elementary events\nare mutually exclusive.\nAxioms of probability\nAprobability distribution Prfgon a sample space Sis a mapping from events of S\nto real numbers satisfying the following probability axioms :\n1. PrfAg/NAK0for any event A.\n2. PrfSgD1.\n3. PrfA[BgDPrfAgCPrfBgfor any two mutually exclusive events A\nandB. More generally, for any (\ufb01nite or countably in\ufb01nite) sequence of events\nA1;A2;:::that are pairwise mutually exclusive,\nPr([\niAi)\nDX\niPrfAig:\nWe call PrfAgtheprobability of the event A. We note here that axiom 2 is a\nnormalization requirement: there is really nothing fundamental about choosing 1\nas the probability of the certain event, except that it is natural and convenient.\nSeveral results follow immediately from these axioms and basic set theory (see\nSection B.1). The null event ;has probability Prf;gD0.I fA/DC2B,t h e n\nPrfAg/DC4PrfBg.U s i n g\n Ato denote the event S/NULA(thecomplement ofA),\nwe have Pr\u02da\nA/TAB\nD1/NULPrfAg. For any two events AandB,\nPrfA[BgDPrfAgCPrfBg/NULPrfA\\Bg (C.12)\n/DC4PrfAgCPrfBg: (C.13)\n1For a general probability distribution, there may be some subsets of the sample space Sthat are not\nconsidered to be events. This situation usually arises when the sample space is uncountably in\ufb01nite.The main requirement for what subsets are events is that the set of events of a sample space be closed\nunder the operations of taking the complement of an event, forming the union of a \ufb01nite or countable\nnumber of events, and taking the intersection of a \ufb01nite or countable number of events. Most of\nthe probability distributions we shall see are over \ufb01nite or countable sample spaces, and we shallgenerally consider all subsets of a sample space to be events. A notable exception is the continuous\nuniform probability distribution, which we shall see shortly.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "1211": {"page_number": 1212, "page_information": "C.2 Probability 1191\nIn our coin-\ufb02ipping example, suppose that each of the four elementary events\nhas probability 1=4. Then the probability of getting at least one head is\nPrfHH;HT;THgDPrfHHgCPrfHTgCPrfTHg\nD3=4 :\nAlternatively, since the probability of getting strictly less than one head is\nPrfTTgD1=4, the probability of getting at least one head is 1/NUL1=4D3=4.\nDiscrete probability distributions\nA probability distribution is discrete if it is de\ufb01ned over a \ufb01nite or countably in\ufb01nite\nsample space. Let Sbe the sample space. Then for any event A,\nPrfAgDX\ns2APrfsg;\nsince elementary events, speci\ufb01cally those in A, are mutually exclusive. If Sis\n\ufb01nite and every elementary event s2Shas probability\nPrfsgD1=jSj;\nthen we have the uniform probability distribution onS. In such a case the experi-\nment is often described as \u201cpicking an element of Sat random.\u201d\nAs an example, consider the process of \ufb02ipping a fair coin , one for which the\nprobability of obtaining a head is the same as the probability of obtaining a tail, thatis,1=2. If we \ufb02ip the coin ntimes, we have the uniform probability distribution\nde\ufb01ned on the sample space SDf\nH;Tgn, a set of size 2n. We can represent each\nelementary event in Sas a string of length noverfH;Tg, each string occurring with\nprobability 1=2n.T h ee v e n t\nADfexactly kheads and exactly n/NULktails occurg\nis a subset of Sof sizejAjD/NULn\nk/SOH\n,s i n c e/NULn\nk/SOH\nstrings of length noverfH;Tgcontain\nexactly kH\u2019s. The probability of event Ais thus PrfAgD/NULn\nk/SOH\n=2n.\nContinuous uniform probability distribution\nThe continuous uniform probability distribution is an example of a probability\ndistribution in which not all subsets of the sample space are considered to beevents. The continuous uniform probability distribution is de\ufb01ned over a closedinterval \u0152a; b/c141 of the reals, where a<b . Our intuition is that each point in the in-\nterval \u0152a; b/c141 should be \u201cequally likely.\u201d There are an uncountable number of points,\nhowever, so if we give all points the same \ufb01nite, positive probability, we cannot si-\nmultaneously satisfy axioms 2 and 3. For this reason, we would like to associate a", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "1212": {"page_number": 1213, "page_information": "1192 Appendix C Counting and Probability\nprobability only with some of the subsets of S, in such a way that the axioms are\nsatis\ufb01ed for these events.\nFor any closed interval \u0152c; d/c141 ,w h e r e a/DC4c/DC4d/DC4b,t h econtinuous uniform\nprobability distribution de\ufb01nes the probability of the event \u0152c; d/c141 to be\nPrf\u0152c; d/c141gDd/NULc\nb/NULa:\nNote that for any point xD\u0152x; x/c141 , the probability of xis0. If we remove\nthe endpoints of an interval \u0152c; d/c141 , we obtain the open interval .c; d/ .S i n c e\n\u0152c; d/c141D\u0152c; c/c141[.c; d/[\u0152d; d/c141 , axiom 3 gives us Pr f\u0152c; d/c141gDPrf.c; d/g.G e n -\nerally, the set of events for the continuous uniform probability distribution containsany subset of the sample space \u0152a; b/c141 that can be obtained by a \ufb01nite or countable\nunion of open and closed intervals, as well as certain more complicated sets.\nConditional probability and independence\nSometimes we have some prior partial knowledge about the outcome of an exper-\niment. For example, suppose that a friend has \ufb02ipped two fair coins and has toldyou that at least one of the coins showed a head. What is the probability that bothcoins are heads? The information given eliminates the possibility of two tails. Thethree remaining elementary events are equally likely, so we infer that each occurswith probability 1=3. Since only one of these elementary events shows two heads,\nthe answer to our question is 1=3.\nConditional probability formalizes the notion of having prior partial knowledge\nof the outcome of an experiment. The conditional probability of an event Agiven\nthat another event Boccurs is de\ufb01ned to be\nPrfAjBgDPrfA\\Bg\nPrfBg(C.14)\nwhenever PrfBg\u00a40. (We read \u201cPrfAjBg\u201d as \u201cthe probability of Agiven B.\u201d)\nIntuitively, since we are given that event Boccurs, the event that Aalso occurs\nisA\\B.T h a t i s , A\\Bis the set of outcomes in which both AandBoccur.\nBecause the outcome is one of the elementary events in B, we normalize the prob-\nabilities of all the elementary events in Bby dividing them by Pr fBg, so that they\nsum to 1. The conditional probability of Agiven Bis, therefore, the ratio of the\nprobability of event A\\Bto the probability of event B. In the example above, A\nis the event that both coins are heads, and Bis the event that at least one coin is a\nhead. Thus, PrfAjBgD.1=4/=.3=4/D1=3.\nTwo events are independent if\nPrfA\\BgDPrfAgPrfBg; (C.15)\nwhich is equivalent, if Pr fBg\u00a40, to the condition", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "1213": {"page_number": 1214, "page_information": "C.2 Probability 1193\nPrfAjBgDPrfAg:\nFor example, suppose that we \ufb02ip two fair coins and that the outcomes are inde-\npendent. Then the probability of two heads is .1=2/.1=2/D1=4. Now suppose\nthat one event is that the \ufb01rst coin comes up heads and the other event is that thecoins come up differently. Each of these events occurs with probability 1=2,a n d\nthe probability that both events occur is 1=4; thus, according to the de\ufb01nition of\nindependence, the events are independent\u2014even though you might think that bothevents depend on the \ufb01rst coin. Finally, suppose that the coins are welded to-gether so that they both fall heads or both fall tails and that the two possibilities areequally likely. Then the probability that each coin comes up heads is 1=2,b u tt h e\nprobability that they both come up heads is 1=2\u00a4.1=2/.1=2/ . Consequently, the\nevent that one comes up heads and the event that the other comes up heads are notindependent.\nA collection A\n1;A2;:::;A nof events is said to be pairwise independent if\nPrfAi\\AjgDPrfAigPrfAjg\nfor all 1/DC4i<j/DC4n. We say that the events of the collection are (mutually)\nindependent if every k-subset Ai1;Ai2;:::;A ikof the collection, where 2/DC4k/DC4n\nand1/DC4i1<i2</SOH/SOH/SOH<ik/DC4n, satis\ufb01es\nPrfAi1\\Ai2\\/SOH/SOH/SOH\\ AikgDPrfAi1gPrfAi2g/SOH/SOH/SOHPrfAikg:\nFor example, suppose we \ufb02ip two fair coins. Let A1be the event that the \ufb01rst coin\nis heads, let A2be the event that the second coin is heads, and let A3be the event\nthat the two coins are different. We have\nPrfA1gD1=2 ;\nPrfA2gD1=2 ;\nPrfA3gD1=2 ;\nPrfA1\\A2gD1=4 ;\nPrfA1\\A3gD1=4 ;\nPrfA2\\A3gD1=4 ;\nPrfA1\\A2\\A3gD0:\nSince for 1/DC4i<j/DC43,w eh a v eP rfAi\\AjgDPrfAigPrfAjgD1=4,t h e\nevents A1,A2,a n d A3are pairwise independent. The events are not mutually inde-\npendent, however, because Pr fA1\\A2\\A3gD0and PrfA1gPrfA2gPrfA3gD\n1=8\u00a40.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "1214": {"page_number": 1215, "page_information": "1194 Appendix C Coun ting and Probability\nBayes\u2019s theorem\nFrom the de\ufb01nition of conditional probability (C.14) and the commutative law\nA\\BDB\\A, it follows that for two events AandB, each with nonzero\nprobability,\nPrfA\\BgDPrfBgPrfAjBg (C.16)\nDPrfAgPrfBjAg:\nSolving for PrfAjBg, we obtain\nPrfAjBgDPrfAgPrfBjAg\nPrfBg; (C.17)\nwhich is known as Bayes\u2019s theorem . The denominator Pr fBgis a normalizing\nconstant, which we can reformulate as follows. Since BD.B\\A/[.B\\\nA/,\nand since B\\AandB\\\nAare mutually exclusive events,\nPrfBgDPrfB\\AgCPr\u02da\nB\\\nA/TAB\nDPrfAgPrfBjAgCPr\u02da\nA/TAB\nPr\u02da\nBj\nA/TAB\n:\nSubstituting into equation (C.17), we obtain an equivalent form of Bayes\u2019s theo-\nrem:\nPrfAjBgDPrfAgPrfBjAg\nPrfAgPrfBjAgCPr\u02da\nA/TAB\nPr\u02da\nBj\nA/TAB: (C.18)\nBayes\u2019s theorem can simplify the computing of conditional probabilities. For\nexample, suppose that we have a fair coin and a biased coin that always comes upheads. We run an experiment consisting of three independent events: we chooseone of the two coins at random, we \ufb02ip that coin once, and then we \ufb02ip it again.Suppose that the coin we have chosen comes up heads both times. What is the\nprobability that it is biased?\nWe solve this problem using Bayes\u2019s theorem. Let Abe the event that we choose\nthe biased coin, and let Bbe the event that the chosen coin comes up heads both\ntimes. We wish to determine Pr fAjBg.W eh a v eP rfAgD1=2,P rfBjAgD1,\nPr\u02da\nA/TAB\nD1=2,a n dP r\u02da\nBj\nA/TAB\nD1=4; hence,\nPrfAjBgD.1=2//SOH1\n.1=2//SOH1C.1=2//SOH.1=4/\nD4=5 :\nExercises\nC.2-1\nProfessor Guildenstern \ufb02ips a fair\n?coin twice. What is the probability that Professor Rosencrantz obtains more headsProfessor Rosencrantz \ufb02ips a fair coin once.\nthan Professor Guildenstern", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "1215": {"page_number": 1216, "page_information": "C.2 Probability 1195\nC.2-2\nProve Boole\u2019s inequality : For any \ufb01nite or countably in\ufb01nite sequence of events\nA1;A2;:::,\nPrfA1[A2[/SOH/SOH/SOHg/DC4PrfA1gCPrfA2gC/SOH/SOH/SOH : (C.19)\nC.2-3\nSuppose we shuf\ufb02e a deck of 10 cards, each bearing a distinct number from 1 to 10,to mix the cards thoroughly. We then remove three cards, one at a time, from thedeck. What is the probability that we select the three cards in sorted (increasing)order?\nC.2-4\nProve that\nPrfAjBgCPr\u02da\nAjB/TAB\nD1:\nC.2-5\nProve that for any collection of events A1;A2;:::;A n,\nPrfA1\\A2\\/SOH/SOH/SOH\\ AngDPrfA1g/SOHPrfA2jA1g/SOHPrfA3jA1\\A2g/SOH/SOH/SOH\nPrfAnjA1\\A2\\/SOH/SOH/SOH\\ An/NUL1g:\nC.2-6 ?\nDescribe a procedure that takes as input two integers aandbsuch that 0<a<b\nand, using fair coin \ufb02ips, produces as output heads with probability a=b and tails\nwith probability .b/NULa/=b . Give a bound on the expected number of coin \ufb02ips,\nwhich should be O.1/ .(Hint: Represent a=bin binary.)\nC.2-7 ?\nShow how to construct a set of nevents that are pairwise independent but such that\nno subset of k>2 of them is mutually independent.\nC.2-8 ?\nTwo events AandBareconditionally independent ,g i v e n C,i f\nPrfA\\BjCgDPrfAjCg/SOHPrfBjCg:\nGive a simple but nontrivial example of two events that are not independent but are\nconditionally independent given a third event.\nC.2-9 ?\nYou are a contestant in a game show in which a prize is hidden behind one ofthree curtains. You will win the prize if you select the correct curtain. After you", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "1216": {"page_number": 1217, "page_information": "1196 Appendix C Counting and Probability\nhave picked one curtain but before the curtain is lifted, the emcee lifts one of the\nother curtains, knowing that it will reveal an empty stage, and asks if you wouldlike to switch from your current selection to the remaining curtain. How wouldyour chances change if you switch? (This question is the celebrated Monty Hall\nproblem , named after a game-show host who often presented contestants with just\nthis dilemma.)\nC.2-10 ?\nA prison warden has randomly picked one prisoner among three to go free. The\nother two will be executed. The guard knows which one will go free but is forbid-\nden to give any prisoner information regarding his status. Let us call the prisonersX,Y,a n d Z. Prisoner Xasks the guard privately which of YorZwill be exe-\ncuted, arguing that since he already knows that at least one of them must die, theguard won\u2019t be revealing any information about his own status. The guard tells X\nthatYis to be executed. Prisoner Xfeels happier now, since he \ufb01gures that either\nhe or prisoner Zwill go free, which means that his probability of going free is\nnow1=2. Is he right, or are his chances still 1=3? Explain.\nC.3 Discrete random variables\nA(discrete) random variable Xis a function from a \ufb01nite or countably in\ufb01nite\nsample space Sto the real numbers. It associates a real number with each possible\noutcome of an experiment, which allows us to work with the probability distribu-tion induced on the resulting set of numbers. Random variables can also be de\ufb01nedfor uncountably in\ufb01nite sample spaces, but they raise technical issues that are un-necessary to address for our purposes. Henceforth, we shall assume that randomvariables are discrete.\nFor a random variable Xand a real number x, we de\ufb01ne the event XDxto be\nfs2SWX.s/Dxg; thus,\nPrfXDxgDX\ns2SWX.s/ DxPrfsg:\nThe function\nf. x/DPrfXDxg\nis theprobability density function of the random variable X. From the probability\naxioms, PrfXDxg/NAK0andP\nxPrfXDxgD1.\nAs an example, consider the experiment of rolling a pair of ordinary, 6-sided\ndice. There are 36possible elementary events in the sample space. We assume", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "1217": {"page_number": 1218, "page_information": "C.3 Discrete random variables 1197\nthat the probability distribution is uniform, so that each elementary event s2Sis\nequally likely: PrfsgD1=36 . De\ufb01ne the random variable Xto be the maximum of\nthe two values showing on the dice. We have Pr fXD3gD5=36 ,s i n c e Xassigns\na value of 3to 5 of the 36 possible elementary events, namely, .1; 3/ ,.2; 3/ ,.3; 3/ ,\n.3; 2/ ,a n d .3; 1/ .\nWe often de\ufb01ne several random variables on the same sample space. If XandY\nare random variables, the function\nf. x;y/DPrfXDxandYDyg\nis thejoint probability density function ofXandY. For a \ufb01xed value y,\nPrfYDygDX\nxPrfXDxandYDyg;\nand similarly, for a \ufb01xed value x,\nPrfXDxgDX\nyPrfXDxandYDyg:\nUsing the de\ufb01nition (C.14) of conditional probability, we have\nPrfXDxjYDygDPrfXDxandYDyg\nPrfYDyg:\nWe de\ufb01ne two random variables XandYto beindependent if for all xandy,t h e\nevents XDxandYDyare independent or, equivalently, if for all xandy,w e\nhave PrfXDxandYDygDPrfXDxgPrfYDyg.\nGiven a set of random variables de\ufb01ned over the same sample space, we can\nde\ufb01ne new random variables as sums, products, or other functions of the originalvariables.\nExpected value of a random variable\nThe simplest and most useful summary of the distribution of a random variable is\nthe \u201caverage\u201d of the values it takes on. The expected value (or, synonymously,\nexpectation ormean ) of a discrete random variable Xis\nE\u0152X/c141DX\nxx/SOHPrfXDxg; (C.20)\nwhich is well de\ufb01ned if the sum is \ufb01nite or converges absolutely. Sometimes the\nexpectation of Xis denoted by /SYNXor, when the random variable is apparent from\ncontext, simply by /SYN.\nConsider a game in which you \ufb02ip two fair coins. You earn $ 3for each head but\nlose $ 2for each tail. The expected value of the random variable Xrepresenting", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "1218": {"page_number": 1219, "page_information": "1198 Appendix C Counting and Probability\nyour earnings is\nE\u0152X/c141D6/SOHPrf2H\u2019sgC1/SOHPrf1H,1Tg/NUL4/SOHPrf2T\u2019sg\nD6.1=4/C1.1=2//NUL4.1=4/\nD1:\nThe expectation of the sum of two random variables is the sum of their expecta-\ntions, that is,\nE\u0152XCY/c141DE\u0152X/c141CE\u0152Y /c141 ; (C.21)\nwhenever E \u0152X/c141and E \u0152Y /c141are de\ufb01ned. We call this property linearity of expecta-\ntion, and it holds even if XandYare not independent. It also extends to \ufb01nite and\nabsolutely convergent summations of expectations. Linearity of expectation is the\nkey property that enables us to perform probabilistic analyses by using indicator\nrandom variables (see Section 5.2).\nIfXis any random variable, any function g.x/ de\ufb01nes a new random vari-\nableg.X/ . If the expectation of g.X/ is de\ufb01ned, then\nE\u0152g.X//c141DX\nxg.x//SOHPrfXDxg:\nLetting g.x/Dax, we have for any constant a,\nE\u0152aX/c141DaE\u0152X/c141 : (C.22)\nConsequently, expectations are linear: for any two random variables XandYand\nany constant a,\nE\u0152aXCY/c141DaE\u0152X/c141CE\u0152Y /c141 : (C.23)\nWhen two random variables XandYare independent and each has a de\ufb01ned\nexpectation,\nE\u0152XY /c141DX\nxX\nyxy/SOHPrfXDxandYDyg\nDX\nxX\nyxy/SOHPrfXDxgPrfYDyg\nD X\nxx/SOHPrfXDxg! X\nyy/SOHPrfYDyg!\nDE\u0152X/c141E\u0152Y /c141 :\nIn general, when nrandom variables X1;X2;:::;X nare mutually independent,\nE\u0152X1X2/SOH/SOH/SOHXn/c141DE\u0152X1/c141E\u0152X2/c141/SOH/SOH/SOHE\u0152Xn/c141: (C.24)", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "1219": {"page_number": 1220, "page_information": "C.3 Discrete random variables 1199\nWhen a random variable Xtakes on values from the set of natural numbers\nNDf0; 1; 2; : : :g, we have a nice formula for its expectation:\nE\u0152X/c141D1X\niD0i/SOHPrfXDig\nD1X\niD0i.PrfX/NAKig/NULPrfX/NAKiC1g/\nD1X\niD1PrfX/NAKig; (C.25)\nsince each term Pr fX/NAKigis added in itimes and subtracted out i/NUL1times\n(except PrfX/NAK0g, which is added in 0times and not subtracted out at all).\nWhen we apply a convex function f. x/ to a random variable X,Jensen\u2019s in-\nequality gives us\nE\u0152f .X//c141/NAKf.E\u0152X/c141/ ; (C.26)\nprovided that the expectations exist and are \ufb01nite. (A function f. x/ isconvex\nif for all xandyand for all 0/DC4/NAK/DC41,w eh a v e f. /NAK xC.1/NUL/NAK/y//DC4\n/NAKf .x /C.1/NUL/NAK/f .y/ .)\nVariance and standard deviation\nThe expected value of a random variable does not tell us how \u201cspread out\u201d the\nvariable\u2019s values are. For example, if we have random variables XandYfor which\nPrfXD1=4gDPrfXD3=4gD1=2and PrfYD0gDPrfYD1gD1=2,\nthen both E \u0152X/c141and E \u0152Y /c141are1=2, yet the actual values taken on by Yare farther\nfrom the mean than the actual values taken on by X.\nThe notion of variance mathematically expresses how far from the mean a ran-\ndom variable\u2019s values are likely to be. The variance of a random variable Xwith\nmean E \u0152X/c141is\nVar\u0152X/c141DE/STX\n.X/NULE\u0152X/c141/2/ETX\nDE/STX\nX2/NUL2XE\u0152X/c141CE2\u0152X/c141/ETX\nDE/STX\nX2/ETX\n/NUL2E\u0152XE\u0152X/c141/c141CE2\u0152X/c141\nDE/STX\nX2/ETX\n/NUL2E2\u0152X/c141CE2\u0152X/c141\nDE/STX\nX2/ETX\n/NULE2\u0152X/c141 : (C.27)\nTo justify the equality E \u0152E2\u0152X/c141/c141DE2\u0152X/c141, note that because E \u0152X/c141i sar e a ln u m -\nber and not a random variable, so is E2\u0152X/c141. The equality E \u0152XE\u0152X/c141/c141DE2\u0152X/c141", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "1220": {"page_number": 1221, "page_information": "1200 Appendix C Counting and Probability\nfollows from equation (C.22), with aDE\u0152X/c141. Rewriting equation (C.27) yields\nan expression for the expectation of the square of a random variable:\nE/STX\nX2/ETX\nDVar\u0152X/c141CE2\u0152X/c141 : (C.28)\nThe variance of a random variable Xand the variance of aXare related (see\nExercise C.3-10):\nVar\u0152aX/c141Da2Var\u0152X/c141 :\nWhen XandYare independent random variables,\nVar\u0152XCY/c141DVar\u0152X/c141CVar\u0152Y /c141 :\nIn general, if nrandom variables X1;X2;:::;X nare pairwise independent, then\nVar\"nX\niD1Xi#\nDnX\niD1Var\u0152Xi/c141: (C.29)\nThestandard deviation of a random variable Xis the nonnegative square root\nof the variance of X. The standard deviation of a random variable Xis sometimes\ndenoted /ESCXor simply /ESCwhen the random variable Xis understood from context.\nWith this notation, the variance of Xis denoted /ESC2.\nExercises\nC.3-1\nSuppose we roll two ordinary, 6-sided dice. What is the expectation of the sum\nof the two values showing? What is the expectation of the maximum of the two\nvalues showing?\nC.3-2\nAn array A\u01521 : : n/c141 contains ndistinct numbers that are randomly ordered, with each\npermutation of the nnumbers being equally likely. What is the expectation of the\nindex of the maximum element in the array? What is the expectation of the index\nof the minimum element in the array?\nC.3-3\nA carnival game consists of three dice in a cage. A player can bet a dollar on anyof the numbers 1through 6. The cage is shaken, and the payoff is as follows. If the\nplayer\u2019s number doesn\u2019t appear on any of the dice, he loses his dollar. Otherwise,if his number appears on exactly kof the three dice, for kD1; 2; 3 , he keeps his\ndollar and wins kmore dollars. What is his expected gain from playing the carnival\ngame once?", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "1221": {"page_number": 1222, "page_information": "C.4 The geometric and binomial distributions 1201\nC.3-4\nArgue that if XandYare nonnegative random variables, then\nE\u0152max.X; Y //c141/DC4E\u0152X/c141CE\u0152Y /c141 :\nC.3-5 ?\nLetXandYbe independent random variables. Prove that f. X/ andg.Y / are\nindependent for any choice of functions fandg.\nC.3-6 ?\nLetXbe a nonnegative random variable, and suppose that E \u0152X/c141is well de\ufb01ned.\nProve Markov\u2019s inequality :\nPrfX/NAKtg/DC4E\u0152X/c141 =t (C.30)\nfor all t>0 .\nC.3-7 ?\nLetSbe a sample space, and let XandX0be random variables such that\nX.s//NAKX0.s/for all s2S. Prove that for any real constant t,\nPrfX/NAKtg/NAKPrfX0/NAKtg:\nC.3-8\nWhich is larger: the expectation of the square of a random variable, or the squareof its expectation?\nC.3-9\nShow that for any random variable Xthat takes on only the values 0and1,w eh a v e\nVar\u0152X/c141DE\u0152X/c141E\u01521/NULX/c141.\nC.3-10\nProve that Var \u0152aX/c141Da\n2Var\u0152X/c141from the de\ufb01nition (C.27) of variance.\nC.4 The geometric and binomial distributions\nWe can think of a coin \ufb02ip as an instance of a Bernoulli trial , which is an experi-\nment with only two possible outcomes: success , which occurs with probability p,\nandfailure , which occurs with probability qD1/NULp. When we speak of Bernoulli\ntrials collectively, we mean that the trials are mutually independent and, unless we\nspeci\ufb01cally say otherwise, that each has the same probability pfor success. Two", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "1222": {"page_number": 1223, "page_information": "1202 Appendix C Counting and Probability\n0.050.100.150.200.25\n123456789 1 0 1 1 1 2 1 3 1 4 1 50.300.35\nk/DC22\n3/DC3k/NUL1/DC21\n3/DC3\nFigure C.1 A geometric distribution with probability pD1=3 of success and a probability\nqD1/NULpof failure. The expectation of the distribution is 1=pD3.\nimportant distributions arise from Bernoulli trials: the geometric distribution and\nthe binomial distribution.\nThe geometric distribution\nSuppose we have a sequence of Bernoulli trials, each with a probability pof suc-\ncess and a probability qD1/NULpof failure. How many trials occur before we obtain\na success? Let us de\ufb01ne the random variable Xbe the number of trials needed to\nobtain a success. Then Xhas values in the range f1 ;2;:::g,a n df o r k/NAK1,\nPrfXDkgDqk/NUL1p; (C.31)\nsince we have k/NUL1failures before the one success. A probability distribution sat-\nisfying equation (C.31) is said to be a geometric distribution . Figure C.1 illustrates\nsuch a distribution.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "1223": {"page_number": 1224, "page_information": "C.4 The geometric and binomial distributions 1203\nAssuming that q<1 , we can calculate the expectation of a geometric distribu-\ntion using identity (A.8):\nE\u0152X/c141D1X\nkD1kqk/NUL1p\nDp\nq1X\nkD0kqk\nDp\nq/SOHq\n.1/NULq/2\nDp\nq/SOHq\np2\nD1=p : (C.32)\nThus, on average, it takes 1=p trials before we obtain a success, an intuitive result.\nThe variance, which can be calculated similarly, but using Exercise A.1-3, is\nVar\u0152X/c141Dq=p2: (C.33)\nAs an example, suppose we repeatedly roll two dice until we obtain either a\nseven or an eleven. Of the 36 possible outcomes, 6 yield a seven and 2 yield aneleven. Thus, the probability of success is pD8=36D2=9, and we must roll\n1=pD9=2D4:5times on average to obtain a seven or eleven.\nThe binomial distribution\nHow many successes occur during nBernoulli trials, where a success occurs with\nprobability pand a failure with probability qD1/NULp? De\ufb01ne the random vari-\nableXto be the number of successes in ntrials. Then Xhas values in the range\nf0; 1; : : : ; ng,a n df o r kD0; 1; : : : ; n ,\nPrfXDkgD \nn\nk!\np\nkqn/NULk; (C.34)\nsince there are/NULn\nk/SOH\nways to pick which kof the ntrials are successes, and the\nprobability that each occurs is pkqn/NULk. A probability distribution satisfying equa-\ntion (C.34) is said to be a binomial distribution . For convenience, we de\ufb01ne the\nfamily of binomial distributions using the notation\nb.kIn;p/D \nn\nk!\npk.1/NULp/n/NULk: (C.35)\nFigure C.2 illustrates a binomial distribution. The name \u201cbinomial\u201d comes from the\nright-hand side of equation (C.34) being the kth term of the expansion of .pCq/n.\nConsequently, since pCqD1,", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "1224": {"page_number": 1225, "page_information": "1204 Appendix C Counting and Probability\n0.050.100.150.200.25\nk0123456789 1 0 1 1 1 2 1 3 1 4 1 5b(k; 15, 1/3)\nFigure C.2 The binomial distribution b.kI15; 1=3/ resulting from nD15Bernoulli trials, each\nwith probability pD1=3of success. The expectation of the distribution is npD5.\nnX\nkD0b.kIn;p/D1; (C.36)\nas axiom 2 of the probability axioms requires.\nWe can compute the expectation of a random variable having a binomial distri-\nbution from equations (C.8) and (C.36). Let Xbe a random variable that follows\nthe binomial distribution b.kIn;p/ ,a n dl e t qD1/NULp. By the de\ufb01nition of expec-\ntation, we have\nE\u0152X/c141DnX\nkD0k/SOHPrfXDkg\nDnX\nkD0k/SOHb.kIn;p/\nDnX\nkD1k \nn\nk!\npkqn/NULk\nDnpnX\nkD1 \nn/NUL1\nk/NUL1!\npk/NUL1qn/NULk(by equation (C.8))\nDnpn/NUL1X\nkD0 \nn/NUL1\nk!\npkq.n/NUL1//NULk", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "1225": {"page_number": 1226, "page_information": "C.4 The geometric and binomial distributions 1205\nDnpn/NUL1X\nkD0b.kIn/NUL1; p/\nDnp (by equation (C.36)) . (C.37)\nBy using the linearity of expectation, we can obtain the same result with sub-\nstantially less algebra. Let Xibe the random variable describing the number of\nsuccesses in the ith trial. Then E \u0152Xi/c141Dp/SOH1Cq/SOH0Dp, and by linearity of\nexpectation (equation (C.21)), the expected number of successes for ntrials is\nE\u0152X/c141DE\"nX\niD1Xi#\nDnX\niD1E\u0152Xi/c141\nDnX\niD1p\nDnp : (C.38)\nWe can use the same approach to calculate the variance of the distribution. Using\nequation (C.27), we have Var \u0152Xi/c141DE\u0152X2\ni/c141/NULE2\u0152Xi/c141.S i n c e Xionly takes on the\nvalues 0and1,w eh a v e X2\niDXi, which implies E \u0152X2\ni/c141DE\u0152Xi/c141Dp. Hence,\nVar\u0152Xi/c141Dp/NULp2Dp.1/NULp/Dpq : (C.39)\nTo compute the variance of X, we take advantage of the independence of the n\ntrials; thus, by equation (C.29),\nVar\u0152X/c141DVar\"nX\niD1Xi#\nDnX\niD1Var\u0152Xi/c141\nDnX\niD1pq\nDnpq : (C.40)\nAs Figure C.2 shows, the binomial distribution b.kIn;p/ increases with kuntil\nit reaches the mean np, and then it decreases. We can prove that the distribution\nalways behaves in this manner by looking at the ratio of successive terms:", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "1226": {"page_number": 1227, "page_information": "1206 Appendix C Counting and Probability\nb.kIn;p/\nb.k/NUL1In;p/D/NULn\nk/SOH\npkqn/NULk\n/NULn\nk/NUL1/SOH\npk/NUL1qn/NULkC1\nDn\u0160.k/NUL1/\u0160.n/NULkC1/\u0160p\nk\u0160.n/NULk/\u0160n\u0160q\nD.n/NULkC1/p\nkq(C.41)\nD1C.nC1/p/NULk\nkq:\nThis ratio is greater than 1precisely when .nC1/p/NULkis positive. Conse-\nquently, b.kIn;p/ > b.k/NUL1In;p/ fork<. nC1/p(the distribution increases),\nandb.kIn;p/ < b.k/NUL1In;p/ fork>. nC1/p (the distribution decreases).\nIfkD.nC1/pis an integer, then b.kIn;p/Db.k/NUL1In;p/ , and so the distri-\nbution then has two maxima: at kD.nC1/pand at k/NUL1D.nC1/p/NUL1Dnp/NULq.\nOtherwise, it attains a maximum at the unique integer kthat lies in the range\nnp/NULq<k<. nC1/p.\nThe following lemma provides an upper bound on the binomial distribution.\nLemma C.1\nLetn/NAK0,l e t0<p<1 ,l e tqD1/NULp,a n dl e t 0/DC4k/DC4n.T h e n\nb.kIn;p//DC4/DLEnp\nk/DC1k/DLEnq\nn/NULk/DC1n/NULk\n:\nProof Using equation (C.6), we have\nb.kIn;p/D \nn\nk!\npkqn/NULk\n/DC4/DLEn\nk/DC1k/DLEn\nn/NULk/DC1n/NULk\npkqn/NULk\nD/DLEnp\nk/DC1k/DLEnq\nn/NULk/DC1n/NULk\n:\nExercises\nC.4-1\nVerify axiom 2 of the probability axioms for the geometric distribution.\nC.4-2\nHow many times on average must we \ufb02ip 6 fair coins before we obtain 3 headsand 3 tails?", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "1227": {"page_number": 1228, "page_information": "C.4 The geometric and binomial distributions 1207\nC.4-3\nShow that b.kIn;p/Db.n/NULkIn;q/ ,w h e r e qD1/NULp.\nC.4-4\nShow that value of the maximum of the binomial distribution b.kIn;p/ is approx-\nimately 1=p\n2/EMnpq ,w h e r e qD1/NULp.\nC.4-5 ?\nShow that the probability of no successes in nBernoulli trials, each with probability\npD1=n, is approximately 1=e. Show that the probability of exactly one success\nis also approximately 1=e.\nC.4-6 ?\nProfessor Rosencrantz \ufb02ips a fair coin ntimes, and so does Professor Guildenstern.\nShow that the probability that they get the same number of heads is/NUL2n\nn/SOH\n=4n.(Hint:\nFor Professor Rosencrantz, call a head a success; for Professor Guildenstern, calla tail a success.) Use your argument to verify the identity\nnX\nkD0 \nn\nk!2\nD \n2n\nn!\n:\nC.4-7 ?\nShow that for 0/DC4k/DC4n,\nb.kIn; 1=2//DC42nH. k=n / /NULn;\nwhere H.x/ is the entropy function (C.7).\nC.4-8 ?\nConsider nBernoulli trials, where for iD1 ;2;:::;n ,t h e ith trial has probabil-\nitypiof success, and let Xbe the random variable denoting the total number of\nsuccesses. Let p/NAKpifor all iD1 ;2;:::;n . Prove that for 1/DC4k/DC4n,\nPrfX<kg/NAKk/NUL1X\niD0b.iIn;p/ :\nC.4-9 ?\nLetXbe the random variable for the total number of successes in a set Aofn\nBernoulli trials, where the ith trial has a probability piof success, and let X0\nbe the random variable for the total number of successes in a second set A0ofn\nBernoulli trials, where the ith trial has a probability p0\ni/NAKpiof success. Prove that\nfor0/DC4k/DC4n,", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "1228": {"page_number": 1229, "page_information": "1208 Appendix C Counting and Probability\nPrfX0/NAKkg/NAKPrfX/NAKkg:\n(Hint: Show how to obtain the Bernoulli trials in A0by an experiment involving\nthe trials of A, and use the result of Exercise C.3-7.)\n?C.5 The tails of the binomial distribution\nThe probability of having at least, or at most, ksuccesses in nBernoulli trials,\neach with probability pof success, is often of more interest than the probability of\nhaving exactly ksuccesses. In this section, we investigate the tails of the binomial\ndistribution: the two regions of the distribution b.kIn;p/ that are far from the\nmean np. We shall prove several important bounds on (the sum of all terms in) a\ntail.\nWe \ufb01rst provide a bound on the right tail of the distribution b.kIn;p/ . We can\ndetermine bounds on the left tail by inverting the roles of successes and failures.\nTheorem C.2\nConsider a sequence of nBernoulli trials, where success occurs with probability p.\nLetXbe the random variable denoting the total number of successes. Then for\n0/DC4k/DC4n, the probability of at least ksuccesses is\nPrfX/NAKkgDnX\niDkb.iIn;p/\n/DC4 \nn\nk!\npk:\nProof ForS/DC2f1 ;2;:::;ng,w el e t ASdenote the event that the ith trial is a\nsuccess for every i2S. Clearly PrfASgDpkifjSjDk.W eh a v e\nPrfX/NAKkgDPrfthere exists S/DC2f1 ;2;:::;ngWjSjDkandASg\nDPr/SUB[\nS/DC2f1;2;:::;n gWjSjDkAS/ESC\n/DC4X\nS/DC2f1;2;:::;n gWjSjDkPrfASg (by inequality (C.19))\nD \nn\nk!\npk:\n", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "1229": {"page_number": 1230, "page_information": "C.5 The tails of the binomial distribution 1209\nThe following corollary restates the theorem for the left tail of the binomial\ndistribution. In general, we shall leave it to you to adapt the proofs from one tail tothe other.\nCorollary C.3\nConsider a sequence of nBernoulli trials, where success occurs with probabil-\nityp.I fXis the random variable denoting the total number of successes, then for\n0/DC4k/DC4n, the probability of at most ksuccesses is\nPrfX/DC4kgD kX\niD0b.iIn;p/\n/DC4 \nn\nn/NULk!\n.1/NULp/n/NULk\nD \nn\nk!\n.1/NULp/n/NULk:\nOur next bound concerns the left tail of the binomial distribution. Its corollary\nshows that, far from the mean, the left tail diminishes exponentially.\nTheorem C.4\nConsider a sequence of nBernoulli trials, where success occurs with probability p\nand failure with probability qD1/NULp.L e t Xbe the random variable denoting the\ntotal number of successes. Then for 0<k<n p , the probability of fewer than k\nsuccesses is\nPrfX<kgDk/NUL1X\niD0b.iIn;p/\n<kq\nnp/NULkb.kIn;p/ :\nProof We bound the seriesPk/NUL1\niD0b.iIn;p/ by a geometric series using the tech-\nnique from Section A.2, page 1151. For iD1 ;2;:::;k , we have from equa-\ntion (C.41),\nb.i/NUL1In;p/\nb.iIn;p/Diq\n.n/NULiC1/p\n<iq\n.n/NULi/p\n/DC4kq\n.n/NULk/p:", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "1230": {"page_number": 1231, "page_information": "1210 Appendix C Counting and Probability\nIf we let\nxDkq\n.n/NULk/p\n<kq\n.n/NULnp/p\nDkq\nnqp\nDk\nnp\n<1 ;\nit follows that\nb.i/NUL1In;p/ < x b.iIn;p/\nfor0<i/DC4k. Iteratively applying this inequality k/NULitimes, we obtain\nb.iIn;p/ < xk/NULib.kIn;p/\nfor0/DC4i<k , and hence\nk/NUL1X\niD0b.iIn;p/ <k/NUL1X\niD0xk/NULib.kIn;p/\n<b . kIn;p/1X\niD0xi\nDx\n1/NULxb.kIn;p/\nDkq\nnp/NULkb.kIn;p/ :\nCorollary C.5\nConsider a sequence of nBernoulli trials, where success occurs with probability p\nand failure with probability qD1/NULp. Then for 0<k/DC4np=2 , the probability of\nfewer than ksuccesses is less than one half of the probability of fewer than kC1\nsuccesses.\nProof Because k/DC4np=2 ,w eh a v e\nkq\nnp/NULk/DC4.np=2/q\nnp/NUL.np=2/", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "1231": {"page_number": 1232, "page_information": "C.5 The tails of the binomial distribution 1211\nD.np=2/q\nnp=2\n/DC41; (C.42)\nsince q/DC41. Letting Xbe the random variable denoting the number of successes,\nTheorem C.4 and inequality (C.42) imply that the probability of fewer than ksuc-\ncesses is\nPrfX<kgDk/NUL1X\niD0b.iIn;p/ < b.kIn;p/ :\nThus we have\nPrfX<kg\nPrfX<kC1gDPk/NUL1\niD0b.iIn;p/\nPk\niD0b.iIn;p/\nDPk/NUL1\niD0b.iIn;p/\nPk/NUL1\niD0b.iIn;p/Cb.kIn;p/\n<1 = 2 ;\nsincePk/NUL1\niD0b.iIn;p/ < b.kIn;p/ .\nBounds on the right tail follow similarly. Exercise C.5-2 asks you to prove them.\nCorollary C.6\nConsider a sequence of nBernoulli trials, where success occurs with probability p.\nLetXbe the random variable denoting the total number of successes. Then for\nn p<k<n , the probability of more than ksuccesses is\nPrfX>kgDnX\niDkC1b.iIn;p/\n<.n/NULk/p\nk/NULnpb.kIn;p/ :\nCorollary C.7\nConsider a sequence of nBernoulli trials, where success occurs with probability p\nand failure with probability qD1/NULp. Then for .npCn/=2 < k < n ,t h e\nprobability of more than ksuccesses is less than one half of the probability of\nmore than k/NUL1successes.\nThe next theorem considers nBernoulli trials, each with a probability piof\nsuccess, for iD1 ;2;:::;n . As the subsequent corollary shows, we can use the", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "1232": {"page_number": 1233, "page_information": "1212 Appendix C Counting and Probability\ntheorem to provide a bound on the right tail of the binomial distribution by setting\npiDpfor each trial.\nTheorem C.8\nConsider a sequence of nBernoulli trials, where in the ith trial, for iD1 ;2;:::;n ,\nsuccess occurs with probability piand failure occurs with probability qiD1/NULpi.\nLetXbe the random variable describing the total number of successes, and let\n/SYNDE\u0152X/c141. Then for r>/SYN ,\nPrfX/NUL/SYN/NAKrg/DC4/DLE/SYNe\nr/DC1r\n:\nProof Since for any \u02db>0 , the function e\u02dbxis strictly increasing in x,\nPrfX/NUL/SYN/NAKrgDPr\u02da\ne\u02db.X/NUL/SYN//NAKe\u02dbr/TAB\n; (C.43)\nwhere we will determine \u02dblater. Using Markov\u2019s inequality (C.30), we obtain\nPr\u02da\ne\u02db.X/NUL/SYN//NAKe\u02dbr/TAB\n/DC4E/STX\ne\u02db.X/NUL/SYN//ETX\ne/NUL\u02dbr: (C.44)\nThe bulk of the proof consists of bounding E/STX\ne\u02db.X/NUL/SYN//ETX\nand substituting a suit-\nable value for \u02dbin inequality (C.44). First, we evaluate E/STX\ne\u02db.X/NUL/SYN//ETX\n.U s i n g t h e\ntechnique of indicator random variables (see Section 5.2), let XiDIftheith\nBernoulli trial is a success gforiD1 ;2;:::;n ;t h a ti s , Xiis the random vari-\nable that is 1if the ith Bernoulli trial is a success and 0if it is a failure. Thus,\nXDnX\niD1Xi;\nand by linearity of expectation,\n/SYNDE\u0152X/c141DE\"nX\niD1Xi#\nDnX\niD1E\u0152Xi/c141DnX\niD1pi;\nwhich implies\nX/NUL/SYNDnX\niD1.Xi/NULpi/:\nTo evaluate E/STX\ne\u02db.X/NUL/SYN//ETX\n, we substitute for X/NUL/SYN, obtaining\nE/STX\ne\u02db.X/NUL/SYN//ETX\nDE/STX\ne\u02dbPn\niD1.Xi/NULpi//ETX\nDE\"nY\niD1e\u02db.X i/NULpi/#\nDnY\niD1E/STX\ne\u02db.X i/NULpi//ETX\n;", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "1233": {"page_number": 1234, "page_information": "C.5 The tails of the binomial distribution 1213\nwhich follows from (C.24), since the mutual independence of the random vari-\nables Xiimplies the mutual independence of the random variables e\u02db.X i/NULpi/(see\nExercise C.3-5). By the de\ufb01nition of expectation,\nE/STX\ne\u02db.X i/NULpi//ETX\nDe\u02db.1/NULpi/piCe\u02db.0/NULpi/qi\nDpie\u02dbqiCqie/NUL\u02dbpi\n/DC4pie\u02dbC1 (C.45)\n/DC4exp.pie\u02db/;\nwhere exp .x/denotes the exponential function: exp .x/Dex. (Inequality (C.45)\nfollows from the inequalities \u02db>0 ,qi/DC41,e\u02dbqi/DC4e\u02db,a n d e/NUL\u02dbpi/DC41, and the last\nline follows from inequality (3.12).) Consequently,\nE/STX\ne\u02db.X/NUL/SYN//ETX\nDnY\niD1E/STX\ne\u02db.X i/NULpi//ETX\n/DC4nY\niD1exp.pie\u02db/\nDexp nX\niD1pie\u02db!\nDexp./SYNe\u02db/; (C.46)\nsince /SYNDPn\niD1pi. Therefore, from equation (C.43) and inequalities (C.44)\nand (C.46), it follows that\nPrfX/NUL/SYN/NAKrg/DC4exp./SYNe\u02db/NUL\u02dbr/ : (C.47)\nChoosing \u02dbDln.r=/SYN/ (see Exercise C.5-7), we obtain\nPrfX/NUL/SYN/NAKrg/DC4exp./SYNeln.r=/SYN//NULrln.r=/SYN//\nDexp.r/NULrln.r=/SYN//\nDer\n.r=/SYN/r\nD/DLE/SYNe\nr/DC1r\n:\nWhen applied to Bernoulli trials in which each trial has the same probability of\nsuccess, Theorem C.8 yields the following corollary bounding the right tail of abinomial distribution.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "1234": {"page_number": 1235, "page_information": "1214 Appendix C Counting and Probability\nCorollary C.9\nConsider a sequence of nBernoulli trials, where in each trial success occurs with\nprobability pand failure occurs with probability qD1/NULp. Then for r>n p ,\nPrfX/NULnp/NAKrgDnX\nkDdnpCreb.kIn;p/\n/DC4/DLEnpe\nr/DC1r\n:\nProof By equation (C.37), we have /SYNDE\u0152X/c141Dnp.\nExercises\nC.5-1 ?\nWhich is less likely: obtaining no heads when you \ufb02ip a fair coin ntimes, or\nobtaining fewer than nheads when you \ufb02ip the coin 4ntimes?\nC.5-2 ?\nProve Corollaries C.6 and C.7.\nC.5-3 ?\nShow that\nk/NUL1X\niD0 \nn\ni!\nai<. aC1/n k\nna/NULk.aC1/b.kIn;a=.aC1//\nfor all a>0 and all ksuch that 0<k<n a = . aC1/.\nC.5-4 ?\nProve that if 0<k<n p ,w h e r e 0<p<1 andqD1/NULp,t h e n\nk/NUL1X\niD0piqn/NULi<kq\nnp/NULk/DLEnp\nk/DC1k/DLEnq\nn/NULk/DC1n/NULk\n:\nC.5-5 ?\nShow that the conditions of Theorem C.8 imply that\nPrf/SYN/NULX/NAKrg/DC4/DC2.n/NUL/SYN/e\nr/DC3r\n:\nSimilarly, show that the conditions of Corollary C.9 imply that\nPrfnp/NULX/NAKrg/DC4/DLEnqe\nr/DC1r\n:", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "1235": {"page_number": 1236, "page_information": "Problems for Appendix C 1215\nC.5-6 ?\nConsider a sequence of nBernoulli trials, where in the ith trial, for iD1 ;2;:::;n ,\nsuccess occurs with probability piand failure occurs with probability qiD1/NULpi.\nLetXbe the random variable describing the total number of successes, and let\n/SYNDE\u0152X/c141. Show that for r/NAK0,\nPrfX/NUL/SYN/NAKrg/DC4e/NULr2=2n:\n(Hint: Prove that pie\u02dbqiCqie/NUL\u02dbpi/DC4e\u02db2=2. Then follow the outline of the proof\nof Theorem C.8, using this inequality in place of inequality (C.45).)\nC.5-7 ?\nShow that choosing \u02dbDln.r=/SYN/ minimizes the right-hand side of inequal-\nity (C.47).\nProblems\nC-1 Balls and binsIn this problem, we investigate the effect of various assumptions on the number ofways of placing nballs into bdistinct bins.\na.Suppose that the nballs are distinct and that their order within a bin does not\nmatter. Argue that the number of ways of placing the balls in the bins is b\nn.\nb.Suppose that the balls are distinct and that the balls in each bin are ordered.\nProve that there are exactly .bCn/NUL1/\u0160=.b/NUL1/\u0160ways to place the balls in the\nbins. ( Hint: Consider the number of ways of arranging ndistinct balls and b/NUL1\nindistinguishable sticks in a row.)\nc.Suppose that the balls are identical, and hence their order within a bin does not\nmatter. Show that the number of ways of placing the balls in the bins is/NULbCn/NUL1\nn/SOH\n.\n(Hint: Of the arrangements in part (b), how many are repeated if the balls are\nmade identical?)\nd.Suppose that the balls are identical and that no bin may contain more than one\nball, so that n/DC4b. Show that the number of ways of placing the balls is/NULb\nn/SOH\n.\ne.Suppose that the balls are identical and that no bin may be left empty. Assuming\nthatn/NAKb, show that the number of ways of placing the balls is/NULn/NUL1\nb/NUL1/SOH\n.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "1236": {"page_number": 1237, "page_information": "1216 Appendix C Counting and Probability\nAppendix notes\nThe \ufb01rst general methods for solving probability problems were discussed in a\nfamous correspondence between B. Pascal and P. de Fermat, which began in 1654,and in a book by C. Huygens in 1657. Rigorous probability theory began with thework of J. Bernoulli in 1713 and A. De Moivre in 1730. Further developments of\nthe theory were provided by P.-S. Laplace, S.-D. Poisson, and C. F. Gauss.\nSums of random variables were originally studied by P. L. Chebyshev and A. A.\nMarkov. A. N. Kolmogorov axiomatized probability theory in 1933. Chernoff [66]and Hoeffding [173] provided bounds on the tails of distributions. Seminal workin random combinatorial structures was done by P. Erd\u00a8 os.\nKnuth [209] and Liu [237] are good references for elementary combinatorics\nand counting. Standard textbooks such as Billingsley [46], Chung [67], Drake [95],Feller [104], and Rozanov [300] offer comprehensive introductions to probability.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "1237": {"page_number": 1238, "page_information": "D Matrices\nMatrices arise in numerous applications, including, but by no means limited to,\nscienti\ufb01c computing. If you have seen matrices before, much of the material in thisappendix will be familiar to you, but some of it might be new. Section D.1 coversbasic matrix de\ufb01nitions and operations, and Section D.2 presents some basic matrixproperties.\nD.1 Matrices and matrix operations\nIn this section, we review some basic concepts of matrix theory and some funda-mental properties of matrices.\nMatrices and vectors\nAmatrix is a rectangular array of numbers. For example,\nAD/DC2a\n11a12a13\na21a22a23/DC3\nD/DC2123\n456/DC3\n(D.1)\nis a2/STX3matrix AD.aij/, where for iD1; 2andjD1; 2; 3 , we denote the\nelement of the matrix in row iand column jbyaij. We use uppercase letters\nto denote matrices and corresponding subscripted lowercase letters to denote their\nelements. We denote the set of all m/STXnmatrices with real-valued entries by Rm/STXn\nand, in general, the set of m/STXnmatrices with entries drawn from a set SbySm/STXn.\nThetranspose of a matrix Ais the matrix ATobtained by exchanging the rows\nand columns of A. For the matrix Aof equation (D.1),", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "1238": {"page_number": 1239, "page_information": "1218 Appendix D Matrices\nATD/NUL\n14\n2536/SOH\n:\nAvector is a one-dimensional array of numbers. For example,\nxD/NUL\n2\n35/SOH\nis a vector of size 3. We sometimes call a vector of length nann-vector .W e\nuse lowercase letters to denote vectors, and we denote the ith element of a size- n\nvector xbyxi,f o riD1 ;2;:::;n . We take the standard form of a vector to be\nas acolumn vector equivalent to an n/STX1matrix; the corresponding row vector is\nobtained by taking the transpose:\nxTD.235 /:\nTheunit vector eiis the vector whose ith element is 1and all of whose other\nelements are 0. Usually, the size of a unit vector is clear from the context.\nAzero matrix is a matrix all of whose entries are 0. Such a matrix is often\ndenoted 0, since the ambiguity between the number 0and a matrix of 0si su s u a l l y\neasily resolved from context. If a matrix of 0s is intended, then the size of the\nmatrix also needs to be derived from the context.\nSquare matrices\nSquare n/STXnmatrices arise frequently. Several special cases of square matrices\nare of particular interest:\n1. Adiagonal matrix hasaijD0whenever i\u00a4j. Because all of the off-diagonal\nelements are zero, we can specify the matrix by listing the elements along thediagonal:\ndiag.a\n11;a22;:::;a nn/D\u02d9\na11 0 ::: 0\n0a 22::: 0\n::::::::::::\n0 0 ::: a\nnn/BEL\n:\n2. The n/STXnidentity matrix Inis a diagonal matrix with 1s along the diagonal:\nInDdiag. 1 ;1 ;:::;1 /\nD\u02d9\n1 0 ::: 0\n0 1 ::: 0\n::::::::::::\n0 0 ::: 1/BEL\n:", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "1239": {"page_number": 1240, "page_information": "D.1 Matrices and matrix operations 1219\nWhen Iappears without a subscript, we derive its size from the context. The ith\ncolumn of an identity matrix is the unit vector ei.\n3. Atridiagonal matrix Tis one for which tijD0ifji/NULjj>1. Nonzero entries\nappear only on the main diagonal, immediately above the main diagonal ( ti;iC1\nforiD1 ;2;:::;n/NUL1), or immediately below the main diagonal ( tiC1;ifor\niD1 ;2;:::;n/NUL1):\nTD/EOT\nt11t120 0 ::: 0 0 0\nt21t22t230 ::: 0 0 0\n0t 32t33t34::: 0 0 0\n::::::::::::::::::::::::\n0000 : : : t\nn/NUL2;n/NUL2tn/NUL2;n/NUL1 0\n0000 : : : t n/NUL1;n/NUL2tn/NUL1;n/NUL1tn/NUL1;n\n0000 : : : 0 t n;n/NUL1 tnn\u02d8\n:\n4. An upper-triangular matrix Uis one for which uijD0ifi>j . All entries\nbelow the diagonal are zero:\nUD\u02d9\nu11u12::: u 1n\n0u 22::: u 2n\n::::::::::::\n0 0 ::: u nn/BEL\n:\nAn upper-triangular matrix is unit upper-triangular if it has all 1s along the\ndiagonal.\n5. Alower-triangular matrix Lis one for which lijD0ifi<j . All entries\nabove the diagonal are zero:\nLD\u02d9\nl110 ::: 0\nl21l22::: 0\n::::::::::::\nln1ln2::: l nn/BEL\n:\nA lower-triangular matrix is unit lower-triangular if it has all 1s along the\ndiagonal.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "1240": {"page_number": 1241, "page_information": "1220 Appendix D Matrices\n6. A permutation matrix Phas exactly one 1in each row or column, and 0s\nelsewhere. An example of a permutation matrix is\nPD\u02c7\n01000\n00010100000000100100/CR\n:\nSuch a matrix is called a permutation matrix because multiplying a vector x\nby a permutation matrix has the effect of permuting (rearranging) the elementsofx. Exercise D.1-4 explores additional properties of permutation matrices.\n7. Asymmetric matrix Asatis\ufb01es the condition ADA\nT. For example,/NUL\n123\n264345/SOH\nis a symmetric matrix.\nBasic matrix operations\nThe elements of a matrix or vector are numbers from a number system, such as\nthe real numbers, the complex numbers, or integers modulo a prime. The numbersystem de\ufb01nes how to add and multiply numbers. We can extend these de\ufb01nitionsto encompass addition and multiplication of matrices.\nWe de\ufb01ne matrix addition as follows. If AD.a\nij/andBD.bij/arem/STXn\nmatrices, then their matrix sum CD.cij/DACBis the m/STXnmatrix de\ufb01ned by\ncijDaijCbij\nforiD1 ;2;:::;m andjD1 ;2;:::;n . That is, matrix addition is performed\ncomponentwise. A zero matrix is the identity for matrix addition:\nAC0DAD0CA:\nIf/NAKis a number and AD.aij/is a matrix, then /NAKAD./NAKa ij/is the scalar\nmultiple ofAobtained by multiplying each of its elements by /NAK. As a special case,\nwe de\ufb01ne the negative of a matrix AD.aij/to be/NUL1/SOHAD/NULA, so that the ijth\nentry of/NULAis/NULaij. Thus,\nAC./NULA/D0D./NULA/CA:", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "1241": {"page_number": 1242, "page_information": "D.1 Matrices and matrix operations 1221\nWe use the negative of a matrix to de\ufb01ne matrix subtraction :A/NULBDAC./NULB/.\nWe de\ufb01ne matrix multiplication as follows. We start with two matrices AandB\nthat are compatible in the sense that the number of columns of Aequals the number\nof rows of B. (In general, an expression containing a matrix product ABis always\nassumed to imply that matrices AandBare compatible.) If AD.aik/is anm/STXn\nmatrix and BD.bkj/is ann/STXpmatrix, then their matrix product CDABis the\nm/STXpmatrix CD.cij/,w h e r e\ncijDnX\nkD1aikbkj (D.2)\nforiD1 ;2;:::;m andjD1 ;2;:::;p . The procedure S QUARE -MATRIX -\nMULTIPLY in Section 4.2 implements matrix multiplication in the straightfor-\nward manner based on equation (D.2), assuming that the matrices are square:mDnDp. To multiply n/STXnmatrices, S\nQUARE -MATRIX -MULTIPLY per-\nforms n3multiplications and n2.n/NUL1/additions, and so its running time is \u201a.n3/.\nMatrices have many (but not all) of the algebraic properties typical of numbers.\nIdentity matrices are identities for matrix multiplication:\nImADAInDA\nfor any m/STXnmatrix A. Multiplying by a zero matrix gives a zero matrix:\nA0D0:\nMatrix multiplication is associative:\nA.BC /D.AB/C\nfor compatible matrices A,B,a n d C. Matrix multiplication distributes over addi-\ntion:\nA.BCC/DABCAC ;\n.BCC/ DDBDCCD :\nForn>1 , multiplication of n/STXnmatrices is not commutative. For example, if\nAD/DC201\n00/DC3\nandBD/DC200\n10/DC3\n,t h e n\nABD/DC210\n00/DC3\nand\nBAD/DC200\n01/DC3\n:", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "1242": {"page_number": 1243, "page_information": "1222 Appendix D Matrices\nWe de\ufb01ne matrix-vector products or vector-vector products as if the vector were\nthe equivalent n/STX1matrix (or a 1/STXnmatrix, in the case of a row vector). Thus,\nifAis an m/STXnmatrix and xis an n-vector, then Axis an m-vector. If xandy\naren-vectors, then\nxTyDnX\niD1xiyi\nis a number (actually a 1/STX1matrix) called the inner product ofxandy.T h em a -\ntrixxyTis ann/STXnmatrix Zcalled the outer product ofxandy, with \u00b4ijDxiyj.\nThe(euclidean) normkxkof an n-vector xis de\ufb01ned by\nkxkD.x2\n1Cx2\n2C/SOH/SOH/SOHC x2\nn/1=2\nD.xTx/1=2:\nThus, the norm of xis its length in n-dimensional euclidean space.\nExercises\nD.1-1\nShow that if AandBare symmetric n/STXnmatrices, then so are ACBandA/NULB.\nD.1-2\nProve that .AB/TDBTATand that ATAis always a symmetric matrix.\nD.1-3\nProve that the product of two lower-triangular matrices is lower-triangular.\nD.1-4\nProve that if Pis an n/STXnpermutation matrix and Ais an n/STXnmatrix, then the\nmatrix product PAisAwith its rows permuted, and the matrix product APisA\nwith its columns permuted. Prove that the product of two permutation matrices isa permutation matrix.\nD.2 Basic matrix properties\nIn this section, we de\ufb01ne some basic properties pertaining to matrices: inverses,linear dependence and independence, rank, and determinants. We also de\ufb01ne theclass of positive-de\ufb01nite matrices.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "1243": {"page_number": 1244, "page_information": "D.2 Basic matrix properties 1223\nMatrix inverses, ranks, and determinants\nWe de\ufb01ne the inverse of an n/STXnmatrix Ato be the n/STXnmatrix, denoted A/NUL1(if\nit exists), such that AA/NUL1DInDA/NUL1A. For example,\n/DC211\n10/DC3/NUL1\nD/DC201\n1/NUL1/DC3\n:\nMany nonzero n/STXnmatrices do not have inverses. A matrix without an inverse is\ncalled noninvertible ,o rsingular . An example of a nonzero singular matrix is\n/DC210\n10/DC3\n:\nIf a matrix has an inverse, it is called invertible ,o rnonsingular . Matrix inverses,\nwhen they exist, are unique. (See Exercise D.2-1.) If AandBare nonsingular\nn/STXnmatrices, then\n.BA//NUL1DA/NUL1B/NUL1:\nThe inverse operation commutes with the transpose operation:\n.A/NUL1/TD.AT//NUL1:\nThe vectors x1;x2;:::;x narelinearly dependent if there exist coef\ufb01cients\nc1;c2;:::;c n, not all of which are zero, such that c1x1Cc2x2C/SOH/SOH/SOHC cnxnD0.\nThe row vectors x1D.123 /,x2D.264 /,a n d x3D.41 19 /are\nlinearly dependent, for example, since 2x1C3x2/NUL2x3D0. If vectors are not\nlinearly dependent, they are linearly independent . For example, the columns of an\nidentity matrix are linearly independent.\nThecolumn rank of a nonzero m/STXnmatrix Ais the size of the largest set\nof linearly independent columns of A. Similarly, the row rank ofAis the size\nof the largest set of linearly independent rows of A. A fundamental property of\nany matrix Ais that its row rank always equals its column rank, so that we can\nsimply refer to the rank ofA. The rank of an m/STXnmatrix is an integer between 0\nand min .m; n/ , inclusive. (The rank of a zero matrix is 0,a n dt h er a n ko fa n n/STXn\nidentity matrix is n.) An alternate, but equivalent and often more useful, de\ufb01nition\nis that the rank of a nonzero m/STXnmatrix Ais the smallest number rsuch that\nthere exist matrices BandCof respective sizes m/STXrandr/STXnsuch that\nADBC :\nA square n/STXnmatrix has full rank if its rank is n.A n m/STXnmatrix has full\ncolumn rank if its rank is n. The following theorem gives a fundamental property\nof ranks.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "1244": {"page_number": 1245, "page_information": "1224 Appendix D Matrices\nTheorem D.1\nA square matrix has full rank if and only if it is nonsingular.\nAnull vector for a matrix Ais a nonzero vector xsuch that AxD0.T h e\nfollowing theorem (whose proof is left as Exercise D.2-7) and its corollary relate\nthe notions of column rank and singularity to null vectors.\nTheorem D.2\nA matrix Ahas full column rank if and only if it does not have a null vector.\nCorollary D.3\nA square matrix Ais singular if and only if it has a null vector.\nTheijthminor of an n/STXnmatrix A,f o rn>1 ,i st h e .n/NUL1//STX.n/NUL1/matrix A\u0152ij /c141\nobtained by deleting the ith row and jth column of A.W ed e \ufb01 n et h e determinant\nof an n/STXnmatrix Arecursively in terms of its minors by\ndet.A/D\u201a\na11 ifnD1;\nnX\njD1./NUL1/1Cja1jdet.A\u01521j /c141/ifn>1:\nThe term ./NUL1/iCjdet.A\u0152ij /c141/is known as the cofactor of the element aij.\nThe following theorems, whose proofs are omitted here, express fundamental\nproperties of the determinant.\nTheorem D.4 (Determinant properties)\nThe determinant of a square matrix Ahas the following properties:\n/SIIf any row or any column of Ais zero, then det .A/D0.\n/SIThe determinant of Ais multiplied by /NAKif the entries of any one row (or any\none column) of Aare all multiplied by /NAK.\n/SIThe determinant of Ais unchanged if the entries in one row (respectively, col-\numn) are added to those in another row (respectively, column).\n/SIThe determinant of Aequals the determinant of AT.\n/SIThe determinant of Ais multiplied by/NUL1if any two rows (or any two columns)\nare exchanged.\nAlso, for any square matrices AandB,w eh a v ed e t .AB/Ddet.A/det.B/.\n", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "1245": {"page_number": 1246, "page_information": "D.2 Basic matrix properties 1225\nTheorem D.5\nAnn/STXnmatrix Ais singular if and only if det .A/D0.\nPositive-de\ufb01nite matrices\nPositive-de\ufb01nite matrices play an important role in many applications. An n/STXn\nmatrix Aispositive-de\ufb01nite ifxTAx > 0 for all n-vectors x\u00a40.F o r\nexample, the identity matrix is positive-de\ufb01nite, since for any nonzero vectorxD.x\n1x2/SOH/SOH/SOHxn/T,\nxTInxDxTx\nDnX\niD1x2\ni\n>0 :\nMatrices that arise in applications are often positive-de\ufb01nite due to the following\ntheorem.\nTheorem D.6\nFor any matrix Awith full column rank, the matrix ATAis positive-de\ufb01nite.\nProof We must show that xT.ATA/x > 0 for any nonzero vector x.F o r a n y\nvector x,\nxT.ATA/xD.Ax/T.Ax/ (by Exercise D.1-2)\nDkAxk2:\nNote thatkAxk2is just the sum of the squares of the elements of the vector Ax.\nTherefore,kAxk2/NAK0.I fkAxk2D0, every element of Axis0, which is to say\nAxD0.S i n c e Ahas full column rank, AxD0implies xD0, by Theorem D.2.\nHence, ATAis positive-de\ufb01nite.\nSection 28.3 explores other properties of positive-de\ufb01nite matrices.\nExercises\nD.2-1\nProve that matrix inverses are unique, that is, if BandCare inverses of A,t h e n\nBDC.\nD.2-2\nProve that the determinant of a lower-triangular or upper-triangular matrix is equalto the product of its diagonal elements. Prove that the inverse of a lower-triangularmatrix, if it exists, is lower-triangular.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "1246": {"page_number": 1247, "page_information": "1226 Appendix D Matrices\nD.2-3\nProve that if Pis a permutation matrix, then Pis invertible, its inverse is PT,\nandPTis a permutation matrix.\nD.2-4\nLetAandBben/STXnmatrices such that ABDI. Prove that if A0is obtained\nfrom Aby adding row jinto row i, then subtracting column ifrom column jofB\nyields the inverse B0ofA0.\nD.2-5\nLetAbe a nonsingular n/STXnmatrix with complex entries. Show that every entry\nofA/NUL1is real if and only if every entry of Ais real.\nD.2-6\nShow that if Ais a nonsingular, symmetric, n/STXnmatrix, then A/NUL1is symmetric.\nShow that if Bis an arbitrary m/STXnmatrix, then the m/STXmmatrix given by the\nproduct BABTis symmetric.\nD.2-7\nProve Theorem D.2. That is, show that a matrix Ahas full column rank if and only\nifAxD0implies xD0.(Hint: Express the linear dependence of one column on\nthe others as a matrix-vector equation.)\nD.2-8\nProve that for any two compatible matrices AandB,\nrank.AB//DC4min.rank.A/; rank.B// ;\nwhere equality holds if either AorBis a nonsingular square matrix. ( Hint: Use\nthe alternate de\ufb01nition of the rank of a matrix.)\nProblems\nD-1 Vandermonde matrixGiven numbers x\n0;x1;:::;x n/NUL1, prove that the determinant of the Vandermonde\nmatrix\nV.x 0;x1;:::;x n/NUL1/D\u02d91x 0 x2\n0/SOH/SOH/SOHxn/NUL1\n0\n1x 1 x2\n1/SOH/SOH/SOHxn/NUL1\n1:::::::::::::::\n1x\nn/NUL1x2\nn/NUL1/SOH/SOH/SOHxn/NUL1\nn/NUL1/BEL", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "1247": {"page_number": 1248, "page_information": "Problems for Appendix D 1227\nis\ndet.V.x 0;x1;:::;x n/NUL1//DY\n0/DC4j< k /DC4n/NUL1.xk/NULxj/:\n(Hint: Multiply column iby/NULx0and add it to column iC1foriDn/NUL1;\nn/NUL2;:::;1 , and then use induction.)\nD-2 Permutations de\ufb01ned by matrix-vector multiplication over GF .2/\nOne class of permutations of the integers in the set SnDf0; 1; 2; : : : ; 2n/NUL1gis\nde\ufb01ned by matrix multiplication over GF.2/. For each integer xinSn, we view its\nbinary representation as an n-bit vector /NUL\nx0\nx1\nx2\n:::\nxn/NUL1/SOH\n;\nwhere xDPn/NUL1\niD0xi2i.I fAis an n/STXnmatrix in which each entry is either 0\nor1, then we can de\ufb01ne a permutation mapping each value xinSnto the number\nwhose binary representation is the matrix-vector product Ax. Here, we perform\nall arithmetic over GF.2/: all values are either 0or1, and with one exception the\nusual rules of addition and multiplication apply. The exception is that 1C1D0.\nYou can think of arithmetic over GF.2/as being just like regular integer arithmetic,\nexcept that you use only the least signi\ufb01cant bit.\nAs an example, for S2Df0; 1; 2; 3g, the matrix\nAD/DC210\n11/DC3\nde\ufb01nes the following permutation /EMA:/EMA.0/D0,/EMA.1/D3,/EMA.2/D2,\n/EMA.3/D1. To see why /EMA.3/D1, observe that, working in GF.2/,\n/EMA.3/D/DC210\n11/DC3/DC21\n1/DC3\nD/DC21/SOH1C0/SOH1\n1/SOH1C1/SOH1/DC3\nD/DC21\n0/DC3\n;\nwhich is the binary representation of 1.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "1248": {"page_number": 1249, "page_information": "1228 Appendix D Matrices\nFor the remainder of this problem, we work over GF.2/, and all matrix and\nvector entries are 0or1. We de\ufb01ne the rank of a 0-1 matrix (a matrix for which\neach entry is either 0or1) over GF.2/the same as for a regular matrix, but with all\narithmetic that determines linear independence performed over GF.2/.W e d e \ufb01 n e\ntherange of an n/STXn0-1 matrix Aby\nR.A/DfyWyDAxfor some x2Sng;\nso that R.A/ is the set of numbers in Snthat we can produce by multiplying each\nvalue xinSnbyA.\na.Ifris the rank of matrix A, prove thatjR.A/jD2r. Conclude that Ade\ufb01nes a\npermutation on Snonly if Ahas full rank.\nFor a given n/STXnmatrix Aand a given value y2R.A/ ,w ed e \ufb01 n et h e preimage\nofyby\nP. A ;y/DfxWAxDyg;\nso that P. A ;y/ is the set of values in Snthat map to ywhen multiplied by A.\nb.Ifris the rank of n/STXnmatrix Aandy2R.A/ , prove thatjP. A ;y/jD2n/NULr.\nLet0/DC4m/DC4n, and suppose we partition the set Sninto blocks of consec-\nutive numbers, where the ith block consists of the 2mnumbers i2m;i2mC1;\ni2mC2;:::;. iC1/2m/NUL1. For any subset S/DC2Sn,d e \ufb01 n e B.S;m/ to be the\nset of size- 2mblocks of Sncontaining some element of S. As an example, when\nnD3,mD1,a n d SDf1; 4; 5g,t h e n B.S;m/ consists of blocks 0(since 1is in\nthe0th block) and 2(since both 4and5are in block 2).\nc.Letrbe the rank of the lower left .n/NULm//STXmsubmatrix of A,t h a ti s ,t h e\nmatrix formed by taking the intersection of the bottom n/NULmrows and the\nleftmost mcolumns of A.L e t Sbe any size- 2mblock of Sn,a n dl e t S0D\nfyWyDAxfor some x2Sg. Prove thatjB.S0;m /jD2rand that for each\nblock in B.S0;m /, exactly 2m/NULrnumbers in Smap to that block.\nBecause multiplying the zero vector by any matrix yields a zero vector, the set\nof permutations of Snde\ufb01ned by multiplying by n/STXn0-1 matrices with full rank\nover GF.2/cannot include all permutations of Sn. Let us extend the class of per-\nmutations de\ufb01ned by matrix-vector multiplication to include an additive term, sothatx2S\nnmaps to AxCc,w h e r e cis an n-bit vector and addition is performed\nover GF.2/. For example, when\nAD/DC210\n11/DC3", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "1249": {"page_number": 1250, "page_information": "Notes for Appendix D 1229\nand\ncD/DC20\n1/DC3\n;\nwe get the following permutation /EMA;c:/EMA;c.0/D2,/EMA;c.1/D1,/EMA;c.2/D0,\n/EMA;c.3/D3. We call any permutation that maps x2SntoAxCc,f o rs o m e n/STXn\n0-1 matrix Awith full rank and some n-bit vector c,alinear permutation .\nd.Use a counting argument to show that the number of linear permutations of Sn\nis much less than the number of permutations of Sn.\ne.Give an example of a value of nand a permutation of Snthat cannot be achieved\nby any linear permutation. ( Hint: For a given permutation, think about how\nmultiplying a matrix by a unit vector relates to the columns of the matrix.)\nAppendix notes\nLinear-algebra textbooks provide plenty of background information on matrices.The books by Strang [323, 324] are particularly good.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "1250": {"page_number": 1251, "page_information": "", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "1251": {"page_number": 1252, "page_information": "Bibliography\n[1] Milton Abramowitz and Irene A. Stegun, editors. Handbook of Mathematical Functions .\nDover, 1965.\n[2] G. M. Adel\u2019son-Vel\u2019ski\u02d8 \u0131 and E. M. Landis. An algorithm for the organization of information.\nSoviet Mathematics Doklady , 3(5):1259\u20131263, 1962.\n[3] Alok Aggarwal and Jeffrey Scott Vitter. The i nput/output complexity of sorting and related\nproblems. Communications of the ACM , 31(9):1116\u20131127, 1988.\n[4] Manindra Agrawal, Neeraj Kayal, and Nitin Saxena. PRIMES is in P. Annals of Mathe-\nmatics , 160(2):781\u2013793, 2004.\n[5] Alfred V . Aho, John E. Hopcroft, and Jeffrey D. Ullman. The Design and Analysis of\nComputer Algorithms . Addison-Wesley, 1974.\n[6] Alfred V . Aho, John E. Hopcroft, and Jeffrey D. Ullman. Data Structures and Algorithms .\nAddison-Wesley, 1983.\n[7] Ravindra K. Ahuja, Thomas L. Magnanti, and James B. Orlin. Network Flows: Theory,\nAlgorithms, and Applications . Prentice Hall, 1993.\n[8] Ravindra K. Ahuja, Kurt Mehlhorn, James B. Or lin, and Robert E. Tarjan. Faster algorithms\nfor the shortest path problem. Journal of the ACM , 37:213\u2013223, 1990.\n[9] Ravindra K. Ahuja and James B. Orlin. A fast and simple algorithm for the maximum \ufb02ow\nproblem. Operations Research , 37(5):748\u2013759, 1989.\n[10] Ravindra K. Ahuja, James B. Orlin, and Robert E. Tarjan. Improved time bounds for the\nmaximum \ufb02ow problem. SIAM Journal on Computing , 18(5):939\u2013954, 1989.\n[11] Mikl\u00b4 os Ajtai, Nimrod Megiddo, and Orli Waarts . Improved algorithms and analysis for\nsecretary problems and generalizations. In Proceedings of the 36th Annual Symposium on\nFoundations of Computer Science , pages 473\u2013482, 1995.\n[12] Selim G. Akl. The Design and Analysis of Parallel Algorithms . Prentice Hall, 1989.\n[13] Mohamad Akra and Louay Bazzi. On the solution of linear recurrence equations. Compu-\ntational Optimization and Applications , 10(2):195\u2013210, 1998.\n[14] Noga Alon. Generating pseudo-random permutations and maximum \ufb02ow algorithms. In-\nformation Processing Letters , 35:201\u2013204, 1990.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "1252": {"page_number": 1253, "page_information": "1232 Bibliography\n[15] Arne Andersson. Balanced search trees made simple. In Proceedings of the Third Workshop\non Algorithms and Data Structures , volume 709 of Lecture Notes in Computer Science ,\npages 60\u201371. Springer, 1993.\n[16] Arne Andersson. Faster deterministic sorting and searching in linear space. In Proceedings\nof the 37th Annual Symposium on Foundations of Computer Science , pages 135\u2013141, 1996.\n[17] Arne Andersson, Torben Hagerup, Stefan Nilsson, and Rajeev Raman. Sorting in linear\ntime? Journal of Computer and System Sciences , 57:74\u201393, 1998.\n[18] Tom M. Apostol. Calculus , volume 1. Blaisdell Publishing Company, second edition, 1967.\n[19] Nimar S. Arora, Robert D. Blumofe, and C. Greg Plaxton. Thread scheduling for multipro-\ngrammed multiprocessors. In Proceedings of the 10th Annual ACM Symposium on Parallel\nAlgorithms and Architectures , pages 119\u2013129, 1998.\n[20] Sanjeev Arora. Probabilistic checking of proofs and the hardness of approximation prob-\nlems. PhD thesis, University of California, Berkeley, 1994.\n[21] Sanjeev Arora. The approximability of NP-hard problems. In Proceedings of the 30th\nAnnual ACM Symposium on Theory of Computing , pages 337\u2013348, 1998.\n[22] Sanjeev Arora. Polynomial time approximation schemes for euclidean traveling salesman\nand other geometric problems. Journal of the ACM , 45(5):753\u2013782, 1998.\n[23] Sanjeev Arora and Carsten Lund. Hardness of approximations. In Dorit S. Hochbaum,\neditor, Approximation Algorithms for NP-Hard Problems , pages 399\u2013446. PWS Publishing\nCompany, 1997.\n[24] Javed A. Aslam. A simple bound on the expected height of a randomly built binary search\ntree. Technical Report TR2001-387, Dartmouth College Department of Computer Science,\n2001.\n[25] Mikhail J. Atallah, editor. Algorithms and Theory of Computation Handbook . CRC Press,\n1999.\n[26] G. Ausiello, P. Crescenzi, G. Gambosi, V . Kann, A. Marchetti-Spaccamela, and M. Protasi.\nComplexity and Approximation: Combinatorial Optimization Problems and Their Approx-imability Properties . Springer, 1999.\n[27] Shai Avidan and Ariel Shamir. Seam carving for content-aware image resizing. ACM Trans-\nactions on Graphics , 26(3), article 10, 2007.\n[28] Sara Baase and Alan Van Gelder. Computer Algorithms: Introduction to Design and Anal-\nysis. Addison-Wesley, third edition, 2000.\n[29] Eric Bach. Private communication, 1989.\n[30] Eric Bach. Number-theoretic algorithms. In Annual Review of Computer Science , volume 4,\npages 119\u2013172. Annual Reviews, Inc., 1990.\n[31] Eric Bach and Jeffrey Shallit. Algorithmic Number Theory\u2014Volume I: Ef\ufb01cient Algorithms .\nThe MIT Press, 1996.\n[32] David H. Bailey, King Lee, and Horst D. Simon. Using Strassen\u2019s algorithm to accelerate\nthe solution of linear systems. The Journal of Supercomputing , 4(4):357\u2013371, 1990.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "1253": {"page_number": 1254, "page_information": "Bibliography 1233\n[33] Surender Baswana, Ramesh Hariharan, and Sandeep Sen. Improved decremental algo-\nrithms for maintaining transitive closure and all-pairs shortest paths. Journal of Algorithms ,\n62(2):74\u201392, 2007.\n[34] R. Bayer. Symmetric binary B-trees: Data structure and maintenance algorithms. Acta\nInformatica , 1(4):290\u2013306, 1972.\n[35] R. Bayer and E. M. McCreight. Organization and maintenance of large ordered indexes.\nActa Informatica , 1(3):173\u2013189, 1972.\n[36] Pierre Beauchemin, Gilles Brassard, Claude Cr\u00b4 epeau, Claude Goutier, and Carl Pomerance.\nThe generation of random numbers that are probably prime. Journal of Cryptology , 1(1):53\u2013\n64, 1988.\n[37] Richard Bellman. Dynamic Programming . Princeton University Press, 1957.\n[38] Richard Bellman. On a routing problem. Quarterly of Applied Mathematics , 16(1):87\u201390,\n1958.\n[39] Michael Ben-Or. Lower bounds for algebraic computation trees. In Proceedings of the\nFifteenth Annual ACM Symposium on Theory of Computing , pages 80\u201386, 1983.\n[40] Michael A. Bender, Erik D. Demaine, and Martin Farach-Colton. Cache-oblivious B-trees.\nInProceedings of the 41st Annual Symposium on Foundations of Computer Science , pages\n399\u2013409, 2000.\n[41] Samuel W. Bent and John W. John. Finding the median requires 2ncomparisons. In Pro-\nceedings of the Seventeenth Annual ACM Symposium on Theory of Computing , pages 213\u2013\n216, 1985.\n[42] Jon L. Bentley. Writing Ef\ufb01cient Programs . Prentice Hall, 1982.\n[43] Jon L. Bentley. Programming Pearls . Addison-Wesley, 1986.\n[44] Jon L. Bentley, Dorothea Haken, and James B. Saxe. A general method for solving divide-\nand-conquer recurrences. SIGACT News , 12(3):36\u201344, 1980.\n[45] Daniel Bienstock and Benjamin McClosky. Tightening simplex mixed-integer sets with\nguaranteed bounds. Optimization Online , July 2008.\n[46] Patrick Billingsley. Probability and Measure . John Wiley & Sons, second edition, 1986.\n[47] Guy E. Blelloch. Scan Primitives and Parallel Vector Models . PhD thesis, Department of\nElectrical Engineering and Computer Science, MIT, 1989. Available as MIT Laboratory for\nComputer Science Technical Report MIT/LCS/TR-463.\n[48] Guy E. Blelloch. Programming parallel algorithms. Communications of the ACM ,\n39(3):85\u201397, 1996.\n[49] Guy E. Blelloch, Phillip B. Gibbons, and Yossi Matias. Provably ef\ufb01cient scheduling for\nlanguages with \ufb01ne-grained parallelism. In Proceedings of the 7th Annual ACM Symposium\non Parallel Algorithms and Architectures , pages 1\u201312, 1995.\n[50] Manuel Blum, Robert W. Floyd, Vaughan Pratt, Ronald L. Rivest, and Robert E. Tarjan.\nTime bounds for selection. Journal of Computer and System Sciences , 7(4):448\u2013461, 1973.\n[51] Robert D. Blumofe, Christopher F. Joerg, Bradley C. Kuszmaul, Charles E. Leiserson,\nKeith H. Randall, and Yuli Zhou. Cilk: An ef\ufb01cient multithreaded runtime system. Journal\nof Parallel and Distributed Computing , 37(1):55\u201369, 1996.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "1254": {"page_number": 1255, "page_information": "1234 Bibliography\n[52] Robert D. Blumofe and Charles E. Leiserson. Scheduling multithreaded computations by\nwork stealing. Journal of the ACM , 46(5):720\u2013748, 1999.\n[53] B\u00b4 ela Bollob\u00b4 as.Random Graphs . Academic Press, 1985.\n[54] Gilles Brassard and Paul Bratley. Fundamentals of Algorithmics . Prentice Hall, 1996.\n[55] Richard P. Brent. The parallel evaluation of general arithmetic expressions. Journal of the\nACM , 21(2):201\u2013206, 1974.\n[56] Richard P. Brent. An improved Monte Carlo factorization algorithm. BIT, 20(2):176\u2013184,\n1980.\n[57] J. P. Buhler, H. W. Lenstra, Jr., and Carl Pomerance. Factoring integers with the number\n\ufb01eld sieve. In A. K. Lenstra and H. W. Lenstra, Jr., editors, The Development of the Number\nField Sieve , volume 1554 of Lecture Notes in Mathematics , pages 50\u201394. Springer, 1993.\n[58] J. Lawrence Carter and Mark N. Wegman. Universal classes of hash functions. Journal of\nComputer and System Sciences , 18(2):143\u2013154, 1979.\n[59] Barbara Chapman, Gabriele Jost, and Ruud van der Pas. Using OpenMP: Portable Shared\nMemory Parallel Programming . The MIT Press, 2007.\n[60] Bernard Chazelle. A minimum spanning tree algorithm with inverse-Ackermann type com-\nplexity. Journal of the ACM , 47(6):1028\u20131047, 2000.\n[61] Joseph Cheriyan and Torben Hager up. A randomized maximum-\ufb02ow algorithm. SIAM\nJournal on Computing , 24(2):203\u2013226, 1995.\n[62] Joseph Cheriyan and S. N. Maheshwari. Analysis of pre\ufb02ow push algorithms for maximum\nnetwork \ufb02ow. SIAM Journal on Computing , 18(6):1057\u20131086, 1989.\n[63] Boris V . Cherkassky and Andrew V . Goldberg. On implementing the push-relabel method\nfor the maximum \ufb02ow problem. Algorithmica , 19(4):390\u2013410, 1997.\n[64] Boris V . Cherkassky, Andrew V . Goldberg, and Tomasz Radzik. Shortest paths algorithms:\nTheory and experimental evaluation. Mathematical Programming , 73(2):129\u2013174, 1996.\n[65] Boris V . Cherkassky, Andrew V . Goldberg, and Craig Silverstein. Buckets, heaps, lists and\nmonotone priority queues. SIAM Journal on Computing , 28(4):1326\u20131346, 1999.\n[66] H. Chernoff. A measure of asymptotic ef\ufb01ciency for tests of a hypothesis based on the sum\nof observations. Annals of Mathematical Statistics , 23(4):493\u2013507, 1952.\n[67] Kai Lai Chung. Elementary Probability Theory with Stochastic Processes . Springer, 1974.\n[68] V . Chv\u00b4 atal. A greedy heuristic for the set-covering problem. Mathematics of Operations\nResearch , 4(3):233\u2013235, 1979.\n[69] V . Chv\u00b4 atal. Linear Programming . W. H. Freeman and Company, 1983.\n[70] V . Chv\u00b4 atal, D. A. Klarner, and D. E. Knuth. Selected combinatorial research problems.\nTechnical Report STAN-CS-72-292, Computer Science Department, Stanford University,\n1972.\n[71] Cilk Arts, Inc., Burlington, Massachusetts. Cilk++ Programmer\u2019s Guide , 2008. Available\nat http://www.cilk.com/archive/docs/cilk1guide.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "1255": {"page_number": 1256, "page_information": "Bibliography 1235\n[72] Alan Cobham. The intrinsic computational dif\ufb01culty of functions. In Proceedings of the\n1964 Congress for Logic, Methodology, and the Philosophy of Science , pages 24\u201330. North-\nHolland, 1964.\n[73] H. Cohen and H. W. Lenstra, Jr. Primality testing and Jacobi sums. Mathematics of Com-\nputation , 42(165):297\u2013330, 1984.\n[74] D. Comer. The ubiquitous B-tree. ACM Computing Surveys , 11(2):121\u2013137, 1979.\n[75] Stephen Cook. The complexity of theorem proving procedures. In Proceedings of the Third\nAnnual ACM Symposium on Theory of Computing , pages 151\u2013158, 1971.\n[76] James W. Cooley and John W. Tukey. An algorithm for the machine calculation of complex\nFourier series. Mathematics of Computation , 19(90):297\u2013301, 1965.\n[77] Don Coppersmith. Modi\ufb01cations to the number \ufb01eld sieve. Journal of Cryptology ,\n6(3):169\u2013180, 1993.\n[78] Don Coppersmith and Shmuel Winograd. Matrix multiplication via arithmetic progression.\nJournal of Symbolic Computation , 9(3):251\u2013280, 1990.\n[79] Thomas H. Cormen, Thomas Sundquist, and Leonard F. Wisniewski. Asymptotically tight\nbounds for performing BMMC permutations on parallel disk systems. SIAM Journal on\nComputing , 28(1):105\u2013136, 1998.\n[80] Don Dailey and Charles E. Leiserson. Using Cilk to write multiprocessor chess programs.\nIn H. J. van den Herik and B. Monien, editors, Advances in Computer Games , volume 9,\npages 25\u201352. University of Maastricht, Netherlands, 2001.\n[81] Paolo D\u2019Alberto and Alexandru Nicolau. Adaptive Strassen\u2019s matrix multiplication. In\nProceedings of the 21st Annual International Conference on Supercomputing , pages 284\u2013\n292, June 2007.\n[82] Sanjoy Dasgupta, Christos Papadimitriou, and Umesh Vazirani. Algorithms . McGraw-Hill,\n2008.\n[83] Roman Dementiev, Lutz Kettner, Jens Mehnert, and Peter Sanders. Engineering a sorted list\ndata structure for 32 bit keys. In Proceedings of the Sixth Workshop on Algorithm Engineer-\ning and Experiments and the First Workshop on Analytic Algorithmics and Combinatorics ,\npages 142\u2013151, January 2004.\n[84] Camil Demetrescu and Giuseppe F. Italiano. Fully dynamic all pairs shortest paths with real\nedge weights. Journal of Computer and System Sciences , 72(5):813\u2013837, 2006.\n[85] Eric V . Denardo and Bennett L. Fox. Shortest-route methods: 1. Reaching, pruning, and\nbuckets. Operations Research , 27(1):161\u2013186, 1979.\n[86] Martin Dietzfelbinger, Anna Karlin, Kurt Mehlhorn, Friedhelm Meyer auf der Heide, Hans\nRohnert, and Robert E. Tarjan. Dynamic perfect hashing: Upper and lower bounds. SIAM\nJournal on Computing , 23(4):738\u2013761, 1994.\n[87] Whit\ufb01eld Dif\ufb01e and Martin E. Hellman. New directions in cryptography. IEEE Transac-\ntions on Information Theory , IT-22(6):644\u2013654, 1976.\n[88] E. W. Dijkstra. A note on two problems in connexion with graphs. Numerische Mathematik ,\n1(1):269\u2013271, 1959.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "1256": {"page_number": 1257, "page_information": "1236 Bibliography\n[89] E. A. Dinic. Algorithm for solution of a problem of maximum \ufb02ow in a network with power\nestimation. Soviet Mathematics Doklady , 11(5):1277\u20131280, 1970.\n[90] Brandon Dixon, Monika Rauch, and Robert E. Tarjan. Veri\ufb01cation and sensitivity analysis\nof minimum spanning trees in linear time. SIAM Journal on Computing , 21(6):1184\u20131192,\n1992.\n[91] John D. Dixon. Fact orization and primality tests. The American Mathematical Monthly ,\n91(6):333\u2013352, 1984.\n[92] Dorit Dor, Johan H\u02da astad, Staffan Ulfberg, and Uri Zwick. On lower bounds for selecting\nthe median. SIAM Journal on Discrete Mathematics , 14(3):299\u2013311, 2001.\n[93] Dorit Dor and Uri Zwick. Selecting the median. SIAM Journal on Computing , 28(5):1722\u2013\n1758, 1999.\n[94] Dorit Dor and Uri Zwick. Median selection requires .2C/SI/ncomparisons. SIAM Journal\non Discrete Mathematics , 14(3):312\u2013325, 2001.\n[95] Alvin W. Drake. Fundamentals of App lied Probability Theory . McGraw-Hill, 1967.\n[96] James R. Driscoll, Harold N. Gabow, Ruth Shrairman, and Robert E. Tarjan. Relaxed heaps:\nAn alternative to Fibonacci heaps with applications to parallel computation. Communica-\ntions of the ACM , 31(11):1343\u20131354, 1988.\n[97] James R. Driscoll, Neil Sarnak, Daniel D. Sl eator, and Robert E. Tarjan. Making data\nstructures persistent. Journal of Computer and System Sciences , 38(1):86\u2013124, 1989.\n[98] Derek L. Eager, John Zahorjan, and Edward D. Lazowska. Speedup versus ef\ufb01ciency in\nparallel systems. IEEE Transactions on Computers , 38(3):408\u2013423, 1989.\n[99] Herbert Edelsbrunner. Algorithms in Combinatorial Geometry , volume 10 of EATCS Mono-\ngraphs on Theoretical Computer Science . Springer, 1987.\n[100] Jack Edmonds. Paths, trees, and \ufb02owers. Canadian Journal of Mathematics , 17:449\u2013467,\n1965.\n[101] Jack Edmonds. Matroids and the greedy algorithm. Mathematical Programming , 1(1):127\u2013\n136, 1971.\n[102] Jack Edmonds and Richard M. Karp. Theore tical improvements in the algorithmic ef\ufb01-\nciency for network \ufb02ow problems. Journal of the ACM , 19(2):248\u2013264, 1972.\n[103] Shimon Even. Graph Algorithms . Computer Science Press, 1979.\n[104] William Feller. An Introduction to Probability Theory and Its Applications . John Wiley &\nSons, third edition, 1968.\n[105] Robert W. Floyd. Algorithm 97 (SHORTEST PATH). Communications of the ACM ,\n5(6):345, 1962.\n[106] Robert W. Floyd. Algorithm 245 (TREESORT). Communications of the ACM , 7(12):701,\n1964.\n[107] Robert W. Floyd. Permuting information in idealized two-level storage. In Raymond E.\nMiller and James W. Thatcher, editors, Complexity of Computer Computations , pages 105\u2013\n109. Plenum Press, 1972.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "1257": {"page_number": 1258, "page_information": "Bibliography 1237\n[108] Robert W. Floyd and Ronald L. Rivest. Expected time bounds for selection. Communica-\ntions of the ACM , 18(3):165\u2013172, 1975.\n[109] Lestor R. Ford, Jr. and D. R. Fulkerson. Flows in Networks . Princeton University Press,\n1962.\n[110] Lestor R. Ford, Jr. and Selmer M. Johnson. A tournament problem. The American Mathe-\nmatical Monthly , 66(5):387\u2013389, 1959.\n[111] Michael L. Fredman. New bounds on the complexity of the shortest path problem. SIAM\nJournal on Computing , 5(1):83\u201389, 1976.\n[112] Michael L. Fredman, J\u00b4 anos Koml\u00b4 os, and Endre Szemer\u00b4 edi. Storing a sparse table with O.1/\nworst case access time. Journal of the ACM , 31(3):538\u2013544, 1984.\n[113] Michael L. Fredman and Michael E. Saks. The cell probe complexity of dynamic data struc-\ntures. In Proceedings of the Twenty First Annual ACM Symposium on Theory of Computing ,\npages 345\u2013354, 1989.\n[114] Michael L. Fredman and Robert E. Tarjan. Fibonacci heaps and their uses in improved\nnetwork optimization algorithms. Journal of the ACM , 34(3):596\u2013615, 1987.\n[115] Michael L. Fredman and Dan E. Willard. Surpassing the information theoretic bound with\nfusion trees. Journal of Computer and System Sciences , 47(3):424\u2013436, 1993.\n[116] Michael L. Fredman and Dan E. Willard. Trans-dichotomous algorithms for minimum span-\nning trees and shortest paths. Journal of Computer and System Sciences , 48(3):533\u2013551,\n1994.\n[117] Matteo Frigo and Steven G. Johnson. The design and implementation of FFTW3. Proceed-\nings of the IEEE , 93(2):216\u2013231, 2005.\n[118] Matteo Frigo, Charles E. Leiserson, and Keith H. Randall. The implementation of the Cilk-5\nmultithreaded language. In Proceedings of the 1998 ACM SIGPLAN Conference on Pro-\ngramming Language Design and Implementation , pages 212\u2013223, 1998.\n[119] Harold N. Gabow. Path-based depth-\ufb01rst search for strong and biconnected components.\nInformation Processing Letters , 74(3\u20134):107\u2013114, 2000.\n[120] Harold N. Gabow, Z. Galil, T. Spencer, and Robert E. Tarjan. Ef\ufb01cient algorithms for \ufb01nd-\ning minimum spanning trees in undirected and directed graphs. Combinatorica , 6(2):109\u2013\n122, 1986.\n[121] Harold N. Gabow and Robert E. Tarjan. A linear-time algorithm for a special case of disjoint\nset union. Journal of Computer and System Sciences , 30(2):209\u2013221, 1985.\n[122] Harold N. Gabow and Robert E. Tarjan. Faster scaling algorithms for network problems.\nSIAM Journal on Computing , 18(5):1013\u20131036, 1989.\n[123] Zvi Galil and Oded Margalit. All pairs shortest distances for graphs with small integer\nlength edges. Information and Computation , 134(2):103\u2013139, 1997.\n[124] Zvi Galil and Oded Margalit. All pairs shortest paths for graphs with small integer length\nedges. Journal of Computer and System Sciences , 54(2):243\u2013254, 1997.\n[125] Zvi Galil and Kunsoo Park. Dynamic programming with convexity, concavity and sparsity.\nTheoretical Computer Science , 92(1):49\u201376, 1992.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "1258": {"page_number": 1259, "page_information": "1238 Bibliography\n[126] Zvi Galil and Joel Seiferas. Time-space-optimal string matching. Journal of Computer and\nSystem Sciences , 26(3):280\u2013294, 1983.\n[127] Igal Galperin and Ronald L. Rivest. Scapegoat trees. In Proceedings of the 4th ACM-SIAM\nSymposium on Discrete Algorithms , pages 165\u2013174, 1993.\n[128] Michael R. Garey, R. L. Graham, and J. D. Ullman. Worst-case analyis of memory al-\nlocation algorithms. In Proceedings of the Fourth Annual ACM Symposium on Theory of\nComputing , pages 143\u2013150, 1972.\n[129] Michael R. Garey and David S. Johnson. Computers and Intractability: A Guide to the\nTheory of NP-Completeness . W. H. Freeman, 1979.\n[130] Saul Gass. Linear Programming: Methods and Applications . International Thomson Pub-\nlishing, fourth edition, 1975.\n[131] F\u02d8 anic\u02d8a Gavril. Algorithms for minimum coloring, maximum clique, minimum covering by\ncliques, and maximum independent set of a chordal graph. SIAM Journal on Computing ,\n1(2):180\u2013187, 1972.\n[132] Alan George and Joseph W-H Liu. Computer Solution of Large Sparse Positive De\ufb01nite\nSystems . Prentice Hall, 1981.\n[133] E. N. Gilbert and E. F. Moore. Variable-length binary encodings. Bell System Technical\nJournal , 38(4):933\u2013967, 1959.\n[134] Michel X. Goemans and David P. Williamson. Improved approximation algorithms for\nmaximum cut and satis\ufb01ability problems using semide\ufb01nite programming. Journal of the\nACM , 42(6):1115\u20131145, 1995.\n[135] Michel X. Goemans and David P. Williamson. The primal-dual method for approximation\nalgorithms and its application to network design problems. In Dorit S. Hochbaum, editor,\nApproximation Algorithms for NP-Hard Problems , pages 144\u2013191. PWS Publishing Com-\npany, 1997.\n[136] Andrew V . Goldberg. Ef\ufb01cient Graph Algorithms for Sequential and Parallel Computers .\nPhD thesis, Department of Electrical Engineering and Computer Science, MIT, 1987.\n[137] Andrew V . Goldberg. Scaling algorithms for the shortest paths problem. SIAM Journal on\nComputing , 24(3):494\u2013504, 1995.\n[138] Andrew V . Goldberg and Satish Rao. Beyond the \ufb02ow decomposition barrier. Journal of\nthe ACM , 45(5):783\u2013797, 1998.\n[139] Andrew V . Goldberg, \u00b4Eva Tardos, and Robert E. Tarjan. Network \ufb02ow algorithms. In Bern-\nhard Korte, L\u00b4 aszl\u00b4oL o v \u00b4 asz, Hans J\u00a8 urgen Pr\u00a8 omel, and Alexander Schrijver, editors, Paths,\nFlows, and VLSI-Layout , pages 101\u2013164. Springer, 1990.\n[140] Andrew V . Goldberg and Robert E. Tarjan. A new approach to the maximum \ufb02ow problem.\nJournal of the ACM , 35(4):921\u2013940, 1988.\n[141] D. Goldfarb and M. J. Todd. Linear programming. In G. L. Nemhauser, A. H. G. Rinnooy-\nKan, and M. J. Todd, editors, Handbook in Operations Research and Management Science,\nVol. 1, Optimization , pages 73\u2013170. Elsevier Science Publishers, 1989.\n[142] Sha\ufb01 Goldwasser and Silvio Micali. Probabilistic encryption. Journal of Computer and\nSystem Sciences , 28(2):270\u2013299, 1984.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "1259": {"page_number": 1260, "page_information": "Bibliography 1239\n[143] Sha\ufb01 Goldwasser, Silvio Micali, and Ronald L. Rivest. A digital signature scheme secure\nagainst adaptive chosen-message attacks. SIAM Journal on Computing , 17(2):281\u2013308,\n1988.\n[144] Gene H. Golub and Charles F. Van Loan. Matrix Computations . The Johns Hopkins Uni-\nversity Press, third edition, 1996.\n[145] G. H. Gonnet. Handbook of Algorithms and Data Structures . Addison-Wesley, 1984.\n[146] Rafael C. Gonzalez and Richard E. Woods. Digital Image Processing . Addison-Wesley,\n1992.\n[147] Michael T. Goodrich and Roberto Tamassia. Data Structures and Algorithms in Java . John\nWiley & Sons, 1998.\n[148] Michael T. Goodrich and Roberto Tamassia. Algorithm Design: Foundations, Analysis, and\nInternet Examples . John Wiley & Sons, 2001.\n[149] Ronald L. Graham. Bounds for certain multiprocessor anomalies. Bell System Technical\nJournal , 45(9):1563\u20131581, 1966.\n[150] Ronald L. Graham. An ef\ufb01cient algorithm for determining the convex hull of a \ufb01nite planar\nset.Information Processing Letters , 1(4):132\u2013133, 1972.\n[151] Ronald L. Graham and Pavol Hell. On the history of the minimum spanning tree problem.\nAnnals of the History of Computing , 7(1):43\u201357, 1985.\n[152] Ronald L. Graham, Donald E. Knuth, and Oren Patashnik. Concrete Mathematics .\nAddison-Wesley, second edition, 1994.\n[153] David Gries. The Science of Programming . Springer, 1981.\n[154] M. Gr\u00a8 otschel, L\u00b4 aszl\u00b4oL o v \u00b4 asz, and Alexander Schrijver. Geometric Algorithms and Combi-\nnatorial Optimization . Springer, 1988.\n[155] Leo J. Guibas and Robert Sedgewick. A dichromatic framework for balanced trees. In\nProceedings of the 19th Annual Symposium on Foundations of Computer Science , pages\n8\u201321, 1978.\n[156] Dan Gus\ufb01eld. Algorithms on Strings, Trees, and Sequences: Computer Science and Com-\nputational Biology . Cambridge University Press, 1997.\n[157] H. Halberstam and R. E. Ingram, editors. The Mathematical Papers of Sir William Rowan\nHamilton , volume III (Algebra). Cambridge University Press, 1967.\n[158] Yijie Han. Improved fast integer sorting in linear space. In Proceedings of the 12th ACM-\nSIAM Symposium on Discrete Algorithms , pages 793\u2013796, 2001.\n[159] Yijie Han. An O.n3.log log n=logn/5=4/time algorithm for all pairs shortest path. Algo-\nrithmica , 51(4):428\u2013434, 2008.\n[160] Frank Harary. Graph Theory . Addison-Wesley, 1969.\n[161] Gregory C. Harfst and Edward M. Reingold. A potential-based amortized analysis of the\nunion-\ufb01nd data structure. SIGACT News , 31(3):86\u201395, 2000.\n[162] J. Hartmanis and R. E. Stearns. On the computational complexity of algorithms. Transac-\ntions of the American Mathematical Society , 117:285\u2013306, May 1965.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "1260": {"page_number": 1261, "page_information": "1240 Bibliography\n[163] Michael T. Heideman, Don H. Johnson, and C. Sidney Burrus. Gauss and the history of the\nFast Fourier Transform. IEEE ASSP Magazine , 1(4):14\u201321, 1984.\n[164] Monika R. Henzinger and Valerie King. Fully dynamic biconnectivity and transitive clo-\nsure. In Proceedings of the 36th Annual Symposium on Foundations of Computer Science ,\npages 664\u2013672, 1995.\n[165] Monika R. Henzinger and Valerie King. Randomized fully dynamic graph algorithms with\npolylogarithmic time per operation. Journal of the ACM , 46(4):502\u2013516, 1999.\n[166] Monika R. Henzinger, Satish Rao, and Harold N. Gabow. Computing vertex connectivity:\nNew bounds from old techniques. Journal of Algorithms , 34(2):222\u2013250, 2000.\n[167] Nicholas J. Higham. Exploiting fast matrix multiplication within the level 3 BLAS. ACM\nTransactions on Mathematical Software , 16(4):352\u2013368, 1990.\n[168] W. Daniel Hillis and Jr. Guy L. Steele. Data parallel algorithms. Communications of the\nACM , 29(12):1170\u20131183, 1986.\n[169] C. A. R. Hoare. Algorithm 63 (PARTITION) and algorithm 65 (FIND). Communications\nof the ACM , 4(7):321\u2013322, 1961.\n[170] C. A. R. Hoare. Quicksort. Computer Journal , 5(1):10\u201315, 1962.\n[171] Dorit S. Hochbaum. Ef\ufb01cient bounds for the stable set, vertex cover and set packing prob-\nlems. Discrete Applied Mathematics , 6(3):243\u2013254, 1983.\n[172] Dorit S. Hochbaum, editor. Approximation Algorithms for NP-Hard Problems . PWS Pub-\nlishing Company, 1997.\n[173] W. Hoeffding. On the distribution of the number of successes in independent trials. Annals\nof Mathematical Statistics , 27(3):713\u2013721, 1956.\n[174] Micha Hofri. Probabilistic Analysis of Algorithms . Springer, 1987.\n[175] Micha Hofri. Analysis of Algorithms . Oxford University Press, 1995.\n[176] John E. Hopcroft and Richard M. Karp. An n5=2algorithm for maximum matchings in\nbipartite graphs. SIAM Journal on Computing , 2(4):225\u2013231, 1973.\n[177] John E. Hopcroft, Rajeev Motwani, and Jeffrey D. Ullman. Introduction to Automata The-\nory, Languages, and Computation . Addison Wesley, third edition, 2006.\n[178] John E. Hopcroft and Robert E. Tarjan. Ef\ufb01cient algorithms for graph manipulation. Com-\nmunications of the ACM , 16(6):372\u2013378, 1973.\n[179] John E. Hopcroft and Jeffrey D. Ullman. Set merging algorithms. SIAM Journal on Com-\nputing , 2(4):294\u2013303, 1973.\n[180] John E. Hopcroft and Jeffrey D. Ullman. Introduction to Automata Theory, Languages, and\nComputation . Addison-Wesley, 1979.\n[181] Ellis Horowitz, Sartaj Sahni, and Sanguthevar Rajasekaran. Computer Algorithms .C o m -\nputer Science Press, 1998.\n[182] T. C. Hu and M. T. Shing. Computation of matrix chain products. Part I. SIAM Journal on\nComputing , 11(2):362\u2013373, 1982.\n[183] T. C. Hu and M. T. Shing. Computation of matrix chain products. Part II. SIAM Journal on\nComputing , 13(2):228\u2013251, 1984.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "1261": {"page_number": 1262, "page_information": "Bibliography 1241\n[184] T. C. Hu and A. C. Tucker. Optimal computer search trees and variable-length alphabetic\ncodes. SIAM Journal on Applied Mathematics , 21(4):514\u2013532, 1971.\n[185] David A. Huffman. A method for the construction of minimum-redundancy codes. Pro-\nceedings of the IRE , 40(9):1098\u20131101, 1952.\n[186] Steven Huss-Lederman, Elaine M. Jacobson, Jeremy R. Johnson, Anna Tsao, and Thomas\nTurnbull. Implementation of Strassen\u2019s algorithm for matrix multiplication. In Proceedings\nof the 1996 ACM/IEEE Conference on Supercomputing , article 32, 1996.\n[187] Oscar H. Ibarra and Chul E. Kim. Fast approximation algorithms for the knapsack and sum\nof subset problems. Journal of the ACM , 22(4):463\u2013468, 1975.\n[188] E. J. Isaac and R. C. Singleton. Sorting by address calculation. Journal of the ACM ,\n3(3):169\u2013174, 1956.\n[189] R. A. Jarvis. On the identi\ufb01cation of the convex hull of a \ufb01nite set of points in the plane.\nInformation Processing Letters , 2(1):18\u201321, 1973.\n[190] David S. Johnson. Approximation algorithms for combinatorial problems. Journal of Com-\nputer and System Sciences , 9(3):256\u2013278, 1974.\n[191] David S. Johnson. The NP-completeness column: An ongoing guide\u2014The tale of the sec-\nond prover. Journal of Algorithms , 13(3):502\u2013524, 1992.\n[192] Donald B. Johnson. Ef\ufb01cient algorithms for shortest paths in sparse networks. Journal of\nthe ACM , 24(1):1\u201313, 1977.\n[193] Richard Johnsonbaugh and Marcus Schaefer. Algorithms . Pearson Prentice Hall, 2004.\n[194] A. Karatsuba and Yu. Ofman. Multiplication of multidigit numbers on automata. Soviet\nPhysics\u2014Doklady , 7(7):595\u2013596, 1963. Translation of an article in Doklady Akademii Nauk\nSSSR , 145(2), 1962.\n[195] David R. Karger, Philip N. Klein, and Robert E. Tarjan. A randomized linear-time algorithm\nto \ufb01nd minimum spanning trees. Journal of the ACM , 42(2):321\u2013328, 1995.\n[196] David R. Karger, Daphne Koller, and Steven J. Phillips. Finding the hidden path: Time\nbounds for all-pairs shortest paths. SIAM Journal on Computing , 22(6):1199\u20131217, 1993.\n[197] Howard Karloff. Linear Programming .B i r k h \u00a8 auser, 1991.\n[198] N. Karmarkar. A new polynomial-time algorithm for linear programming. Combinatorica ,\n4(4):373\u2013395, 1984.\n[199] Richard M. Karp. Reducibility among combinatorial problems. In Raymond E. Miller and\nJames W. Thatcher, editors, Complexity of Computer Computations , pages 85\u2013103. Plenum\nPress, 1972.\n[200] Richard M. Karp. An introduction to randomized algorithms. Discrete Applied Mathemat-\nics, 34(1\u20133):165\u2013201, 1991.\n[201] Richard M. Karp and Michael O. Rabin. Ef\ufb01cient randomized pattern-matching algorithms.\nIBM Journal of Research and Development , 31(2):249\u2013260, 1987.\n[202] A. V . Karzanov. Determining the maximal \ufb02ow in a network by the method of pre\ufb02ows.\nSoviet Mathematics Doklady , 15(2):434\u2013437, 1974.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "1262": {"page_number": 1263, "page_information": "1242 Bibliography\n[203] Valerie King. A simpler minimum spanning tree veri\ufb01cation algorithm. Algorithmica ,\n18(2):263\u2013270, 1997.\n[204] Valerie King, Satish Rao, and Robert E. Tarjan. A faster deterministic maximum \ufb02ow algo-\nrithm. Journal of Algorithms , 17(3):447\u2013474, 1994.\n[205] Jeffrey H. Kingston. Algorithms and Data Structures: Design, Correctness, Analysis .\nAddison-Wesley, second edition, 1997.\n[206] D. G. Kirkpatrick and R. Seidel. The ultimate planar convex hull algorithm? SIAM Journal\non Computing , 15(2):287\u2013299, 1986.\n[207] Philip N. Klein and Neal E. Young. Approximation algorithms for NP-hard optimization\nproblems. In CRC Handbook on Algorithms , pages 34-1\u201334-19. CRC Press, 1999.\n[208] Jon Kleinberg and \u00b4Eva Tardos. Algorithm Design . Addison-Wesley, 2006.\n[209] Donald E. Knuth. Fundamental Algorithms , volume 1 of The Art of Computer Program-\nming . Addison-Wesley, 1968. Third edition, 1997.\n[210] Donald E. Knuth. Seminumerical Algorithms , volume 2 of The Art of Computer Program-\nming . Addison-Wesley, 1969. Third edition, 1997.\n[211] Donald E. Knuth. Sorting and Searching , volume 3 of The Art of Computer Programming .\nAddison-Wesley, 1973. Second edition, 1998.\n[212] Donald E. Knuth. Optimum binary search trees. Acta Informatica , 1(1):14\u201325, 1971.\n[213] Donald E. Knuth. Big omicron and big omega and big theta. SIGACT News , 8(2):18\u201323,\n1976.\n[214] Donald E. Knuth, James H. Morris, Jr., and Vaughan R. Pratt. Fast pattern matching in\nstrings. SIAM Journal on Computing , 6(2):323\u2013350, 1977.\n[215] J. Koml\u00b4 os. Linear veri\ufb01cation for spanning trees. Combinatorica , 5(1):57\u201365, 1985.\n[216] Bernhard Korte and L\u00b4 aszl\u00b4oL o v \u00b4 asz. Mathematical structures underlying greedy algorithms.\nIn F. Gecseg, editor, Fundamentals of Computation Theory , volume 117 of Lecture Notes in\nComputer Science , pages 205\u2013209. Springer, 1981.\n[217] Bernhard Korte and L\u00b4 aszl\u00b4oL o v \u00b4 asz. Structural properties of greedoids. Combinatorica ,\n3(3\u20134):359\u2013374, 1983.\n[218] Bernhard Korte and L\u00b4 aszl\u00b4oL o v \u00b4 asz. Greedoids\u2014A structural framework for the greedy\nalgorithm. In W. Pulleybank, editor, Progress in Combinatorial Optimization , pages 221\u2013\n243. Academic Press, 1984.\n[219] Bernhard Korte and L\u00b4 aszl\u00b4oL o v \u00b4 asz. Greedoids and linear objective functions. SIAM Journal\non Algebraic and Discrete Methods , 5(2):229\u2013238, 1984.\n[220] Dexter C. Kozen. The Design and Analysis of Algorithms . Springer, 1992.\n[221] David W. Krumme, George Cybenko, and K. N. Venkataraman. Gossiping in minimal time.\nSIAM Journal on Computing , 21(1):111\u2013139, 1992.\n[222] Joseph B. Kruskal, Jr. On the shortest spanning subtree of a graph and the traveling salesman\nproblem. Proceedings of the American Mathematical Society , 7(1):48\u201350, 1956.\n[223] Leslie Lamport. How to make a multiprocessor computer that correctly executes multipro-\ncess programs. IEEE Transactions on Computers , C-28(9):690\u2013691, 1979.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "1263": {"page_number": 1264, "page_information": "Bibliography 1243\n[224] Eugene L. Lawler. Combinatorial Optimization: Networks and Matroids . Holt, Rinehart,\nand Winston, 1976.\n[225] Eugene L. Lawler, J. K. Lenstra, A. H. G. Rinnooy Kan, and D. B. Shmoys, editors. The\nTraveling Salesman Problem . John Wiley & Sons, 1985.\n[226] C. Y . Lee. An algorithm for path connection and its applications. IRE Transactions on\nElectronic Computers , EC-10(3):346\u2013365, 1961.\n[227] Tom Leighton. Tight bounds on the complexity of parallel sorting. IEEE Transactions on\nComputers , C-34(4):344\u2013354, 1985.\n[228] Tom Leighton. Notes on better master theorems for divide-and-conquer recurrences. Class\nnotes. Available at http://citeseer.ist.psu.edu/252350.html, October 1996.\n[229] Tom Leighton and Satish Rao. Multicommodity max-\ufb02ow min-cut theorems and their use\nin designing approximation algorithms. Journal of the ACM , 46(6):787\u2013832, 1999.\n[230] Daan Leijen and Judd Hall. Optimize managed code for multi-core machines. MSDN\nMagazine , October 2007.\n[231] Debra A. Lelewer and Daniel S. Hirschberg. Data compression. ACM Computing Surveys ,\n19(3):261\u2013296, 1987.\n[232] A. K. Lenstra, H. W. Lenstra, Jr., M. S. Manasse, and J. M. Pollard. The number \ufb01eld sieve.\nIn A. K. Lenstra and H. W. Lenstra, Jr., editors, The Development of the Number Field Sieve ,\nvolume 1554 of Lecture Notes in Mathematics , pages 11\u201342. Springer, 1993.\n[233] H. W. Lenstra, Jr. Factoring integers with elliptic curves. Annals of Mathematics ,\n126(3):649\u2013673, 1987.\n[234] L. A. Levin. Universal sorting problems. Problemy Peredachi Informatsii , 9(3):265\u2013266,\n1973. In Russian.\n[235] Anany Levitin. Introduction to the Design & Analysis of Algorithms . Addison-Wesley,\n2007.\n[236] Harry R. Lewis and Christos H. Papadimitriou. Elements of the Theory of Computation .\nPrentice Hall, second edition, 1998.\n[237] C. L. Liu. Introduction to Combinatorial Mathematics . McGraw-Hill, 1968.\n[238] L\u00b4 aszl\u00b4oL o v \u00b4 asz. On the ratio of optimal integral and fractional covers. Discrete Mathemat-\nics, 13(4):383\u2013390, 1975.\n[239] L\u00b4 aszl\u00b4oL o v \u00b4 asz and M. D. Plummer. Matching Theory , volume 121 of Annals of Discrete\nMathematics . North Holland, 1986.\n[240] Bruce M. Maggs and Serge A. Plotkin. Minimum-cost spanning tree as a path-\ufb01nding\nproblem. Information Processing Letters , 26(6):291\u2013293, 1988.\n[241] Michael Main. Data Structures and Other Objects Using Java . Addison-Wesley, 1999.\n[242] Udi Manber. Introduction to Algorithms: A Creative Approach . Addison-Wesley, 1989.\n[243] Conrado Mart\u00b4 \u0131nez and Salvador Roura. Randomized binary search trees. Journal of the\nACM , 45(2):288\u2013323, 1998.\n[244] William J. Masek and Michael S. Paterson. A faster algorithm computing string edit dis-\ntances. Journal of Computer and System Sciences , 20(1):18\u201331, 1980.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "1264": {"page_number": 1265, "page_information": "1244 Bibliography\n[245] H. A. Maurer, Th. Ottmann, and H.-W. Six. Implementing dictionaries using binary trees of\nvery small height. Information Processing Letters , 5(1):11\u201314, 1976.\n[246] Ernst W. Mayr, Hans J\u00a8 urgen Pr\u00a8 omel, and Angelika Steger, editors. Lectures on Proof Veri\ufb01-\ncation and Approximation Algorithms , volume 1367 of Lecture Notes in Computer Science .\nSpringer, 1998.\n[247] C. C. McGeoch. All pairs shortest paths and the essential subgraph. Algorithmica ,\n13(5):426\u2013441, 1995.\n[248] M. D. McIlroy. A killer adversary for quicksort. Software\u2014Practice and Experience ,\n29(4):341\u2013344, 1999.\n[249] Kurt Mehlhorn. Sorting and Searching , volume 1 of Data Structures and Algorithms .\nSpringer, 1984.\n[250] Kurt Mehlhorn. Graph Algorithms and NP-Completeness , volume 2 of Data Structures and\nAlgorithms . Springer, 1984.\n[251] Kurt Mehlhorn. Multidimensional Searching and Computational Geometry , volume 3 of\nData Structures and Algorithms . Springer, 1984.\n[252] Kurt Mehlhorn and Stefan N\u00a8 aher. Bounded ordered dictionaries in O.log log N/time and\nO.n/ space. Information Processing Letters , 35(4):183\u2013189, 1990.\n[253] Kurt Mehlhorn and Stefan N\u00a8 aher. LEDA: A Platform for Combinatorial and Geometric\nComputing . Cambridge University Press, 1999.\n[254] Alfred J. Menezes, Paul C. van Oorschot, and Scott A. Vanstone. Handbook of Applied\nCryptography . CRC Press, 1997.\n[255] Gary L. Miller. Riemann\u2019s hypothesis and tests for primality. Journal of Computer and\nSystem Sciences , 13(3):300\u2013317, 1976.\n[256] John C. Mitchell. Foundations for Programming Languages . The MIT Press, 1996.\n[257] Joseph S. B. Mitchell. Guillotine subdivisions approximate polygonal subdivisions: A sim-\nple polynomial-time approximation scheme for geometric TSP, k-MST, and related prob-\nlems. SIAM Journal on Computing , 28(4):1298\u20131309, 1999.\n[258] Louis Monier. Algorithmes de Factorisation D\u2019Entiers . PhD thesis, L\u2019Universit\u00b4 e Paris-Sud,\n1980.\n[259] Louis Monier. Evaluation and comparison of two ef\ufb01cient probabilistic primality testing\nalgorithms. Theoretical Computer Science , 12(1):97\u2013108, 1980.\n[260] Edward F. Moore. The shortest path through a maze. In Proceedings of the International\nSymposium on the Theory of Switching , pages 285\u2013292. Harvard University Press, 1959.\n[261] Rajeev Motwani, Joseph (Sef\ufb01) Naor, and Prabakhar Raghavan. Randomized approxima-\ntion algorithms in combinatorial optimization. In Dorit Hochbaum, editor, Approximation\nAlgorithms for NP-Hard Problems , chapter 11, pages 447\u2013481. PWS Publishing Company,\n1997.\n[262] Rajeev Motwani and Prabhakar Raghavan. Randomized Algorithms . Cambridge University\nPress, 1995.\n[263] J. I. Munro and V . Raman. Fast stable in-place sorting with O.n/ data moves. Algorithmica ,\n16(2):151\u2013160, 1996.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "1265": {"page_number": 1266, "page_information": "Bibliography 1245\n[264] J. Nievergelt and E. M. Reingold. Binary search trees of bounded balance. SIAM Journal\non Computing , 2(1):33\u201343, 1973.\n[265] Ivan Niven and Herbert S. Zuckerman. An Introduction to the Theory of Numbers . John\nWiley & Sons, fourth edition, 1980.\n[266] Alan V . Oppenheim and Ronald W. Schafer, with John R. Buck. Discrete-Time Signal\nProcessing . Prentice Hall, second edition, 1998.\n[267] Alan V . Oppenheim and Alan S. Willsky, with S. Hamid Nawab. Signals and Systems .\nPrentice Hall, second edition, 1997.\n[268] James B. Orlin. A polynomial time primal network simplex algorithm for minimum cost\n\ufb02ows. Mathematical Programming , 78(1):109\u2013129, 1997.\n[269] Joseph O\u2019Rourke. Computational Geometry in C . Cambridge University Press, second\nedition, 1998.\n[270] Christos H. Papadimitriou. Computational Complexity . Addison-Wesley, 1994.\n[271] Christos H. Papadimitriou and Kenneth Steiglitz. Combinatorial Optimization: Algorithms\nand Complexity . Prentice Hall, 1982.\n[272] Michael S. Paterson. Progress in selection. In Proceedings of the Fifth Scandinavian Work-\nshop on Algorithm Theory , pages 368\u2013379, 1996.\n[273] Mihai P\u02c7 atras\u00b8cu and Mikkel Thorup. Time-space trade-offs for predecessor search. In Pro-\nceedings of the 38th Annual ACM Symposium on Theory of Computing , pages 232\u2013240,\n2006.\n[274] Mihai P\u02c7 atras\u00b8cu and Mikkel Thorup. Randomization does not help searching predecessors.\nInProceedings of the 18th ACM-SIAM Symposium on Discrete Algorithms , pages 555\u2013564,\n2007.\n[275] Pavel A. Pevzner. Computational Molecular Biology: An Algorithmic Approach .T h e M I T\nPress, 2000.\n[276] Steven Phillips and Jeffery Westbrook. Online load balancing and network \ufb02ow. In Pro-\nceedings of the 25th Annual ACM Symposium on Theory of Computing , pages 402\u2013411,\n1993.\n[277] J. M. Pollard. A Monte Carlo method for factorization. BIT, 15(3):331\u2013334, 1975.\n[278] J. M. Pollard. Factoring with cubic integers. In A. K. Lenstra and H. W. Lenstra, Jr., editors,\nThe Development of the Number Field Sieve , volume 1554 of Lecture Notes in Mathematics ,\npages 4\u201310. Springer, 1993.\n[279] Carl Pomerance. On the distribution of pseudoprimes. Mathematics of Computation ,\n37(156):587\u2013593, 1981.\n[280] Carl Pomerance, editor. Proceedings of the AMS Symposia in Applied Mathematics: Com-\nputational Number Theory and Cryptography . American Mathematical Society, 1990.\n[281] William K. Pratt. Digital Image Processing . John Wiley & Sons, fourth edition, 2007.\n[282] Franco P. Preparata and Michael Ian Shamos. Computational Geometry: An Introduction .\nSpringer, 1985.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "1266": {"page_number": 1267, "page_information": "1246 Bibliography\n[283] William H. Press, Saul A. Teukolsky, William T. Vetterling, and Brian P. Flannery. Numer-\nical Recipes in C++: The Art of Scienti\ufb01c Computing . Cambridge University Press, second\nedition, 2002.\n[284] William H. Press, Saul A. Teukolsky, William T. Vetterling, and Brian P. Flannery. Numer-\nical Recipes: The Art of Scienti\ufb01c Computing . Cambridge University Press, third edition,\n2007.\n[285] R. C. Prim. Shortest connection networks and some generalizations. Bell System Technical\nJournal , 36(6):1389\u20131401, 1957.\n[286] William Pugh. Skip lists: A probabilistic alternative to balanced trees. Communications of\nthe ACM , 33(6):668\u2013676, 1990.\n[287] Paul W. Purdom, Jr. and Cynthia A. Brown. The Analysis of Algorithms . Holt, Rinehart,\nand Winston, 1985.\n[288] Michael O. Rabin. Probabilistic algorithms. In J. F. Traub, editor, Algorithms and Com-\nplexity: New Directions and Recent Results , pages 21\u201339. Academic Press, 1976.\n[289] Michael O. Rabin. Probabilistic algorithm for testing primality. Journal of Number Theory ,\n12(1):128\u2013138, 1980.\n[290] P. Raghavan and C. D. Thompson. Randomized rounding: A technique for provably good\nalgorithms and algorithmic proofs. Combinatorica , 7(4):365\u2013374, 1987.\n[291] Rajeev Raman. Recent results on the single-source shortest paths problem. SIGACT News ,\n28(2):81\u201387, 1997.\n[292] James Reinders. Intel Threading Building Blocks: Out\ufb01tting C++ for Multi-core Processor\nParallelism . O\u2019Reilly Media, Inc., 2007.\n[293] Edward M. Reingold, J\u00a8 urg Nievergelt, and Narsingh Deo. Combinatorial Algorithms: The-\nory and Practice . Prentice Hall, 1977.\n[294] Edward M. Reingold, Kenneth J. Urban, and David Gries. K-M-P string matching revisited.\nInformation Processing Letters , 64(5):217\u2013223, 1997.\n[295] Hans Riesel. Prime Numbers and Computer Methods for Factorization , volume 126 of\nProgress in Mathematics .B i r k h \u00a8 auser, second edition, 1994.\n[296] Ronald L. Rivest, Adi Shamir, and Leonard M. Adleman. A method for obtaining digital\nsignatures and public-key cryptosystems. Communications of the ACM , 21(2):120\u2013126,\n1978. See also U.S. Patent 4,405,829.\n[297] Herbert Robbins. A remark on Stirling\u2019s formula. American Mathematical Monthly ,\n62(1):26\u201329, 1955.\n[298] D. J. Rosenkrantz, R. E. Stearns, and P. M. Lewis. An analysis of several heuristics for the\ntraveling salesman problem. SIAM Journal on Computing , 6(3):563\u2013581, 1977.\n[299] Salvador Roura. An improved master theorem for divide-and-conquer recurrences. In\nProceedings of Automata, Languages and Programming, 24th International Colloquium,\nICALP\u201997 , volume 1256 of Lecture Notes in Computer Science , pages 449\u2013459. Springer,\n1997.\n[300] Y . A. Rozanov. Probability Theory: A Concise Course . Dover, 1969.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "1267": {"page_number": 1268, "page_information": "Bibliography 1247\n[301] S. Sahni and T. Gonzalez. P-complete approximation problems. Journal of the ACM ,\n23(3):555\u2013565, 1976.\n[302] A. Sch\u00a8 onhage, M. Paterson, and N. Pippenger. Finding the median. Journal of Computer\nand System Sciences , 13(2):184\u2013199, 1976.\n[303] Alexander Schrijver. Theory of Linear and Integer Programming . John Wiley & Sons,\n1986.\n[304] Alexander Schrijver. Paths and \ufb02ows\u2014A historical survey. CWI Quarterly , 6(3):169\u2013183,\n1993.\n[305] Robert Sedgewick. Implementing quicksort programs. Communications of the ACM ,\n21(10):847\u2013857, 1978.\n[306] Robert Sedgewick. Algorithms . Addison-Wesley , second edition, 1988.\n[307] Robert Sedgewick and Philippe Flajolet. An Introduction to the Analysis of Algorithms .\nAddison-Wesley, 1996.\n[308] Raimund Seidel. On the all-pairs-shortest-path problem in unweighted undirected graphs.\nJournal of Computer and System Sciences , 51(3):400\u2013403, 1995.\n[309] Raimund Seidel and C. R. Aragon. Randomized search trees. Algorithmica , 16(4\u20135):464\u2013\n497, 1996.\n[310] Jo\u02dc ao Setubal and Jo\u02dc ao Meidanis. Introduction to Computational Molecular Biology .P W S\nPublishing Company, 1997.\n[311] Clifford A. Shaffer. A Practical Introduction to Data Structures and Algorithm Analysis .\nPrentice Hall, second edition, 2001.\n[312] Jeffrey Shallit. Origins of the analysis of the Euclidean algorithm. Historia Mathematica ,\n21(4):401\u2013419, 1994.\n[313] Michael I. Shamos and Dan Hoey. Geometric intersection problems. In Proceedings of the\n17th Annual Symposium on Foundations of Computer Science , pages 208\u2013215, 1976.\n[314] M. Sharir. A strong-connectivity algorithm and its applications in data \ufb02ow analysis. Com-\nputers and Mathematics with Applications , 7(1):67\u201372, 1981.\n[315] David B. Shmoys. Computing near-optimal solutions to combinatorial optimization prob-\nlems. In William Cook, L\u00b4 aszl\u00b4oL o v \u00b4 asz, and Paul Seymour, editors, Combinatorial Opti-\nmization , volume 20 of DIMACS Series in Discrete Mathematics and Theoretical Computer\nScience . American Mathematical Society, 1995.\n[316] Avi Shoshan and Uri Zwick. All pairs shortest paths in undirected graphs with integer\nweights. In Proceedings of the 40th Annual Symposium on Foundations of Computer Sci-\nence, pages 605\u2013614, 1999.\n[317] Michael Sipser. Introduction to the Theory of Computation . Thomson Course Technology,\nsecond edition, 2006.\n[318] Steven S. Skiena. The Algorithm Design Manual . Springer, second edition, 1998.\n[319] Daniel D. Sleator and Robert E. Tarjan. A data structure for dynamic trees. Journal of\nComputer and System Sciences , 26(3):362\u2013391, 1983.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "1268": {"page_number": 1269, "page_information": "1248 Bibliography\n[320] Daniel D. Sleator and Robert E. Tarjan. Self-adjusting binary search trees. Journal of the\nACM , 32(3):652\u2013686, 1985.\n[321] Joel Spencer. Ten Lectures on the Probabilistic Method , volume 64 of CBMS-NSF Regional\nConference Series in Applied Mathematics . Society for Industrial and Applied Mathematics,\n1993.\n[322] Daniel A. Spielman and Shang-Hua Teng. Smoothed analysis of algorithms: Why the sim-\nplex algorithm usually takes polynomial time. Journal of the ACM , 51(3):385\u2013463, 2004.\n[323] Gilbert Strang. Introduction to Applied Mathematics . Wellesley-Cambridge Press, 1986.\n[324] Gilbert Strang. Linear Algebra and Its Applications . Thomson Brooks/Cole, fourth edition,\n2006.\n[325] V olker Strassen. Gaussian elimination is not optimal. Numerische Mathematik , 14(3):354\u2013\n356, 1969.\n[326] T. G. Szymanski. A special case of the maximal common subsequence problem. Technical\nReport TR-170, Computer Science Laboratory, Princeton University, 1975.\n[327] Robert E. Tarjan. Depth \ufb01rs t search and linear graph algorithms. SIAM Journal on Com-\nputing , 1(2):146\u2013160, 1972.\n[328] Robert E. Tarjan. Ef\ufb01ciency of a good but not linear set union algorithm. Journal of the\nACM , 22(2):215\u2013225, 1975.\n[329] Robert E. Tarjan. A class of algorithms which require nonlinear time to maintain disjoint\nsets. Journal of Computer and System Sciences , 18(2):110\u2013127, 1979.\n[330] Robert E. Tarjan. Data Structures and Network Algorithms . Society for Industrial and\nApplied Mathematics, 1983.\n[331] Robert E. Tarjan. Amortized computational complexity. SIAM Journal on Algebraic and\nDiscrete Methods , 6(2):306\u2013318, 1985.\n[332] Robert E. Tarjan. Class notes: Disjoint set union. COS 423, Princeton University, 1999.[333] Robert E. Tarjan and Jan van Leeuwen. W orst-case analysis of set union algorithms. Jour-\nnal of the ACM , 31(2):245\u2013281, 1984.\n[334] George B. Thomas, Jr., Maurice D. Weir, Joel Hass, and Frank R. Giordano. Thomas\u2019\nCalculus . Addison-Wesley, eleventh edition, 2005.\n[335] Mikkel Thorup. Faster deterministic sorting and priority queues in linear space. In Pro-\nceedings of the 9th ACM-SIAM Symposium on Discrete Algorithms , pages 550\u2013555, 1998.\n[336] Mikkel Thorup. Undirected single-source shortest paths with positive integer weights in\nlinear time. Journal of the ACM , 46(3):362\u2013394, 1999.\n[337] Mikkel Thorup. On RAM priority queues. SIAM Journal on Computing , 30(1):86\u2013109,\n2000.\n[338] Richard Tolimieri, Myoung An, and Chao Lu. Mathematics of Multidimensional Fourier\nTransform Algorithms . Springer, second edition, 1997.\n[339] P. van Emde Boas. Preserving order in a forest in less than logarithmic time. In Proceedings\nof the 16th Annual Symposium on Foundations of Computer Science , pages 75\u201384, 1975.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "1269": {"page_number": 1270, "page_information": "Bibliography 1249\n[340] P. van Emde Boas. Preserving order in a for est in less than logarithmic time and linear\nspace. Information Processing Letters , 6(3):80\u201382, 1977.\n[341] P. van Emde Boas, R. Kaas, and E. Zijlstra. Design and implementation of an ef\ufb01cient\npriority queue. Mathematical Systems Theory , 10(1):99\u2013127, 1976.\n[342] Jan van Leeuwen, editor. Handbook of Theoretical Computer Science, Volume A: Algo-\nrithms and Complexity . Elsevier Science Publishers and the MIT Press, 1990.\n[343] Charles Van Loan. Computational Frameworks for the Fast Fourier Transform . Society for\nIndustrial and Applied Mathematics, 1992.\n[344] Robert J. Vanderbei. Linear Programming: Foundations and Extensions . Kluwer Academic\nPublishers, 1996.\n[345] Vijay V . Vazirani. Approximation Algorithms . Springer, 2001.\n[346] Rakesh M. Verma. General techniques for analyzing recursive algorithms with applications.\nSIAM Journal on Computing , 26(2):568\u2013581, 1997.\n[347] Hao Wang and Bill Lin. Pipelined van Emde Boas tree: Algorithms, analysis, and ap-\nplications. In 26th IEEE International Conference on Computer Communications , pages\n2471\u20132475, 2007.\n[348] Antony F. Ware. Fast approximate Fourier transforms for irregularly spaced data. SIAM\nReview , 40(4):838\u2013856, 1998.\n[349] Stephen Warshall. A theorem on boolean matrices. Journal of the ACM , 9(1):11\u201312, 1962.\n[350] Michael S. Waterman. Introduction to Computational Biology, Maps, Sequences and\nGenomes . Chapman & Hall, 1995.\n[351] Mark Allen Weiss. Data Structures and Problem Solving Using C++ . Addison-Wesley,\nsecond edition, 2000.\n[352] Mark Allen Weiss. Data Structures and Problem Solving Using Java . Addison-Wesley,\nthird edition, 2006.\n[353] Mark Allen Weiss. Data Structures and Algorithm Analysis in C++ . Addison-Wesley, third\nedition, 2007.\n[354] Mark Allen Weiss. Data Structures and Algorithm Analysis in Java . Addison-Wesley,\nsecond edition, 2007.\n[355] Hassler Whitney. On the abstract properties of linear dependence. American Journal of\nMathematics , 57(3):509\u2013533, 1935.\n[356] Herbert S. Wilf. Algorithms and Complexity . A K Peters, second edition, 2002.\n[357] J. W. J. Williams. Algorithm 232 (HEAPSORT). Communications of the ACM , 7(6):347\u2013\n348, 1964.\n[358] Shmuel Winograd. On the algebraic complexity of functions. In Actes du Congr` es Interna-\ntional des Math\u00b4 ematiciens , volume 3, pages 283\u2013288, 1970.\n[359] Andrew C.-C. Yao. A lower bound to \ufb01nding convex hulls. Journal of the ACM , 28(4):780\u2013\n787, 1981.\n[360] Chee Yap. A real elementary approach to the m aster recurrence and generalizations. Un-\npublished manuscript. Available at http://cs.nyu.edu/yap/papers/, July 2008.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "1270": {"page_number": 1271, "page_information": "1250 Bibliography\n[361] Yinyu Ye. Interior Point Algorithms: Theory and Analysis . John Wiley & Sons, 1997.\n[362] Daniel Zwillinger, editor. CRC Standard Mathematical Tables and Formulae . Chapman &\nHall/CRC Press, 31st edition, 2003.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "1271": {"page_number": 1272, "page_information": "Index\nThis index uses the following conventions. Numbers are alphabetized as if spelled\nout; for example, \u201c2-3-4 tree\u201d is indexed as if it were \u201ctwo-three-four tree.\u201d Whenan entry refers to a place other than the main text, the page number is followed bya tag: ex. for exercise, pr. for problem, \ufb01g. for \ufb01gure, and n. for footnote. A taggedpage number often indicates the \ufb01rst page of an exercise or problem, which is notnecessarily the page on which the reference actually appears.\n\u02db.n/ , 574\n/RS(golden ratio), 59, 108 pr.\ny/RS(conjugate of the golden ratio), 59\n/RS.n/ (Euler\u2019s phi function), 943\n/SUB.n/-approximation algorithm, 1106, 1123\no-notation, 50\u201351, 64\nO-notation, 45 \ufb01g., 47\u201348, 64\nO0-notation, 62 pr.\neO-notation, 62 pr.\n!-notation, 51\n/DEL-notation, 45 \ufb01g., 48\u201349, 64\n1/DEL-notation, 62 pr.\ne/DEL-notation, 62 pr.\n\u201a-notation, 44\u201347, 45 \ufb01g., 64\ne\u201a-notation, 62 pr.\nfg(set), 1158\n2(set member), 1158\n62(not a set member), 1158\n;\n(empty language), 1058\n(empty set), 1158\n/DC2(subset), 1159\n/SUB(proper subset), 1159\nW(such that), 1159\n\\(set intersection), 1159\n[(set union), 1159/NUL(set difference), 1159\njj\n(\ufb02ow value), 710\n(length of a string), 986\n(set cardinality), 1161\n/STX\n(Cartesian product), 1162\n(cross product), 1016\nhi\n(sequence), 1166\n(standard encoding), 1057/NULn\nk/SOH\n(choose), 1185\nkk(euclidean norm), 1222\n\u0160(factorial), 57\nde(ceiling), 54\nbc(\ufb02oor), 54\n#p\n(lower square root), 546\n\"p\n(upper square root), 546P(sum), 1145Q(product), 1148\n!(adjacency relation), 1169\n;(reachability relation), 1170\n^(AND), 697, 1071\n:(NOT), 1071\n_(OR), 697, 1071\n\u02da(group operator), 939\n\u02dd(convolution operator), 901", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "1272": {"page_number": 1273, "page_information": "1252 Index\n/ETX(closure operator), 1058\nj(divides relation), 927\n\u2212(does-not-divide relation), 927\n/DC1(equivalent modulo n), 54, 1165 ex.\n6/DC1(not equivalent modulo n), 54\n\u0152a/c141n(equivalence class modulo n), 928\nCn(addition modulo n), 940\n/SOHn(multiplication modulo n), 940\n.a\np/(Legendre symbol), 982 pr.\n\"(empty string), 986, 1058\n<(pre\ufb01x relation), 986\n=(suf\ufb01x relation), 986\n<x(above relation), 1022\n//(comment symbol), 21\n/GS(much-greater-than relation), 574\n/FS(much-less-than relation), 783\n/DC4P(polynomial-time reducibility relation),\n1067, 1077 ex.\nAA-tree, 338\nabelian group, 940\nABOVE , 1024\nabove relation ( <x), 1022\nabsent child, 1178\nabsolutely convergent series, 1146\nabsorption laws for sets, 1160\nabstract problem, 1054\nacceptable pair of integers, 972\nacceptance\nby an algorithm, 1058\nby a \ufb01nite automaton, 996\naccepting state, 995\naccounting method, 456\u2013459\nfor binary counters, 458\nfor dynamic tables, 465\u2013466for stack operations, 457\u2013458, 458 ex.\nAckermann\u2019s function, 585\nactivity-selection problem, 415\u2013422, 450\nacyclic graph, 1170\nrelation to matroids, 448 pr.\nadd instruction, 23\naddition\nof binary integers, 22 ex.\nof matrices, 1220\nmodulo n(C\nn), 940\nof polynomials, 898\nadditive group modulo n, 940\naddressing, open, seeopen-address hash tableADD-SUBARRAY , 805 pr.\nadjacency-list representation, 590\nreplaced by a hash table, 593 ex.\nadjacency-matrix representation, 591\nadjacency relation ( !), 1169\nadjacent vertices, 1169\nadmissible edge, 749admissible network, 749\u2013750\nadversary, 190\naggregate analysis, 452\u2013456\nfor binary counters, 454\u2013455\nfor breadth-\ufb01rst search, 597\nfor depth-\ufb01rst search, 606\nfor Dijkstra\u2019s algorithm, 661\nfor disjoint-set data structures, 566\u2013567,\n568 ex.\nfor dynamic tables, 465\nfor Fibonacci heaps, 518, 522 ex.\nfor Graham\u2019s scan, 1036for the Knuth-Morris-Pratt algorithm, 1006\nfor Prim\u2019s algorithm, 636\nfor rod-cutting, 367for shortest paths in a dag, 655for stack operations, 452\u2013454\naggregate \ufb02ow, 863\nAkra-Bazzi method for solving a recurrence,\n112\u2013113\nalgorithm, 5\ncorrectness of, 6\norigin of word, 42\nrunning time of, 25\nas a technology, 13\nAlice, 959\nA\nLLOCA TE -NODE, 492\nALLOCA TE -OBJECT , 244\nallocation of objects, 243\u2013244\nall-pairs shortest paths, 644, 684\u2013707\nin dynamic graphs, 707in/SI-dense graphs, 706 pr.\nFloyd-Warshall algorithm for, 693\u2013697, 706\nJohnson\u2019s algorithm for, 700\u2013706\nby matrix multiplication, 686\u2013693, 706\u2013707\nby repeated squaring, 689\u2013691\nalphabet, 995, 1057\u02db.n/ , 574\namortized analysis, 451\u2013478\naccounting method of, 456\u2013459aggregate analysis, 367, 452\u2013456", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "1273": {"page_number": 1274, "page_information": "Index 1253\nfor bit-reversal permutation, 472 pr.\nfor breadth-\ufb01rst search, 597\nfor depth-\ufb01rst search, 606\nfor Dijkstra\u2019s algorithm, 661for disjoint-set data structures, 566\u2013567,\n568 ex., 572 ex., 575\u2013581, 581\u2013582 ex.\nfor dynamic tables, 463\u2013471for Fibonacci heaps, 509\u2013512, 517\u2013518,\n520\u2013522, 522 ex.\nfor the generic push-relabel algorithm, 746\nfor Graham\u2019s scan, 1036\nfor the Knuth-Morris-Pratt algorithm, 1006\nfor making binary search dynamic, 473 pr.potential method of, 459\u2013463\nfor restructuring red-black trees, 474 pr.\nfor self-organizing lists with move-to-front,\n476 pr.\nfor shortest paths in a dag, 655\nfor stacks on secondary storage, 502 pr.for weight-balanced trees, 473 pr.\namortized cost\nin the accounting method, 456in aggregate analysis, 452in the potential method, 459\nancestor, 1176\nleast common, 584 pr.\nAND function (^), 697, 1071\nAND gate, 1070\nand, in pseudocode, 22\nantiparallel edges, 711\u2013712\nantisymmetric relation, 1164\nA\nNY-SEGMENTS -INTERSECT , 1025\napproximation\nby least squares, 835\u2013839\nof summation by integrals, 1154\u20131156\napproximation algorithm, 10, 1105\u20131140\nfor bin packing, 1134 pr.\nfor MAX-CNF satis\ufb01ability, 1127 ex.\nfor maximum clique, 1111 ex., 1134 pr.\nfor maximum matching, 1135 pr.\nfor maximum spanning tree, 1137 pr.for maximum-weight cut, 1127 ex.\nfor MAX-3-CNF satis\ufb01ability, 1123\u20131124,\n1139\nfor minimum-weight vertex cover,\n1124\u20131127, 1139\nfor parallel machine scheduling, 1136 pr.\nrandomized, 1123for set cover, 1117\u20131122, 1139\nfor subset sum, 1128\u20131134, 1139\nfor traveling-salesman problem, 1111\u20131117,\n1139\nfor vertex cover, 1108\u20131111, 1139\nfor weighted set cover, 1135 pr.\nfor 0-1 knapsack problem, 1137 pr., 1139\napproximation error, 836\napproximation ratio, 1106, 1123\napproximation scheme, 1107\nA\nPPROX -MIN-WEIGHT -VC, 1126\nAPPROX -SUBSET -SUM, 1131\nAPPROX -TSP-T OUR, 1112\nAPPROX -VERTEX -COVER , 1109\narbitrage, 679 pr.\narc,seeedge\nargument of a function, 1166\u20131167\narithmetic instructions, 23\narithmetic, modular, 54, 939\u2013946arithmetic series, 1146\narithmetic with in\ufb01nities, 650\narm, 485array, 21\nMonge, 110 pr.\npassing as a parameter, 21\narticulation point, 621 pr.\nassignment\nmultiple, 21\nsatisfying, 1072, 1079truth, 1072, 1079\nassociative laws for sets, 1160\nassociative operation, 939\nasymptotically larger, 52\nasymptotically nonnegative, 45\nasymptotically positive, 45\nasymptotically smaller, 52\nasymptotically tight bound, 45\nasymptotic ef\ufb01ciency, 43asymptotic lower bound, 48\nasymptotic notation, 43\u201353, 62 pr.\nand graph algorithms, 588\nand linearity of summations, 1146\nasymptotic upper bound, 47\nattribute of an object, 21\naugmentation of a \ufb02ow, 716\naugmenting data structures, 339\u2013355\naugmenting path, 719\u2013720, 763 pr.authentication, 284 pr., 960\u2013961, 964", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "1274": {"page_number": 1275, "page_information": "1254 Index\nautomaton\n\ufb01nite, 995\nstring-matching, 996\u20131002\nauxiliary hash function, 272auxiliary linear program, 886\naverage-case running time, 28, 116\nAV L - I\nNSERT , 333 pr.\nA VL tree, 333 pr., 337\naxioms, for probability, 1190\nbabyface, 602 ex.\nback edge, 609, 613\nback substitution, 817\nBAD-SET-COVER -INSTANCE , 1122 ex.\nBALANCE , 333 pr.\nbalanced search tree\nAA-trees, 338\nA VL trees, 333 pr., 337\nB-trees, 484\u2013504k-neighbor trees, 338\nred-black trees, 308\u2013338\nscapegoat trees, 338\nsplay trees, 338, 482treaps, 333 pr., 338\n2-3-4 trees, 489, 503 pr.\n2-3 trees, 337, 504\nweight-balanced trees, 338, 473 pr.\nballs and bins, 133\u2013134, 1215 pr.\nbase- apseudoprime, 967\nbase case, 65, 84\nbase, in DNA, 391\nbasic feasible solution, 866basic solution, 866\nbasic variable, 855\nbasis function, 835\nBayes\u2019s theorem, 1194\nB\nELLMAN -FORD, 651\nBellman-Ford algorithm, 651\u2013655, 682\nfor all-pairs shortest paths, 684\nin Johnson\u2019s algorithm, 702\u2013704\nand objective functions, 670 ex.to solve systems of difference constraints,\n668\nYen\u2019s improvement to, 678 pr.\nB\nELOW , 1024\nBernoulli trial, 1201\nand balls and bins, 133\u2013134\nand streaks, 135\u2013139best-case running time, 29 ex., 49\nBFS, 595\nBIASED -RANDOM , 117 ex.\nbiconnected component, 621 pr.\nbig-oh notation, 45 \ufb01g., 47\u201348, 64\nbig-omega notation, 45 \ufb01g., 48\u201349, 64\nbijective function, 1167\nbinary character code, 428\nbinary counter\nanalyzed by accounting method, 458\nanalyzed by aggregate analysis, 454\u2013455\nanalyzed by potential method, 461\u2013462\nbit-reversed, 472 pr.\nbinary entropy function, 1187\nbinary gcd algorithm, 981 pr.\nbinary heap, seeheap\nbinary relation, 1163\nbinary search, 39 ex.\nwith fast insertion, 473 pr.in insertion sort, 39 ex.\nin multithreaded merging, 799\u2013800\nin searching B-trees, 499 ex.\nB\nINARY -SEARCH , 799\nbinary search tree, 286\u2013307\nAA-trees, 338\nA VL trees, 333 pr., 337deletion from, 295\u2013298, 299 ex.\nwith equal keys, 303 pr.\ninsertion into, 294\u2013295\nk-neighbor trees, 338\nmaximum key of, 291\nminimum key of, 291optimal, 397\u2013404, 413\npredecessor in, 291\u2013292\nquerying, 289\u2013294randomly built, 299\u2013303, 304 pr.\nright-converting of, 314 ex.\nscapegoat trees, 338\nsearching, 289\u2013291\nfor sorting, 299 ex.\nsplay trees, 338successor in, 291\u2013292\nand treaps, 333 pr.\nweight-balanced trees, 338see also red-black tree\nbinary-search-tree property, 287\nin treaps, 333 pr.\nvs. min-heap property, 289 ex.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "1275": {"page_number": 1276, "page_information": "Index 1255\nbinary tree, 1177\nfull, 1178\nnumber of different ones, 306 pr.\nrepresentation of, 246superimposed upon a bit vector, 533\u2013534\nsee also binary search tree\nbinomial coef\ufb01cient, 1186\u20131187binomial distribution, 1203\u20131206\nand balls and bins, 133\nmaximum value of, 1207 ex.\ntails of, 1208\u20131215\nbinomial expansion, 1186\nbinomial heap, 527 pr.binomial tree, 527 pr.\nbin packing, 1134 pr.\nbipartite graph, 1172\ncorresponding \ufb02ow network of, 732\nd-regular, 736 ex.\nand hypergraphs, 1173 ex.\nbipartite matching, 530, 732\u2013736, 747 ex., 766\nHopcroft-Karp algorithm for, 763 pr.\nbirthday paradox, 130\u2013133, 142 ex.bisection of a tree, 1181 pr.bitonic euclidean traveling-salesman problem,\n405 pr.\nbitonic sequence, 682 pr.bitonic tour, 405 pr.\nbit operation, 927\nin Euclid\u2019s algorithm, 981 pr.\nbit-reversal permutation, 472 pr., 918\nB\nIT-REVERSE -COPY, 918\nbit-reversed binary counter, 472 pr.\nBIT-REVERSED -INCREMENT , 472 pr.\nbit vector, 255 ex., 532\u2013536\nblack-height, 309\nblack vertex, 594, 603\nblocking \ufb02ow, 765\nblock structure in pseudocode, 20Bob, 959\nBoole\u2019s inequality, 1195 ex.\nboolean combinational circuit, 1071boolean combinational element, 1070\nboolean connective, 1079\nboolean formula, 1049, 1066 ex., 1079,\n1086 ex.\nboolean function, 1187 ex.\nboolean matrix multiplication, 832 ex.Bor\u02d9uvka\u2019s algorithm, 641bottleneck spanning tree, 640 pr.\nbottleneck traveling-salesman problem,\n1117 ex.\nbottom of a stack, 233\nB\nOTTOM -UP-CUT-ROD, 366\nbottom-up method, for dynamic programming,\n365\nbound\nasymptotically tight, 45\nasymptotic lower, 48asymptotic upper, 47\non binomial coef\ufb01cients, 1186\u20131187\non binomial distributions, 1206polylogarithmic, 57\non the tails of a binomial distribution,\n1208\u20131215\nsee also lower bounds\nboundary condition, in a recurrence, 67, 84\nboundary of a polygon, 1020 ex.bounding a summation, 1149\u20131156\nbox, nesting, 678 pr.\nB\nC-tree, 488\nbranching factor, in B-trees, 487branch instructions, 23\nbreadth-\ufb01rst search, 594\u2013602, 623\nin maximum \ufb02ow, 727\u2013730, 766and shortest paths, 597\u2013600, 644\nsimilarity to Dijkstra\u2019s algorithm, 662,\n663 ex.\nbreadth-\ufb01rst tree, 594, 600\nbridge, 621 pr.\nB\n/ETX-tree, 489 n.\nB-tree, 484\u2013504\ncompared with red-black trees, 484, 490\ncreating, 492deletion from, 499\u2013502\nfull node in, 489\nheight of, 489\u2013490\ninsertion into, 493\u2013497\nminimum degree of, 489\nminimum key of, 497 ex.properties of, 488\u2013491\nsearching, 491\u2013492\nsplitting a node in, 493\u20134952-3-4 trees, 489\nB-T\nREE-CREATE , 492\nB-T REE-DELETE , 499\nB-T REE-INSERT , 495", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "1276": {"page_number": 1277, "page_information": "1256 Index\nB-T REE-INSERT -NONFULL , 496\nB-T REE-SEARCH , 492, 499 ex.\nB-T REE-SPLIT-CHILD , 494\nBUBBLESORT ,4 0p r .\nbucket, 200\nbucket sort, 200\u2013204\nBUCKET -SORT, 201\nBUILD -MAX-HEAP, 157\nBUILD -MAX-HEAP0, 167 pr.\nBUILD -MIN-HEAP, 159\nbutter\ufb02y operation, 915\nby, in pseudocode, 21\ncache, 24, 449 pr.\ncache hit, 449 pr.\ncache miss, 449 pr.\ncache obliviousness, 504\ncaching, off-line, 449 pr.\ncall\nin a multithreaded computation, 776\nof a subroutine, 23, 25 n.\nby value, 21\ncall edge, 778cancellation lemma, 907\ncancellation of \ufb02ow, 717\ncanonical form for task scheduling, 444capacity\nof a cut, 721\nof an edge, 709residual, 716, 719\nof a vertex, 714 ex.\ncapacity constraint, 709\u2013710\ncardinality of a set ( jj), 1161\nCarmichael number, 968, 975 ex.\nCartesian product (/STX), 1162\nCartesian sum, 906 ex.\ncascading cut, 520\nC\nASCADING -CUT, 519\nCatalan numbers, 306 pr., 372\nceiling function (de), 54\nin master theorem, 103\u2013106\nceiling instruction, 23\ncertain event, 1190\ncerti\ufb01cate\nin a cryptosystem, 964\nfor veri\ufb01cation algorithms, 1063\nCHAINED -HASH-DELETE , 258\nCHAINED -HASH-INSERT , 258CHAINED -HASH-SEARCH , 258\nchaining, 257\u2013260, 283 pr.\nchain of a convex hull, 1038\nchanging a key, in a Fibonacci heap, 529 pr.changing variables, in the substitution method,\n86\u201387\ncharacter code, 428chess-playing program, 790\u2013791\nchild\nin a binary tree, 1178in a multithreaded computation, 776\nin a rooted tree, 1176\nchild list in a Fibonacci heap, 507\nChinese remainder theorem, 950\u2013954, 983\nchip multiprocessor, 772\nchirp transform, 914 ex.\nchoose/NUL\nn\nk/SOH\n, 1185\nchord, 345 ex.\nCilk, 774, 812\nCilk++, 774, 812\nciphertext, 960\ncircuit\nboolean combinational, 1071\ndepth of, 919\nfor fast Fourier transform, 919\u2013920\nCIRCUIT-SAT, 1072circuit satis\ufb01ability, 1070\u20131077\ncircular, doubly linked list with a sentinel, 239\ncircular linked list, 236\nsee also linked list\nclass\ncomplexity, 1059\nequivalence, 1164\nclassi\ufb01cation of edges\nin breadth-\ufb01rst search, 621 pr.in depth-\ufb01rst search, 609\u2013610, 611 ex.\nin a multithreaded dag, 778\u2013779\nclause, 1081\u20131082clean area, 208 pr.\nclique, 1086\u20131089, 1105\napproximation algorithm for, 1111 ex.,\n1134 pr.\nCLIQUE, 1087\nclosed interval, 348closed semiring, 707\nclosest pair, \ufb01nding, 1039\u20131044, 1047\nclosest-point heuristic, 1117 ex.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "1277": {"page_number": 1278, "page_information": "Index 1257\nclosure\ngroup property, 939\nof a language, 1058\noperator (/ETX), 1058\ntransitive, seetransitive closure\ncluster\nin a bit vector with a superimposed tree of\nconstant height, 534\nfor parallel computing, 772\nin proto van Emde Boas structures, 538\nin van Emde Boas trees, 546\nclustering, 272\nCNF (conjunctive normal form), 1049, 1082CNF satis\ufb01ability, 1127 ex.\ncoarsening leaves of recursion\nin merge sort, 39 pr.when recursively spawning, 787\ncode, 428\u2013429\nHuffman, 428\u2013437, 450\ncodeword, 429\ncodomain, 1166\ncoef\ufb01cient\nbinomial, 1186\nof a polynomial, 55, 898\nin slack form, 856\ncoef\ufb01cient representation, 900\nand fast multiplication, 903\u2013905\ncofactor, 1224\ncoin changing, 446 pr.colinearity, 1016\ncollision, 257\nresolution by chaining, 257\u2013260\nresolution by open addressing, 269\u2013277\ncollision-resistant hash function, 964\ncoloring, 1103 pr., 1180 pr.color, of a red-black-tree node, 308\ncolumn-major order, 208 pr.\ncolumn rank, 1223\ncolumnsort, 208 pr.\ncolumn vector, 1218\ncombination, 1185combinational circuit, 1071\ncombinational element, 1070\ncombine step, in divide-and-conquer, 30, 65\ncomment, in pseudocode ( //), 21\ncommodity, 862\ncommon divisor, 929\ngreatest, seegreatest common divisorcommon multiple, 939 ex.\ncommon subexpression, 915\ncommon subsequence, 7, 391\nlongest, 7, 390\u2013397, 413\ncommutative laws for sets, 1159\ncommutative operation, 940\nC\nOMPACTIFY -LIST, 245 ex.\ncompact list, 250 pr.\nCOMPACT -LIST-SEARCH , 250 pr.\nCOMPACT -LIST-SEARCH0, 251 pr.\ncomparable line segments, 1022\nCOMPARE -EXCHANGE , 208 pr.\ncompare-exchange operation, 208 pr.comparison sort, 191\nand binary search trees, 289 ex.\nrandomized, 205 pr.\nand selection, 222\ncompatible activities, 415\ncompatible matrices, 371, 1221\ncompetitive analysis, 476 pr.\ncomplement\nof an event, 1190\nof a graph, 1090\nof a language, 1058\nSchur, 820, 834\nof a set, 1160\ncomplementary slackness, 894 pr.\ncomplete graph, 1172\ncomplete k-ary tree, 1179\nsee also heap\ncompleteness of a language, 1077 ex.\ncomplete step, 782\ncompletion time, 447 pr., 1136 pr.\ncomplexity class, 1059\nco-NP, 1064NP, 1049, 1064\nNPC, 1050, 1069\nP, 1049, 1055\ncomplexity measure, 1059\ncomplex numbers\ninverting matrices of, 832 ex.multiplication of, 83 ex.\ncomplex root of unity, 906\ninterpolation at, 912\u2013913\ncomponent\nbiconnected, 621 pr.\nconnected, 1170strongly connected, 1170", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "1278": {"page_number": 1279, "page_information": "1258 Index\ncomponent graph, 617\ncomposite number, 928\nwitness to, 968\ncomposition, of multithreaded computations,\n784 \ufb01g.\ncomputational depth, 812\ncomputational geometry, 1014\u20131047\ncomputational problem, 5\u20136\ncomputation dag, 777\ncomputation, multithreaded, 777\nCOMPUTE -PREFIX -FUNCTION , 1006\nCOMPUTE -TRANSITION -FUNCTION , 1001\nconcatenation\nof languages, 1058\nof strings, 986\nconcrete problem, 1055concurrency keywords, 774, 776, 785\nconcurrency platform, 773\nconditional branch instruction, 23\nconditional independence, 1195 ex.\nconditional probability, 1192, 1194\ncon\ufb01guration, 1074conjugate of the golden ratio ( y/RS), 59\nconjugate transpose, 832 ex.\nconjunctive normal form, 1049, 1082\nconnected component, 1170\nidenti\ufb01ed using depth-\ufb01rst search, 612 ex.\nidenti\ufb01ed using disjoint-set data structures,\n562\u2013564\nC\nONNECTED -COMPONENTS , 563\nconnected graph, 1170\nconnective, 1079co-NP (complexity class), 1064\nconquer step, in divide-and-conquer, 30, 65\nconservation of \ufb02ow, 709\u2013710\nconsistency\nof literals, 1088\nsequential, 779, 812\nC\nONSOLIDATE , 516\nconsolidating a Fibonacci-heap root list,\n513\u2013517\nconstraint, 851\ndifference, 665\nequality, 670 ex., 852\u2013853inequality, 852\u2013853\nlinear, 846\nnonnegativity, 851, 853\ntight, 865violation of, 865\nconstraint graph, 666\u2013668\ncontain, in a path, 1170\ncontinuation edge, 778\ncontinuous uniform probability distribution,\n1192\ncontraction\nof a dynamic table, 467\u2013471\nof a matroid, 442\nof an undirected graph by an edge, 1172\ncontrol instructions, 23\nconvergence property, 650, 672\u2013673\nconvergent series, 1146converting binary to decimal, 933 ex.\nconvex combination of points, 1015\nconvex function, 1199convex hull, 8, 1029\u20131039, 1046 pr.\nconvex layers, 1044 pr.\nconvex polygon, 1020 ex.convex set, 714 ex.\nconvolution (\u02dd), 901\nconvolution theorem, 913\ncopy instruction, 23\ncorrectness of an algorithm, 6\ncorresponding \ufb02ow network for bipartite\nmatching, 732\ncountably in\ufb01nite set, 1161\ncounter, seebinary counter\ncounting, 1183\u20131189\nprobabilistic, 143 pr.\ncounting sort, 194\u2013197\nin radix sort, 198\nC\nOUNTING -SORT, 195\ncoupon collector\u2019s problem, 134\ncover\npath, 761 pr.\nby a subset, 1118\nvertex, 1089, 1108, 1124\u20131127, 1139\ncovertical, 1024\nCREATE -NEW-RS- VEB-T REE, 557 pr.\ncredit, 456critical edge, 729\ncritical path\nof a dag, 657of a multithreaded computation, 779\ncross a cut, 626\ncross edge, 609cross product (/STX), 1016", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "1279": {"page_number": 1280, "page_information": "Index 1259\ncryptosystem, 958\u2013965, 983\ncubic spline, 840 pr.\ncurrency exchange, 390 ex., 679 pr.\ncurve \ufb01tting, 835\u2013839cut\ncapacity of, 721\ncascading, 520of a \ufb02ow network, 720\u2013724\nminimum, 721, 731 ex.\nnet \ufb02ow across, 720\nof an undirected graph, 626\nweight of, 1127 ex.\nC\nUT, 519\nCUT-ROD, 363\ncutting, in a Fibonacci heap, 519\ncycle of a graph, 1170\nhamiltonian, 1049, 1061\nminimum mean-weight, 680 pr.\nnegative-weight, seenegative-weight cycle\nand shortest paths, 646\u2013647\ncyclic group, 955\ncyclic rotation, 1012 ex.cycling, of simplex algorithm, 875\ndag, seedirected acyclic graph\nD\nAG-SHORTEST -PATHS , 655\nd-ary heap, 167 pr.\nin shortest-paths algorithms, 706 pr.\ndata-movement instructions, 23data-parallel model, 811\ndata structure, 9, 229\u2013355, 481\u2013585\nAA-trees, 338\naugmentation of, 339\u2013355\nA VL trees, 333 pr., 337\nbinary search trees, 286\u2013307binomial heaps, 527 pr.\nbit vectors, 255 ex., 532\u2013536\nB-trees, 484\u2013504deques, 236 ex.\ndictionaries, 229\ndirect-address tables, 254\u2013255\nfor disjoint sets, 561\u2013585\nfor dynamic graphs, 483\ndynamic sets, 229\u2013231dynamic trees, 482\nexponential search trees, 212, 483\nFibonacci heaps, 505\u2013530fusion trees, 212, 483hash tables, 256\u2013261\nheaps, 151\u2013169\ninterval trees, 348\u2013354\nk-neighbor trees, 338\nlinked lists, 236\u2013241\nmergeable heap, 505\norder-statistic trees, 339\u2013345\npersistent, 331 pr., 482\npotential of, 459\npriority queues, 162\u2013166\nproto van Emde Boas structures, 538\u2013545\nqueues, 232, 234\u2013235\nradix trees, 304 pr.\nred-black trees, 308\u2013338\nrelaxed heaps, 530\nrooted trees, 246\u2013249scapegoat trees, 338\non secondary storage, 484\u2013487\nskip lists, 338\nsplay trees, 338, 482\nstacks, 232\u2013233\ntreaps, 333 pr., 3382-3-4 heaps, 529 pr.2-3-4 trees, 489, 503 pr.\n2-3 trees, 337, 504\nvan Emde Boas trees, 531\u2013560weight-balanced trees, 338\ndata type, 23\ndeadline, 444\ndeallocation of objects, 243\u2013244\ndecision by an algorithm, 1058\u20131059\ndecision problem, 1051, 1054\nand optimization problems, 1051\ndecision tree, 192\u2013193\nD\nECREASE -KEY, 162, 505\ndecreasing a key\nin Fibonacci heaps, 519\u2013522\nin 2-3-4 heaps, 529 pr.\nDECREMENT , 456 ex.\ndegeneracy, 874\ndegree\nof a binomial-tree root, 527 pr.\nmaximum, of a Fibonacci heap, 509,\n523\u2013526\nminimum, of a B-tree, 489\nof a node, 1177\nof a polynomial, 55, 898of a vertex, 1169", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "1280": {"page_number": 1281, "page_information": "1260 Index\ndegree-bound, 898\nDELETE , 230, 505\nDELETE -LARGER -HALF, 463 ex.\ndeletion\nfrom binary search trees, 295\u2013298, 299 ex.\nfrom a bit vector with a superimposed binary\ntree, 534\nfrom a bit vector with a superimposed tree of\nconstant height, 535\nfrom B-trees, 499\u2013502\nfrom chained hash tables, 258\nfrom direct-address tables, 254\nfrom dynamic tables, 467\u2013471from Fibonacci heaps, 522, 526 pr.\nfrom heaps, 166 ex.\nfrom interval trees, 349from linked lists, 238\nfrom open-address hash tables, 271\nfrom order-statistic trees, 343\u2013344from proto van Emde Boas structures, 544\nfrom queues, 234\nfrom red-black trees, 323\u2013330\nfrom stacks, 232\nfrom sweep-line statuses, 1024\nfrom 2-3-4 heaps, 529 pr.\nfrom van Emde Boas trees, 554\u2013556\nDeMorgan\u2019s laws\nfor propositional logic, 1083\nfor sets, 1160, 1162 ex.\ndense graph, 589\n/SI-dense, 706 pr.\ndensity\nof prime numbers, 965\u2013966\nof a rod, 370 ex.\ndependence\nand indicator random variables, 119\nlinear, 1223\nsee also independence\ndepth\naverage, of a node in a randomly built binary\nsearch tree, 304 pr.\nof a circuit, 919\nof a node in a rooted tree, 1177\nof quicksort recursion tree, 178 ex.of a stack, 188 pr.\ndepth-determination problem, 583 pr.\ndepth-\ufb01rst forest, 603depth-\ufb01rst search, 603\u2013612, 623in \ufb01nding articulation points, bridges, and\nbiconnected components, 621 pr.\nin \ufb01nding strongly connected components,\n615\u2013621, 623\nin topological sorting, 612\u2013615\ndepth-\ufb01rst tree, 603\ndeque, 236 ex.\nD\nEQUEUE , 235\nderivative of a series, 1147\ndescendant, 1176\ndestination vertex, 644\ndet,seedeterminant\ndeterminacy race, 788determinant, 1224\u20131225\nand matrix multiplication, 832 ex.\ndeterministic algorithm, 123\nmultithreaded, 787\nD\nETERMINISTIC -SEARCH , 143 pr.\nDFS, 604\nDFS-V ISIT, 604\nDFT (discrete Fourier transform), 9, 909\ndiagonal matrix, 1218\nLUP decomposition of, 827 ex.\ndiameter of a tree, 602 ex.\ndictionary, 229\ndifference constraints, 664\u2013670\ndifference equation, seerecurrence\ndifference of sets (/NUL), 1159\nsymmetric, 763 pr.\ndifferentiation of a series, 1147\ndigital signature, 960\ndigraph, seedirected graph\nDIJKSTRA , 658\nDijkstra\u2019s algorithm, 658\u2013664, 682\nfor all-pairs shortest paths, 684, 704\nimplemented with a Fibonacci heap, 662\nimplemented with a min-heap, 662\nwith integer edge weights, 664 ex.in Johnson\u2019s algorithm, 702\nsimilarity to breadth-\ufb01rst search, 662,\n663 ex.\nsimilarity to Prim\u2019s algorithm, 634, 662\nD\nIRECT -ADDRESS -DELETE , 254\ndirect addressing, 254\u2013255, 532\u2013536\nDIRECT -ADDRESS -INSERT , 254\nDIRECT -ADDRESS -SEARCH , 254\ndirect-address table, 254\u2013255directed acyclic graph (dag), 1172", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "1281": {"page_number": 1282, "page_information": "Index 1261\nand back edges, 613\nand component graphs, 617\nand hamiltonian paths, 1066 ex.\nlongest simple path in, 404 pr.for representing a multithreaded\ncomputation, 777\nsingle-source shortest-paths algorithm for,\n655\u2013658\ntopological sort of, 612\u2013615, 623\ndirected graph, 1168\nall-pairs shortest paths in, 684\u2013707\nconstraint graph, 666\nEuler tour of, 623 pr., 1048hamiltonian cycle of, 1049\nand longest paths, 1048\npath cover of, 761 pr.\nPERT chart, 657, 657 ex.\nsemiconnected, 621 ex.\nshortest path in, 643single-source shortest paths in, 643\u2013683\nsingly connected, 612 ex.\nsquare of, 593 ex.transitive closure of, 697transpose of, 592 ex.\nuniversal sink in, 593 ex.\nsee also directed acyclic graph, graph,\nnetwork\ndirected segment, 1015\u20131017\ndirected version of an undirected graph, 1172\nD\nIRECTION , 1018\ndirty area, 208 pr.\nDISCHARGE , 751\ndischarge of an over\ufb02owing vertex, 751\ndiscovered vertex, 594, 603\ndiscovery time, in depth-\ufb01rst search, 605\ndiscrete Fourier transform, 9, 909\ndiscrete logarithm, 955\ndiscrete logarithm theorem, 955\ndiscrete probability distribution, 1191\ndiscrete random variable, 1196\u20131201\ndisjoint-set data structure, 561\u2013585\nanalysis of, 575\u2013581, 581 ex.\nin connected components, 562\u2013564\nin depth determination, 583 pr.\ndisjoint-set-forest implementation of,\n568\u2013572\nin Kruskal\u2019s algorithm, 631\nlinear-time special case of, 585linked-list implementation of, 564\u2013568\nin off-line least common ancestors, 584 pr.\nin off-line minimum, 582 pr.\nin task scheduling, 448 pr.\ndisjoint-set forest, 568\u2013572\nanalysis of, 575\u2013581, 581 ex.\nrank properties of, 575, 581 ex.\nsee also disjoint-set data structure\ndisjoint sets, 1161\ndisjunctive normal form, 1083disk, 1028 ex.\ndisk drive, 485\u2013487\nsee also secondary storage\nD\nISK-READ, 487\nDISK-WRITE , 487\ndistance\nedit, 406 pr.\neuclidean, 1039\nLm, 1044 ex.\nManhattan, 225 pr., 1044 ex.\nof a shortest path, 597\ndistributed memory, 772distribution\nbinomial, 1203\u20131206\ncontinuous uniform, 1192\ndiscrete, 1191\ngeometric, 1202\u20131203\nof inputs, 116, 122\nof prime numbers, 965probability, 1190\nsparse-hulled, 1046 pr.\nuniform, 1191\ndistributive laws for sets, 1160\ndivergent series, 1146\ndivide-and-conquer method, 30\u201335, 65\nanalysis of, 34\u201335\nfor binary search, 39 ex.\nfor conversion of binary to decimal, 933 ex.for fast Fourier transform, 909\u2013912\nfor \ufb01nding the closest pair of points,\n1040\u20131043\nfor \ufb01nding the convex hull, 1030\nfor matrix inversion, 829\u2013831\nfor matrix multiplication, 76\u201383, 792\u2013797\nfor maximum-subarray problem, 68\u201375\nfor merge sort, 30\u201337, 797\u2013805\nfor multiplication, 920 pr.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "1282": {"page_number": 1283, "page_information": "1262 Index\nfor multithreaded matrix multiplication,\n792\u2013797\nfor multithreaded merge sort, 797\u2013805\nfor quicksort, 170\u2013190relation to dynamic programming, 359\nfor selection, 215\u2013224\nsolving recurrences for, 83\u2013106, 112\u2013113for Strassen\u2019s algorithm, 79\u201383\ndivide instruction, 23\ndivides relation (j), 927\ndivide step, in divide-and-conquer, 30, 65\ndivision method, 263, 268\u2013269 ex.\ndivision theorem, 928divisor, 927\u2013928\ncommon, 929\nsee also greatest common divisor\nDNA, 6\u20137, 390\u2013391, 406 pr.\nDNF (disjunctive normal form), 1083\ndoes-not-divide relation ( \u2212), 927\ndomain, 1166\ndominates relation, 1045 pr.\ndouble hashing, 272\u2013274, 277 ex.doubly linked list, 236\nsee also linked list\ndownto , in pseudocode, 21\nd-regular graph, 736 ex.\nduality, 879\u2013886, 895 pr.\nweak, 880\u2013881, 886 ex.\ndual linear program, 879\ndummy key, 397\ndynamic graph, 562 n.\nall-pairs shortest paths algorithms for, 707data structures for, 483\nminimum-spanning-tree algorithm for,\n637 ex.\ntransitive closure of, 705 pr., 707\ndynamic multithreaded algorithm, see\nmultithreaded algorithm\ndynamic multithreading, 773\ndynamic order statistics, 339\u2013345\ndynamic-programming method, 359\u2013413\nfor activity selection, 421 ex.\nfor all-pairs shortest paths, 686\u2013697\nfor bitonic euclidean traveling-salesman\nproblem, 405 pr.\nbottom-up, 365\nfor breaking a string, 410 pr.compared with greedy algorithms, 381,\n390 ex., 418, 423\u2013427\nfor edit distance, 406 pr.\nelements of, 378\u2013390for Floyd-Warshall algorithm, 693\u2013697\nfor inventory planning, 411 pr.\nfor longest common subsequence, 390\u2013397for longest palindrome subsequence, 405 pr.\nfor longest simple path in a weighted\ndirected acyclic graph, 404 pr.\nfor matrix-chain multiplication, 370\u2013378\nand memoization, 387\u2013389\nfor optimal binary search trees, 397\u2013404optimal substructure in, 379\u2013384\noverlapping subproblems in, 384\u2013386\nfor printing neatly, 405 pr.reconstructing an optimal solution in, 387\nrelation to divide-and-conquer, 359\nfor rod-cutting, 360\u2013370for seam carving, 409 pr.\nfor signing free agents, 411 pr.\ntop-down with memoization, 365\nfor transitive closure, 697\u2013699\nfor Viterbi algorithm, 408 pr.\nfor 0-1 knapsack problem, 427 ex.\ndynamic set, 229\u2013231\nsee also data structure\ndynamic table, 463\u2013471\nanalyzed by accounting method, 465\u2013466analyzed by aggregate analysis, 465\nanalyzed by potential method, 466\u2013471\nload factor of, 463\ndynamic tree, 482\ne,5 5\nE\u0152/c141(expected value), 1197\nearly-\ufb01rst form, 444\nearly task, 444edge, 1168\nadmissible, 749\nantiparallel, 711\u2013712\nattributes of, 592\nback, 609\nbridge, 621 pr.call, 778\ncapacity of, 709\nclassi\ufb01cation in breadth-\ufb01rst search, 621 pr.classi\ufb01cation in depth-\ufb01rst search, 609\u2013610", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "1283": {"page_number": 1284, "page_information": "Index 1263\ncontinuation, 778\ncritical, 729\ncross, 609\nforward, 609inadmissible, 749\nlight, 626\nnegative-weight, 645\u2013646residual, 716\nreturn, 779\nsafe, 626\nsaturated, 739\nspawn, 778\ntree, 601, 603, 609weight of, 591\nedge connectivity, 731 ex.\nedge set, 1168\nedit distance, 406 pr.\nEdmonds-Karp algorithm, 727\u2013730\nelementary event, 1189elementary insertion, 465\nelement of a set (2), 1158\nellipsoid algorithm, 850, 897elliptic-curve factorization method, 984elseif , in pseudocode, 20 n.\nelse, in pseudocode, 20\nempty language (;), 1058\nempty set (;), 1158\nempty set laws, 1159\nempty stack, 233\ne m p t ys t r i n g( \"), 986, 1058\nempty tree, 1178\nencoding of problem instances, 1055\u20131057endpoint\nof an interval, 348\nof a line segment, 1015\nE\nNQUEUE , 235\nentering a vertex, 1169\nentering variable, 867\nentropy function, 1187\n/SI-dense graph, 706 pr.\n/SI-universal hash function, 269 ex.\nequality\nof functions, 1166\nlinear, 845of sets, 1158\nequality constraint, 670 ex., 852\nand inequality constraints, 853\ntight, 865violation of, 865\nequation\nand asymptotic notation, 49\u201350\nnormal, 837recurrence, seerecurrence\nequivalence class, 1164\nmodulo n(\u0152a/c141\nn), 928\nequivalence, modular ( /DC1), 54, 1165 ex.\nequivalence relation, 1164\nand modular equivalence, 1165 ex.\nequivalent linear programs, 852\nerror , in pseudocode, 22\nescape problem, 760 pr.\nEUCLID , 935\nEuclid\u2019s algorithm, 933\u2013939, 981 pr., 983\neuclidean distance, 1039\neuclidean norm (kk), 1222\nEuler\u2019s constant, 943\nEuler\u2019s phi function, 943\nEuler\u2019s theorem, 954, 975 ex.\nEuler tour, 623 pr., 1048\nand hamiltonian cycles, 1048\nevaluation of a polynomial, 41 pr., 900, 905 ex.\nderivatives of, 922 pr.\nat multiple points, 923 pr.\nevent, 1190event point, 1023\nevent-point schedule, 1023\nE\nXACT -SUBSET -SUM, 1129\nexcess \ufb02ow, 736\nexchange property, 437\nexclusion and inclusion, 1163 ex.execute a subroutine, 25 n.\nexpansion of a dynamic table, 464\u2013467\nexpectation, seeexpected value\nexpected running time, 28, 117\nexpected value, 1197\u20131199\nof a binomial distribution, 1204of a geometric distribution, 1202\nof an indicator random variable, 118\nexplored vertex, 605exponential function, 55\u201356\nexponential height, 300\nexponential search tree, 212, 483\nexponential series, 1147\nexponentiation instruction, 24\nexponentiation, modular, 956\nE\nXTENDED -BOTTOM -UP-CUT-ROD, 369", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "1284": {"page_number": 1285, "page_information": "1264 Index\nEXTENDED -EUCLID , 937\nEXTEND -SHORTEST -PAT HS , 688\nextension of a set, 438\nexterior of a polygon, 1020 ex.\nexternal node, 1176\nexternal path length, 1180 ex.\nextracting the maximum key\nfrom d-ary heaps, 167 pr.\nfrom max-heaps, 163\nextracting the minimum key\nfrom Fibonacci heaps, 512\u2013518\nfrom 2-3-4 heaps, 529 pr.\nfrom Young tableaus, 167 pr.\nEXTRACT -MAX, 162\u2013163\nEXTRACT -MIN, 162, 505\nfactor, 928\ntwiddle, 912\nfactorial function ( \u0160), 57\u201358\nfactorization, 975\u2013980, 984\nunique, 931\nfailure, in a Bernoulli trial, 1201\nfair coin, 1191fan-out, 1071\nFarkas\u2019s lemma, 895 pr.\nfarthest-pair problem, 1030\nF\nASTER -ALL-PAIRS -SHORTEST -PAT HS , 691,\n692 ex.\nfast Fourier transform (FFT), 898\u2013925\ncircuit for, 919\u2013920\niterative implementation of, 915\u2013918\nmultidimensional, 921 pr.multithreaded algorithm for, 804 ex.\nrecursive implementation of, 909\u2013912\nusing modular arithmetic, 923 pr.\nfeasibility problem, 665, 894 pr.\nfeasible linear program, 851\nfeasible region, 847\nfeasible solution, 665, 846, 851\nFermat\u2019s theorem, 954\nFFT, seefast Fourier transform\nFFTW, 924\nF\nIB, 775\nFIB-HEAP-CHANGE -KEY, 529 pr.\nFIB-HEAP-DECREASE -KEY, 519\nFIB-HEAP-DELETE , 522\nFIB-HEAP-EXTRACT -MIN, 513\nFIB-HEAP-INSERT , 510FIB-HEAP-LINK, 516\nFIB-HEAP-PRUNE , 529 pr.\nFIB-HEAP-UNION , 512\nFibonacci heap, 505\u2013530\nchanging a key in, 529 pr.\ncompared with binary heaps, 506\u2013507\ncreating, 510decreasing a key in, 519\u2013522\ndeletion from, 522, 526 pr.\nin Dijkstra\u2019s algorithm, 662\nextracting the minimum key from, 512\u2013518\ninsertion into, 510\u2013511\nin Johnson\u2019s algorithm, 704maximum degree of, 509, 523\u2013526\nminimum key of, 511\npotential function for, 509in Prim\u2019s algorithm, 636\npruning, 529 pr.\nrunning times of operations on, 506 \ufb01g.\nuniting, 511\u2013512\nFibonacci numbers, 59\u201360, 108 pr., 523\ncomputation of, 774\u2013780, 981 pr.\nFIFO (\ufb01rst-in, \ufb01rst-out), 232\nsee also queue\n\ufb01nal-state function, 996\n\ufb01nal strand, 779\nF\nIND-DEPTH , 583 pr.\nFIND-MAX-CROSSING -SUBARRAY ,7 1\nFIND-MAXIMUM -SUBARRAY ,7 2\n\ufb01nd path, 569\nFIND-SET, 562\ndisjoint-set-forest implementation of, 571,\n585\nlinked-list implementation of, 564\n\ufb01nished vertex, 603\ufb01nishing time, in depth-\ufb01rst search, 605\nand strongly connected components, 618\n\ufb01nish time, in activity selection, 415\n\ufb01nite automaton, 995\nfor string matching, 996\u20131002\nF\nINITE -AUTOMATON -MAT CHER , 999\n\ufb01nite group, 940\n\ufb01nite sequence, 1166\n\ufb01nite set, 1161\n\ufb01rst-\ufb01t heuristic, 1134 pr.\n\ufb01rst-in, \ufb01rst-out, 232\nsee also queue\n\ufb01xed-length code, 429", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "1285": {"page_number": 1286, "page_information": "Index 1265\n\ufb02oating-point data type, 23\n\ufb02oor function (bc), 54\nin master theorem, 103\u2013106\n\ufb02oor instruction, 23\ufb02ow, 709\u2013714\naggregate, 863\naugmentation of, 716blocking, 765\ncancellation of, 717\nexcess, 736\ninteger-valued, 733\nnet, across a cut, 720\nvalue of, 710\n\ufb02ow conservation, 709\u2013710\n\ufb02ow network, 709\u2013714\ncorresponding to a bipartite graph, 732cut of, 720\u2013724\nwith multiple sources and sinks, 712\nF\nLOYD -WARSHALL , 695\nFLOYD -WARSHALL0, 699 ex.\nFloyd-Warshall algorithm, 693\u2013697,\n699\u2013700 ex., 706\nmultithreaded, 797 ex.\nFORD-FULKERSON , 724\nFord-Fulkerson method, 714\u2013731, 765\nFORD-FULKERSON -METHOD , 715\nforest, 1172\u20131173\ndepth-\ufb01rst, 603\ndisjoint-set, 568\u2013572\nfor, in pseudocode, 20\u201321\nand loop invariants, 19 n.\nformal power series, 108 pr.\nformula satis\ufb01a bility, 1079\u20131081, 1105\nforward edge, 609\nforward substitution, 816\u2013817Fourier transform, seediscrete Fourier\ntransform, fast Fourier transform\nfractional knapsack problem, 426, 428 ex.free agent, 411 pr.\nfreeing of objects, 243\u2013244\nfree list, 243\nF\nREE-OBJECT , 244\nfree tree, 1172\u20131176\nfrequency domain, 898\nfull binary tree, 1178, 1180 ex.\nrelation to optimal code, 430\nfull node, 489full rank, 1223full walk of a tree, 1114\nfully parenthesized matrix-chain product, 370\nfully polynomial-time approximation scheme,\n1107\nfor subset sum, 1128\u20131134, 1139\nfunction, 1166\u20131168\nAckermann\u2019s, 585basis, 835\nconvex, 1199\n\ufb01nal-state, 996hash, seehash function\nlinear, 26, 845\nobjective, 664, 847, 851\npotential, 459\npre\ufb01x, 1003\u20131004\nquadratic, 27reduction, 1067\nsuf\ufb01x, 996\ntransition, 995, 1001\u20131002, 1012 ex.\nfunctional iteration, 58\nfundamental theorem of linear programming,\n892\nfurthest-in-future strategy, 449 pr.fusion tree, 212, 483\nfuzzy sorting, 189 pr.\nGabow\u2019s scaling algorithm for single-source\nshortest paths, 679 pr.\ngap character, 989 ex., 1002 ex.gap heuristic, 760 ex., 766\ngarbage collection, 151, 243\ngate, 1070Gaussian elimination, 819, 842\ngcd, seegreatest common divisor\ngeneral number-\ufb01eld sieve, 984\ngenerating function, 108 pr.\ngenerator\nof a subgroup, 944ofZ\n/ETX\nn, 955\nGENERIC -MST, 626\nGENERIC -PUSH-RELABEL , 741\ngeneric push-relabel algorithm, 740\u2013748\ngeometric distribution, 1202\u20131203\nand balls and bins, 134\ngeometric series, 1147\ngeometry, computational, 1014\u20131047\nGF.2/, 1227 pr.\ngift wrapping, 1037, 1047", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "1286": {"page_number": 1287, "page_information": "1266 Index\nglobal variable, 21\nGoldberg\u2019s algorithm, seepush-relabel\nalgorithm\ngolden ratio ( /RS), 59, 108 pr.\ngossiping, 478\nGRAFT , 583 pr.\nGraham\u2019s scan, 1030\u20131036, 1047\nGRAHAM -SCAN, 1031\ngraph, 1168\u20131173\nadjacency-list representation of, 590\nadjacency-matrix representation of, 591\nalgorithms for, 587\u2013766\nand asymptotic notation, 588attributes of, 588, 592\nbreadth-\ufb01rst search of, 594\u2013602, 623\ncoloring of, 1103 pr.complement of, 1090\ncomponent, 617\nconstraint, 666\u2013668dense, 589\ndepth-\ufb01rst search of, 603\u2013612, 623\ndynamic, 562 n.\n/SI-dense, 706 pr.\nhamiltonian, 1061\nincidence matrix of, 448 pr., 593 ex.\ninterval, 422 ex.nonhamiltonian, 1061\nshortest path in, 597\nsingly connected, 612 ex.sparse, 589\nstatic, 562 n.\nsubproblem, 367\u2013368\ntour of, 1096\nweighted, 591\nsee also directed acyclic graph, directed\ngraph, \ufb02ow network, undirected graph,\ntree\ngraphic matroid, 437\u2013438, 642\nGRAPH-ISOMORPHISM, 1065 ex.\ngray vertex, 594, 603\ngreatest common divisor (gcd), 929\u2013930,\n933 ex.\nbinary gcd algorithm for, 981 pr.\nEuclid\u2019s algorithm for, 933\u2013939, 981 pr., 983with more than two arguments, 939 ex.\nrecursion theorem for, 934\ngreedoid, 450\nG\nREEDY , 440GREEDY -ACTIVITY -SELECTOR , 421\ngreedy algorithm, 414\u2013450\nfor activity selection, 415\u2013422\nfor coin changing, 446 pr.compared with dynamic programming, 381,\n390 ex., 418, 423\u2013427\nDijkstra\u2019s algorithm, 658\u2013664elements of, 423\u2013428\nfor fractional knapsack problem, 426\ngreedy-choice property in, 424\u2013425\nfor Huffman code, 428\u2013437\nKruskal\u2019s algorithm, 631\u2013633\nand matroids, 437\u2013443\nfor minimum spanning tree, 631\u2013638\nfor multithreaded scheduling, 781\u2013783\nfor off-line caching, 449 pr.\noptimal substructure in, 425\nPrim\u2019s algorithm, 634\u2013636\nfor set cover, 1117\u20131122, 1139for task scheduling, 443\u2013446, 447\u2013448 pr.\non a weighted matroid, 439\u2013442\nfor weighted set cover, 1135 pr.\ngreedy-choice property, 424\u2013425\nof activity selection, 417\u2013418\nof Huffman codes, 433\u2013434\nof a weighted matroid, 441\ngreedy scheduler, 782\nG\nREEDY -SET-COVER , 1119\ngrid, 760 pr.group, 939\u2013946\ncyclic, 955\noperator (\u02da), 939\nguessing the solution, in the substitution\nmethod, 84\u201385\nhalf 3-CNF satis\ufb01ability, 1101 ex.\nhalf-open interval, 348\nHall\u2019s theorem, 735 ex.halting problem, 1048\nhalving lemma, 908\nHAM-CYCLE, 1062\nhamiltonian cycle, 1049, 1061, 1091\u20131096,\n1105\nhamiltonian graph, 1061\nhamiltonian path, 1066 ex., 1101 ex.\nHAM-PATH, 1066 ex.\nhandle, 163, 507\nhandshaking lemma, 1172 ex.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "1287": {"page_number": 1288, "page_information": "Index 1267\nharmonic number, 1147, 1153\u20131154\nharmonic series, 1147, 1153\u20131154\nHASH-DELETE , 277 ex.\nhash function, 256, 262\u2013269\nauxiliary, 272\ncollision-resistant, 964\ndivision method for, 263, 268\u2013269 ex./SI-universal, 269 ex.\nmultiplication method for, 263\u2013264\nuniversal, 265\u2013268\nhashing, 253\u2013285\nwith chaining, 257\u2013260, 283 pr.\ndouble, 272\u2013274, 277 ex.k-universal, 284 pr.\nin memoization, 365, 387\nwith open addressing, 269\u2013277perfect, 277\u2013282, 285\nto replace adjacency lists, 593 ex.\nuniversal, 265\u2013268\nH\nASH-INSERT , 270, 277 ex.\nHASH-SEARCH , 271, 277 ex.\nhash table, 256\u2013261\ndynamic, 471 ex.\nsecondary, 278\nsee also hashing\nhash value, 256hat-check problem, 122 ex.\nhead\nin a disk drive, 485of a linked list, 236\nof a queue, 234\nheap, 151\u2013169\nanalyzed by potential method, 462 ex.\nbinomial, 527 pr.\nbuilding, 156\u2013159, 166 pr.\ncompared with Fibonacci heaps, 506\u2013507\nd-ary, 167 pr., 706 pr.\ndeletion from, 166 ex.in Dijkstra\u2019s algorithm, 662\nextracting the maximum key from, 163\nFibonacci, seeFibonacci heap\nas garbage-collected storage, 151\nheight of, 153\nin Huffman\u2019s algorithm, 433to implement a mergeable heap, 506\nincreasing a key in, 163\u2013164\ninsertion into, 164\nin Johnson\u2019s algorithm, 704max-heap, 152\nmaximum key of, 163\nmergeable, seemergeable heap\nmin-heap, 153in Prim\u2019s algorithm, 636\nas a priority queue, 162\u2013166\nrelaxed, 530\nrunning times of operations on, 506 \ufb01g.\nand treaps, 333 pr.\n2-3-4, 529 pr.\nH\nEAP-DECREASE -KEY, 165 ex.\nHEAP-DELETE , 166 ex.\nHEAP-EXTRACT -MAX, 163\nHEAP-EXTRACT -MIN, 165 ex.\nHEAP-INCREASE -KEY, 164\nHEAP-MAXIMUM , 163\nHEAP-MINIMUM , 165 ex.\nheap property, 152\nmaintenance of, 154\u2013156\nvs. binary-search-tr ee property, 289 ex.\nheapsort, 151\u2013169\nHEAPSORT , 160\nheel, 602 ex.height\nof a binomial tree, 527 pr.\nblack-, 309of a B-tree, 489\u2013490\nof ad-ary heap, 167 pr.\nof a decision tree, 193\nexponential, 300\nof a heap, 153\nof a node in a heap, 153, 159 ex.of a node in a tree, 1177\nof a red-black tree, 309\nof a tree, 1177\nheight-balanced tree, 333 pr.\nheight function, in push-relabel algorithms, 738\nhereditary family of subsets, 437\nHermitian matrix, 832 ex.\nhigh endpoint of an interval, 348\nhigh function, 537, 546\nH\nIRE-ASSISTANT , 115\nhiring problem, 114\u2013115, 123\u2013124, 145\non-line, 139\u2013141\nprobabilistic analysis of, 120\u2013121\nhit\ncache, 449 pr.spurious, 991", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "1288": {"page_number": 1289, "page_information": "1268 Index\nHOARE -PARTITION , 185 pr.\nHOPCROFT -KARP, 764 pr.\nHopcroft-Karp bipartite matching algorithm,\n763 pr.\nhorizontal ray, 1021 ex.\nHorner\u2019s rule, 41 pr., 900\nin the Rabin-Karp algorithm, 990\nHUFFMAN , 431\nHuffman code, 428\u2013437, 450\nhull, convex, 8, 1029\u20131039, 1046 pr.\nHuman Genome Project, 6\nhyperedge, 1172\nhypergraph, 1172\nand bipartite graphs, 1173 ex.\nideal parallel computer, 779\nidempotency laws for sets, 1159\nidentity, 939\nidentity matrix, 1218if, in pseudocode, 20\nimage, 1167\nimage compression, 409 pr., 413\ninadmissible edge, 749\nincidence, 1169\nincidence matrix\nand difference constraints, 666of a directed graph, 448 pr., 593 ex.\nof an undirected graph, 448 pr.\ninclusion and exclusion, 1163 ex.incomplete step, 782\nI\nNCREASE -KEY, 162\nincreasing a key, in a max-heap, 163\u2013164\nINCREMENT , 454\nincremental design method, 29\nfor \ufb01nding the convex hull, 1030\nin-degree, 1169\nindentation in pseudocode, 20\nindependence\nof events, 1192\u20131193, 1195 ex.\nof random variables, 1197\nof subproblems in dynamic programming,\n383\u2013384\nindependent family of subsets, 437\nindependent set, 1101 pr.\nof tasks, 444\nindependent strands, 789\nindex function, 537, 546\nindex of an element of Z/ETX\nn, 955indicator random variable, 118\u2013121\nin analysis of expected height of a randomly\nbuilt binary search tree, 300\u2013303\nin analysis of inserting into a treap, 333 pr.in analysis of streaks, 138\u2013139\nin analysis of the birthday paradox, 132\u2013133\nin approximation algorithm for\nMAX-3-CNF satis\ufb01ability, 1124\nin bounding the right tail of the binomial\ndistribution, 1212\u20131213\nin bucket sort analysis, 202\u2013204\nexpected value of, 118\nin hashing analysis, 259\u2013260in hiring-problem analysis, 120\u2013121\nand linearity of expectation, 119\nin quicksort analysis, 182\u2013184, 187 pr.\nin randomized-selection analysis, 217\u2013219,\n226 pr.\nin universal-hashing analysis, 265\u2013266\ninduced subgraph, 1171\ninequality constraint, 852\nand equality constraints, 853\ninequality, linear, 846infeasible linear program, 851\ninfeasible solution, 851\nin\ufb01nite sequence, 1166in\ufb01nite set, 1161\nin\ufb01nite sum, 1145\nin\ufb01nity, arithmetic with, 650\nI\nNITIALIZE -PREFLOW , 740\nINITIALIZE -SIMPLEX , 871, 887\nINITIALIZE -SINGLE -SOURCE , 648\ninitial strand, 779\ninjective function, 1167\ninner product, 1222inorder tree walk, 287, 293 ex., 342\nI\nNORDER -TREE-WALK, 288\nin-place sorting, 17, 148, 206 pr.input\nto an algorithm, 5\nto a combinational circuit, 1071\ndistribution of, 116, 122\nto a logic gate, 1070\nsize of, 25\ninput alphabet, 995\nI\nNSERT , 162, 230, 463 ex., 505\ninsertion\ninto binary search trees, 294\u2013295", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "1289": {"page_number": 1290, "page_information": "Index 1269\ninto a bit vector with a superimposed binary\ntree, 534\ninto a bit vector with a superimposed tree of\nconstant height, 534\ninto B-trees, 493\u2013497\ninto chained hash tables, 258\nintod-ary heaps, 167 pr.\ninto direct-address tables, 254\ninto dynamic tables, 464\u2013467\nelementary, 465into Fibonacci heaps, 510\u2013511\ninto heaps, 164\ninto interval trees, 349into linked lists, 237\u2013238\ninto open-address hash tables, 270\ninto order-statistic trees, 343\ninto proto van Emde Boas structures, 544\ninto queues, 234\ninto red-black trees, 315\u2013323into stacks, 232\ninto sweep-line statuses, 1024\ninto treaps, 333 pr.into 2-3-4 heaps, 529 pr.into van Emde Boas trees, 552\u2013554\ninto Young tableaus, 167 pr.\ninsertion sort, 12, 16\u201320, 25\u201327\nin bucket sort, 201\u2013204\ncompared with merge sort, 14 ex.\ncompared with quicksort, 178 ex.\ndecision tree for, 192 \ufb01g.\nin merge sort, 39 pr.\nin quicksort, 185 ex.using binary search, 39 ex.\nI\nNSERTION -SORT, 18, 26, 208 pr.\ninstance\nof an abstract problem, 1051, 1054\nof a problem, 5\ninstructions of the RAM model, 23\ninteger data type, 23\ninteger linear programming, 850, 895 pr.,\n1101 ex.\nintegers ( Z), 1158\ninteger-valued \ufb02ow, 733\nintegrality theorem, 734\nintegral, to approximate summations,\n1154\u20131156\nintegration of a series, 1147\ninterior of a polygon, 1020 ex.interior-point method, 850, 897\nintermediate vertex, 693\ninternal node, 1176\ninternal path length, 1180 ex.interpolation by a cubic spline, 840 pr.\ninterpolation by a polynomial, 901, 906 ex.\nat complex roots of unity, 912\u2013913\nintersection\nof chords, 345 ex.\ndetermining, for a set of line segments,\n1021\u20131029, 1047\ndetermining, for two line segments,\n1017\u20131019\nof languages, 1058\nof sets (\\), 1159\ninterval, 348\nfuzzy sorting of, 189 pr.\nI\nNTERV AL -DELETE , 349\ninterval graph, 422 ex.\nINTERV AL -INSERT , 349\nINTERV AL -SEARCH , 349, 351\nINTERV AL -SEARCH -EXACTLY , 354 ex.\ninterval tree, 348\u2013354\ninterval trichotomy, 348\nintractability, 1048\ninvalid shift, 985inventory planning, 411 pr.\ninverse\nof a bijective function, 1167\nin a group, 940\nof a matrix, 827\u2013831, 842, 1223, 1225 ex.\nmultiplicative, modulo n, 949\ninversion\nin a self-organizing list, 476 pr.\nin a sequence, 41 pr., 122 ex., 345 ex.\ninverter, 1070\ninvertible matrix, 1223\nisolated vertex, 1169\nisomorphic graphs, 1171\niterated function, 63 pr.\niterated logarithm function, 58\u201359\nI\nTERA TIVE -FFT, 917\nITERA TIVE -TREE-SEARCH , 291\niter function, 577\nJarvis\u2019s march, 1037\u20131038, 1047\nJensen\u2019s inequality, 1199\nJOHNSON , 704", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "1290": {"page_number": 1291, "page_information": "1270 Index\nJohnson\u2019s algorithm, 700\u2013706\njoining\nof red-black trees, 332 pr.\nof 2-3-4 trees, 503 pr.\njoint probability density function, 1197\nJosephus permutation, 355 pr.\nKarmarkar\u2019s algorithm, 897\nKarp\u2019s minimum mean-weight cycle algorithm,\n680 pr.\nk-ary tree, 1179\nk-CNF, 1049\nk-coloring, 1103 pr., 1180 pr.\nk-combination, 1185\nk-conjunctive normal form, 1049\nkernel of a polygon, 1038 ex.\nkey, 16, 147, 162, 229\ndummy, 397\ninterpreted as a natural number, 263median, of a B-tree node, 493\npublic, 959, 962\nsecret, 959, 962static, 277\nkeywords, in pseudocode, 20\u201322\nmultithreaded, 774, 776\u2013777, 785\u2013786\n\u201ckiller adversary\u201d for quicksort, 190Kirchhoff\u2019s current law, 708\nKleene star (\n/ETX), 1058\nKMP algorithm, 1002\u20131013\nKMP-M AT CHE R , 1005\nknapsack problem\nfractional, 426, 428 ex.\n0-1, 425, 427 ex., 1137 pr., 1139\nk-neighbor tree, 338\nknot, of a spline, 840 pr.Knuth-Morris-Pratt algorithm, 1002\u20131013\nk-permutation, 126, 1184\nKraft inequality, 1180 ex.Kruskal\u2019s algorithm, 631\u2013633, 642\nwith integer edge weights, 637 ex.\nk-sorted, 207 pr.\nk-string, 1184\nk-subset, 1161\nk-substring, 1184\nkth power, 933 ex.\nk-universal hashing, 284 pr.\nLagrange\u2019s formula, 902Lagrange\u2019s theorem, 944\nLam\u00b4e\u2019s theorem, 936\nlanguage, 1057\ncompleteness of, 1077 ex.\nproving NP-completeness of, 1078\u20131079\nveri\ufb01cation of, 1063\nlast-in, \ufb01rst-out, 232\nsee also stack\nlate task, 444\nlayers\nconvex, 1044 pr.\nmaximal, 1045 pr.\nLCA, 584 pr.\nlcm (least common multiple), 939 ex.\nLCS, 7, 390\u2013397, 413\nLCS-L\nENGTH , 394\nleading submatrix, 833, 839 ex.\nleaf, 1176\nleast common ancestor, 584 pr.\nleast common multiple, 939 ex.\nleast-squares approximation, 835\u2013839\nleaving a vertex, 1169leaving variable, 867\nL\nEFT, 152\nleft child, 1178\nleft-child, right-sibling representation, 246,\n249 ex.\nLEFT-ROTATE , 313, 353 ex.\nleft rotation, 312left spine, 333 pr.\nleft subtree, 1178\nLegendre symbol .\na\np/, 982 pr.\nlength\nof a path, 1170\nof a sequence, 1166of a spine, 333 pr.\nof a string, 986, 1184\nlevel\nof a function, 573\nof a tree, 1177\nlevel function, 576lexicographically less than, 304 pr.\nlexicographic sorting, 304 pr.\nlg (binary logarithm), 56lg\n/ETX(iterated logarithm function), 58\u201359\nlgk(exponentiation of logarithms), 56\nlg lg (composition of logarithms), 56\nLIFO (last-in, \ufb01rst-out), 232", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "1291": {"page_number": 1292, "page_information": "Index 1271\nsee also stack\nlight edge, 626\nlinear constraint, 846\nlinear dependence, 1223linear equality, 845\nlinear equations\nsolving modular, 946\u2013950solving systems of, 813\u2013827\nsolving tridiagonal systems of, 840 pr.\nlinear function, 26, 845\nlinear independence, 1223\nlinear inequality, 846\nlinear-inequality feasibility problem, 894 pr.linearity of expectation, 1198\nand indicator random variables, 119\nlinearity of summations, 1146\nlinear order, 1165\nlinear permutation, 1229 pr.\nlinear probing, 272linear programming, 7, 843\u2013897\nalgorithms for, 850\napplications of, 849duality in, 879\u2013886ellipsoid algorithm for, 850, 897\n\ufb01nding an initial solution in, 886\u2013891\nfundamental theorem of, 892interior-point methods for, 850, 897\nKarmarkar\u2019s algorithm for, 897\nand maximum \ufb02ow, 860\u2013861\nand minimum-cost circulation, 896 pr.\nand minimum-cost \ufb02ow, 861\u2013862\nand minimum-cost multicommodity \ufb02ow,\n864 ex.\nand multicommodity \ufb02ow, 862\u2013863\nsimplex algorithm for, 864\u2013879, 896and single-pair shortest path, 859\u2013860\nand single-source shortest paths, 664\u2013670,\n863 ex.\nslack form for, 854\u2013857\nstandard form for, 850\u2013854\nsee also integer linear programming, 0-1\ninteger programming\nlinear-programming relaxation, 1125\nlinear search, 22 ex.linear speedup, 780\nline segment, 1015\ncomparable, 1022determining turn of, 1017determining whether any intersect,\n1021\u20131029, 1047\ndetermining whether two intersect,\n1017\u20131019\nlink\nof binomial trees, 527 pr.\nof Fibonacci-heap roots, 513of trees in a disjoint-set forest, 570\u2013571\nL\nINK, 571\nlinked list, 236\u2013241\ncompact, 245 ex., 250 pr.\ndeletion from, 238\nto implement disjoint sets, 564\u2013568insertion into, 237\u2013238\nneighbor list, 750\nsearching, 237, 268 ex.\nself-organizing, 476 pr.\nlist,seelinked list\nL\nIST-DELETE , 238\nLIST-DELETE0, 238\nLIST-INSERT , 238\nLIST-INSERT0, 240\nLIST-SEARCH , 237\nLIST-SEARCH0, 239\nliteral, 1082\nlittle-oh notation, 50\u201351, 64\nlittle-omega notation, 51\nLm-distance, 1044 ex.\nln (natural logarithm), 56load factor\nof a dynamic table, 463\nof a hash table, 258\nload instruction, 23\nlocal variable, 21\nlogarithm function (log), 56\u201357\ndiscrete, 955\niterated (lg\n/ETX), 58\u201359\nlogical parallelism, 777logic gate, 1070\nlongest common subsequence, 7, 390\u2013397, 413\nlongest palindrome subsequence, 405 pr.LONGEST-PATH, 1060 ex.\nLONGEST-PATH-LENGTH, 1060 ex.\nlongest simple cycle, 1101 ex.\nlongest simple path, 1048\nin an unweighted graph, 382\nin a weighted directed acyclic graph, 404 pr.\nL\nOOKUP -CHAIN , 388", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "1292": {"page_number": 1293, "page_information": "1272 Index\nloop, in pseudocode, 20\nparallel, 785\u2013787\nloop invariant, 18\u201319\nfor breadth-\ufb01rst search, 595for building a heap, 157\nfor consolidating the root list of a Fibonacci\nheap, 517\nfor determining the rank of an element in an\norder-statistic tree, 342\nfor Dijkstra\u2019s algorithm, 660andforloops, 19 n.\nfor the generic minimum-spanning-tree\nmethod, 625\nfor the generic push-relabel algorithm, 743\nfor Graham\u2019s scan, 1034\nfor heapsort, 160 ex.\nfor Horner\u2019s rule, 41 pr.\nfor increasing a key in a heap, 166 ex.\ninitialization of, 19for insertion sort, 18\nmaintenance of, 19\nfor merging, 32for modular exponentiation, 957origin of, 42\nfor partitioning, 171\nfor Prim\u2019s algorithm, 636for the Rabin-Karp algorithm, 993\nfor randomly permuting an array, 127,\n128 ex.\nfor red-black tree insertion, 318\nfor the relabel-to-front algorithm, 755\nfor searching an interval tree, 352for the simplex algorithm, 872\nfor string-matching automata, 998, 1000\nand termination, 19\nlow endpoint of an interval, 348\nlower bounds\non approximations, 1140\nasymptotic, 48\nfor average sorting, 207 pr.\non binomial coef\ufb01cients, 1186for comparting water jugs, 206 pr.\nfor convex hull, 1038 ex., 1047\nfor disjoint-set data structures, 585\nfor \ufb01nding the minimum, 214\nfor \ufb01nding the predecessor, 560\nfor length of an optimal traveling-salesman\ntour, 1112\u20131115for median \ufb01nding, 227\nfor merging, 208 pr.\nfor minimum-weight vertex cover,\n1124\u20131126\nfor multithreaded computations, 780\nand potential functions, 478\nfor priority-queue operations, 531\nand recurrences, 67\nfor simultaneous minimum and maximum,\n215 ex.\nfor size of an optimal vertex cover, 1110,\n1135 pr.\nfor sorting, 191\u2013194, 205 pr., 211, 531for streaks, 136\u2013138, 142 ex.\non summations, 1152, 1154\nlower median, 213\nlower square root/NUL\n#p\n/SOH\n, 546\nlower-triangular matrix, 1219, 1222 ex.,\n1225 ex.\nlow function, 537, 546\nLU decomposition, 806 pr., 819\u2013822\nLU-D ECOMPOSITION , 821\nLUP decomposition, 806 pr., 815\ncomputation of, 822\u2013825\nof a diagonal matrix, 827 ex.\nin matrix inversion, 828\nand matrix multiplication, 832 ex.\nof a permutation matrix, 827 ex.\nuse of, 815\u2013819\nLUP-D ECOMPOSITION , 824\nLUP-S OLVE , 817\nmain memory, 484\nMAKE-HEAP, 505\nMAKE-SET, 561\ndisjoint-set-forest implementation of, 571\nlinked-list implementation of, 564\nmakespan, 1136 pr.\nMAKE-TREE, 583 pr.\nManhattan distance, 225 pr., 1044 ex.\nmarked node, 508, 519\u2013520\nMarkov\u2019s inequality, 1201 ex.\nmaster method for solving a recurrence, 93\u201397\nmaster theorem, 94\nproof of, 97\u2013106\nmatched vertex, 732\nmatching\nbipartite, 732, 763 pr.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "1293": {"page_number": 1294, "page_information": "Index 1273\nmaximal, 1110, 1135 pr.\nmaximum, 1135 pr.\nand maximum \ufb02ow, 732\u2013736, 747 ex.\nperfect, 735 ex.of strings, 985\u20131013\nweighted bipartite, 530\nmatric matroid, 437matrix, 1217\u20131229\naddition of, 1220\nadjacency, 591\nconjugate transpose of, 832 ex.\ndeterminant of, 1224\u20131225\ndiagonal, 1218Hermitian, 832 ex.\nidentity, 1218\nincidence, 448 pr., 593 ex.\ninversion of, 806 pr., 827\u2013831, 842\nlower-triangular, 1219, 1222 ex., 1225 ex.\nmultiplication of, seematrix multiplication\nnegative of, 1220\npermutation, 1220, 1222 ex.\npredecessor, 685product of, with a vector, 785\u2013787, 789\u2013790,\n792 ex.\npseudoinverse of, 837\nscalar multiple of, 1220subtraction of, 1221\nsymmetric, 1220\nsymmetric positive-de\ufb01nite, 832\u2013835, 842\nToeplitz, 921 pr.\ntranspose of, 797 ex., 1217\ntranspose of, multithreaded, 792 ex.tridiagonal, 1219\nunit lower-triangular, 1219\nunit upper-triangular, 1219\nupper-triangular, 1219, 1225 ex.\nVandermonde, 902, 1226 pr.\nmatrix-chain multiplication, 370\u2013378\nM\nAT RIX -CHAIN -MULTIPLY\nMAT RIX -CHAIN -ORDER , 375\nmatrix multiplication, 75\u201383, 1221\nfor all-pairs shortest paths, 686\u2013693,\n706\u2013707\nboolean, 832 ex.\nand computing the determinant, 832 ex.\ndivide-and-conquer method for, 76\u201383\nand LUP decomposition, 832 ex.\nand matrix inversion, 828\u2013831, 842multithreaded algorithm for, 792\u2013797,\n806 pr.\nPan\u2019s method for, 82 ex.\nStrassen\u2019s algorithm for, 79\u201383, 111\u2013112\nMAT RIX -MULTIPLY , 371\nmatrix-vector multiplication, multithreaded,\n785\u2013787, 792 ex.\nwith race, 789\u2013790\nmatroid, 437\u2013443, 448 pr., 450, 642\nfor task scheduling, 443\u2013446\nMAT-VEC, 785\nMAT-VEC-MAIN-LOOP, 786\nMAT-VEC-WRONG , 790\nMAX-CNF satis\ufb01ability, 1127 ex.\nMAX-CUT problem, 1127 ex.\nMAX-FLOW -BY-SCALING , 763 pr.\nmax-\ufb02ow min-cut theorem, 723\nmax-heap, 152\nbuilding, 156\u2013159d-ary, 167 pr.\ndeletion from, 166 ex.\nextracting the maximum key from, 163\nin heapsort, 159\u2013162\nincreasing a key in, 163\u2013164\ninsertion into, 164\nmaximum key of, 163as a max-priority queue, 162\u2013166\nmergeable, 250 n., 481 n., 505 n.\nM\nAX-HEAPIFY , 154\nMAX-HEAP-INSERT , 164\nbuilding a heap with, 166 pr.\nmax-heap property, 152\nmaintenance of, 154\u2013156\nmaximal element, of a partially ordered set,\n1165\nmaximal layers, 1045 pr.\nmaximal matching, 1110, 1135 pr.\nmaximal point, 1045 pr.\nmaximal subset, in a matroid, 438\nmaximization linear program, 846\nand minimization linear programs, 852\nmaximum, 213\nin binary search trees, 291\nof a binomial distribution, 1207 ex.\nin a bit vector with a superimposed binary\ntree, 533\nin a bit vector with a superimposed tree of\nconstant height, 535", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "1294": {"page_number": 1295, "page_information": "1274 Index\n\ufb01nding, 214\u2013215\nin heaps, 163\nin order-statistic trees, 347 ex.\nin proto van Emde Boas structures, 544 ex.in red-black trees, 311\nin van Emde Boas trees, 550\nM\nAXIMUM , 162\u2013163, 230\nmaximum bipartite matching, 732\u2013736,\n747 ex., 766\nHopcroft-Karp algorithm for, 763 pr.\nmaximum degree, in a Fibonacci heap, 509,\n523\u2013526\nmaximum \ufb02ow, 708\u2013766\nEdmonds-Karp algorithm for, 727\u2013730\nFord-Fulkerson method for, 714\u2013731, 765\nas a linear program, 860\u2013861and maximum bipartite matching, 732\u2013736,\n747 ex.\npush-relabel algorithms for, 736\u2013760, 765relabel-to-front algorithm for, 748\u2013760\nscaling algorithm for, 762 pr., 765\nupdating, 762 pr.\nmaximum matching, 1135 pr.\nmaximum spanning tree, 1137 pr.\nmaximum-subarray problem, 68\u201375, 111\nmax-priority queue, 162MAX-3-CNF satis\ufb01ability, 1123\u20131124, 1139\nM\nAYBE -MST-A, 641 pr.\nMAYBE -MST-B, 641 pr.\nMAYBE -MST-C, 641 pr.\nmean, seeexpected value\nmean weight of a cycle, 680 pr.\nmedian, 213\u2013227\nmultithreaded algorithm for, 805 ex.\nof sorted lists, 223 ex.of two sorted lists, 804 ex.\nweighted, 225 pr.\nmedian key, of a B-tree node, 493median-of-3 method, 188 pr.\nmember of a set (2), 1158\nmembership\nin proto van Emde Boas structures, 540\u2013541\nin Van Emde Boas trees, 550\nmemoization, 365, 387\u2013389\nM\nEMOIZED -CUT-ROD, 365\nMEMOIZED -CUT-ROD-AUX, 366\nMEMOIZED -MAT RIX -CHAIN , 388\nmemory, 484memory hierarchy, 24\nMERGE ,3 1\nmergeable heap, 481, 505\nbinomial heaps, 527 pr.\nlinked-list implementation of, 250 pr.\nrelaxed heaps, 530\nrunning times of operations on, 506 \ufb01g.2-3-4 heaps, 529 pr.\nsee also Fibonacci heap\nmergeable max-heap, 250 n., 481 n., 505 n.mergeable min-heap, 250 n., 481 n., 505\nM\nERGE -LISTS, 1129\nmerge sort, 12, 30\u201337\ncompared with insertion sort, 14 ex.\nmultithreaded algorithm for, 797\u2013805, 812\nuse of insertion sort in, 39 pr.\nMERGE -SORT,3 4\nMERGE -SORT0, 797\nmerging\nofksorted lists, 166 ex.\nlower bounds for, 208 pr.\nmultithreaded algorithm for, 798\u2013801of two sorted arrays, 30\nM\nILLER -RABIN , 970\nMiller-Rabin primality test, 968\u2013975, 983\nMIN-GAP, 354 ex.\nmin-heap, 153\nanalyzed by potential method, 462 ex.\nbuilding, 156\u2013159d-ary, 706 pr.\nin Dijkstra\u2019s algorithm, 662\nin Huffman\u2019s algorithm, 433\nin Johnson\u2019s algorithm, 704\nmergeable, 250 n., 481 n., 505\nas a min-priority queue, 165 ex.in Prim\u2019s algorithm, 636\nM\nIN-HEAPIFY , 156 ex.\nMIN-HEAP-INSERT , 165 ex.\nmin-heap ordering, 507\nmin-heap property, 153, 507\nmaintenance of, 156 ex.\nin treaps, 333 pr.\nvs. binary-search-tr ee property, 289 ex.\nminimization linear program, 846\nand maximization linear programs, 852\nminimum, 213\nin binary search trees, 291", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "1295": {"page_number": 1296, "page_information": "Index 1275\nin a bit vector with a superimposed binary\ntree, 533\nin a bit vector with a superimposed tree of\nconstant height, 535\nin B-trees, 497 ex.\nin Fibonacci heaps, 511\n\ufb01nding, 214\u2013215\noff-line, 582 pr.\nin order-statistic trees, 347 ex.\nin proto van Emde Boas structures, 541\u2013542in red-black trees, 311\nin 2-3-4 heaps, 529 pr.\nin van Emde Boas trees, 550\nM\nINIMUM , 162, 214, 230, 505\nminimum-cost circulation, 896 pr.\nminimum-cost \ufb02ow, 861\u2013862\nminimum-cost multicommodity \ufb02ow, 864 ex.\nminimum-cost spanning tree, seeminimum\nspanning tree\nminimum cut, 721, 731 ex.\nminimum degree, of a B-tree, 489\nminimum mean-weight cycle, 680 pr.minimum node, of a Fibonacci heap, 508minimum path cover, 761 pr.\nminimum spanning tree, 624\u2013642\nin approximation algorithm for\ntraveling-salesman problem, 1112\nBor\u02d9uvka\u2019s algorithm for, 641\non dynamic graphs, 637 ex.\ngeneric method for, 625\u2013630\nKruskal\u2019s algorithm for, 631\u2013633\nPrim\u2019s algorithm for, 634\u2013636relation to matroids, 437, 439\u2013440\nsecond-best, 638 pr.\nminimum-weight spanning tree, seeminimum\nspanning tree\nminimum-weight vertex cover, 1124\u20131127,\n1139\nminor of a matrix, 1224\nmin-priority queue, 162\nin constructing Huffman codes, 431\nin Dijkstra\u2019s algorithm, 661\nin Prim\u2019s algorithm, 634, 636\nmiss, 449 pr.missing child, 1178\nmod, 54, 928\nmodifying operation, 230\nmodular arithmetic, 54, 923 pr., 939\u2013946modular equivalence, 54, 1165 ex.\nmodular exponentiation, 956\nM\nODULAR -EXPONENTIATION , 957\nmodular linear equations, 946\u2013950\nMODULAR -LINEAR -EQUATION -SOLVER ,\n949\nmodulo, 54, 928\nMonge array, 110 pr.\nmonotone sequence, 168\nmonotonically decreasing, 53\nmonotonically increasing, 53\nMonty Hall problem, 1195 ex.\nmove-to-front heuristic, 476 pr., 478\nMST-K RUSKAL , 631\nMST-P RIM, 634\nMST-R EDUCE , 639 pr.\nmuch-greater-than ( /GS), 574\nmuch-less-than (/FS), 783\nmulticommodity \ufb02ow, 862\u2013863\nminimum-cost, 864 ex.\nmulticore computer, 772\nmultidimensional fast Fourier transform,\n921 pr.\nmultigraph, 1172\nconverting to equivalent undirected graph,\n593 ex.\nmultiple, 927\nof an element modulo n, 946\u2013950\nleast common, 939 ex.scalar, 1220\nmultiple assignment, 21\nmultiple sources and sinks, 712\nmultiplication\nof complex numbers, 83 ex.\ndivide-and-conquer method for, 920 pr.of matrices, seematrix multiplication\nof a matrix chain, 370\u2013378\nmatrix-vector, multithreaded, 785\u2013787,\n789\u2013790, 792 ex.\nmodulo n(/SOH\nn), 940\nof polynomials, 899\nmultiplication method, 263\u2013264\nmultiplicative group modulo n, 941\nmultiplicative inverse, modulo n, 949\nmultiply instruction, 23\nMULTIPOP , 453\nmultiprocessor, 772\nMULTIPUSH , 456 ex.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "1296": {"page_number": 1297, "page_information": "1276 Index\nmultiset, 1158 n.\nmultithreaded algorithm, 10, 772\u2013812\nfor computing Fibonacci numbers, 774\u2013780\nfor fast Fourier transform, 804 ex.Floyd-Warshall algorithm, 797 ex.\nfor LU decomposition, 806 pr.\nfor LUP decomposition, 806 pr.for matrix inversion, 806 pr.\nfor matrix multiplication, 792\u2013797, 806 pr.\nfor matrix transpose, 792 ex., 797 ex.\nfor matrix-vector product, 785\u2013787,\n789\u2013790, 792 ex.\nfor median, 805 ex.for merge sorting, 797\u2013805, 812\nfor merging, 798\u2013801\nfor order statistics, 805 ex.\nfor partitioning, 804 ex.\nfor pre\ufb01x computation, 807 pr.\nfor quicksort, 811 pr.for reduction, 807 pr.\nfor a simple stencil calculation, 809 pr.\nfor solving systems of linear equations,\n806 pr.\nStrassen\u2019s algorithm, 795\u2013796\nmultithreaded composition, 784 \ufb01g.\nmultithreaded computation, 777multithreaded scheduling, 781\u2013783\nmutually exclusive events, 1190\nmutually independent events, 1193\nN(set of natural numbers), 1158\nnaive algorithm, for string matching, 988\u2013990\nN\nAIVE -STRING -MAT CHER , 988\nnatural cubic spline, 840 pr.\nnatural numbers ( N), 1158\nkeys interpreted as, 263\nnegative of a matrix, 1220\nnegative-weight cycle\nand difference constraints, 667\nand relaxation, 677 ex.\nand shortest paths, 645, 653\u2013654, 692 ex.,\n700 ex.\nnegative-weight edges, 645\u2013646\nneighbor, 1172\nneighborhood, 735 ex.\nneighbor list, 750\nnested parallelism, 776, 805 pr.nesting boxes, 678 pr.net \ufb02ow across a cut, 720\nnetwork\nadmissible, 749\u2013750\n\ufb02ow, see\ufb02ow network\nresidual, 715\u2013719\nfor sorting, 811\nN\nEXT-TO-TOP, 1031\nNIL,2 1\nnode, 1176\nsee also vertex\nnonbasic variable, 855\nnondeterministic multithreaded algorithm, 787\nnondeterministic polynomial time, 1064 n.\nsee also NP\nnonhamiltonian graph, 1061\nnoninstance, 1056 n.noninvertible matrix, 1223\nnonnegativity constraint, 851, 853\nnonoverlappable string pattern, 1002 ex.\nnonsaturating push, 739, 745\nnonsingular matrix, 1223\nnontrivial power, 933 ex.\nnontrivial square root of 1, modulo n, 956\nno-path property, 650, 672\nnormal equation, 837\nnorm of a vector, 1222NOT function (:), 1071\nnot a set member (62), 1158\nnot equivalent (6/DC1), 54\nNOT gate, 1070\nNP (complexity class), 1049, 1064, 1066 ex.,\n1105\nNPC (complexity class), 1050, 1069\nNP-complete, 1050, 1069\nNP-completeness, 9\u201310, 1048\u20131105\nof the circuit-satis\ufb01ability problem,\n1070\u20131077\nof the clique problem, 1086\u20131089, 1105of determining whether a boolean formula is\na tautology, 1086 ex.\nof the formula-satis\ufb01ability problem,\n1079\u20131081, 1105\nof the graph-coloring problem, 1103 pr.\nof the half 3-CNF satis\ufb01ability problem,\n1101 ex.\nof the hamiltonian-cycle problem,\n1091\u20131096, 1105\nof the hamiltonian-path problem, 1101 ex.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "1297": {"page_number": 1298, "page_information": "Index 1277\nof the independent-set problem, 1101 pr.\nof integer linear programming, 1101 ex.\nof the longest-simple-cycle problem,\n1101 ex.\nproving, of a language, 1078\u20131079\nof scheduling with pro\ufb01ts and deadlines,\n1104 pr.\nof the set-covering problem, 1122 ex.\nof the set-partition problem, 1101 ex.\nof the subgraph-isomorphism problem,\n1100 ex.\nof the subset-sum problem, 1097\u20131100\nof the 3-CNF-satis\ufb01ability problem,\n1082\u20131085, 1105\nof the traveling-salesman problem,\n1096\u20131097\nof the vertex-cover problem, 1089\u20131091,\n1105\nof 0-1 integer programming, 1100 ex.\nNP-hard, 1069\nn-set, 1161\nn-tuple, 1162\nnull event, 1190null tree, 1178\nnull vector, 1224\nnumber-\ufb01eld sieve, 984numerical stability, 813, 815, 842\nn-vector, 1218\no-notation, 50\u201351, 64\nO-notation, 45 \ufb01g., 47\u201348, 64\nO\n0-notation, 62 pr.\neO-notation, 62 pr.\nobject, 21\nallocation and freeing of, 243\u2013244\narray implementation of, 241\u2013246\npassing as parameter, 21\nobjective function, 664, 847, 851\nobjective value, 847, 851\noblivious compare-exchange algorithm, 208 pr.\noccurrence of a pattern, 985\nOFF-LINE-MINIMUM , 583 pr.\noff-line problem\ncaching, 449 pr.least common ancestors, 584 pr.\nminimum, 582 pr.\nOmega-notation, 45 \ufb01g., 48\u201349, 64\n1-approximation algorithm, 1107one-pass method, 585\none-to-one correspondence, 1167\none-to-one function, 1167\non-line convex-hull problem, 1039 ex.\non-line hiring problem, 139\u2013141\nO\nN-LINE-MAXIMUM , 140\non-line multithreaded scheduler, 781\nON-SEGMENT , 1018\nonto function, 1167\nopen-address hash table, 269\u2013277\nwith double hashing, 272\u2013274, 277 ex.\nwith linear probing, 272\nwith quadratic probing, 272, 283 pr.\nopen interval, 348\nOpenMP, 774\noptimal binary search tree, 397\u2013404, 413\nOPTIMAL -BST, 402\noptimal objective value, 851\noptimal solution, 851optimal subset, of a matroid, 439\noptimal substructure\nof activity selection, 416\nof binary search trees, 399\u2013400\nin dynamic programming, 379\u2013384\nof the fractional knapsack problem, 426\nin greedy algorithms, 425of Huffman codes, 435\nof longest common subsequences, 392\u2013393\nof matrix-chain multiplication, 373of rod-cutting, 362\nof shortest paths, 644\u2013645, 687, 693\u2013694\nof unweighted shortest paths, 382\nof weighted matroids, 442\nof the 0-1 knapsack problem, 426\noptimal vertex cover, 1108optimization problem, 359, 1050, 1054\napproximation algorithms for, 10,\n1106\u20131140\nand decision problems, 1051\nOR function (_), 697, 1071\norder\nof a group, 945\nlinear, 1165\npartial, 1165total, 1165\nordered pair, 1161\nordered tree, 1177\norder of growth, 28", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "1298": {"page_number": 1299, "page_information": "1278 Index\norder statistics, 213\u2013227\ndynamic, 339\u2013345\nmultithreaded algorithm for, 805 ex.\norder-statistic tree, 339\u2013345\nquerying, 347 ex.\nOR gate, 1070\norigin, 1015\nor, in pseudocode, 22\northonormal, 842\nOS-K EY-RANK, 344 ex.\nOS-R ANK, 342\nOS-S ELECT , 341\nout-degree, 1169outer product, 1222\noutput\nof an algorithm, 5of a combinational circuit, 1071\nof a logic gate, 1070\noverdetermined system of linear equations, 814\nover\ufb02ow\nof a queue, 235\nof a stack, 233\nover\ufb02owing vertex, 736\ndischarge of, 751\noverlapping intervals, 348\n\ufb01nding all, 354 ex.\npoint of maximum overlap, 354 pr.\noverlapping rectangles, 354 ex.\noverlapping subproblems, 384\u2013386\noverlapping-suf\ufb01x lemma, 987\nP (complexity class), 1049, 1055, 1059,\n1061 ex., 1105\npackage wrapping, 1037, 1047\npage on a disk, 486, 499 ex., 502 pr.\npair, ordered, 1161\npairwise disjoint sets, 1161\npairwise independence, 1193\npairwise relatively prime, 931\npalindrome, 405 pr.\nPan\u2019s method for matrix multiplication, 82 ex.parallel algorithm, 10, 772\nsee also multithreaded algorithm\nparallel computer, 772\nideal, 779\nparallel for , in pseudocode, 785\u2013786\nparallelism\nlogical, 777of a multithreaded computation, 780\nnested, 776\nof a randomized multithreaded algorithm,\n811 pr.\nparallel loop, 785\u2013787, 805 pr.\nparallel-machine-scheduling problem, 1136 pr.\nparallel pre\ufb01x, 807 pr.parallel random-access machine, 811\nparallel slackness, 781\nrule of thumb, 783\nparallel, strands being logically in, 778\nparameter, 21\ncosts of passing, 107 pr.\nparent\nin a breadth-\ufb01rst tree, 594\nin a multithreaded computation, 776in a rooted tree, 1176\nP\nARENT , 152\nparenthesis structure of depth-\ufb01rst search, 606\nparenthesis theorem, 606\nparenthesization of a matrix-chain product, 370\nparse tree, 1082\npartially ordered set, 1165partial order, 1165\nP\nARTITION , 171\nPARTITION0, 186 pr.\npartition function, 361 n.\npartitioning, 171\u2013173\naround median of 3 elements, 185 ex.Hoare\u2019s method for, 185 pr.\nmultithreaded algorithm for, 804 ex.\nrandomized, 179\npartition of a set, 1161, 1164\nPascal\u2019s triangle, 1188 ex.\npath, 1170\naugmenting, 719\u2013720, 763 pr.\ncritical, 657\n\ufb01nd, 569hamiltonian, 1066 ex.\nlongest, 382, 1048\nshortest, seeshortest paths\nsimple, 1170\nweight of, 643\nPATH, 1051, 1058path compression, 569\npath cover, 761 pr.\npath length, of a tree, 304 pr., 1180 ex.\npath-relaxation property, 650, 673", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "1299": {"page_number": 1300, "page_information": "Index 1279\npattern, in string matching, 985\nnonoverlappable, 1002 ex.\npattern matching, seestring matching\npenalty, 444perfect hashing, 277\u2013282, 285\nperfect linear speedup, 780\nperfect matching, 735 ex.\npermutation, 1167\nbit-reversal, 472 pr., 918\nJosephus, 355 pr.k-permutation, 126, 1184\nlinear, 1229 pr.\nin place, 126random, 124\u2013128\nof a set, 1184\nuniform random, 116, 125\npermutation matrix, 1220, 1222 ex., 1226 ex.\nLUP decomposition of, 827 ex.\nP\nERMUTE -BY-CYCLIC , 129 ex.\nPERMUTE -BY-SORTING , 125\nPERMUTE -WITH-ALL, 129 ex.\nPERMUTE -WITHOUT -IDENTITY , 128 ex.\npersistent data structure, 331 pr., 482\nPERSISTENT -TREE-INSERT , 331 pr.\nPERT chart, 657, 657 ex.\nP-F IB, 776\nphase, of the relabel-t o-front algorithm, 758\nphi function ( /RS.n/ ), 943\nPISANO -DELETE , 526 pr.\npivot\nin linear programming, 867, 869\u2013870,\n878 ex.\nin LU decomposition, 821\nin quicksort, 171\nPIVOT , 869\nplatter, 485\nP-M AT RIX -MULTIPLY -RECURSIVE , 794\nP-M ERGE , 800\nP-M ERGE -SORT, 803\npointer, 21\narray implementation of, 241\u2013246\ntrailing, 295\npoint-value representation, 901\npolar angle, 1020 ex.Pollard\u2019s rho heuristic, 976\u2013980, 980 ex., 984\nP\nOLLARD -RHO, 976\npolygon, 1020 ex.\nkernel of, 1038 ex.star-shaped, 1038 ex.\npolylogarithmically bounded, 57\npolynomial, 55, 898\naddition of, 898\nasymptotic behavior of, 61 pr.\ncoef\ufb01cient representation of, 900\nderivatives of, 922 pr.evaluation of, 41 pr., 900, 905 ex., 923 pr.\ninterpolation by, 901, 906 ex.\nmultiplication of, 899, 903\u2013905, 920 pr.point-value representation of, 901\npolynomial-growth condition, 113\npolynomially bounded, 55\npolynomially related, 1056\npolynomial-time acceptance, 1058\npolynomial-time algorithm, 927, 1048polynomial-time approximation scheme, 1107\nfor maximum clique, 1134 pr.\npolynomial-time computability, 1056polynomial-time decision, 1059\npolynomial-time reducibility ( /DC4\nP), 1067,\n1077 ex.\npolynomial-time solvability, 1055\npolynomial-time veri\ufb01cation, 1061\u20131066\nPOP, 233, 452\npop from a run-time stack, 188 pr.positional tree, 1178\npositive-de\ufb01nite matrix, 1225\npost-of\ufb01ce location problem, 225 pr.postorder tree walk, 287\npotential function, 459\nfor lower bounds, 478\npotential method, 459\u2013463\nfor binary counters, 461\u2013462\nfor disjoint-set data structures, 575\u2013581,\n582 ex.\nfor dynamic tables, 466\u2013471\nfor Fibonacci heaps, 509\u2013512, 517\u2013518,\n520\u2013522\nfor the generic push-relabel algorithm, 746\nfor min-heaps, 462 ex.for restructuring red-black trees, 474 pr.\nfor self-organizing lists with move-to-front,\n476 pr.\nfor stack operations, 460\u2013461\npotential, of a data structure, 459\npower\nof an element, modulo n, 954\u2013958", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "1300": {"page_number": 1301, "page_information": "1280 Index\nkth, 933 ex.\nnontrivial, 933 ex.\npower series, 108 pr.\npower set, 1161Prfg(probability distribution), 1190\nPRAM, 811\npredecessor\nin binary search trees, 291\u2013292\nin a bit vector with a superimposed binary\ntree, 534\nin a bit vector with a superimposed tree of\nconstant height, 535\nin breadth-\ufb01rst trees, 594in B-trees, 497 ex.\nin linked lists, 236\nin order-statistic trees, 347 ex.\nin proto van Emde Boas structures, 544 ex.\nin red-black trees, 311\nin shortest-paths trees, 647in Van Emde Boas trees, 551\u2013552\nP\nREDECESSOR , 230\npredecessor matrix, 685predecessor subgraph\nin all-pairs shortest paths, 685\nin breadth-\ufb01rst search, 600\nin depth-\ufb01rst search, 603in single-source shortest paths, 647\npredecessor-subgraph property, 650, 676\npreemption, 447 pr.pre\ufb01x\nof a sequence, 392\nof a string ( <), 986\npre\ufb01x code, 429\npre\ufb01x computation, 807 pr.\npre\ufb01x function, 1003\u20131004\npre\ufb01x-function iteration lemma, 1007\npre\ufb02ow, 736, 765\npreimage of a matrix, 1228 pr.preorder, total, 1165\npreorder tree walk, 287\npresorting, 1043Prim\u2019s algorithm, 634\u2013636, 642\nwith an adjacency matrix, 637 ex.\nin approximation algorithm for\ntraveling-salesman problem, 1112\nimplemented with a Fibonacci heap, 636\nimplemented with a min-heap, 636with integer edge weights, 637 ex.similarity to Dijkstra\u2019s algorithm, 634, 662\nfor sparse graphs, 638 pr.\nprimality testing, 965\u2013975, 983\nMiller-Rabin test, 968\u2013975, 983pseudoprimality testing, 966\u2013968\nprimal linear program, 880\nprimary clustering, 272primary memory, 484\nprime distribution function, 965\nprime number, 928\ndensity of, 965\u2013966\nprime number theorem, 965\nprimitive root of Z\n/ETX\nn, 955\nprincipal root of unity, 907\nprinciple of inclusion and exclusion, 1163 ex.\nPRINT -ALL-PAIRS -SHORTEST -PATH, 685\nPRINT -CUT-ROD-SOLUTION , 369\nPRINT -INTERSECTING -SEGMENTS , 1028 ex.\nPRINT -LCS, 395\nPRINT -OPTIMAL -PARENS , 377\nPRINT -PAT H, 601\nPRINT -SET, 572 ex.\npriority queue, 162\u2013166\nin constructing Huffman codes, 431\nin Dijkstra\u2019s algorithm, 661\nheap implementation of, 162\u2013166lower bounds for, 531\nmax-priority queue, 162\nmin-priority queue, 162, 165 ex.\nwith monotone extractions, 168\nin Prim\u2019s algorithm, 634, 636\nproto van Emde Boas structure\nimplementation of, 538\u2013545\nvan Emde Boas tree implementation of,\n531\u2013560\nsee also binary search tree, binomial heap,\nFibonacci heap\nprobabilistically checkable proof, 1105, 1140probabilistic analysis, 115\u2013116, 130\u2013142\nof approximation algorithm for\nMAX-3-CNF satis\ufb01ability, 1124\nand average inputs, 28\nof average node depth in a randomly built\nbinary search tree, 304 pr.\nof balls and bins, 133\u2013134\nof birthday paradox, 130\u2013133\nof bucket sort, 201\u2013204, 204 ex.\nof collisions, 261 ex., 282 ex.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "1301": {"page_number": 1302, "page_information": "Index 1281\nof convex hull over a sparse-hulled\ndistribution, 1046 pr.\nof \ufb01le comparison, 995 ex.\nof fuzzy sorting of intervals, 189 pr.of hashing with chaining, 258\u2013260\nof height of a randomly built binary search\ntree, 299\u2013303\nof hiring problem, 120\u2013121, 139\u2013141\nof insertion into a binary search tree with\nequal keys, 303 pr.\nof longest-probe bound for hashing, 282 pr.\nof lower bound for sorting, 205 pr.\nof Miller-Rabin primality test, 971\u2013975and multithreaded algorithms, 811 pr.\nof on-line hiring problem, 139\u2013141\nof open-address hashing, 274\u2013276, 277 ex.of partitioning, 179 ex., 185 ex., 187\u2013188 pr.\nof perfect hashing, 279\u2013282\nof Pollard\u2019s rho heuristic, 977\u2013980\nof probabilistic counting, 143 pr.\nof quicksort, 181\u2013184, 187\u2013188 pr., 303 ex.\nof Rabin-Karp algorithm, 994and randomized algorithms, 123\u2013124of randomized selection, 217\u2013219, 226 pr.\nof searching a compact list, 250 pr.\nof slot-size bound for chaining, 283 pr.of sorting points by distance from origin,\n204 ex.\nof streaks, 135\u2013139\nof universal hashing, 265\u2013268\nprobabilistic counting, 143 pr.\nprobability, 1189\u20131196probability density function, 1196\nprobability distribution, 1190\nprobability distribution function, 204 ex.probe sequence, 270\nprobing, 270, 282 pr.\nsee also linear probing, quadratic probing,\ndouble hashing\nproblem\nabstract, 1054\ncomputational, 5\u20136\nconcrete, 1055\ndecision, 1051, 1054intractable, 1048\noptimization, 359, 1050, 1054\nsolution to, 6, 1054\u20131055\ntractable, 1048procedure, 6, 16\u201317\nproduct .Q/, 1148\nCartesian, 1162\ncross, 1016\ninner, 1222\nof matrices, 1221, 1226 ex.\nouter, 1222of polynomials, 899\nrule of, 1184\nscalar \ufb02ow, 714 ex.\nprofessional wrestler, 602 ex.\nprogram counter, 1073\nprogramming, seedynamic programming,\nlinear programming\nproper ancestor, 1176\nproper descendant, 1176proper subgroup, 944\nproper subset (/SUB), 1159\nproto van Emde Boas structure, 538\u2013545\ncluster in, 538\ncompared with van Emde Boas trees, 547\ndeletion from, 544\ninsertion into, 544\nmaximum in, 544 ex.\nmembership in, 540\u2013541\nminimum in, 541\u2013542predecessor in, 544 ex.\nsuccessor in, 543\u2013544\nsummary in, 540\nP\nROTO -VEB-I NSERT , 544\nPROTO -VEB-M EMBER , 541\nPROTO -VEB-M INIMUM , 542\nproto-vEB structure, seeproto van Emde Boas\nstructure\nPROTO -VEB-S UCCESSOR , 543\nprune-and-search method, 1030\npruning a Fibonacci heap, 529 pr.\nP-S CAN-1, 808 pr.\nP-S CAN-2, 808 pr.\nP-S CAN-3, 809 pr.\nP-S CAN-DOWN , 809 pr.\nP-S CAN-UP, 809 pr.\npseudocode, 16, 20\u201322\npseudoinverse, 837\npseudoprime, 966\u2013968\nPSEUDOPRIME , 967\npseudorandom-number generator, 117\nP-S QUARE -MAT RIX -MULTIPLY , 793", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "1302": {"page_number": 1303, "page_information": "1282 Index\nP-T RANSPOSE , 792 ex.\npublic key, 959, 962\npublic-key cryptosystem, 958\u2013965, 983\nPUSH\npush-relabel operation, 739\nstack operation, 233, 452\npush onto a run-time stack, 188 pr.\npush operation (in push-relabel algorithms),\n738\u2013739\nnonsaturating, 739, 745saturating, 739, 745\npush-relabel algorithm, 736\u2013760, 765\nbasic operations in, 738\u2013740by discharging an over\ufb02owing vertex of\nmaximum height, 760 ex.\nto \ufb01nd a maximum bipartite matching,\n747 ex.\ngap heuristic for, 760 ex., 766\ngeneric algorithm, 740\u2013748with a queue of over\ufb02owing vertices, 759 ex.\nrelabel-to-front algorithm, 748\u2013760\nquadratic function, 27\nquadratic probing, 272, 283 pr.\nquadratic residue, 982 pr.\nquantile, 223 ex.\nquery, 230\nqueue, 232, 234\u2013235\nin breadth-\ufb01rst search, 595implemented by stacks, 236 ex.\nlinked-list implementation of, 240 ex.\npriority, seepriority queue\nin push-relabel algorithms, 759 ex.\nquicksort, 170\u2013190\nanalysis of, 174\u2013185average-case analysis of, 181\u2013184\ncompared with insertion sort, 178 ex.\ncompared with radix sort, 199\nwith equal element values, 186 pr.\ngood worst-case implementation of, 223 ex.\n\u201ckiller adversary\u201d for, 190with median-of-3 method, 188 pr.\nmultithreaded algorithm for, 811 pr.\nrandomized version of, 179\u2013180, 187 pr.stack depth of, 188 pr.\ntail-recursive version of, 188 pr.\nuse of insertion sort in, 185 ex.worst-case analysis of, 180\u2013181Q\nUICKSORT , 171\nQUICKSORT0, 186 pr.\nquotient, 928\nR(set of real numbers), 1158\nRabin-Karp algorithm, 990\u2013995, 1013\nRABIN -KARP-MAT CHE R , 993\nrace, 787\u2013790\nRACE-EXAMPLE , 788\nradix sort, 197\u2013200\ncompared with quicksort, 199\nRADIX -SORT, 198\nradix tree, 304 pr.RAM, 23\u201324\nR\nANDOM , 117\nrandom-access machine, 23\u201324\nparallel, 811\nrandomized algorithm, 116\u2013117, 122\u2013130\nand average inputs, 28comparison sort, 205 pr.\nfor fuzzy sorting of intervals, 189 pr.\nfor hiring problem, 123\u2013124\nfor insertion into a bi nary search tree with\nequal keys, 303 pr.\nfor MAX-3-CNF satis\ufb01ability, 1123\u20131124,\n1139\nMiller-Rabin primality test, 968\u2013975, 983\nmultithreaded, 811 pr.\nfor partitioning, 179, 185 ex., 187\u2013188 pr.\nfor permuting an array, 124\u2013128\nPollard\u2019s rho heuristic, 976\u2013980, 980 ex.,\n984\nand probabilistic analysis, 123\u2013124\nquicksort, 179\u2013180, 185 ex., 187\u2013188 pr.\nrandomized rounding, 1139\nfor searching a compact list, 250 pr.\nfor selection, 215\u2013220\nuniversal hashing, 265\u2013268worst-case performance of, 180 ex.\nR\nANDOMIZED -HIRE-ASSISTANT , 124\nRANDOMIZED -PARTITION , 179\nRANDOMIZED -QUICKSORT , 179, 303 ex.\nrelation to randomly built binary search\ntrees, 304 pr.\nrandomized rounding, 1139\nRANDOMIZED -SELECT , 216\nRANDOMIZE -IN-PLACE , 126", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "1303": {"page_number": 1304, "page_information": "Index 1283\nrandomly built binary search tree, 299\u2013303,\n304 pr.\nrandom-number generator, 117\nrandom permutation, 124\u2013128\nuniform, 116, 125\nRANDOM -SAMPLE , 130 ex.\nrandom sampling, 129 ex., 179\nRANDOM -SEARCH , 143 pr.\nrandom variable, 1196\u20131201\nindicator, seeindicator random variable\nrange, 1167\nof a matrix, 1228 pr.\nrank\ncolumn, 1223\nfull, 1223\nof a matrix, 1223, 1226 ex.of a node in a disjoint-set forest, 569, 575,\n581 ex.\nof a number in an ordered set, 300, 339in order-statistic trees, 341\u2013343, 344\u2013345 ex.\nrow, 1223\nrate of growth, 28\nray, 1021 ex.\nRB-D\nELETE , 324\nRB-D ELETE -FIXUP , 326\nRB-E NUMERATE , 348 ex.\nRB-I NSERT , 315\nRB-I NSERT -FIXUP , 316\nRB-J OIN, 332 pr.\nRB-T RANSPLANT , 323\nreachability in a graph ( ;), 1170\nreal numbers ( R), 1158\nreconstructing an optimal solution, in dynamic\nprogramming, 387\nrecord, 147rectangle, 354 ex.\nrecurrence, 34, 65\u201367, 83\u2013113\nsolution by Akra-Bazzi method, 112\u2013113\nsolution by master method, 93\u201397\nsolution by recursion-tree method, 88\u201393\nsolution by substitution method, 83\u201388\nrecurrence equation, seerecurrence\nrecursion, 30\nrecursion tree, 37, 88\u201393\nin proof of master theorem, 98\u2013100\nand the substitution method, 91\u201392\nR\nECURSIVE -ACTIVITY -SELECTOR , 419\nrecursive case, 65RECURSIVE -FFT,911\nRECURSIVE -MAT RIX -CHAIN , 385\nred-black tree, 308\u2013338\naugmentation of, 346\u2013347compared with B-trees, 484, 490\ndeletion from, 323\u2013330\nin determining whether any line segments\nintersect, 1024\nfor enumerating keys in a range, 348 ex.\nheight of, 309\ninsertion into, 315\u2013323\njoining of, 332 pr.\nmaximum key of, 311minimum key of, 311\npredecessor in, 311\nproperties of, 308\u2013312relaxed, 311 ex.\nrestructuring, 474 pr.\nrotation in, 312\u2013314searching in, 311\nsuccessor in, 311\nsee also interval tree, order-statistic tree\nR\nEDUCE , 807 pr.\nreduced-space van Emde Boas tree, 557 pr.\nreducibility, 1067\u20131068\nreduction algorithm, 1052, 1067\nreduction function, 1067\nreduction, of an array, 807 pr.\nre\ufb02exive relation, 1163\nre\ufb02exivity of asymptotic notation, 51\nregion, feasible, 847\nregularity condition, 95rejection\nby an algorithm, 1058\nby a \ufb01nite automaton, 996\nR\nELABEL , 740\nrelabeled vertex, 740\nrelabel operation, in push-relabel algorithms,\n740, 745\nRELABEL -TO-FRONT , 755\nrelabel-to-front algorithm, 748\u2013760\nphase of, 758\nrelation, 1163\u20131166\nrelatively prime, 931\nRELAX , 649\nrelaxation\nof an edge, 648\u2013650\nlinear programming, 1125", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "1304": {"page_number": 1305, "page_information": "1284 Index\nrelaxed heap, 530\nrelaxed red-black tree, 311 ex.\nrelease time, 447 pr.\nremainder, 54, 928remainder instruction, 23\nrepeated squaring\nfor all-pairs shortest paths, 689\u2013691for raising a number to a power, 956\nrepeat , in pseudocode, 20\nrepetition factor, of a string, 1012 pr.\nR\nEPETITION -MAT CHER , 1013 pr.\nrepresentative of a set, 561\nRESET , 459 ex.\nresidual capacity, 716, 719\nresidual edge, 716\nresidual network, 715\u2013719residue, 54, 928, 982 pr.\nrespecting a set of edges, 626\nreturn edge, 779\nreturn , in pseudocode, 22\nreturn instruction, 23\nreweighting\nin all-pairs shortest paths, 700\u2013702\nin single-source shortest paths, 679 pr.\nrho heuristic, 976\u2013980, 980 ex., 984\n/SUB.n/-approximation algorithm, 1106, 1123\nR\nIGHT , 152\nright child, 1178\nright-conversion, 314 ex.\nright horizontal ray, 1021 ex.\nRIGHT -ROTATE , 313\nright rotation, 312right spine, 333 pr.\nright subtree, 1178\nrod-cutting, 360\u2013370, 390 ex.\nroot\nof a tree, 1176\nof unity, 906\u2013907\nofZ\n/ETX\nn, 955\nrooted tree, 1176\nrepresentation of, 246\u2013249\nroot list, of a Fibonacci heap, 509\nrotation\ncyclic, 1012 ex.in a red-black tree, 312\u2013314\nrotational sweep, 1030\u20131038\nrounding, 1126\nrandomized, 1139row-major order, 394\nrow rank, 1223\nrow vector, 1218\nRSA public-key cryptosystem, 958\u2013965, 983\nRS-vEB tree, 557 pr.\nrule of product, 1184\nrule of sum, 1183running time, 25\naverage-case, 28, 116\nbest-case, 29 ex., 49\nexpected, 28, 117\nof a graph algorithm, 588\nand multithreaded computation, 779\u2013780order of growth, 28\nrate of growth, 28\nworst-case, 27, 49\nsabermetrics, 412 n.\nsafe edge, 626\nS\nAME -COMPONENT , 563\nsample space, 1189\nsampling, 129 ex., 179\nSAT, 1079\nsatellite data, 147, 229\nsatis\ufb01ability, 1072, 1079\u20131081, 1105,\n1123\u20131124, 1127 ex., 1139\nsatis\ufb01able formula, 1049, 1079\nsatisfying assignment, 1072, 1079\nsaturated edge, 739saturating push, 739, 745\nscalar \ufb02ow product, 714 ex.\nscalar multiple, 1220scaling\nin maximum \ufb02ow, 762 pr., 765\nin single-source shortest paths, 679 pr.\nscan, 807 pr.\nS\nCAN, 807 pr.\nscapegoat tree, 338schedule, 444, 1136 pr.\nevent-point, 1023\nscheduler, for multithreaded computations,\n777, 781\u2013783, 812\ncentralized, 782\ngreedy, 782\nwork-stealing algorithm for, 812\nscheduling, 443\u2013446, 447 pr., 450, 1104 pr.,\n1136 pr.\nSchur complement, 820, 834", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "1305": {"page_number": 1306, "page_information": "Index 1285\nSchur complement lemma, 834\nSCRAMBLE -SEARCH , 143 pr.\nseam carving, 409 pr., 413\nSEARCH , 230\nsearching, 22 ex.\nbinary search, 39 ex., 799\u2013800\nin binary search trees, 289\u2013291in B-trees, 491\u2013492\nin chained hash tables, 258\nin compact lists, 250 pr.\nin direct-address tables, 254\nfor an exact interval, 354 ex.\nin interval trees, 350\u2013353linear search, 22 ex.\nin linked lists, 237\nin open-address hash tables, 270\u2013271in proto van Emde Boas structures, 540\u2013541\nin red-black trees, 311\nin an unsorted array, 143 pr.\nin Van Emde Boas trees, 550\nsearch tree, seebalanced search tree, binary\nsearch tree, B-tree, exponential searchtree, interval tree, optimal binary search\ntree, order-statistic tree, red-black tree,\nsplay tree, 2-3 tree, 2-3-4 tree\nsecondary clustering, 272secondary hash table, 278\nsecondary storage\nsearch tree for, 484\u2013504stacks on, 502 pr.\nsecond-best minimum spanning tree, 638 pr.\nsecret key, 959, 962\nsegment, seedirected segment, line segment\nS\nEGMENTS -INTERSECT , 1018\nSELECT , 220\nselection, 213\nof activities, 415\u2013422, 450\nand comparison sorts, 222\nin expected linear time, 215\u2013220\nmultithreaded, 805 ex.\nin order-statistic trees, 340\u2013341in worst-case linear time, 220\u2013224\nselection sort, 29 ex.\nselector vertex, 1093\nself-loop, 1168\nself-organizing list, 476 pr., 478\nsemiconnected graph, 621 ex.sentinel, 31, 238\u2013240, 309sequence (hi)\nbitonic, 682 pr.\n\ufb01nite, 1166\nin\ufb01nite, 1166\ninversion in, 41 pr., 122 ex., 345 ex.\nprobe, 270\nsequential consistency, 779, 812\nserial algorithm versus parallel algorithm, 772\nserialization, of a multithreaded algorithm,\n774, 776\nseries, 108 pr., 1146\u20131148\nstrands being logically in, 778\nset (fg), 1158\u20131163\ncardinality (jj), 1161\nconvex, 714 ex.\ndifference (/NUL), 1159\nindependent, 1101 pr.\nintersection (\\), 1159\nmember (2), 1158\nnot a member (62), 1158\nunion ([), 1159\nset-covering problem, 1117\u20131122, 1139\nweighted, 1135 pr.\nset-partition problem, 1101 ex.\nshadow of a point, 1038 ex.\nshared memory, 772\nShell\u2019s sort, 42\nshift, in string matching, 985\nshift instruction, 24short-circuiting operator, 22\nSHORTEST-PATH, 1050\nshortest paths, 7, 643\u2013707\nall-pairs, 644, 684\u2013707\nBellman-Ford algorithm for, 651\u2013655\nwith bitonic paths, 682 pr.\nand breadth-\ufb01rst search, 597\u2013600, 644\nconvergence property of, 650, 672\u2013673\nand difference constraints, 664\u2013670Dijkstra\u2019s algorithm for, 658\u2013664\nin a directed acyclic graph, 655\u2013658\nin/SI-dense graphs, 706 pr.\nestimate of, 648\nFloyd-Warshall algorithm for, 693\u2013697,\n700 ex., 706\nGabow\u2019s scaling algorithm for, 679 pr.\nJohnson\u2019s algorithm for, 700\u2013706\nas a linear program, 859\u2013860\nand longest paths, 1048", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "1306": {"page_number": 1307, "page_information": "1286 Index\nby matrix multiplication, 686\u2013693, 706\u2013707\nand negative-weight cycles, 645, 653\u2013654,\n692 ex., 700 ex.\nwith negative-weight edges, 645\u2013646no-path property of, 650, 672\noptimal substructure of, 644\u2013645, 687,\n693\u2013694\npath-relaxation property of, 650, 673\npredecessor-subgraph property of, 650, 676\nproblem variants, 644and relaxation, 648\u2013650\nby repeated squaring, 689\u2013691\nsingle-destination, 644single-pair, 381, 644\nsingle-source, 643\u2013683\ntree of, 647\u2013648, 673\u2013676\ntriangle inequality of, 650, 671\nin an unweighted graph, 381, 597\nupper-bound property of, 650, 671\u2013672\nin a weighted graph, 643\nsibling, 1176\nside of a polygon, 1020 ex.\nsignature, 960simple cycle, 1170\nsimple graph, 1170\nsimple path, 1170\nlongest, 382, 1048\nsimple polygon, 1020 ex.\nsimple stencil calculation, 809 pr.\nsimple uniform hashing, 259\nsimplex, 848\nS\nIMPLEX , 871\nsimplex algorithm, 848, 864\u2013879, 896\u2013897\nsingle-destination shortest paths, 644\nsingle-pair shortest path, 381, 644\nas a linear program, 859\u2013860\nsingle-source shortest paths, 643\u2013683\nBellman-Ford algorithm for, 651\u2013655with bitonic paths, 682 pr.\nand difference constraints, 664\u2013670\nDijkstra\u2019s algorithm for, 658\u2013664\nin a directed acyclic graph, 655\u2013658\nin/SI-dense graphs, 706 pr.\nGabow\u2019s scaling algorithm for, 679 pr.\nas a linear program, 863 ex.\nand longest paths, 1048\nsingleton, 1161\nsingly connected graph, 612 ex.singly linked list, 236\nsee also linked list\nsingular matrix, 1223\nsingular value decomposition, 842\nsink vertex, 593 ex., 709, 712\nsize\nof an algorithm\u2019s input, 25, 926\u2013927,\n1055\u20131057\nof a binomial tree, 527 pr.\nof a boolean combinational circuit, 1072of a clique, 1086\nof a set, 1161\nof a subtree in a Fibonacci heap, 524of a vertex cover, 1089, 1108\nskip list, 338\nslack, 855slack form, 846, 854\u2013857\nuniqueness of, 876\nslackness\ncomplementary, 894 pr.\nparallel, 781\nslack variable, 855slot\nof a direct-access table, 254\nof a hash table, 256\nS\nLOW -ALL-PAIRS -SHORTEST -PATHS , 689\nsmoothed analysis, 897\n?Socrates, 790\nsolution\nto an abstract problem, 1054\nbasic, 866\nto a computational problem, 6\nto a concrete problem, 1055\nfeasible, 665, 846, 851\ninfeasible, 851optimal, 851\nto a system of linear equations, 814\nsorted linked list, 236\nsee also linked list\nsorting, 5, 16\u201320, 30\u201337, 147\u2013212, 797\u2013805\nbubblesort, 40 pr.\nbucket sort, 200\u2013204\ncolumnsort, 208 pr.\ncomparison sort, 191counting sort, 194\u2013197\nfuzzy, 189 pr.\nheapsort, 151\u2013169insertion sort, 12, 16\u201320", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "1307": {"page_number": 1308, "page_information": "Index 1287\nk-sorting, 207 pr.\nlexicographic, 304 pr.\nin linear time, 194\u2013204, 206 pr.\nlower bounds for, 191\u2013194, 211, 531merge sort, 12, 30\u201337, 797\u2013805\nby oblivious compare-exchange algorithms,\n208 pr.\nin place, 17, 148, 206 pr.\nof points by polar angle, 1020 ex.\nprobabilistic lower bound for, 205 pr.quicksort, 170\u2013190\nradix sort, 197\u2013200\nselection sort, 29 ex.Shell\u2019s sort, 42\nstable, 196\ntable of running times, 149\ntopological, 8, 612\u2013615, 623\nusing a binary search tree, 299 ex.\nwith variable-length items, 206 pr.\n0-1 sorting lemma, 208 pr.\nsorting network, 811\nsource vertex, 594, 644, 709, 712\nspan law, 780spanning tree, 439, 624\nbottleneck, 640 pr.\nmaximum, 1137 pr.veri\ufb01cation of, 642\nsee also minimum spanning tree\nspan, of a multithreaded computation, 779\nsparse graph, 589\nall-pairs shortest paths for, 700\u2013705\nand Prim\u2019s algorithm, 638 pr.\nsparse-hulled distribution, 1046 pr.\nspawn , in pseudocode, 776\u2013777\nspawn edge, 778speedup, 780\nof a randomized multithreaded algorithm,\n811 pr.\nspindle, 485\nspine\nof a string-matching automaton, 997 \ufb01g.\nof a treap, 333 pr.\nsplay tree, 338, 482\nspline, 840 pr.splitting\nof B-tree nodes, 493\u2013495\nof 2-3-4 trees, 503 pr.\nsplitting summations, 1152\u20131154spurious hit, 991\nsquare matrix, 1218\nS\nQUARE -MAT RIX -MULTIPLY , 75, 689\nSQUARE -MAT RIX -MULTIPLY -RECURSIVE ,\n77\nsquare of a directed graph, 593 ex.\nsquare root, modulo a prime, 982 pr.squaring, repeated\nfor all-pairs shortest paths, 689\u2013691\nfor raising a number to a power, 956\nstability\nnumerical, 813, 815, 842\nof sorting algorithms, 196, 200 ex.\nstack, 232\u2013233\nin Graham\u2019s scan, 1030\nimplemented by queues, 236 ex.linked-list implementation of, 240 ex.\noperations analyzed by accounting method,\n457\u2013458\noperations analyzed by aggregate analysis,\n452\u2013454\noperations analyzed by potential method,\n460\u2013461\nfor procedure execution, 188 pr.\non secondary storage, 502 pr.\nS\nTACK -EMPTY , 233\nstandard deviation, 1200\nstandard encoding ( hi), 1057\nstandard form, 846, 850\u2013854star-shaped polygon, 1038 ex.\nstart state, 995\nstart time, 415\nstate of a \ufb01nite automaton, 995\nstatic graph, 562 n.\nstatic set of keys, 277\nstatic threading, 773\nstencil, 809 pr.\nstencil calculation, 809 pr.Stirling\u2019s approximation, 57\nstorage management, 151, 243\u2013244, 245 ex.,\n261 ex.\nstore instruction, 23\nstraddle, 1017\nstrand, 777\n\ufb01nal, 779\nindependent, 789\ninitial, 779\nlogically in parallel, 778", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "1308": {"page_number": 1309, "page_information": "1288 Index\nlogically in series, 778\nStrassen\u2019s algorithm, 79\u201383, 111\u2013112\nmultithreaded, 795\u2013796\nstreaks, 135\u2013139strictly decreasing, 53\nstrictly increasing, 53\nstring, 985, 1184\nstring matching, 985\u20131013\nbased on repetition factors, 1012 pr.\nby \ufb01nite automata, 995\u20131002with gap characters, 989 ex., 1002 ex.\nKnuth-Morris-Pratt algorithm for,\n1002\u20131013\nnaive algorithm for, 988\u2013990\nRabin-Karp algorithm for, 990\u2013995, 1013\nstring-matching automaton, 996\u20131002,\n1002 ex.\nstrongly connected component, 1170\ndecomposition into, 615\u2013621, 623\nS\nTRONGLY -CONNECTED -COMPONENTS , 617\nstrongly connected graph, 1170\nsubgraph, 1171\npredecessor, seepredecessor subgraph\nsubgraph-isomorphism problem, 1100 ex.\nsubgroup, 943\u2013946\nsubpath, 1170\nsubproblem graph, 367\u2013368\nsubroutine\ncalling, 21, 23, 25 n.executing, 25 n.\nsubsequence, 391\nsubset (/DC2), 1159, 1161\nhereditary family of, 437\nindependent family of, 437\nSUBSET-SUM, 1097\nsubset-sum problem\napproximation algorithm for, 1128\u20131134,\n1139\nNP-completeness of, 1097\u20131100\nwith unary target, 1101 ex.\nsubstitution method, 83\u201388\nand recursion trees, 91\u201392\nsubstring, 1184\nsubtract instruction, 23\nsubtraction of matrices, 1221\nsubtree, 1176\nmaintaining sizes of, in order-statistic trees,\n343\u2013344success, in a Bernoulli trial, 1201\nsuccessor\nin binary search trees, 291\u2013292\nin a bit vector with a superimposed binary\ntree, 533\nin a bit vector with a superimposed tree of\nconstant height, 535\n\ufb01nding ith, of a node in an order-statistic\ntree, 344 ex.\nin linked lists, 236in order-statistic trees, 347 ex.\nin proto van Emde Boas structures, 543\u2013544\nin red-black trees, 311\nin Van Emde Boas trees, 550\u2013551\nS\nUCCESSOR , 230\nsuch that (W), 1159\nsuf\ufb01x (=), 986\nsuf\ufb01x function, 996\nsuf\ufb01x-function inequality, 999suf\ufb01x-function recursion lemma, 1000\nsum.P/, 1145\nCartesian, 906 ex.\nin\ufb01nite, 1145\nof matrices, 1220\nof polynomials, 898\nrule of, 1183telescoping, 1148\nS\nUM-ARRAYS , 805 pr.\nSUM-ARRAYS0, 805 pr.\nsummary\nin a bit vector with a superimposed tree of\nconstant height, 534\nin proto van Emde Boas structures, 540\nin van Emde Boas trees, 546\nsummation, 1145\u20131157\nin asymptotic notation, 49\u201350, 1146\nbounding, 1149\u20131156\nformulas and properties of, 1145\u20131149linearity of, 1146\nsummation lemma, 908\nsupercomputer, 772superpolynomial time, 1048\nsupersink, 712\nsupersource, 712\nsurjection, 1167\nSVD, 842\nsweeping, 1021\u20131029, 1045 pr.\nrotational, 1030\u20131038", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "1309": {"page_number": 1310, "page_information": "Index 1289\nsweep line, 1022\nsweep-line status, 1023\u20131024\nsymbol table, 253, 262, 265\nsymmetric difference, 763 pr.symmetric matrix, 1220, 1222 ex., 1226 ex.\nsymmetric positive-de\ufb01nite matrix, 832\u2013835,\n842\nsymmetric relation, 1163\nsymmetry of \u201a-notation, 52\nsync , in pseudocode, 776\u2013777\nsystem of difference constraints, 664\u2013670\nsystem of linear equations, 806 pr., 813\u2013827,\n840 pr.\nT\nABLE -DELETE , 468\nTABLE -INSERT , 464\ntail\nof a binomial distribution, 1208\u20131215\nof a linked list, 236of a queue, 234\ntail recursion, 188 pr., 419\nT\nAIL-RECURSIVE -QUICKSORT , 188 pr.\ntarget, 1097Tarjan\u2019s off-line least-common-ancestors\nalgorithm, 584 pr.\ntask, 443Task Parallel Library, 774\ntask scheduling, 443\u2013446, 448 pr., 450\ntautology, 1066 ex., 1086 ex.\nTaylor series, 306 pr.\ntelescoping series, 1148\ntelescoping sum, 1148testing\nof primality, 965\u2013975, 983\nof pseudoprimality, 966\u2013968\ntext, in string matching, 985\nthen clause, 20 n.\nTheta-notation, 44\u201347, 64thread, 773\nThreading Building Blocks, 774\n3-CNF, 1082\n3-CNF-SAT, 1082\n3-CNF satis\ufb01ability, 1082\u20131085, 1105\napproximation algorithm for, 1123\u20131124,\n1139\nand 2-CNF satis\ufb01ability, 1049\n3-COLOR, 1103 pr.3-conjunctive normal form, 1082tight constraint, 865\ntime, seerunning time\ntime domain, 898\ntime-memory trade-off, 365timestamp, 603, 611 ex.\nToeplitz matrix, 921 pr.\nto, in pseudocode, 20\nT\nOP, 1031\ntop-down method, for dynamic programming,\n365\ntop of a stack, 232\ntopological sort, 8, 612\u2013615, 623\nin computing single-source shortest paths in\na dag, 655\nTOPOLOGICAL -SORT, 613\ntotal order, 1165\ntotal path length, 304 pr.\ntotal preorder, 1165\ntotal relation, 1165tour\nbitonic, 405 pr.\nEuler, 623 pr., 1048\nof a graph, 1096\ntrack, 486\ntractability, 1048\ntrailing pointer, 295\ntransition function, 995, 1001\u20131002, 1012 ex.\ntransitive closure, 697\u2013699\nand boolean matrix multiplication, 832 ex.of dynamic graphs, 705 pr., 707\nT\nRANSITIVE -CLOSURE , 698\ntransitive relation, 1163transitivity of asymptotic notation, 51\nT\nRANSPLANT , 296, 323\ntranspose\nconjugate, 832 ex.\nof a directed graph, 592 ex.\nof a matrix, 1217of a matrix, multithreaded, 792 ex.\ntranspose symmetry of asymptotic notation, 52\ntraveling-salesman problem\napproximation algorithm for, 1111\u20131117,\n1139\nbitonic euclidean, 405 pr.bottleneck, 1117 ex.\nNP-completeness of, 1096\u20131097\nwith the triangle inequality, 1112\u20131115\nwithout the triangle inequality, 1115\u20131116", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "1310": {"page_number": 1311, "page_information": "1290 Index\ntraversal of a tree, 287, 293 ex., 342, 1114\ntreap, 333 pr., 338\nTREAP -INSERT , 333 pr.\ntree, 1173\u20131180\nAA-trees, 338\nA VL, 333 pr., 337\nbinary, seebinary tree\nbinomial, 527 pr.\nbisection of, 1181 pr.\nbreadth-\ufb01rst, 594, 600\nB-trees, 484\u2013504\ndecision, 192\u2013193\ndepth-\ufb01rst, 603diameter of, 602 ex.\ndynamic, 482\nfree, 1172\u20131176full walk of, 1114\nfusion, 212, 483\nheap, 151\u2013169height-balanced, 333 pr.\nheight of, 1177\ninterval, 348\u2013354\nk-neighbor, 338\nminimum spanning, seeminimum spanning\ntree\noptimal binary search, 397\u2013404, 413order-statistic, 339\u2013345\nparse, 1082\nrecursion, 37, 88\u201393red-black, seered-black tree\nrooted, 246\u2013249, 1176\nscapegoat, 338\nsearch, seesearch tree\nshortest-paths, 647\u2013648, 673\u2013676\nspanning, seeminimum spanning tree,\nspanning tree\nsplay, 338, 482\ntreap, 333 pr., 3382-3, 337, 504\n2-3-4, 489, 503 pr.\nvan Emde Boas, 531\u2013560walk of, 287, 293 ex., 342, 1114\nweight-balanced trees, 338\nT\nREE-DELETE , 298, 299 ex., 323\u2013324\ntree edge, 601, 603, 609\nTREE-INSERT , 294, 315\nTREE-MAXIMUM , 291\nTREE-MINIMUM , 291TREE-PREDECESSOR , 292\nTREE-SEARCH , 290\nTREE-SUCCESSOR , 292\ntree walk, 287, 293 ex., 342, 1114trial, Bernoulli, 1201\ntrial division, 966\ntriangle inequality, 1112\nfor shortest paths, 650, 671\ntriangular matrix, 1219, 1222 ex., 1225 ex.\ntrichotomy, interval, 348\ntrichotomy property of real numbers, 52\ntridiagonal linear systems, 840 pr.\ntridiagonal matrix, 1219trie (radix tree), 304 pr.\ny-fast, 558 pr.\nT\nRIM, 1130\ntrimming a list, 1130\ntrivial divisor, 928\ntruth assignment, 1072, 1079\ntruth table, 1070\nTSP, 1096\ntuple, 1162twiddle factor, 9122-CNF-SAT, 1086 ex.\n2-CNF satis\ufb01ability, 1086 ex.\nand 3-CNF satis\ufb01ability, 1049\ntwo-pass method, 571\n2-3-4 heap, 529 pr.\n2-3-4 tree, 489\njoining, 503 pr.\nsplitting, 503 pr.\n2-3 tree, 337, 504\nunary, 1056\nunbounded linear program, 851\nunconditional branch instruction, 23\nuncountable set, 1161\nunderdetermined system of linear equations,\n814\nunder\ufb02ow\nof a queue, 234of a stack, 233\nundirected graph, 1168\narticulation point of, 621 pr.\nbiconnected component of, 621 pr.\nbridge of, 621 pr.\nclique in, 1086coloring of, 1103 pr., 1180 pr.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "1311": {"page_number": 1312, "page_information": "Index 1291\ncomputing a minimum spanning tree in,\n624\u2013642\nconverting to, from a multigraph, 593 ex.\nd-regular, 736 ex.\ngrid, 760 pr.\nhamiltonian, 1061\nindependent set of, 1101 pr.\nmatching of, 732\nnonhamiltonian, 1061\nvertex cover of, 1089, 1108see also graph\nundirected version of a directed graph, 1172\nuniform hashing, 271uniform probability distribution, 1191\u20131192\nuniform random permutation, 116, 125\nunion\nof dynamic sets, seeuniting\nof languages, 1058\nof sets ([), 1159\nU\nNION , 505, 562\ndisjoint-set-forest implementation of, 571\nlinked-list implementation of, 565\u2013567,\n568 ex.\nunion by rank, 569\nunique factorization of integers, 931\nunit ( 1), 928\nuniting\nof Fibonacci heaps, 511\u2013512\nof heaps, 506\nof linked lists, 241 ex.\nof 2-3-4 heaps, 529 pr.\nunit lower-triangular matrix, 1219\nunit-time task, 443\nunit upper-triangular matrix, 1219\nunit vector, 1218universal collection of hash functions, 265\nuniversal hashing, 265\u2013268\nuniversal sink, 593 ex.universe, 1160\nof keys in van Emde Boas trees, 532\nuniverse size, 532unmatched vertex, 732\nunsorted linked list, 236\nsee also linked list\nuntil , in pseudocode, 20\nunweighted longest simple paths, 382\nunweighted shortest paths, 381\nupper bound, 47upper-bound property, 650, 671\u2013672\nupper median, 213\nupper square root/NUL\n\"p\n/SOH\n, 546\nupper-triangular matrix, 1219, 1225 ex.\nvalid shift, 985\nvalue\nof a \ufb02ow, 710\nof a function, 1166\nobjective, 847, 851\nvalue over replacement player, 411 pr.\nVandermonde matrix, 902, 1226 pr.\nvan Emde Boas tree, 531\u2013560\ncluster in, 546\ncompared with proto van Emde Boas\nstructures, 547\ndeletion from, 554\u2013556\ninsertion into, 552\u2013554\nmaximum in, 550membership in, 550\nminimum in, 550\npredecessor in, 551\u2013552\nwith reduced space, 557 pr.\nsuccessor in, 550\u2013551\nsummary in, 546\nVar\u0152/c141(variance), 1199\nvariable\nbasic, 855\nentering, 867\nleaving, 867\nnonbasic, 855\nin pseudocode, 21\nrandom, 1196\u20131201\nslack, 855\nsee also indicator random variable\nvariable-length code, 429\nvariance, 1199\nof a binomial distribution, 1205of a geometric distribution, 1203\nVEB-E MPTY -TREE-INSERT , 553\nvEB tree, seevan Emde Boas tree\nVEB-T REE-DELETE , 554\nVEB-T REE-INSERT , 553\nVEB-T REE-MAXIMUM , 550\nVEB-T REE-MEMBER , 550\nVEB-T REE-MINIMUM , 550\nVEB-T REE-PREDECESSOR , 552\nVEB-T REE-SUCCESSOR , 551", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}, "1312": {"page_number": 1313, "page_information": "1292 Index\nvector, 1218, 1222\u20131224\nconvolution of, 901\ncross product of, 1016\northonormal, 842in the plane, 1015\nVenn diagram, 1160\nveri\ufb01cation, 1061\u20131066\nof spanning trees, 642\nveri\ufb01cation algorithm, 1063\nvertex\narticulation point, 621 pr.\nattributes of, 592\ncapacity of, 714 ex.in a graph, 1168\nintermediate, 693\nisolated, 1169\nover\ufb02owing, 736\nof a polygon, 1020 ex.\nrelabeled, 740selector, 1093\nvertex cover, 1089, 1108, 1124\u20131127, 1139\nVERTEX-COVER, 1090vertex-cover problem\napproximation algorithm for, 1108\u20131111,\n1139\nNP-completeness of, 1089\u20131091, 1105\nvertex set, 1168\nviolation, of an equality constraint, 865\nvirtual memory, 24\nViterbi algorithm, 408 pr.\nVORP, 411 pr.\nwalk of a tree, 287, 293 ex., 342, 1114\nweak duality, 880\u2013881, 886 ex., 895 pr.\nweight\nof a cut, 1127 ex.\nof an edge, 591\nmean, 680 pr.\nof a path, 643\nweight-balanced tree, 338, 473 pr.\nweighted bipartite matching, 530\nweighted matroid, 439\u2013442\nweighted median, 225 pr.\nweighted set-covering problem, 1135 pr.weighted-union heuristic, 566\nweighted vertex cover, 1124\u20131127, 1139\nweight function\nfor a graph, 591in a weighted matroid, 439\nwhile , in pseudocode, 20\nwhite-path theorem, 608\nwhite vertex, 594, 603widget, 1092\nwire, 1071\nW\nITNESS , 969\nwitness, to the compositeness of a number, 968\nwork law, 780\nwork, of a multithreaded computation, 779\nwork-stealing scheduling algorithm, 812\nworst-case running time, 27, 49\nYen\u2019s improvement to the Bellman-Ford\nalgorithm, 678 pr.\ny-fast trie, 558 pr.\nYoung tableau, 167 pr.\nZ(set of integers), 1158\nZn(equivalence classes modulo n), 928\nZ/ETX\nn(elements of multiplicative group\nmodulo n), 941\nZC\nn(nonzero elements of Zn), 967\nzero matrix, 1218\nzero of a polynomial modulo a prime, 950 ex.\n0-1 integer programming, 1100 ex., 1125\n0-1 knapsack problem, 425, 427 ex., 1137 pr.,\n1139\n0-1 sorting lemma, 208 pr.\nzonk, 1195 ex.", "book_name": "Introduction_to_algorithms-3rd Edition.pdf"}}